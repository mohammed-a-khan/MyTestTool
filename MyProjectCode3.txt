/**
 * Self-Healing Service Implementation
 */
package com.cstestforge.service.impl.selfhealing;

import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.service.selfhealing.SelfHealingService;
import com.microsoft.playwright.ElementHandle;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.options.WaitForSelectorState;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
public class SelfHealingServiceImpl implements SelfHealingService {
    private static final Logger logger = LoggerFactory.getLogger(SelfHealingServiceImpl.class);
    
    // Store element fingerprints for faster lookup during healing
    private final Map<String, Map<String, Object>> elementFingerprints = new ConcurrentHashMap<>();
    
    // Store successful healing strategies for learning
    private final Map<String, List<String>> successfulHealingStrategies = new ConcurrentHashMap<>();
    
    @Override
    public String healSelector(Page page, TestStep step, String originalSelector) {
        logger.info("Attempting to heal selector: {}", originalSelector);
        
        // List of selector strategies to try in order of preference
        List<String> selectorStrategies = determineHealingStrategies(step);
        
        // Original selector type
        String originalSelectorType = step.getSelectorType();
        
        // Create fingerprint if not exists
        String elementId = step.getId() + "_" + originalSelector;
        if (!elementFingerprints.containsKey(elementId)) {
            try {
                // Try to find with original selector first
                ElementHandle element = page.waitForSelector(originalSelector, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(2000));
                
                if (element != null) {
                    captureElementFingerprint(element, elementId);
                }
            } catch (Exception e) {
                logger.warn("Could not capture fingerprint using original selector: {}", originalSelector);
            }
        }
        
        // Try healing strategies
        for (String strategy : selectorStrategies) {
            try {
                String healedSelector = applyHealingStrategy(page, strategy, step, originalSelector);
                
                if (healedSelector != null && !healedSelector.equals(originalSelector)) {
                    // Validate healed selector works
                    ElementHandle element = page.waitForSelector(healedSelector, 
                        new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(2000));
                    
                    if (element != null) {
                        logger.info("Successfully healed selector from {} to {}", originalSelector, healedSelector);
                        
                        // Update fingerprint
                        captureElementFingerprint(element, elementId);
                        
                        // Update successful strategies
                        recordSuccessfulStrategy(step.getId(), strategy);
                        
                        return healedSelector;
                    }
                }
            } catch (Exception e) {
                logger.debug("Healing strategy {} failed: {}", strategy, e.getMessage());
            }
        }
        
        logger.warn("Failed to heal selector: {}", originalSelector);
        return originalSelector;
    }
    
    @Override
    public List<String> determineHealingStrategies(TestStep step) {
        List<String> strategies = new ArrayList<>();
        
        // Check if we have successful strategies for this step
        if (successfulHealingStrategies.containsKey(step.getId())) {
            // Add previously successful strategies first
            strategies.addAll(successfulHealingStrategies.get(step.getId()));
        }
        
        // Add default strategies if not already included
        List<String> defaultStrategies = Arrays.asList(
            "CSS_RELAXED", "XPATH_BY_TEXT", "CSS_BY_ATTRIBUTES",
            "XPATH_BY_ATTRIBUTES", "NEAREST_NEIGHBOR", "FINGERPRINT_MATCH");
        
        for (String strategy : defaultStrategies) {
            if (!strategies.contains(strategy)) {
                strategies.add(strategy);
            }
        }
        
        return strategies;
    }
    
    private String applyHealingStrategy(Page page, String strategy, TestStep step, String originalSelector) {
        switch (strategy) {
            case "CSS_RELAXED":
                return healWithRelaxedCssSelector(page, originalSelector);
            case "XPATH_BY_TEXT":
                return healWithXpathByText(page, step);
            case "CSS_BY_ATTRIBUTES":
                return healWithCssByAttributes(page, originalSelector);
            case "XPATH_BY_ATTRIBUTES":
                return healWithXpathByAttributes(page, originalSelector);
            case "NEAREST_NEIGHBOR":
                return healWithNearestNeighbor(page, originalSelector);
            case "FINGERPRINT_MATCH":
                return healWithFingerprint(page, step.getId() + "_" + originalSelector);
            default:
                logger.warn("Unknown healing strategy: {}", strategy);
                return null;
        }
    }
    
    private String healWithRelaxedCssSelector(Page page, String originalSelector) {
        if (!originalSelector.startsWith("#") && !originalSelector.startsWith(".")) {
            return null;
        }
        
        // Strip away specific attributes, leaving just the core identifiers
        String simplified = originalSelector.replaceAll("\\[.*?\\]", "");
        
        // Handle complex selectors with > or space
        String[] parts = simplified.split("[ >]+");
        if (parts.length <= 1) {
            return simplified;
        }
        
        // Try removing the most specific parts one by one
        for (int i = parts.length - 2; i >= 0; i--) {
            // Join from the start to the current position
            String partial = String.join(" > ", Arrays.copyOfRange(parts, 0, i + 2));
            try {
                ElementHandle element = page.waitForSelector(partial, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
                
                if (element != null) {
                    return partial;
                }
            } catch (Exception ignored) {
                // Continue with the next iteration
            }
        }
        
        return null;
    }
    
    private String healWithXpathByText(Page page, TestStep step) {
        // Use action parameter as text if this is a 'click' or similar action
        if (step.getAction().equals("click") && step.getParameters() != null && step.getParameters().containsKey("text")) {
            String text = step.getParameters().get("text").toString();
            String xpathWithText = String.format("//*[text()='%s' or contains(text(),'%s')]", text, text);
            
            try {
                ElementHandle element = page.waitForSelector(xpathWithText, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
                
                if (element != null) {
                    return xpathWithText;
                }
            } catch (Exception ignored) {
                // Continue with the next attempt
            }
            
            // Try with button or anchor
            String xpathWithTextTagged = String.format("//button[text()='%s' or contains(text(),'%s')] | //a[text()='%s' or contains(text(),'%s')]", 
                text, text, text, text);
            
            try {
                ElementHandle element = page.waitForSelector(xpathWithTextTagged, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
                
                if (element != null) {
                    return xpathWithTextTagged;
                }
            } catch (Exception ignored) {
                // No match found
            }
        }
        
        return null;
    }
    
    private String healWithCssByAttributes(Page page, String originalSelector) {
        // Extract the tag if possible
        String tag = "div"; // Default tag
        if (originalSelector.matches("^[a-zA-Z0-9]+.*")) {
            tag = originalSelector.split("[.#\\[]")[0];
        }
        
        // Try to find by data attributes which are less likely to change
        String[] dataAttributes = {"data-testid", "data-id", "data-automation", "id", "name", "title"};
        
        for (String attr : dataAttributes) {
            // Get attribute value from the page
            try {
                // Try to find the original element first
                ElementHandle originalElement = page.querySelector(originalSelector);
                if (originalElement == null) {
                    continue;
                }
                
                String attrValue = originalElement.getAttribute(attr);
                if (attrValue != null && !attrValue.isEmpty()) {
                    String newSelector = String.format("%s[%s='%s']", tag, attr, attrValue);
                    
                    ElementHandle element = page.querySelector(newSelector);
                    if (element != null) {
                        return newSelector;
                    }
                }
            } catch (Exception ignored) {
                // Continue to next attribute
            }
        }
        
        return null;
    }
    
    private String healWithXpathByAttributes(Page page, String originalSelector) {
        // Try to find the original element first
        ElementHandle originalElement;
        try {
            originalElement = page.querySelector(originalSelector);
            if (originalElement == null) {
                return null;
            }
        } catch (Exception e) {
            return null;
        }
        
        // Get key attributes
        String[] keyAttributes = {"id", "name", "data-testid", "data-id", "class", "title", "aria-label"};
        
        // Build XPath based on available attributes
        StringBuilder xpathBuilder = new StringBuilder("//");
        
        // Get tag name
        String tagName;
        try {
            tagName = (String) page.evaluate("el => el.tagName.toLowerCase()", originalElement);
            xpathBuilder.append(tagName);
        } catch (Exception e) {
            xpathBuilder.append("*");
        }
        
        // Add attribute conditions
        boolean hasCondition = false;
        for (String attr : keyAttributes) {
            try {
                String attrValue = originalElement.getAttribute(attr);
                if (attrValue != null && !attrValue.isEmpty()) {
                    if (!hasCondition) {
                        xpathBuilder.append("[");
                        hasCondition = true;
                    } else {
                        xpathBuilder.append(" and ");
                    }
                    
                    // For class, handle multiple classes
                    if (attr.equals("class")) {
                        String[] classes = attrValue.split("\\s+");
                        for (String cls : classes) {
                            if (!cls.isEmpty()) {
                                xpathBuilder.append(String.format("contains(@class,'%s')", cls));
                                break; // Just use the first class to avoid over-specificity
                            }
                        }
                    } else {
                        xpathBuilder.append(String.format("@%s='%s'", attr, attrValue));
                    }
                }
            } catch (Exception ignored) {
                // Continue to next attribute
            }
        }
        
        if (hasCondition) {
            xpathBuilder.append("]");
        }
        
        String newXpath = xpathBuilder.toString();
        try {
            ElementHandle element = page.waitForSelector(newXpath, 
                new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
            
            if (element != null) {
                return newXpath;
            }
        } catch (Exception ignored) {
            // XPath didn't work
        }
        
        return null;
    }
    
    private String healWithNearestNeighbor(Page page, String originalSelector) {
        try {
            // Find any nearby stable elements like headers or containers
            String script = String.format(
                "function findNearestNeighbor(selector) {" +
                "  try {" +
                "    const el = document.querySelector(selector);" +
                "    if (!el) return null;" +
                "    " +
                "    // Look for parent with ID or stable attributes" +
                "    let parent = el.parentElement;" +
                "    while (parent && parent !== document.body) {" +
                "      if (parent.id || parent.getAttribute('data-testid')) {" +
                "        const tag = parent.tagName.toLowerCase();" +
                "        const id = parent.id ? `#${parent.id}` : '';" +
                "        const dataAttr = parent.getAttribute('data-testid') ? `[data-testid=\"${parent.getAttribute('data-testid')}\"]` : '';" +
                "        const parentSelector = tag + id + dataAttr;" +
                "        " +
                "        // Find position of element among siblings of same type" +
                "        const elTag = el.tagName.toLowerCase();" +
                "        const siblings = parent.querySelectorAll(elTag);" +
                "        for (let i = 0; i < siblings.length; i++) {" +
                "          if (siblings[i] === el) {" +
                "            return `${parentSelector} > ${elTag}:nth-child(${i+1})`;" +
                "          }" +
                "        }" +
                "        return null;" +
                "      }" +
                "      parent = parent.parentElement;" +
                "    }" +
                "    return null;" +
                "  } catch (e) {" +
                "    return null;" +
                "  }" +
                "}" +
                "return findNearestNeighbor('%s');", originalSelector.replace("'", "\\'"));
            
            Object result = page.evaluate(script);
            if (result != null) {
                String neighborSelector = result.toString();
                
                // Verify the selector works
                ElementHandle element = page.waitForSelector(neighborSelector, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
                
                if (element != null) {
                    return neighborSelector;
                }
            }
        } catch (Exception ignored) {
            // Continue with other strategies
        }
        
        return null;
    }
    
    private String healWithFingerprint(Page page, String elementId) {
        Map<String, Object> fingerprint = elementFingerprints.get(elementId);
        if (fingerprint == null) {
            return null;
        }
        
        try {
            // Create a script to find element by fingerprint
            StringBuilder scriptBuilder = new StringBuilder(
                "function findByFingerprint(fingerprint) {" +
                "  try {" +
                "    const elements = document.querySelectorAll('*');" +
                "    let bestMatch = null;" +
                "    let bestScore = 0;" +
                "    " +
                "    for (const el of elements) {");
            
            // Add checks for each fingerprint property
            for (Map.Entry<String, Object> entry : fingerprint.entrySet()) {
                String property = entry.getKey();
                Object value = entry.getValue();
                
                if (value instanceof String) {
                    scriptBuilder.append(String.format(
                        "      const %sScore = (el.%s === '%s') ? 1 : 0;",
                        property, property, ((String) value).replace("'", "\\'")));
                } else if (value instanceof Number) {
                    scriptBuilder.append(String.format(
                        "      const %sScore = (el.%s === %s) ? 1 : 0;",
                        property, property, value));
                } else if (value instanceof Boolean) {
                    scriptBuilder.append(String.format(
                        "      const %sScore = (el.%s === %s) ? 1 : 0;",
                        property, property, value));
                } else {
                    continue;
                }
                
                scriptBuilder.append(String.format("      currentScore += %sScore;", property));
            }
            
            // Finish the script
            scriptBuilder.append(
                "      if (currentScore > bestScore) {" +
                "        bestScore = currentScore;" +
                "        bestMatch = el;" +
                "      }" +
                "    }" +
                "    " +
                "    if (bestMatch && bestScore > (Object.keys(fingerprint).length / 2)) {" +
                "      let selector = bestMatch.tagName.toLowerCase();" +
                "      if (bestMatch.id) selector += `#${bestMatch.id}`;" +
                "      return selector;" +
                "    }" +
                "    return null;" +
                "  } catch (e) {" +
                "    return null;" +
                "  }" +
                "}" +
                "return findByFingerprint(" + fingerprint + ");");
            
            Object result = page.evaluate(scriptBuilder.toString());
            if (result != null) {
                String fingerprintSelector = result.toString();
                
                // Verify the selector works
                ElementHandle element = page.waitForSelector(fingerprintSelector, 
                    new Page.WaitForSelectorOptions().setState(WaitForSelectorState.ATTACHED).setTimeout(500));
                
                if (element != null) {
                    return fingerprintSelector;
                }
            }
        } catch (Exception e) {
            logger.debug("Fingerprint healing failed: {}", e.getMessage());
        }
        
        return null;
    }
    
    private void captureElementFingerprint(ElementHandle element, String elementId) {
        try {
            Map<String, Object> fingerprint = new HashMap<>();
            
            // Capture key properties
            String tagName = (String) element.evaluate("el => el.tagName.toLowerCase()");
            fingerprint.put("tagName", tagName);
            
            // Capture dimensions and position
            Map<String, Object> rect = (Map<String, Object>) element.evaluate(
                "el => {const rect = el.getBoundingClientRect(); return {width: rect.width, height: rect.height};}");
            fingerprint.put("width", rect.get("width"));
            fingerprint.put("height", rect.get("height"));
            
            // Capture attributes
            List<String> attributes = Arrays.asList("id", "class", "name", "type", "value", "href", "src");
            for (String attr : attributes) {
                String value = element.getAttribute(attr);
                if (value != null && !value.isEmpty()) {
                    fingerprint.put(attr, value);
                }
            }
            
            // Capture text content
            String textContent = (String) element.evaluate("el => el.textContent");
            if (textContent != null && !textContent.isEmpty()) {
                fingerprint.put("textContent", textContent.trim());
            }
            
            // Store fingerprint
            elementFingerprints.put(elementId, fingerprint);
        } catch (Exception e) {
            logger.warn("Failed to capture element fingerprint: {}", e.getMessage());
        }
    }
    
    private void recordSuccessfulStrategy(String stepId, String strategy) {
        successfulHealingStrategies.computeIfAbsent(stepId, k -> new ArrayList<>());
        List<String> strategies = successfulHealingStrategies.get(stepId);
        
        // Move successful strategy to the front
        strategies.remove(strategy);
        strategies.add(0, strategy);
        
        // Keep only the most recent 5 successful strategies
        if (strategies.size() > 5) {
            successfulHealingStrategies.put(stepId, strategies.subList(0, 5));
        }
    }
    
    @Override
    public Map<String, Object> getSuccessMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        metrics.put("totalHealingAttempts", elementFingerprints.size());
        metrics.put("successfulHealingStrategies", successfulHealingStrategies);
        
        // Calculate success rates per strategy
        Map<String, Integer> strategyCounts = new HashMap<>();
        successfulHealingStrategies.values().stream()
            .flatMap(List::stream)
            .forEach(strategy -> strategyCounts.put(strategy, 
                strategyCounts.getOrDefault(strategy, 0) + 1));
        
        metrics.put("strategyCounts", strategyCounts);
        
        return metrics;
    }
    
    @Override
    public void resetMetrics() {
        elementFingerprints.clear();
        successfulHealingStrategies.clear();
    }
}


/**
 * Playwright Browser Automation Service
 */
package com.cstestforge.service.impl.browser;

import com.cstestforge.model.execution.BrowserConfig;
import com.cstestforge.model.execution.StepResult;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.service.browser.BrowserAutomationService;
import com.cstestforge.service.selfhealing.SelfHealingService;
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

@Service
public class PlaywrightBrowserService implements BrowserAutomationService {
    private static final Logger logger = LoggerFactory.getLogger(PlaywrightBrowserService.class);
    
    @Autowired
    private SelfHealingService selfHealingService;
    
    private final Playwright playwright;
    private final Map<String, Browser> browsers = new ConcurrentHashMap<>();
    private final Map<String, BrowserContext> contexts = new ConcurrentHashMap<>();
    private final Map<String, Page> pages = new ConcurrentHashMap<>();
    
    public PlaywrightBrowserService() {
        this.playwright = Playwright.create();
    }
    
    @Override
    public String initializeBrowser(BrowserConfig config) {
        logger.info("Initializing browser with config: {}", config);
        
        try {
            String browserId = UUID.randomUUID().toString();
            
            BrowserType browserType;
            switch (config.getBrowserType().toLowerCase()) {
                case "firefox":
                    browserType = playwright.firefox();
                    break;
                case "webkit":
                    browserType = playwright.webkit();
                    break;
                case "chrome":
                default:
                    browserType = playwright.chromium();
                    break;
            }
            
            Browser.LaunchOptions launchOptions = new Browser.LaunchOptions()
                .setHeadless(config.isHeadless())
                .setSlowMo(config.getSlowMoMs());
            
            if (config.getExecutablePath() != null && !config.getExecutablePath().isEmpty()) {
                launchOptions.setExecutablePath(Path.of(config.getExecutablePath()));
            }
            
            Browser browser = browserType.launch(launchOptions);
            browsers.put(browserId, browser);
            
            // Create browser context
            BrowserContext.NewContextOptions contextOptions = new BrowserContext.NewContextOptions()
                .setViewportSize(config.getViewportWidth(), config.getViewportHeight())
                .setUserAgent(config.getUserAgent())
                .setLocale(config.getLocale())
                .setDeviceScaleFactor(config.getDeviceScaleFactor())
                .setHasTouch(config.isHasTouch())
                .setIsMobile(config.isMobile());
            
            if (config.isRecordVideo()) {
                contextOptions.setRecordVideoDir(Paths.get("./recordings"));
                contextOptions.setRecordVideoSize(config.getViewportWidth(), config.getViewportHeight());
            }
            
            if (config.getGeolocation() != null) {
                contextOptions.setGeolocation(
                    config.getGeolocation().getLatitude(), 
                    config.getGeolocation().getLongitude());
            }
            
            if (config.getTimezoneId() != null) {
                contextOptions.setTimezoneId(config.getTimezoneId());
            }
            
            if (config.getPermissions() != null && !config.getPermissions().isEmpty()) {
                contextOptions.setPermissions(config.getPermissions());
            }
            
            BrowserContext context = browser.newContext(contextOptions);
            String contextId = browserId + "_context";
            contexts.put(contextId, context);
            
            // Setup context tracing if enabled
            if (config.isEnableTracing()) {
                context.tracing().start(new Tracing.StartOptions()
                    .setScreenshots(true)
                    .setSnapshots(true));
            }
            
            // Create page
            Page page = context.newPage();
            String pageId = browserId + "_page";
            pages.put(pageId, page);
            
            logger.info("Browser initialized with ID: {}", browserId);
            return browserId;
        } catch (Exception e) {
            logger.error("Failed to initialize browser: {}", e.getMessage(), e);
            throw new RuntimeException("Browser initialization failed", e);
        }
    }
    
    @Override
    public StepResult executeStep(String browserId, TestStep step) {
        logger.info("Executing step: {} on browser: {}", step.getAction(), browserId);
        StepResult result = new StepResult();
        result.setStepId(step.getId());
        result.setAction(step.getAction());
        
        try {
            Page page = getPage(browserId);
            if (page == null) {
                logger.error("Page not found for browser ID: {}", browserId);
                result.setSuccess(false);
                result.setErrorMessage("Page not found");
                return result;
            }
            
            // Try to heal selector if needed
            String selector = step.getSelector();
            if (selector != null && !selector.isEmpty()) {
                selector = selfHealingService.healSelector(page, step, selector);
                result.setUsedSelector(selector);
            }
            
            long startTime = System.currentTimeMillis();
            
            switch (step.getAction().toLowerCase()) {
                case "navigate":
                    executeNavigate(page, step, result);
                    break;
                case "click":
                    executeClick(page, step, selector, result);
                    break;
                case "type":
                    executeType(page, step, selector, result);
                    break;
                case "check":
                    executeCheck(page, step, selector, result);
                    break;
                case "uncheck":
                    executeUncheck(page, step, selector, result);
                    break;
                case "select":
                    executeSelect(page, step, selector, result);
                    break;
                case "wait":
                    executeWait(page, step, selector, result);
                    break;
                case "screenshot":
                    executeScreenshot(browserId, step, result);
                    break;
                case "assert":
                    executeAssert(page, step, selector, result);
                    break;
                case "js":
                    executeJs(page, step, result);
                    break;
                default:
                    logger.warn("Unsupported action: {}", step.getAction());
                    result.setSuccess(false);
                    result.setErrorMessage("Unsupported action: " + step.getAction());
                    break;
            }
            
            long endTime = System.currentTimeMillis();
            result.setDurationMs(endTime - startTime);
            
            // Take screenshot on failure if configured
            if (!result.isSuccess() && step.getParameters() != null && 
                Boolean.TRUE.equals(step.getParameters().get("screenshotOnFailure"))) {
                try {
                    String screenshotPath = "screenshots/failure_" + step.getId() + "_" + System.currentTimeMillis() + ".png";
                    page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get(screenshotPath)));
                    result.setScreenshotPath(screenshotPath);
                } catch (Exception e) {
                    logger.warn("Failed to take failure screenshot", e);
                }
            }
            
        } catch (Exception e) {
            logger.error("Step execution failed: {}", e.getMessage(), e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        }
        
        return result;
    }
    
    private void executeNavigate(Page page, TestStep step, StepResult result) {
        try {
            String url = getRequiredParameter(step, "url");
            Response response = page.navigate(url, new Page.NavigateOptions()
                .setTimeout(getTimeoutParam(step))
                .setWaitUntil(getWaitUntilParam(step)));
            
            if (response != null) {
                result.setSuccess(response.ok());
                if (!response.ok()) {
                    result.setErrorMessage("Navigation resulted in status: " + response.status());
                }
            } else {
                result.setSuccess(true);
            }
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Navigation failed: " + e.getMessage());
        }
    }
    
    private void executeClick(Page page, TestStep step, String selector, StepResult result) {
        try {
            if (selector == null || selector.isEmpty()) {
                result.setSuccess(false);
                result.setErrorMessage("Selector is required for click action");
                return;
            }
            
            Locator locator = page.locator(selector);
            locator.click(new Locator.ClickOptions()
                .setTimeout(getTimeoutParam(step))
                .setButton(getMouseButtonParam(step))
                .setForce(getBooleanParam(step, "force", false))
                .setNoWaitAfter(getBooleanParam(step, "noWaitAfter", false)));
            
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Click failed: " + e.getMessage());
        }
    }
    
    private void executeType(Page page, TestStep step, String selector, StepResult result) {
        try {
            if (selector == null || selector.isEmpty()) {
                result.setSuccess(false);
                result.setErrorMessage("Selector is required for type action");
                return;
            }
            
            String text = getRequiredParameter(step, "text");
            
            Locator locator = page.locator(selector);
            
            // Clear input first if requested
            if (getBooleanParam(step, "clear", true)) {
                locator.clear();
            }
            
            locator.type(text, new Locator.TypeOptions()
                .setTimeout(getTimeoutParam(step))
                .setDelay(getIntParam(step, "delay", 0)));
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Type failed: " + e.getMessage());
        }
    }
    
    private void executeCheck(Page page, TestStep step, String selector, StepResult result) {
        try {
            if (selector == null || selector.isEmpty()) {
                result.setSuccess(false);
                result.setErrorMessage("Selector is required for check action");
                return;
            }
            
            Locator locator = page.locator(selector);
            locator.check(new Locator.CheckOptions()
                .setTimeout(getTimeoutParam(step))
                .setForce(getBooleanParam(step, "force", false)));
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Check failed: " + e.getMessage());
        }
    }
    
    private void executeUncheck(Page page, TestStep step, String selector, StepResult result) {
        try {
            if (selector == null || selector.isEmpty()) {
                result.setSuccess(false);
                result.setErrorMessage("Selector is required for uncheck action");
                return;
            }
            
            Locator locator = page.locator(selector);
            locator.uncheck(new Locator.UncheckOptions()
                .setTimeout(getTimeoutParam(step))
                .setForce(getBooleanParam(step, "force", false)));
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Uncheck failed: " + e.getMessage());
        }
    }
    
    private void executeSelect(Page page, TestStep step, String selector, StepResult result) {
        try {
            if (selector == null || selector.isEmpty()) {
                result.setSuccess(false);
                result.setErrorMessage("Selector is required for select action");
                return;
            }
            
            Object valueObj = step.getParameters().get("value");
            if (valueObj == null) {
                result.setSuccess(false);
                result.setErrorMessage("Value is required for select action");
                return;
            }
            
            Locator locator = page.locator(selector);
            
            // Handle different types of select values (single string, array of strings, by label, etc.)
            if (valueObj instanceof String) {
                locator.selectOption((String) valueObj);
            } else if (valueObj instanceof String[]) {
                locator.selectOption((String[]) valueObj);
            } else if (valueObj instanceof Map) {
                Map<String, String> valueMap = (Map<String, String>) valueObj;
                SelectOption option = new SelectOption();
                
                if (valueMap.containsKey("label")) {
                    option.setLabel(valueMap.get("label"));
                } else if (valueMap.containsKey("value")) {
                    option.setValue(valueMap.get("value"));
                } else if (valueMap.containsKey("index")) {
                    option.setIndex(Integer.parseInt(valueMap.get("index")));
                }
                
                locator.selectOption(option);
            }
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Select failed: " + e.getMessage());
        }
    }
    
    private void executeWait(Page page, TestStep step, String selector, StepResult result) {
        try {
            String waitType = getStringParam(step, "waitType", "selector");
            
            switch (waitType) {
                case "selector":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for wait action");
                        return;
                    }
                    
                    String state = getStringParam(step, "state", "visible");
                    WaitForSelectorState selectorState;
                    
                    switch (state) {
                        case "attached":
                            selectorState = WaitForSelectorState.ATTACHED;
                            break;
                        case "detached":
                            selectorState = WaitForSelectorState.DETACHED;
                            break;
                        case "hidden":
                            selectorState = WaitForSelectorState.HIDDEN;
                            break;
                        case "visible":
                        default:
                            selectorState = WaitForSelectorState.VISIBLE;
                            break;
                    }
                    
                    page.waitForSelector(selector, new Page.WaitForSelectorOptions()
                        .setState(selectorState)
                        .setTimeout(getTimeoutParam(step)));
                    break;
                    
                case "navigation":
                    page.waitForNavigation(new Page.WaitForNavigationOptions()
                        .setTimeout(getTimeoutParam(step))
                        .setWaitUntil(getWaitUntilParam(step)));
                    break;
                    
                case "loadstate":
                    String loadState = getStringParam(step, "state", "load");
                    LoadState pageLoadState;
                    
                    switch (loadState) {
                        case "domcontentloaded":
                            pageLoadState = LoadState.DOMCONTENTLOADED;
                            break;
                        case "networkidle":
                            pageLoadState = LoadState.NETWORKIDLE;
                            break;
                        case "load":
                        default:
                            pageLoadState = LoadState.LOAD;
                            break;
                    }
                    
                    page.waitForLoadState(pageLoadState, 
                        new Page.WaitForLoadStateOptions().setTimeout(getTimeoutParam(step)));
                    break;
                    
                case "timeout":
                    int duration = getIntParam(step, "duration", 1000);
                    page.waitForTimeout(duration);
                    break;
                    
                case "function":
                    String functionBody = getRequiredParameter(step, "function");
                    page.waitForFunction(functionBody, 
                        new Page.WaitForFunctionOptions().setTimeout(getTimeoutParam(step)));
                    break;
                    
                default:
                    result.setSuccess(false);
                    result.setErrorMessage("Unsupported wait type: " + waitType);
                    return;
            }
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Wait failed: " + e.getMessage());
        }
    }
    
    private void executeScreenshot(String browserId, TestStep step, StepResult result) {
        try {
            Page page = getPage(browserId);
            String path = getStringParam(step, "path", "screenshots/screenshot_" + System.currentTimeMillis() + ".png");
            
            boolean fullPage = getBooleanParam(step, "fullPage", false);
            
            page.screenshot(new Page.ScreenshotOptions()
                .setPath(Paths.get(path))
                .setFullPage(fullPage)
                .setQuality(getIntParam(step, "quality", 90))
                .setOmitBackground(getBooleanParam(step, "omitBackground", false)));
                
            result.setSuccess(true);
            result.setScreenshotPath(path);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Screenshot failed: " + e.getMessage());
        }
    }
    
    private void executeAssert(Page page, TestStep step, String selector, StepResult result) {
        try {
            String assertType = getRequiredParameter(step, "assertType");
            
            switch (assertType) {
                case "visible":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for visible assertion");
                        return;
                    }
                    
                    boolean isVisible = page.locator(selector).isVisible();
                    boolean shouldBeVisible = getBooleanParam(step, "expected", true);
                    
                    result.setSuccess(isVisible == shouldBeVisible);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Visibility assertion failed: element should %s visible but was %s", 
                            shouldBeVisible ? "be" : "not be",
                            isVisible ? "visible" : "not visible"));
                    }
                    break;
                    
                case "enabled":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for enabled assertion");
                        return;
                    }
                    
                    boolean isEnabled = page.locator(selector).isEnabled();
                    boolean shouldBeEnabled = getBooleanParam(step, "expected", true);
                    
                    result.setSuccess(isEnabled == shouldBeEnabled);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Enabled assertion failed: element should %s enabled but was %s", 
                            shouldBeEnabled ? "be" : "not be",
                            isEnabled ? "enabled" : "disabled"));
                    }
                    break;
                    
                case "text":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for text assertion");
                        return;
                    }
                    
                    String actualText = page.locator(selector).textContent();
                    String expectedText = getRequiredParameter(step, "expected");
                    String matchType = getStringParam(step, "matchType", "exact");
                    
                    boolean textMatches;
                    switch (matchType) {
                        case "contains":
                            textMatches = actualText != null && actualText.contains(expectedText);
                            break;
                        case "regex":
                            textMatches = actualText != null && actualText.matches(expectedText);
                            break;
                        case "exact":
                        default:
                            textMatches = expectedText.equals(actualText);
                            break;
                    }
                    
                    result.setSuccess(textMatches);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Text assertion failed: expected text %s '%s' but got '%s'", 
                            matchType.equals("contains") ? "to contain" : 
                            matchType.equals("regex") ? "to match regex" : "to equal",
                            expectedText, actualText));
                    }
                    break;
                    
                case "attribute":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for attribute assertion");
                        return;
                    }
                    
                    String attributeName = getRequiredParameter(step, "attribute");
                    String actualAttribute = page.locator(selector).getAttribute(attributeName);
                    String expectedAttribute = getRequiredParameter(step, "expected");
                    
                    result.setSuccess(expectedAttribute.equals(actualAttribute));
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Attribute assertion failed: expected attribute '%s' to equal '%s' but got '%s'", 
                            attributeName, expectedAttribute, actualAttribute));
                    }
                    break;
                    
                case "count":
                    if (selector == null || selector.isEmpty()) {
                        result.setSuccess(false);
                        result.setErrorMessage("Selector is required for count assertion");
                        return;
                    }
                    
                    int actualCount = page.locator(selector).count();
                    int expectedCount = Integer.parseInt(getRequiredParameter(step, "expected"));
                    
                    result.setSuccess(actualCount == expectedCount);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Count assertion failed: expected %d elements but found %d", 
                            expectedCount, actualCount));
                    }
                    break;
                    
                case "url":
                    String actualUrl = page.url();
                    String expectedUrl = getRequiredParameter(step, "expected");
                    String urlMatchType = getStringParam(step, "matchType", "exact");
                    
                    boolean urlMatches;
                    switch (urlMatchType) {
                        case "contains":
                            urlMatches = actualUrl.contains(expectedUrl);
                            break;
                        case "regex":
                            urlMatches = actualUrl.matches(expectedUrl);
                            break;
                        case "exact":
                        default:
                            urlMatches = expectedUrl.equals(actualUrl);
                            break;
                    }
                    
                    result.setSuccess(urlMatches);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "URL assertion failed: expected URL %s '%s' but got '%s'", 
                            urlMatchType.equals("contains") ? "to contain" : 
                            urlMatchType.equals("regex") ? "to match regex" : "to equal",
                            expectedUrl, actualUrl));
                    }
                    break;
                    
                case "title":
                    String actualTitle = page.title();
                    String expectedTitle = getRequiredParameter(step, "expected");
                    String titleMatchType = getStringParam(step, "matchType", "exact");
                    
                    boolean titleMatches;
                    switch (titleMatchType) {
                        case "contains":
                            titleMatches = actualTitle.contains(expectedTitle);
                            break;
                        case "regex":
                            titleMatches = actualTitle.matches(expectedTitle);
                            break;
                        case "exact":
                        default:
                            titleMatches = expectedTitle.equals(actualTitle);
                            break;
                    }
                    
                    result.setSuccess(titleMatches);
                    if (!result.isSuccess()) {
                        result.setErrorMessage(String.format(
                            "Title assertion failed: expected title %s '%s' but got '%s'", 
                            titleMatchType.equals("contains") ? "to contain" : 
                            titleMatchType.equals("regex") ? "to match regex" : "to equal",
                            expectedTitle, actualTitle));
                    }
                    break;
                    
                default:
                    result.setSuccess(false);
                    result.setErrorMessage("Unsupported assertion type: " + assertType);
                    break;
            }
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("Assertion failed: " + e.getMessage());
        }
    }
    
    private void executeJs(Page page, TestStep step, StepResult result) {
        try {
            String script = getRequiredParameter(step, "script");
            Object jsResult = page.evaluate(script);
            
            // Store JS result if needed
            if (step.getParameters().containsKey("resultVariable")) {
                String varName = getStringParam(step, "resultVariable", null);
                if (varName != null && !varName.isEmpty()) {
                    // Result could be stored for use in a subsequent step
                    result.getOutputVariables().put(varName, jsResult);
                }
            }
                
            result.setSuccess(true);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMessage("JavaScript execution failed: " + e.getMessage());
        }
    }
    
    @Override
    public void closeBrowser(String browserId) {
        logger.info("Closing browser: {}", browserId);
        
        try {
            String pageId = browserId + "_page";
            String contextId = browserId + "_context";
            
            // Close page
            if (pages.containsKey(pageId)) {
                pages.get(pageId).close();
                pages.remove(pageId);
            }
            
            // Stop tracing and save trace file
            if (contexts.containsKey(contextId)) {
                try {
                    BrowserContext context = contexts.get(contextId);
                    context.tracing().stop(new Tracing.StopOptions()
                        .setPath(Paths.get("traces/trace_" + browserId + ".zip")));
                } catch (Exception e) {
                    logger.warn("Failed to save trace file: {}", e.getMessage());
                }
                
                // Close context
                contexts.get(contextId).close();
                contexts.remove(contextId);
            }
            
            // Close browser
            if (browsers.containsKey(browserId)) {
                browsers.get(browserId).close();
                browsers.remove(browserId);
            }
            
            logger.info("Browser closed successfully: {}", browserId);
        } catch (Exception e) {
            logger.error("Failed to close browser: {}", e.getMessage(), e);
            throw new RuntimeException("Browser closing failed", e);
        }
    }
    
    @Override
    public void shutdown() {
        logger.info("Shutting down Playwright service");
        
        try {
            // Close all pages, contexts, and browsers
            for (Map.Entry<String, Page> entry : pages.entrySet()) {
                try {
                    logger.debug("Closing page: {}", entry.getKey());
                    entry.getValue().close();
                } catch (Exception e) {
                    logger.warn("Failed to close page: {}", e.getMessage());
                }
            }
            pages.clear();
            
            for (Map.Entry<String, BrowserContext> entry : contexts.entrySet()) {
                try {
                    logger.debug("Closing context: {}", entry.getKey());
                    entry.getValue().close();
                } catch (Exception e) {
                    logger.warn("Failed to close context: {}", e.getMessage());
                }
            }
            contexts.clear();
            
            for (Map.Entry<String, Browser> entry : browsers.entrySet()) {
                try {
                    logger.debug("Closing browser: {}", entry.getKey());
                    entry.getValue().close();
                } catch (Exception e) {
                    logger.warn("Failed to close browser: {}", e.getMessage());
                }
            }
            browsers.clear();
            
            // Finally close playwright
            playwright.close();
            
            logger.info("Playwright service shutdown complete");
        } catch (Exception e) {
            logger.error("Failed to shutdown Playwright service: {}", e.getMessage(), e);
        }
    }
    
    private Page getPage(String browserId) {
        String pageId = browserId + "_page";
        return pages.getOrDefault(pageId, null);
    }
    
    private String getRequiredParameter(TestStep step, String paramName) {
        if (step.getParameters() == null || !step.getParameters().containsKey(paramName)) {
            throw new IllegalArgumentException("Required parameter missing: " + paramName);
        }
        
        Object value = step.getParameters().get(paramName);
        if (value == null) {
            throw new IllegalArgumentException("Required parameter is null: " + paramName);
        }
        
        return value.toString();
    }
    
    private String getStringParam(TestStep step, String paramName, String defaultValue) {
        if (step.getParameters() == null || !step.getParameters().containsKey(paramName)) {
            return defaultValue;
        }
        
        Object value = step.getParameters().get(paramName);
        return value != null ? value.toString() : defaultValue;
    }
    
    private int getIntParam(TestStep step, String paramName, int defaultValue) {
        if (step.getParameters() == null || !step.getParameters().containsKey(paramName)) {
            return defaultValue;
        }
        
        Object value = step.getParameters().get(paramName);
        if (value == null) {
            return defaultValue;
        }
        
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }
    
    private boolean getBooleanParam(TestStep step, String paramName, boolean defaultValue) {
        if (step.getParameters() == null || !step.getParameters().containsKey(paramName)) {
            return defaultValue;
        }
        
        Object value = step.getParameters().get(paramName);
        if (value == null) {
            return defaultValue;
        }
        
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        
        return Boolean.parseBoolean(value.toString());
    }
    
    private int getTimeoutParam(TestStep step) {
        return getIntParam(step, "timeout", 30000);
    }
    
    private WaitUntilState getWaitUntilParam(TestStep step) {
        String waitUntil = getStringParam(step, "waitUntil", "load");
        
        switch (waitUntil) {
            case "domcontentloaded":
                return WaitUntilState.DOMCONTENTLOADED;
            case "networkidle":
                return WaitUntilState.NETWORKIDLE;
            case "commit":
                return WaitUntilState.COMMIT;
            case "load":
            default:
                return WaitUntilState.LOAD;
        }
    }
    
    private MouseButton getMouseButtonParam(TestStep step) {
        String button = getStringParam(step, "button", "left");
        
        switch (button.toLowerCase()) {
            case "right":
                return MouseButton.RIGHT;
            case "middle":
                return MouseButton.MIDDLE;
            case "left":
            default:
                return MouseButton.LEFT;
        }
    }
}


/**
 * Custom Reporting Service
 * Provides comprehensive test execution reporting without third-party dependencies
 */
package com.cstestforge.service.impl.reporting;

import com.cstestforge.model.execution.ExecutionResult;
import com.cstestforge.model.execution.ExecutionStepResult;
import com.cstestforge.model.execution.ExecutionSummary;
import com.cstestforge.model.execution.TestCaseResult;
import com.cstestforge.model.project.Project;
import com.cstestforge.model.testcase.TestCase;
import com.cstestforge.service.project.ProjectService;
import com.cstestforge.service.reporting.ReportingService;
import com.cstestforge.service.testcase.TestCaseService;
import com.cstestforge.util.DateTimeUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
public class CustomReportingServiceImpl implements ReportingService {
    private static final Logger logger = LoggerFactory.getLogger(CustomReportingServiceImpl.class);
    
    @Autowired
    private ProjectService projectService;
    
    @Autowired
    private TestCaseService testCaseService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Value("${app.reports.dir:./reports}")
    private String reportsDirectory;
    
    // In-memory storage for historical data
    private final Map<String, List<ExecutionSummary>> projectExecutionHistory = new ConcurrentHashMap<>();
    private final Map<String, Map<String, List<TestCaseResult>>> testCaseExecutionHistory = new ConcurrentHashMap<>();
    
    // Store trend data
    private final Map<String, List<Map<String, Object>>> projectTrends = new ConcurrentHashMap<>();
    
    @Override
    public String generateExecutionReport(ExecutionResult result) {
        logger.info("Generating execution report for execution {}", result.getExecutionId());
        
        try {
            // Create reports directory if it doesn't exist
            Files.createDirectories(Paths.get(reportsDirectory));
            
            // Create execution-specific directory
            String executionDirName = String.format("%s_%s", 
                DateTimeUtils.formatDateTime(result.getStartTime(), "yyyyMMdd_HHmmss"),
                result.getExecutionId());
            Path executionDir = Paths.get(reportsDirectory, executionDirName);
            Files.createDirectories(executionDir);
            
            // Generate report files
            String htmlReportPath = generateHtmlReport(result, executionDir);
            generateJsonReport(result, executionDir);
            
            // Update historical data
            updateExecutionHistory(result);
            
            return htmlReportPath;
        } catch (Exception e) {
            logger.error("Failed to generate execution report: {}", e.getMessage(), e);
            return null;
        }
    }
    
    @Override
    public ExecutionSummary getExecutionSummary(String executionId) {
        // Find execution summary from historical data
        for (List<ExecutionSummary> executions : projectExecutionHistory.values()) {
            for (ExecutionSummary summary : executions) {
                if (summary.getExecutionId().equals(executionId)) {
                    return summary;
                }
            }
        }
        
        return null;
    }
    
    @Override
    public List<ExecutionSummary> getProjectExecutionHistory(String projectId) {
        return projectExecutionHistory.getOrDefault(projectId, new ArrayList<>());
    }
    
    @Override
    public Map<String, Object> getProjectMetrics(String projectId) {
        Map<String, Object> metrics = new HashMap<>();
        List<ExecutionSummary> executions = projectExecutionHistory.getOrDefault(projectId, new ArrayList<>());
        
        if (executions.isEmpty()) {
            metrics.put("totalExecutions", 0);
            return metrics;
        }
        
        // Basic metrics
        metrics.put("totalExecutions", executions.size());
        
        int totalPassed = 0;
        int totalFailed = 0;
        int totalSkipped = 0;
        long totalDuration = 0;
        
        for (ExecutionSummary summary : executions) {
            totalPassed += summary.getPassedCount();
            totalFailed += summary.getFailedCount();
            totalSkipped += summary.getSkippedCount();
            totalDuration += summary.getDurationMs();
        }
        
        int totalTests = totalPassed + totalFailed + totalSkipped;
        
        metrics.put("totalTests", totalTests);
        metrics.put("totalPassed", totalPassed);
        metrics.put("totalFailed", totalFailed);
        metrics.put("totalSkipped", totalSkipped);
        metrics.put("averageDuration", totalTests > 0 ? totalDuration / totalTests : 0);
        
        // Success rate
        double successRate = totalTests > 0 ? (double) totalPassed / totalTests * 100 : 0;
        metrics.put("successRate", Math.round(successRate * 100) / 100.0);
        
        // Recent executions (last 10)
        List<ExecutionSummary> recentExecutions = executions.stream()
            .sorted(Comparator.comparing(ExecutionSummary::getStartTime).reversed())
            .limit(10)
            .collect(Collectors.toList());
        metrics.put("recentExecutions", recentExecutions);
        
        // Trends data
        metrics.put("trends", projectTrends.getOrDefault(projectId, new ArrayList<>()));
        
        // Test case success rates
        Map<String, List<TestCaseResult>> testCaseHistory = testCaseExecutionHistory.getOrDefault(projectId, new HashMap<>());
        List<Map<String, Object>> testCaseMetrics = new ArrayList<>();
        
        for (Map.Entry<String, List<TestCaseResult>> entry : testCaseHistory.entrySet()) {
            String testCaseId = entry.getKey();
            List<TestCaseResult> results = entry.getValue();
            
            if (results.isEmpty()) {
                continue;
            }
            
            TestCase testCase = testCaseService.getTestCase(projectId, testCaseId);
            if (testCase == null) {
                continue;
            }
            
            Map<String, Object> testCaseMetric = new HashMap<>();
            testCaseMetric.put("testCaseId", testCaseId);
            testCaseMetric.put("testCaseName", testCase.getName());
            
            int tcPassed = 0;
            int tcFailed = 0;
            int tcSkipped = 0;
            long tcTotalDuration = 0;
            
            for (TestCaseResult result : results) {
                if (result.isSuccess()) {
                    tcPassed++;
                } else if (result.isSkipped()) {
                    tcSkipped++;
                } else {
                    tcFailed++;
                }
                tcTotalDuration += result.getDurationMs();
            }
            
            testCaseMetric.put("totalExecutions", results.size());
            testCaseMetric.put("passed", tcPassed);
            testCaseMetric.put("failed", tcFailed);
            testCaseMetric.put("skipped", tcSkipped);
            testCaseMetric.put("successRate", Math.round((double) tcPassed / results.size() * 10000) / 100.0);
            testCaseMetric.put("averageDuration", results.size() > 0 ? tcTotalDuration / results.size() : 0);
            testCaseMetric.put("lastExecuted", results.stream()
                .max(Comparator.comparing(TestCaseResult::getEndTime))
                .map(TestCaseResult::getEndTime)
                .orElse(null));
            
            testCaseMetrics.add(testCaseMetric);
        }
        
        // Sort by success rate ascending (most problematic tests first)
        testCaseMetrics.sort(Comparator.comparingDouble(tc -> (double) tc.get("successRate")));
        metrics.put("testCaseMetrics", testCaseMetrics);
        
        return metrics;
    }
    
    @Override
    public List<Map<String, Object>> getTestCaseExecutionHistory(String projectId, String testCaseId) {
        Map<String, List<TestCaseResult>> projectHistory = testCaseExecutionHistory.getOrDefault(projectId, new HashMap<>());
        List<TestCaseResult> history = projectHistory.getOrDefault(testCaseId, new ArrayList<>());
        
        return history.stream()
            .sorted(Comparator.comparing(TestCaseResult::getStartTime).reversed())
            .map(this::convertTestCaseResultToMap)
            .collect(Collectors.toList());
    }
    
    @Override
    public Map<String, Object> getFailureAnalysis(String projectId) {
        Map<String, Object> analysis = new HashMap<>();
        List<ExecutionSummary> executions = projectExecutionHistory.getOrDefault(projectId, new ArrayList<>());
        
        if (executions.isEmpty()) {
            return analysis;
        }
        
        // Collect all failures
        Map<String, List<Map<String, Object>>> failuresByTestCase = new HashMap<>();
        Map<String, Integer> failureCountByError = new HashMap<>();
        Map<String, List<String>> testCasesByError = new HashMap<>();
        
        // Process test case history to find failures
        Map<String, List<TestCaseResult>> testCaseHistory = testCaseExecutionHistory.getOrDefault(projectId, new HashMap<>());
        
        for (Map.Entry<String, List<TestCaseResult>> entry : testCaseHistory.entrySet()) {
            String testCaseId = entry.getKey();
            List<TestCaseResult> results = entry.getValue();
            
            // Filter failed results
            List<TestCaseResult> failures = results.stream()
                .filter(r -> !r.isSuccess() && !r.isSkipped())
                .collect(Collectors.toList());
            
            if (failures.isEmpty()) {
                continue;
            }
            
            // Convert to maps for the report
            List<Map<String, Object>> failureMaps = failures.stream()
                .map(this::convertTestCaseResultToMap)
                .collect(Collectors.toList());
            
            failuresByTestCase.put(testCaseId, failureMaps);
            
            // Process failure reasons
            for (TestCaseResult failure : failures) {
                String errorMessage = normalizeErrorMessage(failure.getErrorMessage());
                
                failureCountByError.put(errorMessage, failureCountByError.getOrDefault(errorMessage, 0) + 1);
                
                testCasesByError.computeIfAbsent(errorMessage, k -> new ArrayList<>());
                if (!testCasesByError.get(errorMessage).contains(testCaseId)) {
                    testCasesByError.get(errorMessage).add(testCaseId);
                }
            }
        }
        
        // Convert to list for sorting
        List<Map<String, Object>> topErrors = failureCountByError.entrySet().stream()
            .map(entry -> {
                Map<String, Object> error = new HashMap<>();
                error.put("errorMessage", entry.getKey());
                error.put("count", entry.getValue());
                error.put("affectedTestCases", testCasesByError.get(entry.getKey()));
                return error;
            })
            .sorted(Comparator.comparingInt(m -> -((Integer) m.get("count"))))
            .limit(10)
            .collect(Collectors.toList());
        
        analysis.put("topErrors", topErrors);
        analysis.put("failuresByTestCase", failuresByTestCase);
        
        // Find most unstable test cases (those that sometimes pass, sometimes fail)
        List<Map<String, Object>> unstableTestCases = new ArrayList<>();
        
        for (Map.Entry<String, List<TestCaseResult>> entry : testCaseHistory.entrySet()) {
            String testCaseId = entry.getKey();
            List<TestCaseResult> results = entry.getValue();
            
            if (results.size() < 3) {
                continue; // Need at least 3 executions to determine stability
            }
            
            long passCount = results.stream().filter(TestCaseResult::isSuccess).count();
            long failCount = results.stream().filter(r -> !r.isSuccess() && !r.isSkipped()).count();
            
            // Calculate instability score - highest when pass/fail ratio is close to 50/50
            double passRatio = (double) passCount / results.size();
            double instabilityScore = 4 * passRatio * (1 - passRatio); // Will be highest (1.0) at 50/50
            
            if (instabilityScore > 0.4 && passCount > 0 && failCount > 0) { // Only include truly unstable tests
                TestCase testCase = testCaseService.getTestCase(projectId, testCaseId);
                
                if (testCase != null) {
                    Map<String, Object> unstableTest = new HashMap<>();
                    unstableTest.put("testCaseId", testCaseId);
                    unstableTest.put("testCaseName", testCase.getName());
                    unstableTest.put("passCount", passCount);
                    unstableTest.put("failCount", failCount);
                    unstableTest.put("totalRuns", results.size());
                    unstableTest.put("instabilityScore", Math.round(instabilityScore * 100) / 100.0);
                    unstableTest.put("lastResults", results.stream()
                        .sorted(Comparator.comparing(TestCaseResult::getStartTime).reversed())
                        .limit(5)
                        .map(r -> r.isSuccess() ? "PASS" : r.isSkipped() ? "SKIP" : "FAIL")
                        .collect(Collectors.toList()));
                    
                    unstableTestCases.add(unstableTest);
                }
            }
        }
        
        // Sort by instability score
        unstableTestCases.sort(Comparator.comparingDouble(m -> -((Double) m.get("instabilityScore"))));
        analysis.put("unstableTestCases", unstableTestCases);
        
        return analysis;
    }
    
    private Map<String, Object> convertTestCaseResultToMap(TestCaseResult result) {
        Map<String, Object> map = new HashMap<>();
        map.put("testCaseId", result.getTestCaseId());
        map.put("executionId", result.getExecutionId());
        map.put("success", result.isSuccess());
        map.put("skipped", result.isSkipped());
        map.put("startTime", result.getStartTime());
        map.put("endTime", result.getEndTime());
        map.put("durationMs", result.getDurationMs());
        map.put("errorMessage", result.getErrorMessage());
        
        return map;
    }
    
    private String normalizeErrorMessage(String errorMessage) {
        if (errorMessage == null) {
            return "Unknown error";
        }
        
        // Remove dynamic parts like specific selectors, timestamps, etc.
        String normalized = errorMessage
            .replaceAll("\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b", "{UUID}")
            .replaceAll("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}", "{TIMESTAMP}")
            .replaceAll("line \\d+", "line {LINE}")
            .replaceAll("at position \\d+", "at position {POS}");
        
        // Truncate if too long
        if (normalized.length() > 200) {
            return normalized.substring(0, 197) + "...";
        }
        
        return normalized;
    }
    
    private void updateExecutionHistory(ExecutionResult result) {
        // Create summary
        ExecutionSummary summary = createExecutionSummary(result);
        
        // Update project execution history
        projectExecutionHistory.computeIfAbsent(result.getProjectId(), k -> new ArrayList<>());
        List<ExecutionSummary> projectHistory = projectExecutionHistory.get(result.getProjectId());
        projectHistory.add(summary);
        
        // Keep only the last 100 executions per project
        if (projectHistory.size() > 100) {
            projectHistory.sort(Comparator.comparing(ExecutionSummary::getStartTime));
            projectExecutionHistory.put(result.getProjectId(), 
                new ArrayList<>(projectHistory.subList(projectHistory.size() - 100, projectHistory.size())));
        }
        
        // Update test case execution history
        testCaseExecutionHistory.computeIfAbsent(result.getProjectId(), k -> new HashMap<>());
        Map<String, List<TestCaseResult>> projectTestCaseHistory = testCaseExecutionHistory.get(result.getProjectId());
        
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            projectTestCaseHistory.computeIfAbsent(testCaseResult.getTestCaseId(), k -> new ArrayList<>());
            List<TestCaseResult> testCaseHistory = projectTestCaseHistory.get(testCaseResult.getTestCaseId());
            testCaseHistory.add(testCaseResult);
            
            // Keep only the last 50 executions per test case
            if (testCaseHistory.size() > 50) {
                testCaseHistory.sort(Comparator.comparing(TestCaseResult::getStartTime));
                projectTestCaseHistory.put(testCaseResult.getTestCaseId(), 
                    new ArrayList<>(testCaseHistory.subList(testCaseHistory.size() - 50, testCaseHistory.size())));
            }
        }
        
        // Update trends data
        updateTrendsData(result);
    }
    
    private ExecutionSummary createExecutionSummary(ExecutionResult result) {
        ExecutionSummary summary = new ExecutionSummary();
        summary.setExecutionId(result.getExecutionId());
        summary.setProjectId(result.getProjectId());
        summary.setName(result.getName());
        summary.setStartTime(result.getStartTime());
        summary.setEndTime(result.getEndTime());
        summary.setStatus(result.getStatus());
        
        // Calculate counts
        int passedCount = 0;
        int failedCount = 0;
        int skippedCount = 0;
        
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            if (testCaseResult.isSkipped()) {
                skippedCount++;
            } else if (testCaseResult.isSuccess()) {
                passedCount++;
            } else {
                failedCount++;
            }
        }
        
        summary.setTotalCount(passedCount + failedCount + skippedCount);
        summary.setPassedCount(passedCount);
        summary.setFailedCount(failedCount);
        summary.setSkippedCount(skippedCount);
        
        // Calculate duration
        if (result.getStartTime() != null && result.getEndTime() != null) {
            long durationMs = Duration.between(result.getStartTime(), result.getEndTime()).toMillis();
            summary.setDurationMs(durationMs);
        }
        
        return summary;
    }
    
    private void updateTrendsData(ExecutionResult result) {
        projectTrends.computeIfAbsent(result.getProjectId(), k -> new ArrayList<>());
        List<Map<String, Object>> trends = projectTrends.get(result.getProjectId());
        
        // Create trend point
        Map<String, Object> trendPoint = new HashMap<>();
        trendPoint.put("executionId", result.getExecutionId());
        trendPoint.put("timestamp", result.getEndTime());
        
        // Count results
        int passedCount = 0;
        int failedCount = 0;
        int skippedCount = 0;
        long totalDuration = 0;
        
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            if (testCaseResult.isSkipped()) {
                skippedCount++;
            } else if (testCaseResult.isSuccess()) {
                passedCount++;
            } else {
                failedCount++;
            }
            totalDuration += testCaseResult.getDurationMs();
        }
        
        int totalCount = passedCount + failedCount + skippedCount;
        double successRate = totalCount > 0 ? (double) passedCount / totalCount * 100 : 0;
        double avgDuration = totalCount > 0 ? (double) totalDuration / totalCount : 0;
        
        trendPoint.put("totalCount", totalCount);
        trendPoint.put("passedCount", passedCount);
        trendPoint.put("failedCount", failedCount);
        trendPoint.put("skippedCount", skippedCount);
        trendPoint.put("successRate", Math.round(successRate * 100) / 100.0);
        trendPoint.put("avgDuration", avgDuration);
        
        trends.add(trendPoint);
        
        // Keep only the last 100 trend points
        if (trends.size() > 100) {
            trends.sort(Comparator.comparing(p -> ((LocalDateTime) p.get("timestamp"))));
            projectTrends.put(result.getProjectId(), 
                new ArrayList<>(trends.subList(trends.size() - 100, trends.size())));
        }
    }
    
    private String generateHtmlReport(ExecutionResult result, Path reportDir) throws IOException {
        // Create HTML report file
        Path htmlReportPath = reportDir.resolve("report.html");
        
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(htmlReportPath.toFile()))) {
            // Generate HTML content
            writer.write(generateHtmlContent(result));
        }
        
        // Generate individual test case reports
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            Path testCaseReportPath = reportDir.resolve("testcase_" + testCaseResult.getTestCaseId() + ".html");
            
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(testCaseReportPath.toFile()))) {
                writer.write(generateTestCaseHtmlContent(result, testCaseResult));
            }
        }
        
        // Copy screenshots if available
        copyScreenshots(result, reportDir);
        
        // Copy any videos if available
        copyVideos(result, reportDir);
        
        return htmlReportPath.toAbsolutePath().toString();
    }
    
    private void generateJsonReport(ExecutionResult result, Path reportDir) throws IOException {
        // Create JSON report file
        Path jsonReportPath = reportDir.resolve("report.json");
        
        // Write execution result as JSON
        objectMapper.writerWithDefaultPrettyPrinter().writeValue(jsonReportPath.toFile(), result);
    }
    
    private String generateHtmlContent(ExecutionResult result) {
        StringBuilder html = new StringBuilder();
        Project project = projectService.getProject(result.getProjectId());
        String projectName = project != null ? project.getName() : "Unknown Project";
        
        // Calculate summary
        int totalTests = result.getTestCaseResults().size();
        int passedTests = (int) result.getTestCaseResults().stream().filter(TestCaseResult::isSuccess).count();
        int failedTests = (int) result.getTestCaseResults().stream()
            .filter(r -> !r.isSuccess() && !r.isSkipped()).count();
        int skippedTests = (int) result.getTestCaseResults().stream().filter(TestCaseResult::isSkipped).count();
        
        double successRate = totalTests > 0 ? (double) passedTests / totalTests * 100 : 0;
        String duration = formatDuration(result.getStartTime(), result.getEndTime());
        
        // HTML header
        html.append("<!DOCTYPE html>\n")
            .append("<html lang=\"en\">\n")
            .append("<head>\n")
            .append("  <meta charset=\"UTF-8\">\n")
            .append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
            .append("  <title>Test Execution Report</title>\n")
            .append("  <style>\n")
            .append("    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }\n")
            .append("    h1, h2, h3 { color: #444; }\n")
            .append("    .summary { display: flex; justify-content: space-between; flex-wrap: wrap; margin-bottom: 20px; }\n")
            .append("    .summary-box { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin: 10px; min-width: 200px; }\n")
            .append("    .success { color: #4CAF50; }\n")
            .append("    .failure { color: #F44336; }\n")
            .append("    .skipped { color: #FF9800; }\n")
            .append("    table { border-collapse: collapse; width: 100%; margin-top: 20px; }\n")
            .append("    th, td { text-align: left; padding: 12px; border-bottom: 1px solid #ddd; }\n")
            .append("    tr:hover { background-color: #f5f5f5; }\n")
            .append("    th { background-color: #4CAF50; color: white; }\n")
            .append("    .pass { background-color: rgba(76, 175, 80, 0.1); }\n")
            .append("    .fail { background-color: rgba(244, 67, 54, 0.1); }\n")
            .append("    .skip { background-color: rgba(255, 152, 0, 0.1); }\n")
            .append("    .step-table { margin-left: 20px; width: calc(100% - 20px); font-size: 0.9em; }\n")
            .append("    .step-success { color: #4CAF50; }\n")
            .append("    .step-failure { color: #F44336; }\n")
            .append("    .collapsible { cursor: pointer; }\n")
            .append("    .content { display: none; overflow: hidden; }\n")
            .append("  </style>\n")
            .append("</head>\n")
            .append("<body>\n");
        
        // Report header
        html.append("  <h1>Test Execution Report</h1>\n")
            .append("  <p><strong>Project:</strong> ").append(projectName).append("</p>\n")
            .append("  <p><strong>Execution:</strong> ").append(result.getName()).append("</p>\n")
            .append("  <p><strong>Start Time:</strong> ").append(formatDateTime(result.getStartTime())).append("</p>\n")
            .append("  <p><strong>End Time:</strong> ").append(formatDateTime(result.getEndTime())).append("</p>\n")
            .append("  <p><strong>Duration:</strong> ").append(duration).append("</p>\n");
        
        // Summary boxes
        html.append("  <div class=\"summary\">\n")
            .append("    <div class=\"summary-box\">\n")
            .append("      <h3>Total Tests</h3>\n")
            .append("      <p style=\"font-size: 24px;\">").append(totalTests).append("</p>\n")
            .append("    </div>\n")
            .append("    <div class=\"summary-box\">\n")
            .append("      <h3>Success Rate</h3>\n")
            .append("      <p style=\"font-size: 24px;").append(successRate >= 90 ? " class=\"success\"" : successRate >= 70 ? "" : " class=\"failure\"").append("\">")
            .append(String.format("%.1f%%", successRate)).append("</p>\n")
            .append("    </div>\n")
            .append("    <div class=\"summary-box\">\n")
            .append("      <h3>Passed</h3>\n")
            .append("      <p style=\"font-size: 24px;\" class=\"success\">").append(passedTests).append("</p>\n")
            .append("    </div>\n")
            .append("    <div class=\"summary-box\">\n")
            .append("      <h3>Failed</h3>\n")
            .append("      <p style=\"font-size: 24px;\" class=\"failure\">").append(failedTests).append("</p>\n")
            .append("    </div>\n")
            .append("    <div class=\"summary-box\">\n")
            .append("      <h3>Skipped</h3>\n")
            .append("      <p style=\"font-size: 24px;\" class=\"skipped\">").append(skippedTests).append("</p>\n")
            .append("    </div>\n")
            .append("  </div>\n");
        
        // Test case results table
        html.append("  <h2>Test Results</h2>\n")
            .append("  <table>\n")
            .append("    <tr>\n")
            .append("      <th>Test Case</th>\n")
            .append("      <th>Status</th>\n")
            .append("      <th>Duration</th>\n")
            .append("      <th>Error Message</th>\n")
            .append("      <th>Details</th>\n")
            .append("    </tr>\n");
        
        // Sort test cases - failed first, then passed, then skipped
        List<TestCaseResult> sortedResults = new ArrayList<>(result.getTestCaseResults());
        sortedResults.sort((a, b) -> {
            if (a.isSuccess() && !b.isSuccess() && !b.isSkipped()) return 1;
            if (!a.isSuccess() && !a.isSkipped() && b.isSuccess()) return -1;
            if (a.isSkipped() && !b.isSkipped()) return 1;
            if (!a.isSkipped() && b.isSkipped()) return -1;
            return 0;
        });
        
        for (TestCaseResult testCaseResult : sortedResults) {
            TestCase testCase = testCaseService.getTestCase(result.getProjectId(), testCaseResult.getTestCaseId());
            String testCaseName = testCase != null ? testCase.getName() : "Unknown Test Case";
            
            String rowClass = testCaseResult.isSuccess() ? "pass" : testCaseResult.isSkipped() ? "skip" : "fail";
            String status = testCaseResult.isSuccess() ? "PASS" : testCaseResult.isSkipped() ? "SKIP" : "FAIL";
            String statusClass = testCaseResult.isSuccess() ? "success" : testCaseResult.isSkipped() ? "skipped" : "failure";
            
            html.append("    <tr class=\"").append(rowClass).append("\">\n")
                .append("      <td>").append(testCaseName).append("</td>\n")
                .append("      <td class=\"").append(statusClass).append("\">").append(status).append("</td>\n")
                .append("      <td>").append(formatDurationMs(testCaseResult.getDurationMs())).append("</td>\n")
                .append("      <td>").append(testCaseResult.getErrorMessage() != null ? testCaseResult.getErrorMessage() : "").append("</td>\n")
                .append("      <td><a href=\"testcase_").append(testCaseResult.getTestCaseId()).append(".html\" target=\"_blank\">View Details</a></td>\n")
                .append("    </tr>\n");
        }
        
        html.append("  </table>\n");
        
        // JavaScript for collapsible sections
        html.append("  <script>\n")
            .append("    document.addEventListener('DOMContentLoaded', function() {\n")
            .append("      var coll = document.getElementsByClassName('collapsible');\n")
            .append("      for (var i = 0; i < coll.length; i++) {\n")
            .append("        coll[i].addEventListener('click', function() {\n")
            .append("          this.classList.toggle('active');\n")
            .append("          var content = this.nextElementSibling;\n")
            .append("          if (content.style.display === 'block') {\n")
            .append("            content.style.display = 'none';\n")
            .append("          } else {\n")
            .append("            content.style.display = 'block';\n")
            .append("          }\n")
            .append("        });\n")
            .append("      }\n")
            .append("    });\n")
            .append("  </script>\n");
        
        // Close HTML
        html.append("</body>\n")
            .append("</html>");
        
        return html.toString();
    }
    
    private String generateTestCaseHtmlContent(ExecutionResult execution, TestCaseResult testCaseResult) {
        StringBuilder html = new StringBuilder();
        TestCase testCase = testCaseService.getTestCase(execution.getProjectId(), testCaseResult.getTestCaseId());
        String testCaseName = testCase != null ? testCase.getName() : "Unknown Test Case";
        
        // HTML header
        html.append("<!DOCTYPE html>\n")
            .append("<html lang=\"en\">\n")
            .append("<head>\n")
            .append("  <meta charset=\"UTF-8\">\n")
            .append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
            .append("  <title>Test Case Report - ").append(testCaseName).append("</title>\n")
            .append("  <style>\n")
            .append("    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }\n")
            .append("    h1, h2, h3 { color: #444; }\n")
            .append("    .success { color: #4CAF50; }\n")
            .append("    .failure { color: #F44336; }\n")
            .append("    .skipped { color: #FF9800; }\n")
            .append("    table { border-collapse: collapse; width: 100%; margin-top: 20px; }\n")
            .append("    th, td { text-align: left; padding: 12px; border-bottom: 1px solid #ddd; }\n")
            .append("    tr:hover { background-color: #f5f5f5; }\n")
            .append("    th { background-color: #4CAF50; color: white; }\n")
            .append("    .pass { background-color: rgba(76, 175, 80, 0.1); }\n")
            .append("    .fail { background-color: rgba(244, 67, 54, 0.1); }\n")
            .append("    .screenshot { max-width: 800px; margin-top: 20px; border: 1px solid #ddd; }\n")
            .append("    .code { font-family: monospace; background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; }\n")
            .append("  </style>\n")
            .append("</head>\n")
            .append("<body>\n");
        
        // Test case header
        String status = testCaseResult.isSuccess() ? "PASS" : testCaseResult.isSkipped() ? "SKIP" : "FAIL";
        String statusClass = testCaseResult.isSuccess() ? "success" : testCaseResult.isSkipped() ? "skipped" : "failure";
        
        html.append("  <h1>Test Case Report</h1>\n")
            .append("  <p><a href=\"report.html\">&larr; Back to Execution Report</a></p>\n")
            .append("  <p><strong>Test Case:</strong> ").append(testCaseName).append("</p>\n")
            .append("  <p><strong>Status:</strong> <span class=\"").append(statusClass).append("\">").append(status).append("</span></p>\n")
            .append("  <p><strong>Start Time:</strong> ").append(formatDateTime(testCaseResult.getStartTime())).append("</p>\n")
            .append("  <p><strong>End Time:</strong> ").append(formatDateTime(testCaseResult.getEndTime())).append("</p>\n")
            .append("  <p><strong>Duration:</strong> ").append(formatDurationMs(testCaseResult.getDurationMs())).append("</p>\n");
        
        if (!testCaseResult.isSuccess() && !testCaseResult.isSkipped() && testCaseResult.getErrorMessage() != null) {
            html.append("  <h2>Error</h2>\n")
                .append("  <div class=\"code\">").append(testCaseResult.getErrorMessage()).append("</div>\n");
        }
        
        // Test step results
        html.append("  <h2>Step Results</h2>\n");
        
        if (testCaseResult.getStepResults() == null || testCaseResult.getStepResults().isEmpty()) {
            html.append("  <p>No step results available.</p>\n");
        } else {
            html.append("  <table>\n")
                .append("    <tr>\n")
                .append("      <th>#</th>\n")
                .append("      <th>Action</th>\n")
                .append("      <th>Selector</th>\n")
                .append("      <th>Status</th>\n")
                .append("      <th>Duration</th>\n")
                .append("      <th>Error</th>\n")
                .append("    </tr>\n");
            
            int stepNumber = 1;
            for (ExecutionStepResult stepResult : testCaseResult.getStepResults()) {
                String stepStatus = stepResult.isSuccess() ? "PASS" : "FAIL";
                String stepStatusClass = stepResult.isSuccess() ? "step-success" : "step-failure";
                String rowClass = stepResult.isSuccess() ? "pass" : "fail";
                
                html.append("    <tr class=\"").append(rowClass).append("\">\n")
                    .append("      <td>").append(stepNumber++).append("</td>\n")
                    .append("      <td>").append(stepResult.getAction()).append("</td>\n")
                    .append("      <td>").append(stepResult.getUsedSelector() != null ? stepResult.getUsedSelector() : "").append("</td>\n")
                    .append("      <td class=\"").append(stepStatusClass).append("\">").append(stepStatus).append("</td>\n")
                    .append("      <td>").append(formatDurationMs(stepResult.getDurationMs())).append("</td>\n")
                    .append("      <td>").append(stepResult.getErrorMessage() != null ? stepResult.getErrorMessage() : "").append("</td>\n")
                    .append("    </tr>\n");
            }
            
            html.append("  </table>\n");
        }
        
        // Screenshots
        if (testCaseResult.getStepResults() != null) {
            List<String> screenshots = testCaseResult.getStepResults().stream()
                .filter(step -> step.getScreenshotPath() != null)
                .map(ExecutionStepResult::getScreenshotPath)
                .collect(Collectors.toList());
            
            if (!screenshots.isEmpty()) {
                html.append("  <h2>Screenshots</h2>\n");
                
                for (String screenshot : screenshots) {
                    // Get just the filename
                    String fileName = new File(screenshot).getName();
                    
                    html.append("  <div>\n")
                        .append("    <h3>").append(fileName).append("</h3>\n")
                        .append("    <img class=\"screenshot\" src=\"").append(fileName).append("\" alt=\"Screenshot\">\n")
                        .append("  </div>\n");
                }
            }
        }
        
        // Videos
        if (testCaseResult.getVideoPath() != null) {
            String videoFileName = new File(testCaseResult.getVideoPath()).getName();
            
            html.append("  <h2>Video Recording</h2>\n")
                .append("  <video width=\"800\" controls>\n")
                .append("    <source src=\"").append(videoFileName).append("\" type=\"video/webm\">\n")
                .append("    Your browser does not support the video tag.\n")
                .append("  </video>\n");
        }
        
        // Close HTML
        html.append("</body>\n")
            .append("</html>");
        
        return html.toString();
    }
    
    private void copyScreenshots(ExecutionResult result, Path reportDir) {
        // Create screenshots directory in report dir
        Path screenshotsDir = reportDir.resolve("screenshots");
        try {
            Files.createDirectories(screenshotsDir);
        } catch (IOException e) {
            logger.warn("Failed to create screenshots directory", e);
            return;
        }
        
        // Collect all screenshot paths
        List<String> screenshotPaths = new ArrayList<>();
        
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            if (testCaseResult.getStepResults() != null) {
                for (ExecutionStepResult stepResult : testCaseResult.getStepResults()) {
                    if (stepResult.getScreenshotPath() != null) {
                        screenshotPaths.add(stepResult.getScreenshotPath());
                    }
                }
            }
        }
        
        // Copy screenshots
        for (String screenshotPath : screenshotPaths) {
            Path source = Paths.get(screenshotPath);
            if (Files.exists(source)) {
                Path destination = reportDir.resolve(source.getFileName());
                try {
                    Files.copy(source, destination);
                } catch (IOException e) {
                    logger.warn("Failed to copy screenshot: {}", screenshotPath, e);
                }
            }
        }
    }
    
    private void copyVideos(ExecutionResult result, Path reportDir) {
        // Create videos directory in report dir
        Path videosDir = reportDir.resolve("videos");
        try {
            Files.createDirectories(videosDir);
        } catch (IOException e) {
            logger.warn("Failed to create videos directory", e);
            return;
        }
        
        // Collect all video paths
        List<String> videoPaths = new ArrayList<>();
        
        for (TestCaseResult testCaseResult : result.getTestCaseResults()) {
            if (testCaseResult.getVideoPath() != null) {
                videoPaths.add(testCaseResult.getVideoPath());
            }
        }
        
        // Copy videos
        for (String videoPath : videoPaths) {
            Path source = Paths.get(videoPath);
            if (Files.exists(source)) {
                Path destination = reportDir.resolve(source.getFileName());
                try {
                    Files.copy(source, destination);
                } catch (IOException e) {
                    logger.warn("Failed to copy video: {}", videoPath, e);
                }
            }
        }
    }
    
    private String formatDateTime(LocalDateTime dateTime) {
        if (dateTime == null) {
            return "N/A";
        }
        
        return dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }
    
    private String formatDuration(LocalDateTime start, LocalDateTime end) {
        if (start == null || end == null) {
            return "N/A";
        }
        
        Duration duration = Duration.between(start, end);
        return formatDuration(duration);
    }
    
    private String formatDurationMs(long durationMs) {
        return formatDuration(Duration.ofMillis(durationMs));
    }
    
    private String formatDuration(Duration duration) {
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        if (hours > 0) {
            return String.format("%d h %d min %d s", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%d min %d s", minutes, seconds);
        } else if (seconds > 0) {
            return String.format("%d.%03d s", seconds, millis);
        } else {
            return String.format("%d ms", millis);
        }
    }
}


/**
 * Custom NLP Service Implementation
 * Converts natural language to test steps without relying on third-party AI libraries
 */
package com.cstestforge.service.impl.nlp;

import com.cstestforge.model.nlp.NLPMatchResult;
import com.cstestforge.model.nlp.NLPParsingResult;
import com.cstestforge.model.nlp.NLPTemplate;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.service.nlp.NLPService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class NLPServiceImpl implements NLPService {
    private static final Logger logger = LoggerFactory.getLogger(NLPServiceImpl.class);
    
    // Templates storage
    private final List<NLPTemplate> templates = new ArrayList<>();
    
    // Word synonyms for more flexible matching
    private final Map<String, List<String>> synonyms = new HashMap<>();
    
    // Tokenization and text normalization patterns
    private static final Pattern TOKENIZE_PATTERN = Pattern.compile("\\b\\w+\\b|[.,;!?]");
    private static final Pattern URL_PATTERN = Pattern.compile("(https?://[\\w-]+(\\.[\\w-]+)+([\\w.,@?^=%&:/~+#-]*[\\w@?^=%&/~+#-])?)");
    private static final Pattern SELECTOR_PATTERN = Pattern.compile("([#.][\\w-]+|\\[\\w+=['\"].*?['\"]\\])");
    
    // Action verbs mapping
    private final Map<String, String> actionVerbMappings = new HashMap<>();
    
    // Element type mappings
    private final Map<String, String> elementTypeMappings = new HashMap<>();
    
    @PostConstruct
    public void init() {
        // Load built-in templates
        loadBuiltInTemplates();
        
        // Initialize synonyms
        initializeSynonyms();
        
        // Initialize action verb mappings
        initializeActionVerbMappings();
        
        // Initialize element type mappings
        initializeElementTypeMappings();
        
        logger.info("NLP Service initialized with {} templates", templates.size());
    }
    
    private void loadBuiltInTemplates() {
        try (InputStream is = getClass().getResourceAsStream("/nlp/templates.txt")) {
            if (is == null) {
                logger.warn("Could not find built-in NLP templates file");
                return;
            }
            
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
                String line;
                NLPTemplate currentTemplate = null;
                
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) {
                        continue; // Skip empty lines and comments
                    }
                    
                    if (line.startsWith("TEMPLATE:")) {
                        // Start a new template
                        if (currentTemplate != null) {
                            templates.add(currentTemplate);
                        }
                        
                        String templateName = line.substring("TEMPLATE:".length()).trim();
                        currentTemplate = new NLPTemplate();
                        currentTemplate.setName(templateName);
                    } else if (line.startsWith("PATTERN:") && currentTemplate != null) {
                        String pattern = line.substring("PATTERN:".length()).trim();
                        currentTemplate.getPatterns().add(pattern);
                    } else if (line.startsWith("ACTION:") && currentTemplate != null) {
                        String action = line.substring("ACTION:".length()).trim();
                        currentTemplate.setAction(action);
                    } else if (line.startsWith("SELECTOR_TYPE:") && currentTemplate != null) {
                        String selectorType = line.substring("SELECTOR_TYPE:".length()).trim();
                        currentTemplate.setSelectorType(selectorType);
                    } else if (line.startsWith("PARAM:") && currentTemplate != null) {
                        String paramDef = line.substring("PARAM:".length()).trim();
                        String[] parts = paramDef.split("=", 2);
                        if (parts.length == 2) {
                            currentTemplate.getParameterMappings().put(parts[0].trim(), parts[1].trim());
                        }
                    } else if (line.startsWith("EXAMPLE:") && currentTemplate != null) {
                        String example = line.substring("EXAMPLE:".length()).trim();
                        currentTemplate.getExamples().add(example);
                    }
                }
                
                // Add the last template
                if (currentTemplate != null) {
                    templates.add(currentTemplate);
                }
            }
        } catch (IOException e) {
            logger.error("Failed to load built-in NLP templates", e);
        }
        
        // If no templates were loaded, add some default ones
        if (templates.isEmpty()) {
            addDefaultTemplates();
        }
    }
    
    private void addDefaultTemplates() {
        // Navigate template
        NLPTemplate navigateTemplate = new NLPTemplate();
        navigateTemplate.setName("Navigate to URL");
        navigateTemplate.getPatterns().add("navigate to {url}");
        navigateTemplate.getPatterns().add("go to {url}");
        navigateTemplate.getPatterns().add("open {url}");
        navigateTemplate.getPatterns().add("visit {url}");
        navigateTemplate.getPatterns().add("browse to {url}");
        navigateTemplate.setAction("navigate");
        navigateTemplate.getParameterMappings().put("url", "url");
        navigateTemplate.getExamples().add("navigate to https://example.com");
        navigateTemplate.getExamples().add("go to the login page");
        templates.add(navigateTemplate);
        
        // Click template
        NLPTemplate clickTemplate = new NLPTemplate();
        clickTemplate.setName("Click element");
        clickTemplate.getPatterns().add("click {element}");
        clickTemplate.getPatterns().add("click on {element}");
        clickTemplate.getPatterns().add("click the {element}");
        clickTemplate.getPatterns().add("press {element}");
        clickTemplate.getPatterns().add("select {element}");
        clickTemplate.setAction("click");
        clickTemplate.setSelectorType("css");
        clickTemplate.getParameterMappings().put("element", "selector");
        clickTemplate.getExamples().add("click the login button");
        clickTemplate.getExamples().add("click on #submit-btn");
        templates.add(clickTemplate);
        
        // Type template
        NLPTemplate typeTemplate = new NLPTemplate();
        typeTemplate.setName("Type text");
        typeTemplate.getPatterns().add("type {text} in {element}");
        typeTemplate.getPatterns().add("enter {text} in {element}");
        typeTemplate.getPatterns().add("fill {element} with {text}");
        typeTemplate.getPatterns().add("input {text} in {element}");
        typeTemplate.setAction("type");
        typeTemplate.setSelectorType("css");
        typeTemplate.getParameterMappings().put("element", "selector");
        typeTemplate.getParameterMappings().put("text", "text");
        typeTemplate.getExamples().add("type test@example.com in the email field");
        typeTemplate.getExamples().add("enter password in #password-input");
        templates.add(typeTemplate);
        
        // Wait template
        NLPTemplate waitTemplate = new NLPTemplate();
        waitTemplate.setName("Wait for element");
        waitTemplate.getPatterns().add("wait for {element}");
        waitTemplate.getPatterns().add("wait until {element} appears");
        waitTemplate.getPatterns().add("wait for {element} to be visible");
        waitTemplate.getPatterns().add("wait {seconds} seconds");
        waitTemplate.setAction("wait");
        waitTemplate.setSelectorType("css");
        waitTemplate.getParameterMappings().put("element", "selector");
        waitTemplate.getParameterMappings().put("seconds", "duration");
        waitTemplate.getExamples().add("wait for the loading spinner to disappear");
        waitTemplate.getExamples().add("wait 5 seconds");
        templates.add(waitTemplate);
        
        // Assert template
        NLPTemplate assertTemplate = new NLPTemplate();
        assertTemplate.setName("Assert element");
        assertTemplate.getPatterns().add("assert {element} is visible");
        assertTemplate.getPatterns().add("verify {element} is displayed");
        assertTemplate.getPatterns().add("check {element} exists");
        assertTemplate.getPatterns().add("ensure {element} contains {text}");
        assertTemplate.setAction("assert");
        assertTemplate.setSelectorType("css");
        assertTemplate.getParameterMappings().put("element", "selector");
        assertTemplate.getParameterMappings().put("text", "expected");
        assertTemplate.getExamples().add("assert the success message is visible");
        assertTemplate.getExamples().add("verify #error-message contains Invalid credentials");
        templates.add(assertTemplate);
    }
    
    private void initializeSynonyms() {
        // Navigation synonyms
        addSynonyms("navigate", "go", "open", "visit", "browse", "load");
        
        // Click synonyms
        addSynonyms("click", "press", "tap", "select", "choose");
        
        // Type synonyms
        addSynonyms("type", "enter", "input", "fill", "write");
        
        // Wait synonyms
        addSynonyms("wait", "pause", "delay");
        
        // Assert synonyms
        addSynonyms("assert", "verify", "check", "ensure", "validate");
        
        // Element synonyms
        addSynonyms("button", "btn", "link", "cta");
        addSynonyms("field", "input", "textbox", "textarea", "box");
        addSynonyms("dropdown", "select", "combobox", "list");
        addSynonyms("checkbox", "check", "tick");
        addSynonyms("radio", "option", "radio button");
    }
    
    private void addSynonyms(String... words) {
        if (words.length < 2) {
            return;
        }
        
        List<String> allWords = Arrays.asList(words);
        for (String word : words) {
            synonyms.put(word, allWords.stream()
                .filter(w -> !w.equals(word))
                .collect(Collectors.toList()));
        }
    }
    
    private void initializeActionVerbMappings() {
        // Navigation verbs
        actionVerbMappings.put("navigate", "navigate");
        actionVerbMappings.put("go", "navigate");
        actionVerbMappings.put("open", "navigate");
        actionVerbMappings.put("visit", "navigate");
        actionVerbMappings.put("browse", "navigate");
        
        // Click verbs
        actionVerbMappings.put("click", "click");
        actionVerbMappings.put("press", "click");
        actionVerbMappings.put("tap", "click");
        actionVerbMappings.put("select", "click");
        actionVerbMappings.put("choose", "click");
        
        // Type verbs
        actionVerbMappings.put("type", "type");
        actionVerbMappings.put("enter", "type");
        actionVerbMappings.put("input", "type");
        actionVerbMappings.put("fill", "type");
        actionVerbMappings.put("write", "type");
        
        // Wait verbs
        actionVerbMappings.put("wait", "wait");
        actionVerbMappings.put("pause", "wait");
        actionVerbMappings.put("delay", "wait");
        
        // Assert verbs
        actionVerbMappings.put("assert", "assert");
        actionVerbMappings.put("verify", "assert");
        actionVerbMappings.put("check", "assert");
        actionVerbMappings.put("ensure", "assert");
        actionVerbMappings.put("validate", "assert");
        
        // Other action verbs
        actionVerbMappings.put("drag", "drag");
        actionVerbMappings.put("drop", "drop");
        actionVerbMappings.put("hover", "hover");
        actionVerbMappings.put("check", "check");
        actionVerbMappings.put("uncheck", "uncheck");
        actionVerbMappings.put("refresh", "refresh");
        actionVerbMappings.put("reload", "refresh");
        actionVerbMappings.put("submit", "submit");
        actionVerbMappings.put("upload", "upload");
        actionVerbMappings.put("download", "download");
        actionVerbMappings.put("switch", "switch");
        actionVerbMappings.put("take", "screenshot");
        actionVerbMappings.put("capture", "screenshot");
        actionVerbMappings.put("screenshot", "screenshot");
    }
    
    private void initializeElementTypeMappings() {
        // Button types
        elementTypeMappings.put("button", "button");
        elementTypeMappings.put("btn", "button");
        elementTypeMappings.put("submit", "button[type='submit']");
        
        // Input types
        elementTypeMappings.put("input", "input");
        elementTypeMappings.put("field", "input");
        elementTypeMappings.put("textbox", "input[type='text']");
        elementTypeMappings.put("email", "input[type='email']");
        elementTypeMappings.put("password", "input[type='password']");
        elementTypeMappings.put("textarea", "textarea");
        
        // Select types
        elementTypeMappings.put("dropdown", "select");
        elementTypeMappings.put("select", "select");
        elementTypeMappings.put("combobox", "select");
        
        // Checkbox types
        elementTypeMappings.put("checkbox", "input[type='checkbox']");
        elementTypeMappings.put("check", "input[type='checkbox']");
        
        // Radio types
        elementTypeMappings.put("radio", "input[type='radio']");
        elementTypeMappings.put("option", "input[type='radio']");
        
        // Link types
        elementTypeMappings.put("link", "a");
        elementTypeMappings.put("anchor", "a");
        
        // Other element types
        elementTypeMappings.put("image", "img");
        elementTypeMappings.put("table", "table");
        elementTypeMappings.put("row", "tr");
        elementTypeMappings.put("cell", "td");
        elementTypeMappings.put("heading", "h1, h2, h3, h4, h5, h6");
        elementTypeMappings.put("paragraph", "p");
        elementTypeMappings.put("text", "span, p, div");
        elementTypeMappings.put("div", "div");
        elementTypeMappings.put("span", "span");
        elementTypeMappings.put("label", "label");
        elementTypeMappings.put("form", "form");
        elementTypeMappings.put("file", "input[type='file']");
    }
    
    @Override
    public List<NLPTemplate> getAllTemplates() {
        return new ArrayList<>(templates);
    }
    
    @Override
    public NLPTemplate getTemplate(String name) {
        return templates.stream()
            .filter(t -> t.getName().equals(name))
            .findFirst()
            .orElse(null);
    }
    
    @Override
    public void addTemplate(NLPTemplate template) {
        templates.add(template);
    }
    
    @Override
    public void updateTemplate(NLPTemplate template) {
        for (int i = 0; i < templates.size(); i++) {
            if (templates.get(i).getName().equals(template.getName())) {
                templates.set(i, template);
                return;
            }
        }
        
        // If template doesn't exist, add it
        templates.add(template);
    }
    
    @Override
    public void deleteTemplate(String name) {
        templates.removeIf(t -> t.getName().equals(name));
    }
    
    @Override
    public NLPParsingResult parseNaturalLanguage(String text) {
        logger.info("Parsing natural language: {}", text);
        
        NLPParsingResult result = new NLPParsingResult();
        result.setOriginalText(text);
        
        // Preprocess text
        String preprocessedText = preprocessText(text);
        result.setPreprocessedText(preprocessedText);
        
        // Try template matching first
        NLPMatchResult templateMatch = findBestTemplateMatch(preprocessedText);
        if (templateMatch != null && templateMatch.getConfidence() > 0.7) {
            logger.debug("Found template match: {}", templateMatch.getTemplate().getName());
            
            // Use template to create a test step
            TestStep step = createTestStepFromTemplate(templateMatch);
            result.setTestStep(step);
            result.setMatchedTemplate(templateMatch.getTemplate());
            result.setConfidence(templateMatch.getConfidence());
            
            return result;
        }
        
        // If no good template match, try rule-based parsing
        TestStep ruleBasedStep = parseWithRules(preprocessedText);
        if (ruleBasedStep != null) {
            result.setTestStep(ruleBasedStep);
            result.setConfidence(0.6); // Rule-based parsing has lower confidence
            
            return result;
        }
        
        // If all parsing methods failed, extract what we can
        TestStep fallbackStep = createFallbackTestStep(preprocessedText);
        result.setTestStep(fallbackStep);
        result.setConfidence(0.3); // Very low confidence
        
        return result;
    }
    
    @Override
    public List<NLPParsingResult> parseNaturalLanguageBatch(List<String> textLines) {
        return textLines.stream()
            .map(this::parseNaturalLanguage)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<TestStep> convertToTestSteps(List<String> textLines) {
        return textLines.stream()
            .map(this::parseNaturalLanguage)
            .map(NLPParsingResult::getTestStep)
            .collect(Collectors.toList());
    }
    
    private String preprocessText(String text) {
        // Convert to lowercase
        String processed = text.toLowerCase();
        
        // Normalize punctuation
        processed = processed.replaceAll("\\s+", " ");
        processed = processed.replaceAll("\\s*([.,;:!?])\\s*", "$1 ");
        
        // Trim extra spaces
        processed = processed.trim();
        
        return processed;
    }
    
    private NLPMatchResult findBestTemplateMatch(String text) {
        NLPMatchResult bestMatch = null;
        double highestConfidence = 0;
        
        // Try each template
        for (NLPTemplate template : templates) {
            for (String pattern : template.getPatterns()) {
                double confidence = calculatePatternMatchConfidence(text, pattern);
                
                if (confidence > highestConfidence) {
                    Map<String, String> extractedParams = extractParametersFromPattern(text, pattern);
                    
                    if (extractedParams != null) {
                        bestMatch = new NLPMatchResult();
                        bestMatch.setTemplate(template);
                        bestMatch.setPattern(pattern);
                        bestMatch.setExtractedParameters(extractedParams);
                        bestMatch.setConfidence(confidence);
                        highestConfidence = confidence;
                    }
                }
            }
        }
        
        return bestMatch;
    }
    
    private double calculatePatternMatchConfidence(String text, String pattern) {
        // Convert pattern to regex format
        String regexPattern = pattern.replaceAll("\\{[^}]+\\}", "(.+?)");
        
        // Check if the pattern matches at all
        if (!text.matches(".*" + regexPattern + ".*")) {
            return 0;
        }
        
        // Tokenize both text and pattern
        List<String> textTokens = tokenize(text);
        List<String> patternTokens = tokenize(pattern);
        
        // Remove parameter placeholders from pattern tokens
        patternTokens.removeIf(token -> token.matches("\\{[^}]+\\}"));
        
        // Count matching tokens
        int matchingTokens = 0;
        for (String patternToken : patternTokens) {
            if (textTokens.contains(patternToken) || 
                textTokens.stream().anyMatch(t -> isSynonym(t, patternToken))) {
                matchingTokens++;
            }
        }
        
        // Calculate confidence based on matching tokens ratio
        if (patternTokens.isEmpty()) {
            return 0;
        }
        
        double confidence = (double) matchingTokens / patternTokens.size();
        
        // Boost confidence for exact matches
        if (patternTokens.size() == textTokens.size() && 
            matchingTokens == patternTokens.size()) {
            confidence = Math.min(1.0, confidence + 0.2);
        }
        
        return confidence;
    }
    
    private boolean isSynonym(String word1, String word2) {
        if (word1.equals(word2)) {
            return true;
        }
        
        List<String> synonymsForWord1 = synonyms.get(word1);
        if (synonymsForWord1 != null && synonymsForWord1.contains(word2)) {
            return true;
        }
        
        List<String> synonymsForWord2 = synonyms.get(word2);
        return synonymsForWord2 != null && synonymsForWord2.contains(word1);
    }
    
    private List<String> tokenize(String text) {
        List<String> tokens = new ArrayList<>();
        Matcher matcher = TOKENIZE_PATTERN.matcher(text);
        
        while (matcher.find()) {
            tokens.add(matcher.group());
        }
        
        return tokens;
    }
    
    private Map<String, String> extractParametersFromPattern(String text, String pattern) {
        // Extract parameter names from pattern
        List<String> paramNames = new ArrayList<>();
        Matcher paramMatcher = Pattern.compile("\\{([^}]+)\\}").matcher(pattern);
        
        while (paramMatcher.find()) {
            paramNames.add(paramMatcher.group(1));
        }
        
        if (paramNames.isEmpty()) {
            return new HashMap<>();
        }
        
        // Convert pattern to regex for extraction
        String regexPattern = pattern;
        for (String paramName : paramNames) {
            regexPattern = regexPattern.replace("{" + paramName + "}", "(.+?)");
        }
        
        // Make the regex match anywhere in the text
        regexPattern = ".*?" + regexPattern + ".*?";
        
        // Extract values
        Matcher valueMatcher = Pattern.compile(regexPattern, Pattern.DOTALL).matcher(text);
        if (!valueMatcher.matches() || valueMatcher.groupCount() != paramNames.size()) {
            return null;
        }
        
        // Map param names to values
        Map<String, String> params = new HashMap<>();
        for (int i = 0; i < paramNames.size(); i++) {
            String value = valueMatcher.group(i + 1).trim();
            params.put(paramNames.get(i), value);
        }
        
        return params;
    }
    
    private TestStep createTestStepFromTemplate(NLPMatchResult matchResult) {
        NLPTemplate template = matchResult.getTemplate();
        Map<String, String> extractedParams = matchResult.getExtractedParameters();
        
        TestStep step = new TestStep();
        step.setId(UUID.randomUUID().toString());
        step.setAction(template.getAction());
        
        // Set selector type if specified in template
        if (template.getSelectorType() != null && !template.getSelectorType().isEmpty()) {
            step.setSelectorType(template.getSelectorType());
        }
        
        // Map extracted parameters to test step properties based on template mappings
        Map<String, Object> stepParams = new HashMap<>();
        
        for (Map.Entry<String, String> paramMapping : template.getParameterMappings().entrySet()) {
            String templateParam = paramMapping.getKey();
            String stepProperty = paramMapping.getValue();
            
            if (extractedParams.containsKey(templateParam)) {
                String value = extractedParams.get(templateParam);
                
                // Handle special mappings
                switch (stepProperty) {
                    case "selector":
                        // Convert descriptive element to selector
                        step.setSelector(convertToSelector(value));
                        break;
                    case "url":
                        // Detect if the value is a URL or add http:// if needed
                        stepParams.put(stepProperty, normalizeUrl(value));
                        break;
                    case "duration":
                        // Convert duration text to milliseconds
                        try {
                            long durationMs = parseDurationToMs(value);
                            stepParams.put(stepProperty, durationMs);
                        } catch (NumberFormatException e) {
                            stepParams.put(stepProperty, value);
                        }
                        break;
                    default:
                        stepParams.put(stepProperty, value);
                        break;
                }
            }
        }
        
        // Set step parameters
        step.setParameters(stepParams);
        
        // Post-process the step based on its action type
        postProcessStep(step);
        
        return step;
    }
    
    private TestStep parseWithRules(String text) {
        // Extract the first verb to determine action
        List<String> tokens = tokenize(text);
        if (tokens.isEmpty()) {
            return null;
        }
        
        String firstVerb = findFirstVerb(tokens);
        if (firstVerb == null) {
            return null;
        }
        
        // Map the verb to an action
        String action = mapVerbToAction(firstVerb);
        if (action == null) {
            return null;
        }
        
        TestStep step = new TestStep();
        step.setId(UUID.randomUUID().toString());
        step.setAction(action);
        
        // Set default selector type
        step.setSelectorType("css");
        
        // Extract parameters based on the action
        Map<String, Object> params = new HashMap<>();
        
        switch (action) {
            case "navigate":
                String url = extractUrl(text);
                if (url != null) {
                    params.put("url", url);
                }
                break;
                
            case "click":
                String element = extractElement(text, firstVerb);
                if (element != null) {
                    step.setSelector(convertToSelector(element));
                }
                break;
                
            case "type":
                Map<String, String> typeParams = extractTypeParams(text, firstVerb);
                if (typeParams != null) {
                    if (typeParams.containsKey("element")) {
                        step.setSelector(convertToSelector(typeParams.get("element")));
                    }
                    if (typeParams.containsKey("text")) {
                        params.put("text", typeParams.get("text"));
                    }
                }
                break;
                
            case "wait":
                if (text.matches(".*\\b\\d+\\s*sec(ond)?s?\\b.*")) {
                    // Wait for duration
                    long durationMs = parseDurationToMs(text);
                    params.put("waitType", "timeout");
                    params.put("duration", durationMs);
                } else {
                    // Wait for element
                    String waitElement = extractElement(text, firstVerb);
                    if (waitElement != null) {
                        step.setSelector(convertToSelector(waitElement));
                        params.put("waitType", "selector");
                        
                        // Determine wait state
                        if (text.contains("disappear") || text.contains("hidden") || text.contains("gone")) {
                            params.put("state", "hidden");
                        } else {
                            params.put("state", "visible");
                        }
                    }
                }
                break;
                
            case "assert":
                Map<String, String> assertParams = extractAssertParams(text, firstVerb);
                if (assertParams != null) {
                    if (assertParams.containsKey("element")) {
                        step.setSelector(convertToSelector(assertParams.get("element")));
                    }
                    
                    // Determine assertion type
                    if (text.contains("visible") || text.contains("displayed") || text.contains("appears") || text.contains("show")) {
                        params.put("assertType", "visible");
                        params.put("expected", "true");
                    } else if (text.contains("hidden") || text.contains("invisible") || text.contains("gone") || text.contains("disappear")) {
                        params.put("assertType", "visible");
                        params.put("expected", "false");
                    } else if (text.contains("enabled")) {
                        params.put("assertType", "enabled");
                        params.put("expected", "true");
                    } else if (text.contains("disabled")) {
                        params.put("assertType", "enabled");
                        params.put("expected", "false");
                    } else if (text.contains("contains") || text.contains("has text")) {
                        params.put("assertType", "text");
                        params.put("matchType", "contains");
                        if (assertParams.containsKey("text")) {
                            params.put("expected", assertParams.get("text"));
                        }
                    } else if (text.contains("text") || text.contains("value")) {
                        params.put("assertType", "text");
                        params.put("matchType", "exact");
                        if (assertParams.containsKey("text")) {
                            params.put("expected", assertParams.get("text"));
                        }
                    } else {
                        params.put("assertType", "visible");
                        params.put("expected", "true");
                    }
                }
                break;
                
            case "check":
            case "uncheck":
                String checkElement = extractElement(text, firstVerb);
                if (checkElement != null) {
                    step.setSelector(convertToSelector(checkElement));
                }
                break;
                
            case "select":
                Map<String, String> selectParams = extractSelectParams(text, firstVerb);
                if (selectParams != null) {
                    if (selectParams.containsKey("element")) {
                        step.setSelector(convertToSelector(selectParams.get("element")));
                    }
                    if (selectParams.containsKey("value")) {
                        params.put("value", selectParams.get("value"));
                    }
                }
                break;
                
            case "screenshot":
                String path = "screenshots/screenshot_" + System.currentTimeMillis() + ".png";
                params.put("path", path);
                
                if (text.contains("full") || text.contains("entire")) {
                    params.put("fullPage", true);
                }
                break;
        }
        
        // Set parameters
        step.setParameters(params);
        
        // Post-process the step
        postProcessStep(step);
        
        return step;
    }
    
    private String findFirstVerb(List<String> tokens) {
        for (String token : tokens) {
            if (actionVerbMappings.containsKey(token)) {
                return token;
            }
        }
        return null;
    }
    
    private String mapVerbToAction(String verb) {
        return actionVerbMappings.get(verb);
    }
    
    private String extractUrl(String text) {
        // First try to find a standard URL
        Matcher urlMatcher = URL_PATTERN.matcher(text);
        if (urlMatcher.find()) {
            return urlMatcher.group();
        }
        
        // If no standard URL, look for words after navigate/go/open verbs
        String[] navigateVerbs = {"navigate", "go", "open", "visit", "browse"};
        
        for (String verb : navigateVerbs) {
            Pattern afterVerbPattern = Pattern.compile(verb + "\\s+(?:to\\s+)?(.+?)(?:\\s|$)");
            Matcher afterVerbMatcher = afterVerbPattern.matcher(text);
            
            if (afterVerbMatcher.find()) {
                String potential = afterVerbMatcher.group(1).trim();
                // Remove common words
                potential = potential.replaceAll("\\b(?:the|a|an)\\b", "").trim();
                return normalizeUrl(potential);
            }
        }
        
        return null;
    }
    
    private String normalizeUrl(String url) {
        if (url == null || url.isEmpty()) {
            return url;
        }
        
        // Check if it's already a URL
        if (url.matches("^https?://.*")) {
            return url;
        }
        
        // Check if it's a domain name
        if (url.matches("^[\\w-]+(\\.[\\w-]+)+$")) {
            return "https://" + url;
        }
        
        // Otherwise just return as is
        return url;
    }
    
    private String extractElement(String text, String actionVerb) {
        // Skip the action verb and look for element descriptions
        int verbIndex = text.indexOf(actionVerb);
        if (verbIndex < 0) {
            return null;
        }
        
        String afterVerb = text.substring(verbIndex + actionVerb.length()).trim();
        
        // Remove common prepositions and articles
        afterVerb = afterVerb.replaceAll("^\\b(?:on|the|a|an)\\b\\s+", "");
        
        // First, check if it's a direct selector
        Matcher selectorMatcher = SELECTOR_PATTERN.matcher(afterVerb);
        if (selectorMatcher.find()) {
            return selectorMatcher.group();
        }
        
        // Look for element type keywords
        for (String elementType : elementTypeMappings.keySet()) {
            Pattern elementPattern = Pattern.compile("(?:the\\s+)?" + elementType + "\\s+([\\w-]+)", Pattern.CASE_INSENSITIVE);
            Matcher elementMatcher = elementPattern.matcher(afterVerb);
            
            if (elementMatcher.find()) {
                String elementName = elementMatcher.group(1).trim();
                return elementType + " " + elementName;
            }
        }
        
        // If no element type found, take the rest of the string
        return afterVerb;
    }
    
    private Map<String, String> extractTypeParams(String text, String actionVerb) {
        Map<String, String> params = new HashMap<>();
        
        // Look for "in" or "into" to separate text and element
        Pattern pattern = Pattern.compile("(?i)" + actionVerb + "\\s+\"?([^\"]+)\"?\\s+(?:in|into|to)\\s+(.+)");
        Matcher matcher = pattern.matcher(text);
        
        if (matcher.find()) {
            String typedText = matcher.group(1).trim();
            String element = matcher.group(2).trim();
            
            // Remove surrounding quotes if present
            typedText = typedText.replaceAll("^[\"']|[\"']$", "");
            
            params.put("text", typedText);
            params.put("element", element);
            return params;
        }
        
        // Try alternative pattern: "fill element with text"
        pattern = Pattern.compile("(?i)" + actionVerb + "\\s+(.+?)\\s+(?:with|using)\\s+\"?([^\"]+)\"?");
        matcher = pattern.matcher(text);
        
        if (matcher.find()) {
            String element = matcher.group(1).trim();
            String typedText = matcher.group(2).trim();
            
            // Remove surrounding quotes if present
            typedText = typedText.replaceAll("^[\"']|[\"']$", "");
            
            params.put("element", element);
            params.put("text", typedText);
            return params;
        }
        
        return null;
    }
    
    private Map<String, String> extractAssertParams(String text, String actionVerb) {
        Map<String, String> params = new HashMap<>();
        
        // First extract the element
        String element = extractElement(text, actionVerb);
        if (element != null) {
            params.put("element", element);
        }
        
        // Look for assertions with expected text
        Pattern pattern = Pattern.compile("(?i)(?:contains|has|with)\\s+(?:text|value)\\s+\"?([^\"]+)\"?");
        Matcher matcher = pattern.matcher(text);
        
        if (matcher.find()) {
            String expectedText = matcher.group(1).trim();
            params.put("text", expectedText);
        }
        
        return params;
    }
    
    private Map<String, String> extractSelectParams(String text, String actionVerb) {
        Map<String, String> params = new HashMap<>();
        
        // Extract the dropdown
        Pattern dropdownPattern = Pattern.compile("(?i)" + actionVerb + "\\s+(.+?)\\s+(?:from|in)\\s+(.+)");
        Matcher dropdownMatcher = dropdownPattern.matcher(text);
        
        if (dropdownMatcher.find()) {
            String value = dropdownMatcher.group(1).trim();
            String element = dropdownMatcher.group(2).trim();
            
            params.put("value", value);
            params.put("element", element);
            return params;
        }
        
        // Try alternative pattern
        dropdownPattern = Pattern.compile("(?i)" + actionVerb + "\\s+(.+?)\\s+(?:option|value)\\s+(.+)");
        dropdownMatcher = dropdownPattern.matcher(text);
        
        if (dropdownMatcher.find()) {
            String element = dropdownMatcher.group(1).trim();
            String value = dropdownMatcher.group(2).trim();
            
            params.put("element", element);
            params.put("value", value);
            return params;
        }
        
        return null;
    }
    
    private long parseDurationToMs(String text) {
        // Extract numeric values and units
        Pattern durationPattern = Pattern.compile("(\\d+)\\s*(ms|millisecond|second|sec|minute|min|hour|h)s?");
        Matcher matcher = durationPattern.matcher(text);
        
        long totalMs = 0;
        while (matcher.find()) {
            int value = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2).toLowerCase();
            
            switch (unit) {
                case "ms":
                case "millisecond":
                    totalMs += value;
                    break;
                case "second":
                case "sec":
                    totalMs += value * 1000L;
                    break;
                case "minute":
                case "min":
                    totalMs += value * 60 * 1000L;
                    break;
                case "hour":
                case "h":
                    totalMs += value * 60 * 60 * 1000L;
                    break;
            }
        }
        
        // If no specific units found, default to seconds for single numbers
        if (totalMs == 0) {
            Pattern numberPattern = Pattern.compile("\\b(\\d+)\\b");
            matcher = numberPattern.matcher(text);
            if (matcher.find()) {
                int value = Integer.parseInt(matcher.group(1));
                totalMs = value * 1000L;
            }
        }
        
        return totalMs;
    }
    
    private String convertToSelector(String elementDescription) {
        // If it's already a valid selector, return it
        if (elementDescription.startsWith("#") || 
            elementDescription.startsWith(".") || 
            elementDescription.startsWith("[") || 
            elementDescription.startsWith("//")) {
            return elementDescription;
        }
        
        // Check if it matches a pattern like "button login" or "input email"
        String[] parts = elementDescription.split("\\s+", 2);
        if (parts.length >= 2) {
            String elementType = parts[0].toLowerCase();
            String elementName = parts[1].toLowerCase();
            
            // Check if the element type is known
            if (elementTypeMappings.containsKey(elementType)) {
                String tagSelector = elementTypeMappings.get(elementType);
                
                // Generate a selector based on element name
                // Try various attributes for identification
                return String.format("%s[id*='%s'], %s[name*='%s'], %s[placeholder*='%s'], %s[title*='%s'], %s:contains('%s')", 
                    tagSelector, elementName, tagSelector, elementName, tagSelector, elementName, tagSelector, elementName, tagSelector, elementName);
            }
        }
        
        // If it's just a name with no type, try to find it by common attributes
        return String.format("[id*='%s'], [name*='%s'], [placeholder*='%s'], [title*='%s'], *:contains('%s')",
            elementDescription, elementDescription, elementDescription, elementDescription, elementDescription);
    }
    
    private TestStep createFallbackTestStep(String text) {
        // Try to create a minimal step even with low confidence
        String firstVerb = findFirstVerb(tokenize(text));
        String action = firstVerb != null ? mapVerbToAction(firstVerb) : "click"; // Default to click
        
        TestStep step = new TestStep();
        step.setId(UUID.randomUUID().toString());
        step.setAction(action);
        step.setSelectorType("css");
        
        // Set minimal parameters based on action
        Map<String, Object> params = new HashMap<>();
        
        switch (action) {
            case "navigate":
                String url = extractUrl(text);
                if (url != null) {
                    params.put("url", url);
                } else {
                    params.put("url", "about:blank");
                }
                break;
                
            case "click":
            case "type":
            case "wait":
            case "assert":
                String element = extractElement(text, firstVerb != null ? firstVerb : "");
                if (element != null) {
                    step.setSelector(convertToSelector(element));
                } else {
                    step.setSelector("body");
                }
                
                if (action.equals("type")) {
                    params.put("text", "");
                } else if (action.equals("wait")) {
                    params.put("waitType", "selector");
                    params.put("state", "visible");
                } else if (action.equals("assert")) {
                    params.put("assertType", "visible");
                    params.put("expected", "true");
                }
                break;
                
            case "screenshot":
                params.put("path", "screenshots/screenshot_" + System.currentTimeMillis() + ".png");
                break;
        }
        
        step.setParameters(params);
        return step;
    }
    
    private void postProcessStep(TestStep step) {
        // Add default timeout to certain actions
        if (step.getAction().equals("wait") || 
            step.getAction().equals("navigate") || 
            step.getAction().equals("click") || 
            step.getAction().equals("type")) {
            
            if (step.getParameters() == null) {
                step.setParameters(new HashMap<>());
            }
            
            if (!step.getParameters().containsKey("timeout")) {
                step.getParameters().put("timeout", 30000); // Default 30 seconds timeout
            }
        }
        
        // Add screenshotOnFailure to assertions
        if (step.getAction().equals("assert") && step.getParameters() != null) {
            step.getParameters().put("screenshotOnFailure", true);
        }
    }
    
    @Override
    public String generateSuggestions(String partialText) {
        // Find close matches in templates
        List<String> suggestions = new ArrayList<>();
        
        for (NLPTemplate template : templates) {
            for (String pattern : template.getPatterns()) {
                if (pattern.startsWith(partialText.toLowerCase())) {
                    suggestions.add(pattern);
                }
            }
            
            for (String example : template.getExamples()) {
                if (example.startsWith(partialText.toLowerCase())) {
                    suggestions.add(example);
                }
            }
        }
        
        // Return top 5 suggestions
        return String.join("\n", suggestions.stream().distinct().limit(5).collect(Collectors.toList()));
    }
    
    @Override
    public Map<String, Object> analyzeSentenceStructure(String text) {
        Map<String, Object> analysis = new HashMap<>();
        
        // Tokenize
        List<String> tokens = tokenize(text);
        analysis.put("tokens", tokens);
        
        // Find action verb
        String verb = findFirstVerb(tokens);
        analysis.put("verb", verb);
        
        if (verb != null) {
            analysis.put("action", mapVerbToAction(verb));
        }
        
        // Extract targets
        if (verb != null) {
            String element = extractElement(text, verb);
            analysis.put("element", element);
            
            if (element != null) {
                analysis.put("selector", convertToSelector(element));
            }
        }
        
        // Find potential parameters
        Map<String, String> params = new HashMap<>();
        
        // Check for URL
        String url = extractUrl(text);
        if (url != null) {
            params.put("url", url);
        }
        
        // Check for text input
        if (verb != null && actionVerbMappings.get(verb).equals("type")) {
            Map<String, String> typeParams = extractTypeParams(text, verb);
            if (typeParams != null) {
                params.putAll(typeParams);
            }
        }
        
        analysis.put("parameters", params);
        
        return analysis;
    }
}


/**
 * Project Management Implementation
 * Handles project creation, configuration, and settings management
 */
package com.cstestforge.service.impl.project;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.project.Project;
import com.cstestforge.model.project.ProjectSettings;
import com.cstestforge.repository.FileSystemRepository;
import com.cstestforge.service.project.ProjectService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class ProjectServiceImpl implements ProjectService {
    private static final Logger logger = LoggerFactory.getLogger(ProjectServiceImpl.class);
    
    @Value("${app.data.dir:./data}")
    private String dataDirectory;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    private Path projectsDirectory;
    
    @PostConstruct
    public void init() throws IOException {
        // Create projects directory if it doesn't exist
        projectsDirectory = Paths.get(dataDirectory, "projects");
        Files.createDirectories(projectsDirectory);
        
        logger.info("Project service initialized with data directory: {}", projectsDirectory);
    }
    
    @Override
    public List<Project> getAllProjects() {
        logger.debug("Getting all projects");
        
        try {
            List<Project> projects = new ArrayList<>();
            
            // List all project files
            Files.list(projectsDirectory)
                .filter(path -> path.getFileName().toString().startsWith("project-") && 
                               path.getFileName().toString().endsWith(".json"))
                .forEach(path -> {
                    try {
                        Project project = objectMapper.readValue(path.toFile(), Project.class);
                        projects.add(project);
                    } catch (IOException e) {
                        logger.error("Failed to read project file: {}", path, e);
                    }
                });
            
            return projects;
        } catch (IOException e) {
            logger.error("Failed to list projects", e);
            return new ArrayList<>();
        }
    }
    
    @Override
    public Project getProject(String projectId) {
        logger.debug("Getting project by ID: {}", projectId);
        
        Path projectFile = projectsDirectory.resolve("project-" + projectId + ".json");
        
        if (!Files.exists(projectFile)) {
            logger.warn("Project not found: {}", projectId);
            throw new ResourceNotFoundException("Project not found: " + projectId);
        }
        
        try {
            return objectMapper.readValue(projectFile.toFile(), Project.class);
        } catch (IOException e) {
            logger.error("Failed to read project file: {}", projectFile, e);
            throw new RuntimeException("Failed to read project: " + projectId, e);
        }
    }
    
    @Override
    public Project createProject(Project project) {
        logger.info("Creating new project: {}", project.getName());
        
        // Generate ID if not provided
        if (project.getId() == null || project.getId().isEmpty()) {
            project.setId(UUID.randomUUID().toString());
        }
        
        // Set creation and update time
        LocalDateTime now = LocalDateTime.now();
        project.setCreatedAt(now);
        project.setUpdatedAt(now);
        
        // Create project directory structure
        try {
            createProjectDirectoryStructure(project.getId());
            
            // Create default settings
            createDefaultSettings(project.getId());
            
            // Save project metadata
            saveProject(project);
            
            return project;
        } catch (IOException e) {
            logger.error("Failed to create project: {}", project.getName(), e);
            throw new RuntimeException("Failed to create project: " + project.getName(), e);
        }
    }
    
    @Override
    public Project updateProject(Project project) {
        logger.info("Updating project: {}", project.getId());
        
        // Verify project exists
        Path projectFile = projectsDirectory.resolve("project-" + project.getId() + ".json");
        
        if (!Files.exists(projectFile)) {
            logger.warn("Project not found for update: {}", project.getId());
            throw new ResourceNotFoundException("Project not found: " + project.getId());
        }
        
        try {
            // Load existing project to preserve creation time
            Project existingProject = objectMapper.readValue(projectFile.toFile(), Project.class);
            
            // Update fields
            project.setCreatedAt(existingProject.getCreatedAt());
            project.setUpdatedAt(LocalDateTime.now());
            
            // Save project
            saveProject(project);
            
            return project;
        } catch (IOException e) {
            logger.error("Failed to update project: {}", project.getId(), e);
            throw new RuntimeException("Failed to update project: " + project.getId(), e);
        }
    }
    
    @Override
    public void deleteProject(String projectId) {
        logger.info("Deleting project: {}", projectId);
        
        Path projectFile = projectsDirectory.resolve("project-" + projectId + ".json");
        Path projectDir = projectsDirectory.resolve(projectId);
        
        // Verify project exists
        if (!Files.exists(projectFile)) {
            logger.warn("Project not found for deletion: {}", projectId);
            throw new ResourceNotFoundException("Project not found: " + projectId);
        }
        
        try {
            // Delete project file
            Files.delete(projectFile);
            
            // Delete project directory recursively
            if (Files.exists(projectDir) && Files.isDirectory(projectDir)) {
                deleteDirectoryRecursively(projectDir);
            }
            
            logger.info("Project deleted successfully: {}", projectId);
        } catch (IOException e) {
            logger.error("Failed to delete project: {}", projectId, e);
            throw new RuntimeException("Failed to delete project: " + projectId, e);
        }
    }
    
    @Override
    public ProjectSettings getProjectSettings(String projectId) {
        logger.debug("Getting settings for project: {}", projectId);
        
        Path settingsFile = getProjectSettingsPath(projectId);
        
        if (!Files.exists(settingsFile)) {
            logger.warn("Settings not found for project: {}", projectId);
            throw new ResourceNotFoundException("Project settings not found: " + projectId);
        }
        
        try {
            return objectMapper.readValue(settingsFile.toFile(), ProjectSettings.class);
        } catch (IOException e) {
            logger.error("Failed to read project settings: {}", projectId, e);
            throw new RuntimeException("Failed to read project settings: " + projectId, e);
        }
    }
    
    @Override
    public ProjectSettings updateProjectSettings(String projectId, ProjectSettings settings) {
        logger.info("Updating settings for project: {}", projectId);
        
        // Verify project exists
        getProject(projectId);
        
        Path settingsFile = getProjectSettingsPath(projectId);
        
        try {
            // Update settings
            settings.setProjectId(projectId);
            settings.setUpdatedAt(LocalDateTime.now());
            
            // Write settings file
            objectMapper.writerWithDefaultPrettyPrinter().writeValue(settingsFile.toFile(), settings);
            
            return settings;
        } catch (IOException e) {
            logger.error("Failed to update project settings: {}", projectId, e);
            throw new RuntimeException("Failed to update project settings: " + projectId, e);
        }
    }
    
    @Override
    public List<Project> searchProjects(String query) {
        logger.debug("Searching projects with query: {}", query);
        
        if (query == null || query.trim().isEmpty()) {
            return getAllProjects();
        }
        
        String normalizedQuery = query.toLowerCase().trim();
        
        return getAllProjects().stream()
            .filter(project -> 
                project.getName().toLowerCase().contains(normalizedQuery) ||
                (project.getDescription() != null && project.getDescription().toLowerCase().contains(normalizedQuery)))
            .collect(Collectors.toList());
    }
    
    @Override
    public boolean duplicateProject(String sourceProjectId, String newName) {
        logger.info("Duplicating project {} with new name: {}", sourceProjectId, newName);
        
        try {
            // Get source project
            Project sourceProject = getProject(sourceProjectId);
            
            // Create new project
            Project newProject = new Project();
            newProject.setId(UUID.randomUUID().toString());
            newProject.setName(newName);
            newProject.setDescription(sourceProject.getDescription() + " (Copy)");
            
            // Create project structure
            createProject(newProject);
            
            // Copy settings
            ProjectSettings settings = getProjectSettings(sourceProjectId);
            settings.setProjectId(newProject.getId());
            updateProjectSettings(newProject.getId(), settings);
            
            // Copy all project files
            Path sourceDir = projectsDirectory.resolve(sourceProjectId);
            Path targetDir = projectsDirectory.resolve(newProject.getId());
            
            copyDirectoryContents(sourceDir, targetDir);
            
            // Update references in copied files
            updateProjectReferences(targetDir, sourceProjectId, newProject.getId());
            
            return true;
        } catch (Exception e) {
            logger.error("Failed to duplicate project: {}", sourceProjectId, e);
            return false;
        }
    }
    
    @Override
    public boolean exportProject(String projectId, Path exportPath) {
        logger.info("Exporting project {} to {}", projectId, exportPath);
        
        try {
            // Verify project exists
            getProject(projectId);
            
            // Create export directory
            Files.createDirectories(exportPath);
            
            // Copy project metadata
            Path projectFile = projectsDirectory.resolve("project-" + projectId + ".json");
            Files.copy(projectFile, exportPath.resolve("project.json"));
            
            // Copy project directory
            Path projectDir = projectsDirectory.resolve(projectId);
            copyDirectoryContents(projectDir, exportPath.resolve("content"));
            
            return true;
        } catch (Exception e) {
            logger.error("Failed to export project: {}", projectId, e);
            return false;
        }
    }
    
    @Override
    public Project importProject(Path importPath) {
        logger.info("Importing project from {}", importPath);
        
        try {
            // Read project metadata
            Path projectFile = importPath.resolve("project.json");
            Project project = objectMapper.readValue(projectFile.toFile(), Project.class);
            
            // Generate new ID
            String oldId = project.getId();
            project.setId(UUID.randomUUID().toString());
            
            // Create project structure
            createProject(project);
            
            // Copy content
            Path sourceContentDir = importPath.resolve("content");
            Path targetContentDir = projectsDirectory.resolve(project.getId());
            
            copyDirectoryContents(sourceContentDir, targetContentDir);
            
            // Update references
            updateProjectReferences(targetContentDir, oldId, project.getId());
            
            return project;
        } catch (Exception e) {
            logger.error("Failed to import project", e);
            throw new RuntimeException("Failed to import project", e);
        }
    }
    
    // Helper methods
    
    private void saveProject(Project project) throws IOException {
        Path projectFile = projectsDirectory.resolve("project-" + project.getId() + ".json");
        objectMapper.writerWithDefaultPrettyPrinter().writeValue(projectFile.toFile(), project);
    }
    
    private Path getProjectSettingsPath(String projectId) {
        return projectsDirectory.resolve(projectId).resolve("settings.json");
    }
    
    private void createProjectDirectoryStructure(String projectId) throws IOException {
        Path projectDir = projectsDirectory.resolve(projectId);
        
        // Create main project directory
        Files.createDirectories(projectDir);
        
        // Create subdirectories
        String[] subdirs = {
            "testcases",
            "bdd",
            "testsuites",
            "datasources",
            "executions",
            "database",
            "api",
            "nlp",
            "integrations"
        };
        
        for (String subdir : subdirs) {
            Files.createDirectories(projectDir.resolve(subdir));
        }
    }
    
    private void createDefaultSettings(String projectId) throws IOException {
        ProjectSettings settings = new ProjectSettings();
        settings.setProjectId(projectId);
        settings.setDefaultBrowser("chrome");
        settings.setDefaultTimeout(30000);
        settings.setScreenshotsEnabled(true);
        settings.setVideoRecordingEnabled(false);
        settings.setParallelExecutionEnabled(false);
        settings.setMaxThreads(4);
        settings.setRetryFailedTests(false);
        settings.setMaxRetries(2);
        settings.setCreatedAt(LocalDateTime.now());
        settings.setUpdatedAt(LocalDateTime.now());
        
        // Save settings
        Path settingsFile = getProjectSettingsPath(projectId);
        objectMapper.writerWithDefaultPrettyPrinter().writeValue(settingsFile.toFile(), settings);
    }
    
    private void deleteDirectoryRecursively(Path path) throws IOException {
        if (Files.isDirectory(path)) {
            try (var children = Files.list(path)) {
                for (Path child : children.collect(Collectors.toList())) {
                    deleteDirectoryRecursively(child);
                }
            }
        }
        Files.delete(path);
    }
    
    private void copyDirectoryContents(Path source, Path target) throws IOException {
        if (!Files.exists(source) || !Files.isDirectory(source)) {
            return;
        }
        
        Files.createDirectories(target);
        
        try (var children = Files.list(source)) {
            for (Path child : children.collect(Collectors.toList())) {
                Path targetChild = target.resolve(child.getFileName().toString());
                
                if (Files.isDirectory(child)) {
                    copyDirectoryContents(child, targetChild);
                } else {
                    Files.copy(child, targetChild);
                }
            }
        }
    }
    
    private void updateProjectReferences(Path directory, String oldProjectId, String newProjectId) throws IOException {
        if (!Files.exists(directory) || !Files.isDirectory(directory)) {
            return;
        }
        
        try (var children = Files.list(directory)) {
            for (Path child : children.collect(Collectors.toList())) {
                if (Files.isDirectory(child)) {
                    updateProjectReferences(child, oldProjectId, newProjectId);
                } else if (child.toString().endsWith(".json")) {
                    // Update references in JSON files
                    String content = new String(Files.readAllBytes(child));
                    content = content.replace("\"projectId\":\"" + oldProjectId + "\"", 
                                             "\"projectId\":\"" + newProjectId + "\"");
                    Files.write(child, content.getBytes());
                }
            }
        }
    }
}


/**
 * File System Repository Implementation
 * Provides a generic data access layer for storing entities in the file system
 */
package com.cstestforge.repository.impl;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.repository.FileSystemRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Generic implementation of the FileSystemRepository interface
 * @param <T> The entity type
 */
public class FileSystemRepositoryImpl<T> implements FileSystemRepository<T> {
    private static final Logger logger = LoggerFactory.getLogger(FileSystemRepositoryImpl.class);
    
    @Autowired
    private ObjectMapper objectMapper;
    
    private final Path repositoryPath;
    private final Class<T> entityClass;
    private final Function<T, String> idExtractor;
    private final String fileExtension;
    private final String filePrefix;
    
    /**
     * Constructor for FileSystemRepositoryImpl
     * @param basePath Base directory path
     * @param subPath Sub-directory within the base path
     * @param entityClass The entity class type
     * @param idExtractor Function to extract ID from entity
     * @param filePrefix Prefix for filenames
     * @param fileExtension File extension (default is .json)
     */
    public FileSystemRepositoryImpl(
            String basePath,
            String subPath,
            Class<T> entityClass,
            Function<T, String> idExtractor,
            String filePrefix,
            String fileExtension) {
        this.repositoryPath = Paths.get(basePath, subPath);
        this.entityClass = entityClass;
        this.idExtractor = idExtractor;
        this.filePrefix = filePrefix != null ? filePrefix : "";
        this.fileExtension = fileExtension != null ? fileExtension : ".json";
        
        try {
            Files.createDirectories(repositoryPath);
            logger.debug("Repository directory created/confirmed: {}", repositoryPath);
        } catch (IOException e) {
            logger.error("Failed to create repository directory: {}", repositoryPath, e);
            throw new RuntimeException("Failed to initialize repository: " + repositoryPath, e);
        }
    }
    
    /**
     * Constructor with default file extension (.json)
     */
    public FileSystemRepositoryImpl(
            String basePath,
            String subPath,
            Class<T> entityClass,
            Function<T, String> idExtractor,
            String filePrefix) {
        this(basePath, subPath, entityClass, idExtractor, filePrefix, ".json");
    }
    
    /**
     * Constructor with default file prefix (empty) and extension (.json)
     */
    public FileSystemRepositoryImpl(
            String basePath,
            String subPath,
            Class<T> entityClass,
            Function<T, String> idExtractor) {
        this(basePath, subPath, entityClass, idExtractor, "", ".json");
    }
    
    @Override
    public List<T> findAll() {
        logger.debug("Finding all entities in {}", repositoryPath);
        
        try (Stream<Path> files = Files.list(repositoryPath)) {
            return files
                .filter(path -> path.toString().endsWith(fileExtension))
                .filter(path -> filePrefix.isEmpty() || path.getFileName().toString().startsWith(filePrefix))
                .map(this::readEntityFromFile)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Failed to list files in repository: {}", repositoryPath, e);
            return new ArrayList<>();
        }
    }
    
    @Override
    public Optional<T> findById(String id) {
        logger.debug("Finding entity by ID: {} in {}", id, repositoryPath);
        
        Path filePath = getFilePath(id);
        
        if (!Files.exists(filePath)) {
            logger.debug("Entity not found: {}", id);
            return Optional.empty();
        }
        
        T entity = readEntityFromFile(filePath);
        return Optional.ofNullable(entity);
    }
    
    @Override
    public List<T> findByIds(Collection<String> ids) {
        logger.debug("Finding entities by IDs: {} in {}", ids, repositoryPath);
        
        return ids.stream()
            .map(this::findById)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
    }
    
    @Override
    public T save(T entity) {
        String id = idExtractor.apply(entity);
        logger.debug("Saving entity with ID: {} in {}", id, repositoryPath);
        
        Path filePath = getFilePath(id);
        
        try {
            objectMapper.writerWithDefaultPrettyPrinter().writeValue(filePath.toFile(), entity);
            logger.debug("Entity saved successfully: {}", id);
            return entity;
        } catch (IOException e) {
            logger.error("Failed to save entity: {}", id, e);
            throw new RuntimeException("Failed to save entity: " + id, e);
        }
    }
    
    @Override
    public List<T> saveAll(Collection<T> entities) {
        logger.debug("Saving multiple entities in {}", repositoryPath);
        
        return entities.stream()
            .map(this::save)
            .collect(Collectors.toList());
    }
    
    @Override
    public void deleteById(String id) {
        logger.debug("Deleting entity by ID: {} in {}", id, repositoryPath);
        
        Path filePath = getFilePath(id);
        
        if (!Files.exists(filePath)) {
            logger.warn("Entity not found for deletion: {}", id);
            throw new ResourceNotFoundException("Entity not found: " + id);
        }
        
        try {
            Files.delete(filePath);
            logger.debug("Entity deleted successfully: {}", id);
        } catch (IOException e) {
            logger.error("Failed to delete entity: {}", id, e);
            throw new RuntimeException("Failed to delete entity: " + id, e);
        }
    }
    
    @Override
    public void deleteAll() {
        logger.warn("Deleting all entities in {}", repositoryPath);
        
        try (Stream<Path> files = Files.list(repositoryPath)) {
            files
                .filter(path -> path.toString().endsWith(fileExtension))
                .filter(path -> filePrefix.isEmpty() || path.getFileName().toString().startsWith(filePrefix))
                .forEach(path -> {
                    try {
                        Files.delete(path);
                    } catch (IOException e) {
                        logger.error("Failed to delete file: {}", path, e);
                    }
                });
        } catch (IOException e) {
            logger.error("Failed to list files for deletion in repository: {}", repositoryPath, e);
            throw new RuntimeException("Failed to delete all entities", e);
        }
    }
    
    @Override
    public boolean exists(String id) {
        logger.debug("Checking if entity exists by ID: {} in {}", id, repositoryPath);
        
        Path filePath = getFilePath(id);
        return Files.exists(filePath);
    }
    
    @Override
    public long count() {
        logger.debug("Counting entities in {}", repositoryPath);
        
        try (Stream<Path> files = Files.list(repositoryPath)) {
            return files
                .filter(path -> path.toString().endsWith(fileExtension))
                .filter(path -> filePrefix.isEmpty() || path.getFileName().toString().startsWith(filePrefix))
                .count();
        } catch (IOException e) {
            logger.error("Failed to count files in repository: {}", repositoryPath, e);
            return 0;
        }
    }
    
    @Override
    public Path getRepositoryPath() {
        return repositoryPath;
    }
    
    /**
     * Get the file path for an entity ID
     * @param id Entity ID
     * @return Path to the entity file
     */
    protected Path getFilePath(String id) {
        return repositoryPath.resolve(filePrefix + id + fileExtension);
    }
    
    /**
     * Read an entity from a file
     * @param filePath Path to the entity file
     * @return Entity object or null if read fails
     */
    protected T readEntityFromFile(Path filePath) {
        try {
            return objectMapper.readValue(filePath.toFile(), entityClass);
        } catch (IOException e) {
            logger.error("Failed to read entity from file: {}", filePath, e);
            return null;
        }
    }
    
    /**
     * Extract ID from filename
     * @param filePath Path to the entity file
     * @return Extracted ID
     */
    protected String extractIdFromFilename(Path filePath) {
        String filename = filePath.getFileName().toString();
        
        // Remove prefix and extension
        String id = filename;
        
        if (!filePrefix.isEmpty() && id.startsWith(filePrefix)) {
            id = id.substring(filePrefix.length());
        }
        
        if (id.endsWith(fileExtension)) {
            id = id.substring(0, id.length() - fileExtension.length());
        }
        
        return id;
    }
    
    /**
     * Find entities by a field value
     * @param fieldExtractor Function to extract the field value from entity
     * @param fieldValue Value to match
     * @return List of matching entities
     */
    protected List<T> findByField(Function<T, Object> fieldExtractor, Object fieldValue) {
        return findAll().stream()
            .filter(entity -> Objects.equals(fieldExtractor.apply(entity), fieldValue))
            .collect(Collectors.toList());
    }
    
    /**
     * Find entities by a partial field value match (contains)
     * @param fieldExtractor Function to extract the field value from entity
     * @param partialValue Partial value to match
     * @return List of matching entities
     */
    protected List<T> findByFieldContains(Function<T, String> fieldExtractor, String partialValue) {
        if (partialValue == null || partialValue.isEmpty()) {
            return findAll();
        }
        
        String normalizedQuery = partialValue.toLowerCase();
        
        return findAll().stream()
            .filter(entity -> {
                String fieldValue = fieldExtractor.apply(entity);
                return fieldValue != null && fieldValue.toLowerCase().contains(normalizedQuery);
            })
            .collect(Collectors.toList());
    }
    
    /**
     * Search entities by multiple fields
     * @param query Search query
     * @param fieldExtractors List of field extractors to search in
     * @return List of matching entities
     */
    protected List<T> searchByFields(String query, List<Function<T, String>> fieldExtractors) {
        if (query == null || query.isEmpty()) {
            return findAll();
        }
        
        String normalizedQuery = query.toLowerCase();
        
        return findAll().stream()
            .filter(entity -> fieldExtractors.stream()
                .map(extractor -> extractor.apply(entity))
                .filter(Objects::nonNull)
                .anyMatch(fieldValue -> fieldValue.toLowerCase().contains(normalizedQuery)))
            .collect(Collectors.toList());
    }
}



/**
 * Test Suite Management Implementation
 * Handles test suite creation, organization, and configuration
 */
package com.cstestforge.service.impl.testsuite;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.testsuite.TestSuite;
import com.cstestforge.model.testsuite.TestSuiteConfig;
import com.cstestforge.repository.FileSystemRepository;
import com.cstestforge.service.testsuite.TestSuiteService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class TestSuiteServiceImpl implements TestSuiteService {
    private static final Logger logger = LoggerFactory.getLogger(TestSuiteServiceImpl.class);
    
    @Value("${app.data.dir:./data}")
    private String dataDirectory;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    private Map<String, FileSystemRepository<TestSuite>> projectRepositories = new HashMap<>();
    
    @Override
    public List<TestSuite> getAllTestSuites(String projectId) {
        logger.debug("Getting all test suites for project: {}", projectId);
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.findAll();
    }
    
    @Override
    public TestSuite getTestSuite(String projectId, String testSuiteId) {
        logger.debug("Getting test suite by ID: {} for project: {}", testSuiteId, projectId);
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        Optional<TestSuite> testSuite = repository.findById(testSuiteId);
        
        if (!testSuite.isPresent()) {
            logger.warn("Test suite not found: {} for project: {}", testSuiteId, projectId);
            throw new ResourceNotFoundException("Test suite not found: " + testSuiteId);
        }
        
        return testSuite.get();
    }
    
    @Override
    public TestSuite createTestSuite(String projectId, TestSuite testSuite) {
        logger.info("Creating new test suite: {} for project: {}", testSuite.getName(), projectId);
        
        // Generate ID if not provided
        if (testSuite.getId() == null || testSuite.getId().isEmpty()) {
            testSuite.setId(UUID.randomUUID().toString());
        }
        
        // Set project ID
        testSuite.setProjectId(projectId);
        
        // Set creation and update time
        LocalDateTime now = LocalDateTime.now();
        testSuite.setCreatedAt(now);
        testSuite.setUpdatedAt(now);
        
        // Initialize configuration if not set
        if (testSuite.getConfig() == null) {
            testSuite.setConfig(createDefaultConfig());
        }
        
        // Initialize test case IDs list if not set
        if (testSuite.getTestCaseIds() == null) {
            testSuite.setTestCaseIds(new ArrayList<>());
        }
        
        // Save test suite
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public TestSuite updateTestSuite(String projectId, TestSuite testSuite) {
        logger.info("Updating test suite: {} for project: {}", testSuite.getId(), projectId);
        
        // Verify test suite exists
        getTestSuite(projectId, testSuite.getId());
        
        // Set project ID (in case it's not set or different)
        testSuite.setProjectId(projectId);
        
        // Update timestamp
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        // Save updated test suite
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public void deleteTestSuite(String projectId, String testSuiteId) {
        logger.info("Deleting test suite: {} for project: {}", testSuiteId, projectId);
        
        // Verify test suite exists
        getTestSuite(projectId, testSuiteId);
        
        // Delete test suite
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        repository.deleteById(testSuiteId);
    }
    
    @Override
    public TestSuite addTestCasesToSuite(String projectId, String testSuiteId, List<String> testCaseIds) {
        logger.info("Adding test cases {} to suite: {} for project: {}", testCaseIds, testSuiteId, projectId);
        
        // Get test suite
        TestSuite testSuite = getTestSuite(projectId, testSuiteId);
        
        // Add test cases
        List<String> currentTestCaseIds = testSuite.getTestCaseIds();
        if (currentTestCaseIds == null) {
            currentTestCaseIds = new ArrayList<>();
            testSuite.setTestCaseIds(currentTestCaseIds);
        }
        
        // Filter out duplicates
        List<String> newTestCaseIds = testCaseIds.stream()
            .filter(id -> !currentTestCaseIds.contains(id))
            .collect(Collectors.toList());
        
        currentTestCaseIds.addAll(newTestCaseIds);
        
        // Update test suite
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public TestSuite removeTestCasesFromSuite(String projectId, String testSuiteId, List<String> testCaseIds) {
        logger.info("Removing test cases {} from suite: {} for project: {}", testCaseIds, testSuiteId, projectId);
        
        // Get test suite
        TestSuite testSuite = getTestSuite(projectId, testSuiteId);
        
        // Remove test cases
        List<String> currentTestCaseIds = testSuite.getTestCaseIds();
        if (currentTestCaseIds != null) {
            currentTestCaseIds.removeAll(testCaseIds);
        }
        
        // Update test suite
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public TestSuite reorderTestCases(String projectId, String testSuiteId, List<String> orderedTestCaseIds) {
        logger.info("Reordering test cases in suite: {} for project: {}", testSuiteId, projectId);
        
        // Get test suite
        TestSuite testSuite = getTestSuite(projectId, testSuiteId);
        
        // Verify all test cases are included
        Set<String> currentIds = new HashSet<>(testSuite.getTestCaseIds());
        Set<String> newIds = new HashSet<>(orderedTestCaseIds);
        
        if (!currentIds.equals(newIds)) {
            logger.warn("New order doesn't contain the same test cases as the current order");
            throw new IllegalArgumentException("New order must contain the same test cases as the current order");
        }
        
        // Update order
        testSuite.setTestCaseIds(orderedTestCaseIds);
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public TestSuite updateTestSuiteConfig(String projectId, String testSuiteId, TestSuiteConfig config) {
        logger.info("Updating config for test suite: {} for project: {}", testSuiteId, projectId);
        
        // Get test suite
        TestSuite testSuite = getTestSuite(projectId, testSuiteId);
        
        // Update config
        testSuite.setConfig(config);
        testSuite.setUpdatedAt(LocalDateTime.now());
        
        FileSystemRepository<TestSuite> repository = getRepository(projectId);
        return repository.save(testSuite);
    }
    
    @Override
    public List<TestSuite> searchTestSuites(String projectId, String query) {
        logger.debug("Searching test suites with query: {} for project: {}", query, projectId);
        
        if (query == null || query.trim().isEmpty()) {
            return getAllTestSuites(projectId);
        }
        
        String normalizedQuery = query.toLowerCase().trim();
        
        return getAllTestSuites(projectId).stream()
            .filter(testSuite -> 
                testSuite.getName().toLowerCase().contains(normalizedQuery) ||
                (testSuite.getDescription() != null && testSuite.getDescription().toLowerCase().contains(normalizedQuery)))
            .collect(Collectors.toList());
    }
    
    @Override
    public List<TestSuite> getTestSuitesByTag(String projectId, String tag) {
        logger.debug("Getting test suites by tag: {} for project: {}", tag, projectId);
        
        return getAllTestSuites(projectId).stream()
            .filter(testSuite -> testSuite.getTags() != null && testSuite.getTags().contains(tag))
            .collect(Collectors.toList());
    }
    
    @Override
    public boolean duplicateTestSuite(String projectId, String testSuiteId, String newName) {
        logger.info("Duplicating test suite: {} with new name: {} for project: {}", testSuiteId, newName, projectId);
        
        try {
            // Get source test suite
            TestSuite sourceTestSuite = getTestSuite(projectId, testSuiteId);
            
            // Create new test suite
            TestSuite newTestSuite = new TestSuite();
            newTestSuite.setId(UUID.randomUUID().toString());
            newTestSuite.setProjectId(projectId);
            newTestSuite.setName(newName);
            newTestSuite.setDescription(sourceTestSuite.getDescription() + " (Copy)");
            newTestSuite.setTestCaseIds(new ArrayList<>(sourceTestSuite.getTestCaseIds()));
            newTestSuite.setTags(sourceTestSuite.getTags() != null ? new ArrayList<>(sourceTestSuite.getTags()) : null);
            
            // Copy config
            if (sourceTestSuite.getConfig() != null) {
                newTestSuite.setConfig(copyConfig(sourceTestSuite.getConfig()));
            }
            
            // Set timestamps
            LocalDateTime now = LocalDateTime.now();
            newTestSuite.setCreatedAt(now);
            newTestSuite.setUpdatedAt(now);
            
            // Save new test suite
            FileSystemRepository<TestSuite> repository = getRepository(projectId);
            repository.save(newTestSuite);
            
            return true;
        } catch (Exception e) {
            logger.error("Failed to duplicate test suite: {}", testSuiteId, e);
            return false;
        }
    }
    
    // Helper methods
    
    private FileSystemRepository<TestSuite> getRepository(String projectId) {
        return projectRepositories.computeIfAbsent(projectId, id -> {
            String projectPath = Paths.get(dataDirectory, "projects", id, "testsuites").toString();
            return new FileSystemRepositoryImpl<>(
                projectPath, "", TestSuite.class, TestSuite::getId, "", ".json");
        });
    }
    
    private TestSuiteConfig createDefaultConfig() {
        TestSuiteConfig config = new TestSuiteConfig();
        config.setParallelExecution(false);
        config.setMaxThreads(1);
        config.setRetryFailedTests(false);
        config.setMaxRetries(0);
        config.setContinueOnFailure(true);
        config.setScreenshotsEnabled(true);
        config.setVideoRecordingEnabled(false);
        config.setTimeoutMs(30000);
        return config;
    }
    
    private TestSuiteConfig copyConfig(TestSuiteConfig source) {
        TestSuiteConfig copy = new TestSuiteConfig();
        copy.setParallelExecution(source.isParallelExecution());
        copy.setMaxThreads(source.getMaxThreads());
        copy.setRetryFailedTests(source.isRetryFailedTests());
        copy.setMaxRetries(source.getMaxRetries());
        copy.setContinueOnFailure(source.isContinueOnFailure());
        copy.setScreenshotsEnabled(source.isScreenshotsEnabled());
        copy.setVideoRecordingEnabled(source.isVideoRecordingEnabled());
        copy.setTimeoutMs(source.getTimeoutMs());
        return copy;
    }
}

/**
 * Test Execution Service Implementation
 * Handles test execution, parallelization, and results processing
 */
package com.cstestforge.service.impl.execution;

import com.cstestforge.model.execution.*;
import com.cstestforge.model.project.ProjectSettings;
import com.cstestforge.model.testcase.TestCase;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.model.testsuite.TestSuite;
import com.cstestforge.model.testsuite.TestSuiteConfig;
import com.cstestforge.repository.FileSystemRepository;
import com.cstestforge.service.browser.BrowserAutomationService;
import com.cstestforge.service.execution.ExecutionService;
import com.cstestforge.service.project.ProjectService;
import com.cstestforge.service.reporting.ReportingService;
import com.cstestforge.service.testcase.TestCaseService;
import com.cstestforge.service.testsuite.TestSuiteService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Service
public class ExecutionServiceImpl implements ExecutionService {
    private static final Logger logger = LoggerFactory.getLogger(ExecutionServiceImpl.class);
    
    @Value("${app.data.dir:./data}")
    private String dataDirectory;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private ProjectService projectService;
    
    @Autowired
    private TestSuiteService testSuiteService;
    
    @Autowired
    private TestCaseService testCaseService;
    
    @Autowired
    private BrowserAutomationService browserService;
    
    @Autowired
    private ReportingService reportingService;
    
    private Map<String, FileSystemRepository<ExecutionResult>> projectRepositories = new HashMap<>();
    
    // Execution thread pool
    private ExecutorService executorService;
    
    // Active executions
    private final Map<String, Future<ExecutionResult>> activeExecutions = new ConcurrentHashMap<>();
    
    // Execution status listeners
    private final Map<String, Set<ExecutionStatusListener>> executionListeners = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // Create a thread pool with a reasonable number of threads
        int processors = Runtime.getRuntime().availableProcessors();
        executorService = Executors.newFixedThreadPool(processors * 2);
        
        logger.info("Execution service initialized with thread pool size: {}", processors * 2);
    }
    
    @Override
    public ExecutionPlan createExecutionPlan(String projectId, ExecutionPlanRequest request) {
        logger.info("Creating execution plan for project: {}", projectId);
        
        ExecutionPlan plan = new ExecutionPlan();
        plan.setId(UUID.randomUUID().toString());
        plan.setProjectId(projectId);
        plan.setName(request.getName());
        plan.setDescription(request.getDescription());
        
        // Set creation time
        LocalDateTime now = LocalDateTime.now();
        plan.setCreatedAt(now);
        
        // Process test cases to execute
        Set<String> testCaseIds = new HashSet<>();
        
        // Add test cases from test suites
        if (request.getTestSuiteIds() != null && !request.getTestSuiteIds().isEmpty()) {
            for (String testSuiteId : request.getTestSuiteIds()) {
                try {
                    TestSuite testSuite = testSuiteService.getTestSuite(projectId, testSuiteId);
                    testCaseIds.addAll(testSuite.getTestCaseIds());
                } catch (Exception e) {
                    logger.warn("Failed to get test suite: {}", testSuiteId, e);
                }
            }
        }
        
        // Add individual test cases
        if (request.getTestCaseIds() != null && !request.getTestCaseIds().isEmpty()) {
            testCaseIds.addAll(request.getTestCaseIds());
        }
        
        // Set test case IDs
        plan.setTestCaseIds(new ArrayList<>(testCaseIds));
        
        // Set configuration
        BrowserConfig browserConfig = request.getBrowserConfig();
        if (browserConfig == null) {
            // Use default browser config
            ProjectSettings settings = projectService.getProjectSettings(projectId);
            browserConfig = createDefaultBrowserConfig(settings);
        }
        plan.setBrowserConfig(browserConfig);
        
        // Set execution config
        ExecutionConfig executionConfig = request.getExecutionConfig();
        if (executionConfig == null) {
            // Use default execution config
            executionConfig = createDefaultExecutionConfig();
        }
        plan.setExecutionConfig(executionConfig);
        
        logger.info("Created execution plan: {} with {} test cases", plan.getId(), plan.getTestCaseIds().size());
        return plan;
    }
    
    @Override
    public ExecutionResult executeTests(String projectId, ExecutionPlan plan) {
        logger.info("Starting test execution for plan: {} with {} test cases", 
            plan.getId(), plan.getTestCaseIds().size());
        
        // Create execution result
        ExecutionResult result = new ExecutionResult();
        result.setExecutionId(UUID.randomUUID().toString());
        result.setProjectId(projectId);
        result.setName(plan.getName());
        result.setDescription(plan.getDescription());
        result.setPlanId(plan.getId());
        result.setStatus(ExecutionStatus.RUNNING);
        result.setStartTime(LocalDateTime.now());
        result.setTestCaseResults(new ArrayList<>());
        
        // Save initial state
        saveExecutionResult(result);
        
        // Submit execution task
        Future<ExecutionResult> future = executorService.submit(() -> executeTestsAsync(projectId, plan, result));
        activeExecutions.put(result.getExecutionId(), future);
        
        return result;
    }
    
    @Override
    public List<ExecutionResult> getAllExecutionResults(String projectId) {
        logger.debug("Getting all execution results for project: {}", projectId);
        
        FileSystemRepository<ExecutionResult> repository = getRepository(projectId);
        return repository.findAll();
    }
    
    @Override
    public ExecutionResult getExecutionResult(String projectId, String executionId) {
        logger.debug("Getting execution result by ID: {} for project: {}", executionId, projectId);
        
        FileSystemRepository<ExecutionResult> repository = getRepository(projectId);
        Optional<ExecutionResult> result = repository.findById(executionId);
        
        if (!result.isPresent()) {
            logger.warn("Execution result not found: {} for project: {}", executionId, projectId);
            throw new NoSuchElementException("Execution result not found: " + executionId);
        }
        
        return result.get();
    }
    
    @Override
    public boolean cancelExecution(String projectId, String executionId) {
        logger.info("Cancelling execution: {} for project: {}", executionId, projectId);
        
        Future<ExecutionResult> future = activeExecutions.get(executionId);
        if (future == null) {
            logger.warn("No active execution found with ID: {}", executionId);
            return false;
        }
        
        boolean cancelled = future.cancel(true);
        if (cancelled) {
            activeExecutions.remove(executionId);
            
            try {
                // Update execution status to cancelled
                ExecutionResult result = getExecutionResult(projectId, executionId);
                result.setStatus(ExecutionStatus.CANCELLED);
                result.setEndTime(LocalDateTime.now());
                saveExecutionResult(result);
                
                // Notify listeners
                notifyExecutionStatusListeners(executionId, result);
                
                logger.info("Execution cancelled successfully: {}", executionId);
            } catch (Exception e) {
                logger.error("Failed to update execution status after cancellation: {}", executionId, e);
            }
        }
        
        return cancelled;
    }
    
    @Override
    public void registerExecutionStatusListener(String executionId, ExecutionStatusListener listener) {
        logger.debug("Registering execution status listener for execution: {}", executionId);
        
        executionListeners.computeIfAbsent(executionId, id -> ConcurrentHashMap.newKeySet())
            .add(listener);
    }
    
    @Override
    public void unregisterExecutionStatusListener(String executionId, ExecutionStatusListener listener) {
        logger.debug("Unregistering execution status listener for execution: {}", executionId);
        
        Set<ExecutionStatusListener> listeners = executionListeners.get(executionId);
        if (listeners != null) {
            listeners.remove(listener);
            
            // Clean up if no listeners left
            if (listeners.isEmpty()) {
                executionListeners.remove(executionId);
            }
        }
    }
    
    @Override
    public List<ExecutionResult> searchExecutionResults(String projectId, String query) {
        logger.debug("Searching execution results with query: {} for project: {}", query, projectId);
        
        if (query == null || query.trim().isEmpty()) {
            return getAllExecutionResults(projectId);
        }
        
        String normalizedQuery = query.toLowerCase().trim();
        
        return getAllExecutionResults(projectId).stream()
            .filter(result -> 
                result.getName().toLowerCase().contains(normalizedQuery) ||
                (result.getDescription() != null && result.getDescription().toLowerCase().contains(normalizedQuery)))
            .collect(Collectors.toList());
    }
    
    @Override
    public List<ExecutionResult> getRecentExecutionResults(String projectId, int limit) {
        logger.debug("Getting recent execution results for project: {} with limit: {}", projectId, limit);
        
        return getAllExecutionResults(projectId).stream()
            .sorted(Comparator.comparing(ExecutionResult::getStartTime).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }
    
    // Helper methods
    
    private FileSystemRepository<ExecutionResult> getRepository(String projectId) {
        return projectRepositories.computeIfAbsent(projectId, id -> {
            String projectPath = Paths.get(dataDirectory, "projects", id, "executions").toString();
            return new FileSystemRepositoryImpl<>(
                projectPath, "", ExecutionResult.class, ExecutionResult::getExecutionId, "", ".json");
        });
    }
    
    private BrowserConfig createDefaultBrowserConfig(ProjectSettings settings) {
        BrowserConfig config = new BrowserConfig();
        config.setBrowserType(settings.getDefaultBrowser());
        config.setHeadless(true);
        config.setViewportWidth(1280);
        config.setViewportHeight(720);
        config.setDeviceScaleFactor(1.0);
        config.setHasTouch(false);
        config.setIsMobile(false);
        config.setSlowMoMs(0);
        config.setRecordVideo(settings.isVideoRecordingEnabled());
        return config;
    }
    
    private ExecutionConfig createDefaultExecutionConfig() {
        ExecutionConfig config = new ExecutionConfig();
        config.setParallelExecution(false);
        config.setMaxThreads(1);
        config.setContinueOnFailure(true);
        config.setRetryFailedTests(false);
        config.setMaxRetries(0);
        config.setTimeoutMs(30000);
        config.setScreenshotsEnabled(true);
        return config;
    }
    
    private void saveExecutionResult(ExecutionResult result) {
        FileSystemRepository<ExecutionResult> repository = getRepository(result.getProjectId());
        repository.save(result);
    }
    
    private void notifyExecutionStatusListeners(String executionId, ExecutionResult result) {
        Set<ExecutionStatusListener> listeners = executionListeners.get(executionId);
        if (listeners != null) {
            for (ExecutionStatusListener listener : listeners) {
                try {
                    listener.onExecutionStatusUpdate(result);
                } catch (Exception e) {
                    logger.error("Error notifying listener for execution: {}", executionId, e);
                }
            }
        }
    }
    
    private ExecutionResult executeTestsAsync(String projectId, ExecutionPlan plan, ExecutionResult result) {
        logger.info("Executing tests asynchronously for execution: {}", result.getExecutionId());
        
        try {
            ExecutionConfig config = plan.getExecutionConfig();
            List<String> testCaseIds = plan.getTestCaseIds();
            
            // Determine if we should use parallel execution
            boolean parallel = config.isParallelExecution() && config.getMaxThreads() > 1;
            
            if (parallel) {
                executeTestsInParallel(projectId, plan, result);
            } else {
                executeTestsSequentially(projectId, plan, result);
            }
            
            // Set final status
            result.setStatus(ExecutionStatus.COMPLETED);
        } catch (InterruptedException e) {
            logger.info("Execution was interrupted: {}", result.getExecutionId());
            result.setStatus(ExecutionStatus.CANCELLED);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            logger.error("Execution failed: {}", result.getExecutionId(), e);
            result.setStatus(ExecutionStatus.FAILED);
            result.setErrorMessage(e.getMessage());
        } finally {
            // Set end time
            result.setEndTime(LocalDateTime.now());
            
            // Save final result
            saveExecutionResult(result);
            
            // Notify listeners
            notifyExecutionStatusListeners(result.getExecutionId(), result);
            
            // Clean up
            activeExecutions.remove(result.getExecutionId());
            
            // Generate report
            try {
                String reportPath = reportingService.generateExecutionReport(result);
                logger.info("Generated execution report at: {}", reportPath);
                result.setReportPath(reportPath);
                
                // Save with report path
                saveExecutionResult(result);
            } catch (Exception e) {
                logger.error("Failed to generate report for execution: {}", result.getExecutionId(), e);
            }
        }
        
        return result;
    }
    
    private void executeTestsSequentially(String projectId, ExecutionPlan plan, ExecutionResult result) 
            throws InterruptedException {
        
        logger.info("Executing tests sequentially for execution: {}", result.getExecutionId());
        
        BrowserConfig browserConfig = plan.getBrowserConfig();
        ExecutionConfig executionConfig = plan.getExecutionConfig();
        List<String> testCaseIds = plan.getTestCaseIds();
        
        // Initialize browser
        String browserId = browserService.initializeBrowser(browserConfig);
        
        try {
            // Execute each test case
            for (String testCaseId : testCaseIds) {
                // Check if execution was interrupted
                if (Thread.currentThread().isInterrupted()) {
                    throw new InterruptedException("Execution was interrupted");
                }
                
                try {
                    // Execute test case
                    TestCaseResult testCaseResult = executeTestCase(projectId, testCaseId, browserId, executionConfig);
                    testCaseResult.setExecutionId(result.getExecutionId());
                    
                    // Add to results
                    result.getTestCaseResults().add(testCaseResult);
                    
                    // Update and save intermediate result
                    saveExecutionResult(result);
                    
                    // Notify listeners
                    notifyExecutionStatusListeners(result.getExecutionId(), result);
                    
                    // If test failed and we shouldn't continue on failure, stop execution
                    if (!testCaseResult.isSuccess() && !executionConfig.isContinueOnFailure()) {
                        logger.info("Stopping execution due to test failure and continueOnFailure=false");
                        break;
                    }
                } catch (Exception e) {
                    logger.error("Failed to execute test case: {}", testCaseId, e);
                    
                    // Create failed test case result
                    TestCaseResult failedResult = new TestCaseResult();
                    failedResult.setTestCaseId(testCaseId);
                    failedResult.setExecutionId(result.getExecutionId());
                    failedResult.setSuccess(false);
                    failedResult.setErrorMessage(e.getMessage());
                    failedResult.setStartTime(LocalDateTime.now());
                    failedResult.setEndTime(LocalDateTime.now());
                    
                    // Add to results
                    result.getTestCaseResults().add(failedResult);
                    
                    // Update and save intermediate result
                    saveExecutionResult(result);
                    
                    // Notify listeners
                    notifyExecutionStatusListeners(result.getExecutionId(), result);
                    
                    // If we shouldn't continue on failure, stop execution
                    if (!executionConfig.isContinueOnFailure()) {
                        logger.info("Stopping execution due to test failure and continueOnFailure=false");
                        break;
                    }
                }
            }
        } finally {
            // Close browser
            try {
                browserService.closeBrowser(browserId);
            } catch (Exception e) {
                logger.error("Failed to close browser: {}", browserId, e);
            }
        }
    }
    
    private void executeTestsInParallel(String projectId, ExecutionPlan plan, ExecutionResult result) 
            throws InterruptedException {
        
        logger.info("Executing tests in parallel for execution: {}", result.getExecutionId());
        
        BrowserConfig browserConfig = plan.getBrowserConfig();
        ExecutionConfig executionConfig = plan.getExecutionConfig();
        List<String> testCaseIds = plan.getTestCaseIds();
        
        // Create thread pool for test case execution
        int threadCount = Math.min(executionConfig.getMaxThreads(), testCaseIds.size());
        ExecutorService testExecutorService = Executors.newFixedThreadPool(threadCount);
        
        try {
            // Create a collection to hold the futures
            List<Future<TestCaseResult>> futures = new ArrayList<>();
            
            // Submit test case execution tasks
            for (String testCaseId : testCaseIds) {
                futures.add(testExecutorService.submit(() -> {
                    // Create a browser instance for this test
                    String browserId = browserService.initializeBrowser(browserConfig);
                    try {
                        // Execute test case
                        TestCaseResult testCaseResult = executeTestCase(projectId, testCaseId, browserId, executionConfig);
                        testCaseResult.setExecutionId(result.getExecutionId());
                        return testCaseResult;
                    } finally {
                        // Close browser
                        try {
                            browserService.closeBrowser(browserId);
                        } catch (Exception e) {
                            logger.error("Failed to close browser: {}", browserId, e);
                        }
                    }
                }));
            }
            
            // Wait for all test cases to complete
            for (Future<TestCaseResult> future : futures) {
                try {
                    // Check if execution was interrupted
                    if (Thread.currentThread().isInterrupted()) {
                        throw new InterruptedException("Execution was interrupted");
                    }
                    
                    TestCaseResult testCaseResult = future.get();
                    
                    // Add to results
                    synchronized (result) {
                        result.getTestCaseResults().add(testCaseResult);
                        
                        // Update and save intermediate result
                        saveExecutionResult(result);
                        
                        // Notify listeners
                        notifyExecutionStatusListeners(result.getExecutionId(), result);
                    }
                } catch (ExecutionException e) {
                    logger.error("Test case execution failed", e.getCause());
                    
                    // If the cause is InterruptedException, propagate it
                    if (e.getCause() instanceof InterruptedException) {
                        throw (InterruptedException) e.getCause();
                    }
                }
            }
        } finally {
            // Shutdown the test executor service
            testExecutorService.shutdownNow();
            testExecutorService.awaitTermination(30, TimeUnit.SECONDS);
        }
    }
    
    private TestCaseResult executeTestCase(String projectId, String testCaseId, String browserId, 
            ExecutionConfig config) {
        
        logger.info("Executing test case: {} using browser: {}", testCaseId, browserId);
        
        // Get test case
        TestCase testCase = testCaseService.getTestCase(projectId, testCaseId);
        
        // Create test case result
        TestCaseResult result = new TestCaseResult();
        result.setTestCaseId(testCaseId);
        result.setStartTime(LocalDateTime.now());
        result.setStepResults(new ArrayList<>());
        
        boolean success = true;
        String errorMessage = null;
        
        try {
            // Execute test steps
            for (TestStep step : testCase.getSteps()) {
                // Execute step
                ExecutionStepResult stepResult = executeTestStep(browserId, step, config);
                result.getStepResults().add(stepResult);
                
                // If step failed, mark test case as failed
                if (!stepResult.isSuccess()) {
                    success = false;
                    errorMessage = "Step failed: " + stepResult.getErrorMessage();
                    break;
                }
            }
        } catch (Exception e) {
            logger.error("Failed to execute test case: {}", testCaseId, e);
            success = false;
            errorMessage = e.getMessage();
        }
        
        // Set result
        result.setSuccess(success);
        result.setErrorMessage(errorMessage);
        result.setEndTime(LocalDateTime.now());
        result.setDurationMs(
            java.time.Duration.between(result.getStartTime(), result.getEndTime()).toMillis());
        
        return result;
    }
    
    private ExecutionStepResult executeTestStep(String browserId, TestStep step, ExecutionConfig config) {
        logger.debug("Executing test step: {} in browser: {}", step.getId(), browserId);
        
        // Execute step
        StepResult result = browserService.executeStep(browserId, step);
        
        // Convert to ExecutionStepResult
        ExecutionStepResult stepResult = new ExecutionStepResult();
        stepResult.setStepId(step.getId());
        stepResult.setAction(step.getAction());
        stepResult.setSelector(step.getSelector());
        stepResult.setUsedSelector(result.getUsedSelector());
        stepResult.setSuccess(result.isSuccess());
        stepResult.setErrorMessage(result.getErrorMessage());
        stepResult.setDurationMs(result.getDurationMs());
        stepResult.setScreenshotPath(result.getScreenshotPath());
        
        // Add output variables
        if (result.getOutputVariables() != null && !result.getOutputVariables().isEmpty()) {
            stepResult.setOutputVariables(new HashMap<>(result.getOutputVariables()));
        }
        
        return stepResult;
    }
}


