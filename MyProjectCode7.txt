{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}


# CS TestForge Implementation Plan

## 1. Backend Model Implementation

First, let's create the missing model classes:

### Common Models

```java
// com.cstestforge.model.common.ApiResponse.java
package com.cstestforge.model.common;

import java.time.LocalDateTime;

public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private LocalDateTime timestamp;

    public ApiResponse() {
        this.timestamp = LocalDateTime.now();
    }

    public ApiResponse(boolean success, String message, T data) {
        this.success = success;
        this.message = message;
        this.data = data;
        this.timestamp = LocalDateTime.now();
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Operation successful", data);
    }

    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }

    // Getters and setters
    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}
```

### API Testing Models

```java
// com.cstestforge.model.api.ApiTest.java
package com.cstestforge.model.api;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ApiTest {
    private String id;
    private String name;
    private String description;
    private String url;
    private String method;
    private Map<String, String> headers;
    private Map<String, String> queryParams;
    private String requestBody;
    private List<ApiAssertion> assertions;
    
    public ApiTest() {
        this.headers = new HashMap<>();
        this.queryParams = new HashMap<>();
        this.assertions = new ArrayList<>();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getMethod() {
        return method;
    }
    
    public void setMethod(String method) {
        this.method = method;
    }
    
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    public void setHeaders(Map<String, String> headers) {
        this.headers = headers;
    }
    
    public Map<String, String> getQueryParams() {
        return queryParams;
    }
    
    public void setQueryParams(Map<String, String> queryParams) {
        this.queryParams = queryParams;
    }
    
    public String getRequestBody() {
        return requestBody;
    }
    
    public void setRequestBody(String requestBody) {
        this.requestBody = requestBody;
    }
    
    public List<ApiAssertion> getAssertions() {
        return assertions;
    }
    
    public void setAssertions(List<ApiAssertion> assertions) {
        this.assertions = assertions;
    }
}

// com.cstestforge.model.api.ApiAssertion.java
package com.cstestforge.model.api;

public class ApiAssertion {
    private String id;
    private String type; // RESPONSE_CODE, RESPONSE_TIME, RESPONSE_BODY, HEADER
    private String property; // For HEADER type: header name, for RESPONSE_BODY: JSON path
    private String operator; // EQUALS, CONTAINS, GREATER_THAN, LESS_THAN, etc.
    private String expectedValue;
    
    public ApiAssertion() {
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getType() {
        return type;
    }
    
    public void setType(String type) {
        this.type = type;
    }
    
    public String getProperty() {
        return property;
    }
    
    public void setProperty(String property) {
        this.property = property;
    }
    
    public String getOperator() {
        return operator;
    }
    
    public void setOperator(String operator) {
        this.operator = operator;
    }
    
    public String getExpectedValue() {
        return expectedValue;
    }
    
    public void setExpectedValue(String expectedValue) {
        this.expectedValue = expectedValue;
    }
}

// com.cstestforge.model.api.ApiResponse.java
package com.cstestforge.model.api;

import java.util.HashMap;
import java.util.Map;

public class ApiResponse {
    private int statusCode;
    private String statusText;
    private Map<String, String> headers;
    private String body;
    private long responseTimeMs;
    
    public ApiResponse() {
        this.headers = new HashMap<>();
    }
    
    // Getters and setters
    public int getStatusCode() {
        return statusCode;
    }
    
    public void setStatusCode(int statusCode) {
        this.statusCode = statusCode;
    }
    
    public String getStatusText() {
        return statusText;
    }
    
    public void setStatusText(String statusText) {
        this.statusText = statusText;
    }
    
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    public void setHeaders(Map<String, String> headers) {
        this.headers = headers;
    }
    
    public String getBody() {
        return body;
    }
    
    public void setBody(String body) {
        this.body = body;
    }
    
    public long getResponseTimeMs() {
        return responseTimeMs;
    }
    
    public void setResponseTimeMs(long responseTimeMs) {
        this.responseTimeMs = responseTimeMs;
    }
}

// com.cstestforge.model.api.ApiTestDto.java
package com.cstestforge.model.api;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ApiTestDto {
    private String name;
    private String description;
    private String url;
    private String method;
    private Map<String, String> headers;
    private Map<String, String> queryParams;
    private String requestBody;
    private List<ApiAssertion> assertions;
    
    public ApiTestDto() {
        this.headers = new HashMap<>();
        this.queryParams = new HashMap<>();
    }
    
    // Getters and setters
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public String getMethod() {
        return method;
    }
    
    public void setMethod(String method) {
        this.method = method;
    }
    
    public Map<String, String> getHeaders() {
        return headers;
    }
    
    public void setHeaders(Map<String, String> headers) {
        this.headers = headers;
    }
    
    public Map<String, String> getQueryParams() {
        return queryParams;
    }
    
    public void setQueryParams(Map<String, String> queryParams) {
        this.queryParams = queryParams;
    }
    
    public String getRequestBody() {
        return requestBody;
    }
    
    public void setRequestBody(String requestBody) {
        this.requestBody = requestBody;
    }
    
    public List<ApiAssertion> getAssertions() {
        return assertions;
    }
    
    public void setAssertions(List<ApiAssertion> assertions) {
        this.assertions = assertions;
    }
}
```

### Execution Models

```java
// com.cstestforge.model.execution.ExecutionConfig.java
package com.cstestforge.model.execution;

import java.util.HashMap;
import java.util.Map;

public class ExecutionConfig {
    private String browser; // chrome, firefox, safari, edge
    private boolean headless;
    private int timeout; // in seconds
    private Map<String, String> environment; // environment variables
    private Map<String, String> testData; // test data variables
    private boolean captureVideo;
    private boolean captureScreenshots;
    private boolean captureConsoleOutput;
    private boolean captureNetworkTraffic;
    
    public ExecutionConfig() {
        this.environment = new HashMap<>();
        this.testData = new HashMap<>();
        this.browser = "chrome";
        this.headless = false;
        this.timeout = 30;
        this.captureVideo = false;
        this.captureScreenshots = true;
        this.captureConsoleOutput = true;
        this.captureNetworkTraffic = false;
    }
    
    // Getters and setters
    public String getBrowser() {
        return browser;
    }
    
    public void setBrowser(String browser) {
        this.browser = browser;
    }
    
    public boolean isHeadless() {
        return headless;
    }
    
    public void setHeadless(boolean headless) {
        this.headless = headless;
    }
    
    public int getTimeout() {
        return timeout;
    }
    
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }
    
    public Map<String, String> getEnvironment() {
        return environment;
    }
    
    public void setEnvironment(Map<String, String> environment) {
        this.environment = environment;
    }
    
    public Map<String, String> getTestData() {
        return testData;
    }
    
    public void setTestData(Map<String, String> testData) {
        this.testData = testData;
    }
    
    public boolean isCaptureVideo() {
        return captureVideo;
    }
    
    public void setCaptureVideo(boolean captureVideo) {
        this.captureVideo = captureVideo;
    }
    
    public boolean isCaptureScreenshots() {
        return captureScreenshots;
    }
    
    public void setCaptureScreenshots(boolean captureScreenshots) {
        this.captureScreenshots = captureScreenshots;
    }
    
    public boolean isCaptureConsoleOutput() {
        return captureConsoleOutput;
    }
    
    public void setCaptureConsoleOutput(boolean captureConsoleOutput) {
        this.captureConsoleOutput = captureConsoleOutput;
    }
    
    public boolean isCaptureNetworkTraffic() {
        return captureNetworkTraffic;
    }
    
    public void setCaptureNetworkTraffic(boolean captureNetworkTraffic) {
        this.captureNetworkTraffic = captureNetworkTraffic;
    }
}

// com.cstestforge.model.execution.ExecutionRequest.java
package com.cstestforge.model.execution;

import java.util.ArrayList;
import java.util.List;

public class ExecutionRequest {
    private String id;
    private String projectId;
    private List<String> testCaseIds;
    private List<String> testSuiteIds;
    private ExecutionConfig config;
    
    public ExecutionRequest() {
        this.testCaseIds = new ArrayList<>();
        this.testSuiteIds = new ArrayList<>();
        this.config = new ExecutionConfig();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public List<String> getTestCaseIds() {
        return testCaseIds;
    }
    
    public void setTestCaseIds(List<String> testCaseIds) {
        this.testCaseIds = testCaseIds;
    }
    
    public List<String> getTestSuiteIds() {
        return testSuiteIds;
    }
    
    public void setTestSuiteIds(List<String> testSuiteIds) {
        this.testSuiteIds = testSuiteIds;
    }
    
    public ExecutionConfig getConfig() {
        return config;
    }
    
    public void setConfig(ExecutionConfig config) {
        this.config = config;
    }
}

// com.cstestforge.model.execution.ExecutionStepResult.java
package com.cstestforge.model.execution;

import java.time.LocalDateTime;

public class ExecutionStepResult {
    private String id;
    private String testStepId;
    private String status; // PASSED, FAILED, SKIPPED, ERROR
    private String message;
    private String screenshot;
    private long durationMs;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    
    public ExecutionStepResult() {
        this.startTime = LocalDateTime.now();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getTestStepId() {
        return testStepId;
    }
    
    public void setTestStepId(String testStepId) {
        this.testStepId = testStepId;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public String getScreenshot() {
        return screenshot;
    }
    
    public void setScreenshot(String screenshot) {
        this.screenshot = screenshot;
    }
    
    public long getDurationMs() {
        return durationMs;
    }
    
    public void setDurationMs(long durationMs) {
        this.durationMs = durationMs;
    }
    
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }
    
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
        if (startTime != null && endTime != null) {
            this.durationMs = java.time.Duration.between(startTime, endTime).toMillis();
        }
    }
}

// com.cstestforge.model.execution.ExecutionSummary.java
package com.cstestforge.model.execution;

import java.time.LocalDateTime;

public class ExecutionSummary {
    private String id;
    private String projectId;
    private int totalTests;
    private int passedTests;
    private int failedTests;
    private int skippedTests;
    private int errorTests;
    private long totalDurationMs;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String status; // RUNNING, COMPLETED, ABORTED, FAILED
    
    public ExecutionSummary() {
        this.startTime = LocalDateTime.now();
        this.status = "RUNNING";
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public int getTotalTests() {
        return totalTests;
    }
    
    public void setTotalTests(int totalTests) {
        this.totalTests = totalTests;
    }
    
    public int getPassedTests() {
        return passedTests;
    }
    
    public void setPassedTests(int passedTests) {
        this.passedTests = passedTests;
    }
    
    public int getFailedTests() {
        return failedTests;
    }
    
    public void setFailedTests(int failedTests) {
        this.failedTests = failedTests;
    }
    
    public int getSkippedTests() {
        return skippedTests;
    }
    
    public void setSkippedTests(int skippedTests) {
        this.skippedTests = skippedTests;
    }
    
    public int getErrorTests() {
        return errorTests;
    }
    
    public void setErrorTests(int errorTests) {
        this.errorTests = errorTests;
    }
    
    public long getTotalDurationMs() {
        return totalDurationMs;
    }
    
    public void setTotalDurationMs(long totalDurationMs) {
        this.totalDurationMs = totalDurationMs;
    }
    
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }
    
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
        if (startTime != null && endTime != null) {
            this.totalDurationMs = java.time.Duration.between(startTime, endTime).toMillis();
        }
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
}

// com.cstestforge.model.execution.BrowserContext.java
package com.cstestforge.model.execution;

import java.util.HashMap;
import java.util.Map;

public class BrowserContext {
    private String id;
    private String browser; // chrome, firefox, safari, edge
    private String browserVersion;
    private BrowserOptions options;
    private Map<String, String> cookies;
    private Map<String, String> localStorage;
    private Map<String, String> sessionStorage;
    
    public BrowserContext() {
        this.options = new BrowserOptions();
        this.cookies = new HashMap<>();
        this.localStorage = new HashMap<>();
        this.sessionStorage = new HashMap<>();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getBrowser() {
        return browser;
    }
    
    public void setBrowser(String browser) {
        this.browser = browser;
    }
    
    public String getBrowserVersion() {
        return browserVersion;
    }
    
    public void setBrowserVersion(String browserVersion) {
        this.browserVersion = browserVersion;
    }
    
    public BrowserOptions getOptions() {
        return options;
    }
    
    public void setOptions(BrowserOptions options) {
        this.options = options;
    }
    
    public Map<String, String> getCookies() {
        return cookies;
    }
    
    public void setCookies(Map<String, String> cookies) {
        this.cookies = cookies;
    }
    
    public Map<String, String> getLocalStorage() {
        return localStorage;
    }
    
    public void setLocalStorage(Map<String, String> localStorage) {
        this.localStorage = localStorage;
    }
    
    public Map<String, String> getSessionStorage() {
        return sessionStorage;
    }
    
    public void setSessionStorage(Map<String, String> sessionStorage) {
        this.sessionStorage = sessionStorage;
    }
}

// com.cstestforge.model.execution.BrowserOptions.java
package com.cstestforge.model.execution;

import java.util.HashMap;
import java.util.Map;

public class BrowserOptions {
    private boolean headless;
    private boolean incognito;
    private int defaultTimeout; // in milliseconds
    private int defaultNavigationTimeout; // in milliseconds
    private Map<String, Object> additionalOptions;
    
    public BrowserOptions() {
        this.headless = false;
        this.incognito = true;
        this.defaultTimeout = 30000;
        this.defaultNavigationTimeout = 30000;
        this.additionalOptions = new HashMap<>();
    }
    
    // Getters and setters
    public boolean isHeadless() {
        return headless;
    }
    
    public void setHeadless(boolean headless) {
        this.headless = headless;
    }
    
    public boolean isIncognito() {
        return incognito;
    }
    
    public void setIncognito(boolean incognito) {
        this.incognito = incognito;
    }
    
    public int getDefaultTimeout() {
        return defaultTimeout;
    }
    
    public void setDefaultTimeout(int defaultTimeout) {
        this.defaultTimeout = defaultTimeout;
    }
    
    public int getDefaultNavigationTimeout() {
        return defaultNavigationTimeout;
    }
    
    public void setDefaultNavigationTimeout(int defaultNavigationTimeout) {
        this.defaultNavigationTimeout = defaultNavigationTimeout;
    }
    
    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }
    
    public void setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
    }
}

// com.cstestforge.model.execution.ElementInfo.java
package com.cstestforge.model.execution;

import java.util.HashMap;
import java.util.Map;

public class ElementInfo {
    private String selector;
    private String selectorType; // css, xpath, id, text, etc.
    private String tagName;
    private String text;
    private Map<String, String> attributes;
    private boolean visible;
    private boolean enabled;
    private Map<String, Object> boundingBox; // x, y, width, height
    
    public ElementInfo() {
        this.attributes = new HashMap<>();
        this.boundingBox = new HashMap<>();
    }
    
    // Getters and setters
    public String getSelector() {
        return selector;
    }
    
    public void setSelector(String selector) {
        this.selector = selector;
    }
    
    public String getSelectorType() {
        return selectorType;
    }
    
    public void setSelectorType(String selectorType) {
        this.selectorType = selectorType;
    }
    
    public String getTagName() {
        return tagName;
    }
    
    public void setTagName(String tagName) {
        this.tagName = tagName;
    }
    
    public String getText() {
        return text;
    }
    
    public void setText(String text) {
        this.text = text;
    }
    
    public Map<String, String> getAttributes() {
        return attributes;
    }
    
    public void setAttributes(Map<String, String> attributes) {
        this.attributes = attributes;
    }
    
    public boolean isVisible() {
        return visible;
    }
    
    public void setVisible(boolean visible) {
        this.visible = visible;
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    public Map<String, Object> getBoundingBox() {
        return boundingBox;
    }
    
    public void setBoundingBox(Map<String, Object> boundingBox) {
        this.boundingBox = boundingBox;
    }
}

// com.cstestforge.model.execution.ExecutionRequestDto.java
package com.cstestforge.model.execution;

import java.util.ArrayList;
import java.util.List;

public class ExecutionRequestDto {
    private String projectId;
    private List<String> testCaseIds;
    private List<String> testSuiteIds;
    private ExecutionConfig config;
    
    public ExecutionRequestDto() {
        this.testCaseIds = new ArrayList<>();
        this.testSuiteIds = new ArrayList<>();
        this.config = new ExecutionConfig();
    }
    
    // Getters and setters
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public List<String> getTestCaseIds() {
        return testCaseIds;
    }
    
    public void setTestCaseIds(List<String> testCaseIds) {
        this.testCaseIds = testCaseIds;
    }
    
    public List<String> getTestSuiteIds() {
        return testSuiteIds;
    }
    
    public void setTestSuiteIds(List<String> testSuiteIds) {
        this.testSuiteIds = testSuiteIds;
    }
    
    public ExecutionConfig getConfig() {
        return config;
    }
    
    public void setConfig(ExecutionConfig config) {
        this.config = config;
    }
}
```

### NLP Models

```java
// com.cstestforge.model.nlp.NLPMatchResult.java
package com.cstestforge.model.nlp;

import java.util.HashMap;
import java.util.Map;

public class NLPMatchResult {
    private String templateId;
    private String templateText;
    private double confidence;
    private Map<String, String> extractedParameters;
    
    public NLPMatchResult() {
        this.extractedParameters = new HashMap<>();
    }
    
    // Getters and setters
    public String getTemplateId() {
        return templateId;
    }
    
    public void setTemplateId(String templateId) {
        this.templateId = templateId;
    }
    
    public String getTemplateText() {
        return templateText;
    }
    
    public void setTemplateText(String templateText) {
        this.templateText = templateText;
    }
    
    public double getConfidence() {
        return confidence;
    }
    
    public void setConfidence(double confidence) {
        this.confidence = confidence;
    }
    
    public Map<String, String> getExtractedParameters() {
        return extractedParameters;
    }
    
    public void setExtractedParameters(Map<String, String> extractedParameters) {
        this.extractedParameters = extractedParameters;
    }
}

// com.cstestforge.model.nlp.NLPParsingResult.java
package com.cstestforge.model.nlp;

import java.util.ArrayList;
import java.util.List;

public class NLPParsingResult {
    private String originalText;
    private List<NLPMatchResult> matches;
    private boolean successful;
    private String errorMessage;
    
    public NLPParsingResult() {
        this.matches = new ArrayList<>();
        this.successful = true;
    }
    
    // Getters and setters
    public String getOriginalText() {
        return originalText;
    }
    
    public void setOriginalText(String originalText) {
        this.originalText = originalText;
    }
    
    public List<NLPMatchResult> getMatches() {
        return matches;
    }
    
    public void setMatches(List<NLPMatchResult> matches) {
        this.matches = matches;
    }
    
    public boolean isSuccessful() {
        return successful;
    }
    
    public void setSuccessful(boolean successful) {
        this.successful = successful;
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
        if (errorMessage != null && !errorMessage.isEmpty()) {
            this.successful = false;
        }
    }
}

// com.cstestforge.model.nlp.NLPTemplate.java
package com.cstestforge.model.nlp;

import java.util.ArrayList;
import java.util.List;

public class NLPTemplate {
    private String id;
    private String pattern;
    private String action;
    private List<String> parameterNames;
    private List<String> examples;
    
    public NLPTemplate() {
        this.parameterNames = new ArrayList<>();
        this.examples = new ArrayList<>();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getPattern() {
        return pattern;
    }
    
    public void setPattern(String pattern) {
        this.pattern = pattern;
    }
    
    public String getAction() {
        return action;
    }
    
    public void setAction(String action) {
        this.action = action;
    }
    
    public List<String> getParameterNames() {
        return parameterNames;
    }
    
    public void setParameterNames(List<String> parameterNames) {
        this.parameterNames = parameterNames;
    }
    
    public List<String> getExamples() {
        return examples;
    }
    
    public void setExamples(List<String> examples) {
        this.examples = examples;
    }
}
```

### Recorder Models

```java
// com.cstestforge.model.recorder.RecordingSession.java
package com.cstestforge.model.recorder;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class RecordingSession {
    private String id;
    private String projectId;
    private String url;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private List<RecordedAction> actions;
    private String status; // ACTIVE, PAUSED, COMPLETED, ABORTED
    
    public RecordingSession() {
        this.startTime = LocalDateTime.now();
        this.actions = new ArrayList<>();
        this.status = "ACTIVE";
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }
    
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
    }
    
    public List<RecordedAction> getActions() {
        return actions;
    }
    
    public void setActions(List<RecordedAction> actions) {
        this.actions = actions;
    }
    
    public String getStatus() {
        return status;
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    // Inner class to store recorded actions
    public static class RecordedAction {
        private String type; // CLICK, TYPE, SELECT, ASSERTION, etc.
        private String selector;
        private String selectorType; // css, xpath, id, text, etc.
        private String value;
        private LocalDateTime timestamp;
        
        public RecordedAction() {
            this.timestamp = LocalDateTime.now();
        }
        
        // Getters and setters
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public String getSelector() {
            return selector;
        }
        
        public void setSelector(String selector) {
            this.selector = selector;
        }
        
        public String getSelectorType() {
            return selectorType;
        }
        
        public void setSelectorType(String selectorType) {
            this.selectorType = selectorType;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public LocalDateTime getTimestamp() {
            return timestamp;
        }
        
        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }
    }
}
```

### TestSuite Models

```java
// com.cstestforge.model.testsuite.TestSuite.java
package com.cstestforge.model.testsuite;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class TestSuite {
    private String id;
    private String name;
    private String description;
    private String projectId;
    private List<String> testCaseIds;
    private TestSuiteConfig config;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    public TestSuite() {
        this.testCaseIds = new ArrayList<>();
        this.config = new TestSuiteConfig();
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    // Getters and setters
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getProjectId() {
        return projectId;
    }
    
    public void setProjectId(String projectId) {
        this.projectId = projectId;
    }
    
    public List<String> getTestCaseIds() {
        return testCaseIds;
    }
    
    public void setTestCaseIds(List<String> testCaseIds) {
        this.testCaseIds = testCaseIds;
    }
    
    public TestSuiteConfig getConfig() {
        return config;
    }
    
    public void setConfig(TestSuiteConfig config) {
        this.config = config;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}

// com.cstestforge.model.testsuite.TestSuiteConfig.java
package com.cstestforge.model.testsuite;

public class TestSuiteConfig {
    private boolean parallelExecution;
    private boolean failFast;
    private int retryCount;
    private int maxParallelTests;
    
    public TestSuiteConfig() {
        this.parallelExecution = false;
        this.failFast = false;
        this.retryCount = 0;
        this.maxParallelTests = 1;
    }
    
    // Getters and setters
    public boolean isParallelExecution() {
        return parallelExecution;
    }
    
    public void setParallelExecution(boolean parallelExecution) {
        this.parallelExecution = parallelExecution;
    }
    
    public boolean isFailFast() {
        return failFast;
    }
    
    public void setFailFast(boolean failFast) {
        this.failFast = failFast;
    }
    
    public int getRetryCount() {
        return retryCount;
    }
    
    public void setRetryCount(int retryCount) {
        this.retryCount = retryCount;
    }
    
    public int getMaxParallelTests() {
        return maxParallelTests;
    }
    
    public void setMaxParallelTests(int maxParallelTests) {
        this.maxParallelTests = maxParallelTests;
    }
}

// com.cstestforge.model.project.ProjectConfig.java
package com.cstestforge.model.project;

import java.util.HashMap;
import java.util.Map;

public class ProjectConfig {
    private String baseUrl;
    private Map<String, String> environment;
    private Map<String, String> defaultHeaders;
    private boolean captureScreenshots;
    private boolean captureVideo;
    private int defaultTimeout;
    
    public ProjectConfig() {
        this.environment = new HashMap<>();
        this.defaultHeaders = new HashMap<>();
        this.captureScreenshots = true;
        this.captureVideo = false;
        this.defaultTimeout = 30;
    }
    
    // Getters and setters
    public String getBaseUrl() {
        return baseUrl;
    }
    
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }
    
    public Map<String, String> getEnvironment() {
        return environment;
    }
    
    public void setEnvironment(Map<String, String> environment) {
        this.environment = environment;
    }
    
    public Map<String, String> getDefaultHeaders() {
        return defaultHeaders;
    }
    
    public void setDefaultHeaders(Map<String, String> defaultHeaders) {
        this.defaultHeaders = defaultHeaders;
    }
    
    public boolean isCaptureScreenshots() {
        return captureScreenshots;
    }
    
    public void setCaptureScreenshots(boolean captureScreenshots) {
        this.captureScreenshots = captureScreenshots;
    }
    
    public boolean isCaptureVideo() {
        return captureVideo;
    }
    
    public void setCaptureVideo(boolean captureVideo) {
        this.captureVideo = captureVideo;
    }
    
    public int getDefaultTimeout() {
        return defaultTimeout;
    }
    
    public void setDefaultTimeout(int defaultTimeout) {
        this.defaultTimeout = defaultTimeout;
    }
}
```

## 2. Backend Service Interfaces

Let's implement the missing service interfaces:

```java
// com.cstestforge.service.api.ApiTestingService.java
package com.cstestforge.service.api;

import com.cstestforge.model.api.ApiTest;
import com.cstestforge.model.api.ApiResponse;
import com.cstestforge.model.common.ApiResponse as CommonApiResponse;
import java.util.List;

public interface ApiTestingService {
    CommonApiResponse<ApiTest> createApiTest(String projectId, ApiTest apiTest);
    CommonApiResponse<ApiTest> getApiTest(String id);
    CommonApiResponse<List<ApiTest>> getApiTestsByProject(String projectId);
    CommonApiResponse<ApiTest> updateApiTest(String id, ApiTest apiTest);
    CommonApiResponse<Boolean> deleteApiTest(String id);
    CommonApiResponse<ApiResponse> executeApiTest(String id);
}

// com.cstestforge.service.bdd.BDDTestingService.java
package com.cstestforge.service.bdd;

import com.cstestforge.model.bdd.Feature;
import com.cstestforge.model.bdd.Scenario;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface BDDTestingService {
    ApiResponse<Feature> createFeature(String projectId, Feature feature);
    ApiResponse<Feature> getFeature(String id);
    ApiResponse<List<Feature>> getFeaturesByProject(String projectId);
    ApiResponse<Feature> updateFeature(String id, Feature feature);
    ApiResponse<Boolean> deleteFeature(String id);
    
    ApiResponse<Scenario> createScenario(String featureId, Scenario scenario);
    ApiResponse<Scenario> getScenario(String id);
    ApiResponse<List<Scenario>> getScenariosByFeature(String featureId);
    ApiResponse<Scenario> updateScenario(String id, Scenario scenario);
    ApiResponse<Boolean> deleteScenario(String id);
    
    ApiResponse<String> generateTestCaseFromScenario(String scenarioId);
}

// com.cstestforge.service.database.DatabaseTestingService.java
package com.cstestforge.service.database;

import com.cstestforge.model.database.DatabaseConnection;
import com.cstestforge.model.database.DatabaseTest;
import com.cstestforge.model.database.QueryResult;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface DatabaseTestingService {
    ApiResponse<DatabaseConnection> createConnection(String projectId, DatabaseConnection connection);
    ApiResponse<DatabaseConnection> getConnection(String id);
    ApiResponse<List<DatabaseConnection>> getConnectionsByProject(String projectId);
    ApiResponse<DatabaseConnection> updateConnection(String id, DatabaseConnection connection);
    ApiResponse<Boolean> deleteConnection(String id);
    ApiResponse<Boolean> testConnection(String id);
    
    ApiResponse<DatabaseTest> createDatabaseTest(String projectId, DatabaseTest databaseTest);
    ApiResponse<DatabaseTest> getDatabaseTest(String id);
    ApiResponse<List<DatabaseTest>> getDatabaseTestsByProject(String projectId);
    ApiResponse<DatabaseTest> updateDatabaseTest(String id, DatabaseTest databaseTest);
    ApiResponse<Boolean> deleteDatabaseTest(String id);
    
    ApiResponse<QueryResult> executeQuery(String connectionId, String query);
    ApiResponse<QueryResult> executeDatabaseTest(String databaseTestId);
}

// com.cstestforge.service.browser.BrowserAutomationService.java
package com.cstestforge.service.browser;

import com.cstestforge.model.execution.BrowserContext;
import com.cstestforge.model.execution.ElementInfo;
import com.cstestforge.exception.BrowserException;
import com.cstestforge.model.common.ApiResponse;
import com.microsoft.playwright.Page;
import java.util.List;

public interface BrowserAutomationService {
    ApiResponse<BrowserContext> createBrowserContext(String browser, boolean headless);
    ApiResponse<Boolean> closeBrowserContext(String contextId);
    ApiResponse<String> takeScreenshot(String contextId);
    ApiResponse<Boolean> navigate(String contextId, String url);
    ApiResponse<ElementInfo> getElementInfo(String contextId, String selector);
    ApiResponse<Boolean> click(String contextId, String selector);
    ApiResponse<Boolean> fill(String contextId, String selector, String value);
    ApiResponse<Boolean> select(String contextId, String selector, String value);
    ApiResponse<Boolean> check(String contextId, String selector);
    ApiResponse<Boolean> uncheck(String contextId, String selector);
    ApiResponse<String> getInnerText(String contextId, String selector);
    ApiResponse<String> getAttribute(String contextId, String selector, String attributeName);
    ApiResponse<Boolean> waitForElement(String contextId, String selector, int timeout);
    ApiResponse<Boolean> waitForNavigation(String contextId, int timeout);
    ApiResponse<Boolean> waitForUrl(String contextId, String url, int timeout);
    ApiResponse<List<ElementInfo>> getElements(String contextId, String selector);
    ApiResponse<Page> getPage(String contextId) throws BrowserException;
}

// com.cstestforge.service.execution.ExecutionService.java
package com.cstestforge.service.execution;

import com.cstestforge.model.execution.ExecutionRequest;
import com.cstestforge.model.execution.ExecutionStepResult;
import com.cstestforge.model.execution.ExecutionSummary;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface ExecutionService {
    ApiResponse<String> startExecution(ExecutionRequest request);
    ApiResponse<Boolean> stopExecution(String executionId);
    ApiResponse<ExecutionSummary> getExecutionSummary(String executionId);
    ApiResponse<List<ExecutionStepResult>> getExecutionResults(String executionId);
    ApiResponse<List<ExecutionSummary>> getExecutionsByProject(String projectId);
    ApiResponse<String> getExecutionStatus(String executionId);
    ApiResponse<String> getExecutionVideo(String executionId);
    ApiResponse<List<String>> getExecutionScreenshots(String executionId);
}

// com.cstestforge.service.integration.IntegrationService.java
package com.cstestforge.service.integration;

import com.cstestforge.model.integration.GitConfig;
import com.cstestforge.model.integration.AzureDevOpsConfig;
import com.cstestforge.model.integration.JiraConfig;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface IntegrationService {
    // Git integration
    ApiResponse<GitConfig> createGitConfig(String projectId, GitConfig gitConfig);
    ApiResponse<GitConfig> getGitConfig(String id);
    ApiResponse<GitConfig> updateGitConfig(String id, GitConfig gitConfig);
    ApiResponse<Boolean> deleteGitConfig(String id);
    ApiResponse<Boolean> syncWithGit(String configId, String branch);
    
    // Azure DevOps integration
    ApiResponse<AzureDevOpsConfig> createAzureDevOpsConfig(String projectId, AzureDevOpsConfig config);
    ApiResponse<AzureDevOpsConfig> getAzureDevOpsConfig(String id);
    ApiResponse<AzureDevOpsConfig> updateAzureDevOpsConfig(String id, AzureDevOpsConfig config);
    ApiResponse<Boolean> deleteAzureDevOpsConfig(String id);
    ApiResponse<Boolean> syncWithAzureDevOps(String configId);
    
    // Jira integration
    ApiResponse<JiraConfig> createJiraConfig(String projectId, JiraConfig config);
    ApiResponse<JiraConfig> getJiraConfig(String id);
    ApiResponse<JiraConfig> updateJiraConfig(String id, JiraConfig config);
    ApiResponse<Boolean> deleteJiraConfig(String id);
    ApiResponse<Boolean> syncWithJira(String configId);
}

// com.cstestforge.service.nlp.NLPService.java
package com.cstestforge.service.nlp;

import com.cstestforge.model.nlp.NLPTemplate;
import com.cstestforge.model.nlp.NLPParsingResult;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface NLPService {
    ApiResponse<NLPParsingResult> parseText(String projectId, String text);
    ApiResponse<NLPTemplate> createTemplate(String projectId, NLPTemplate template);
    ApiResponse<NLPTemplate> getTemplate(String id);
    ApiResponse<List<NLPTemplate>> getTemplatesByProject(String projectId);
    ApiResponse<NLPTemplate> updateTemplate(String id, NLPTemplate template);
    ApiResponse<Boolean> deleteTemplate(String id);
    ApiResponse<String> generateTestCaseFromText(String projectId, String text);
}

// com.cstestforge.service.project.ProjectService.java
package com.cstestforge.service.project;

import com.cstestforge.model.project.Project;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface ProjectService {
    ApiResponse<Project> createProject(Project project);
    ApiResponse<Project> getProject(String id);
    ApiResponse<List<Project>> getAllProjects();
    ApiResponse<Project> updateProject(String id, Project project);
    ApiResponse<Boolean> deleteProject(String id);
    ApiResponse<Project> cloneProject(String id, String newName);
    ApiResponse<String> exportProject(String id);
    ApiResponse<Project> importProject(String projectData);
}

// com.cstestforge.service.recorder.RecorderService.java
package com.cstestforge.service.recorder;

import com.cstestforge.model.recorder.RecordingSession;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface RecorderService {
    ApiResponse<RecordingSession> startRecording(String projectId, String url);
    ApiResponse<RecordingSession> getRecordingSession(String id);
    ApiResponse<List<RecordingSession>> getRecordingSessionsByProject(String projectId);
    ApiResponse<RecordingSession> pauseRecording(String id);
    ApiResponse<RecordingSession> resumeRecording(String id);
    ApiResponse<RecordingSession> stopRecording(String id);
    ApiResponse<Boolean> deleteRecordingSession(String id);
    ApiResponse<String> generateTestCaseFromRecording(String recordingSessionId);
}

// com.cstestforge.service.testsuite.TestSuiteService.java
package com.cstestforge.service.testsuite;

import com.cstestforge.model.testsuite.TestSuite;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface TestSuiteService {
    ApiResponse<TestSuite> createTestSuite(String projectId, TestSuite testSuite);
    ApiResponse<TestSuite> getTestSuite(String id);
    ApiResponse<List<TestSuite>> getTestSuitesByProject(String projectId);
    ApiResponse<TestSuite> updateTestSuite(String id, TestSuite testSuite);
    ApiResponse<Boolean> deleteTestSuite(String id);
    ApiResponse<TestSuite> cloneTestSuite(String id, String newName);
    ApiResponse<Boolean> addTestCaseToTestSuite(String testSuiteId, String testCaseId);
    ApiResponse<Boolean> removeTestCaseFromTestSuite(String testSuiteId, String testCaseId);
}

// com.cstestforge.service.testcase.TestCaseService.java
package com.cstestforge.service.testcase;

import com.cstestforge.model.testcase.TestCase;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface TestCaseService {
    ApiResponse<TestCase> createTestCase(String projectId, TestCase testCase);
    ApiResponse<TestCase> getTestCase(String id);
    ApiResponse<List<TestCase>> getTestCasesByProject(String projectId);
    ApiResponse<TestCase> updateTestCase(String id, TestCase testCase);
    ApiResponse<Boolean> deleteTestCase(String id);
    ApiResponse<TestCase> cloneTestCase(String id, String newName);
    
    ApiResponse<TestStep> addTestStep(String testCaseId, TestStep testStep);
    ApiResponse<TestStep> updateTestStep(String testCaseId, String stepId, TestStep testStep);
    ApiResponse<Boolean> deleteTestStep(String testCaseId, String stepId);
    ApiResponse<Boolean> reorderTestSteps(String testCaseId, List<String> stepIds);
}

// com.cstestforge.service.reporting.ReportingService.java
package com.cstestforge.service.reporting;

import com.cstestforge.model.reporting.Report;
import com.cstestforge.model.reporting.ReportConfig;
import com.cstestforge.model.common.ApiResponse;
import java.util.List;

public interface ReportingService {
    ApiResponse<Report> generateReport(String projectId, ReportConfig config);
    ApiResponse<Report> getReport(String id);
    ApiResponse<List<Report>> getReportsByProject(String projectId);
    ApiResponse<Boolean> deleteReport(String id);
    ApiResponse<String> exportReport(String id, String format);
    ApiResponse<List<String>> getAvailableReportTemplates();
}

// com.cstestforge.service.selfhealing.SelfHealingService.java
package com.cstestforge.service.selfhealing;

import com.cstestforge.model.selfhealing.HealingAttempt;
import com.cstestforge.model.selfhealing.HealingRule;
import com.cstestforge.model.common.ApiResponse;
import com.microsoft.playwright.Page;
import java.util.List;

public interface SelfHealingService {
    ApiResponse<String> healSelector(Page page, String brokenSelector, String context);
    ApiResponse<List<String>> generateAlternativeSelectors(String selector, String html);
    ApiResponse<Boolean> testSelector(Page page, String selector);
    
    ApiResponse<HealingRule> createHealingRule(String projectId, HealingRule rule);
    ApiResponse<HealingRule> getHealingRule(String id);
    ApiResponse<List<HealingRule>> getHealingRulesByProject(String projectId);
    ApiResponse<HealingRule> updateHealingRule(String id, HealingRule rule);
    ApiResponse<Boolean> deleteHealingRule(String id);
    
    ApiResponse<List<HealingAttempt>> getHealingHistory(String projectId);
    ApiResponse<Boolean> approveHealing(String healingAttemptId);
    ApiResponse<Boolean> rejectHealing(String healingAttemptId);
}
```

## 3. Repository Interfaces

```java
// com.cstestforge.repository.ProjectRepository.java
package com.cstestforge.repository;

import com.cstestforge.model.project.Project;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ProjectRepository extends CrudRepository<Project, String> {
    List<Project> findAll();
}

// com.cstestforge.repository.TestCaseRepository.java
package com.cstestforge.repository;

import com.cstestforge.model.testcase.TestCase;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface TestCaseRepository extends CrudRepository<TestCase, String> {
    List<TestCase> findByProjectId(String projectId);
}

// com.cstestforge.repository.TestSuiteRepository.java
package com.cstestforge.repository;

import com.cstestforge.model.testsuite.TestSuite;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface TestSuiteRepository extends CrudRepository<TestSuite, String> {
    List<TestSuite> findByProjectId(String projectId);
}

// com.cstestforge.repository.ExecutionRepository.java
package com.cstestforge.repository;

import com.cstestforge.model.execution.ExecutionSummary;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ExecutionRepository extends CrudRepository<ExecutionSummary, String> {
    List<ExecutionSummary> findByProjectId(String projectId);
}
```

## 4. Utility Classes

```java
// com.cstestforge.util.FileUtils.java
package com.cstestforge.util;

import org.springframework.stereotype.Component;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Base64;

@Component
public class FileUtils {
    
    public static String readFile(String path) throws IOException {
        return Files.readString(Paths.get(path));
    }
    
    public static void writeFile(String path, String content) throws IOException {
        Files.writeString(Paths.get(path), content);
    }
    
    public static void copyFile(String source, String target) throws IOException {
        Files.copy(Paths.get(source), Paths.get(target), StandardCopyOption.REPLACE_EXISTING);
    }
    
    public static boolean deleteFile(String path) {
        return new File(path).delete();
    }
    
    public static boolean createDirectory(String path) {
        return new File(path).mkdirs();
    }
    
    public static String encodeFileToBase64(String filePath) throws IOException {
        byte[] fileContent = Files.readAllBytes(Paths.get(filePath));
        return Base64.getEncoder().encodeToString(fileContent);
    }
    
    public static void decodeBase64ToFile(String base64Content, String filePath) throws IOException {
        byte[] decodedBytes = Base64.getDecoder().decode(base64Content);
        Files.write(Paths.get(filePath), decodedBytes);
    }
    
    public static boolean exists(String path) {
        return Files.exists(Paths.get(path));
    }
    
    public static long getFileSize(String path) throws IOException {
        return Files.size(Paths.get(path));
    }
    
    public static String getFileExtension(String filename) {
        int lastDotIndex = filename.lastIndexOf(".");
        if (lastDotIndex == -1) {
            return "";
        }
        return filename.substring(lastDotIndex + 1);
    }
}

// com.cstestforge.util.DateTimeUtils.java
package com.cstestforge.util;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Date;

public class DateTimeUtils {
    
    private static final DateTimeFormatter DEFAULT_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    public static String formatDateTime(LocalDateTime dateTime) {
        return dateTime.format(DEFAULT_FORMATTER);
    }
    
    public static String formatDateTime(LocalDateTime dateTime, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return dateTime.format(formatter);
    }
    
    public static LocalDateTime parseDateTime(String dateTimeString) {
        return LocalDateTime.parse(dateTimeString, DEFAULT_FORMATTER);
    }
    
    public static LocalDateTime parseDateTime(String dateTimeString, String pattern) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return LocalDateTime.parse(dateTimeString, formatter);
    }
    
    public static LocalDateTime toLocalDateTime(Date date) {
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }
    
    public static Date toDate(LocalDateTime localDateTime) {
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    public static String getTimestamp() {
        return formatDateTime(LocalDateTime.now(), "yyyyMMdd_HHmmss");
    }
    
    public static long getDurationInMillis(LocalDateTime start, LocalDateTime end) {
        return java.time.Duration.between(start, end).toMillis();
    }
}
```

## 5. Exception Classes

```java
// com.cstestforge.exception.BrowserException.java
package com.cstestforge.exception;

public class BrowserException extends Exception {
    
    private String browserName;
    private String action;
    
    public BrowserException(String message) {
        super(message);
    }
    
    public BrowserException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BrowserException(String message, String browserName, String action) {
        super(message);
        this.browserName = browserName;
        this.action = action;
    }
    
    public BrowserException(String message, Throwable cause, String browserName, String action) {
        super(message, cause);
        this.browserName = browserName;
        this.action = action;
    }
    
    public String getBrowserName() {
        return browserName;
    }
    
    public String getAction() {
        return action;
    }
}
```

## 6. Frontend TypeScript Configuration

Create a `tsconfig.json` file in your frontend directory:

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

## 7. React Context Implementations

Now let's implement the missing context files for the frontend:

### 7.1 API Context

```typescript
// src/contexts/ApiContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useAuth } from './AuthContext';

interface ApiContextType {
  api: {
    get: <T>(url: string) => Promise<T>;
    post: <T>(url: string, data?: any) => Promise<T>;
    put: <T>(url: string, data?: any) => Promise<T>;
    delete: <T>(url: string) => Promise<T>;
  };
  loading: boolean;
  error: string | null;
}

const defaultValue: ApiContextType = {
  api: {
    get: async <T,>(url: string): Promise<T> => {
      throw new Error('API context not initialized');
    },
    post: async <T,>(url: string, data?: any): Promise<T> => {
      throw new Error('API context not initialized');
    },
    put: async <T,>(url: string, data?: any): Promise<T> => {
      throw new Error('API context not initialized');
    },
    delete: async <T,>(url: string): Promise<T> => {
      throw new Error('API context not initialized');
    },
  },
  loading: false,
  error: null,
};

const ApiContext = createContext<ApiContextType>(defaultValue);

export const useApi = () => useContext(ApiContext);
export const useApiContext = useContext(ApiContext);

interface ApiProviderProps {
  children: ReactNode;
  baseUrl?: string;
}

export const ApiProvider: React.FC<ApiProviderProps> = ({ 
  children, 
  baseUrl = '/api'
}) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const { token, logout } = useAuth();

  const handleResponse = async (response: Response) => {
    if (response.status === 401) {
      // Unauthorized, token expired or invalid
      if (logout) {
        logout();
      }
      throw new Error('Unauthorized');
    }

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      const errorMessage = errorData?.message || response.statusText || 'An error occurred';
      throw new Error(errorMessage);
    }

    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }

    return response.text();
  };

  const api = {
    get: async <T,>(url: string): Promise<T> => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`${baseUrl}${url}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
        });
        const data = await handleResponse(response);
        setLoading(false);
        return data;
      } catch (err) {
        setLoading(false);
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
        throw err;
      }
    },

    post: async <T,>(url: string, data?: any): Promise<T> => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`${baseUrl}${url}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
          body: data ? JSON.stringify(data) : undefined,
        });
        const responseData = await handleResponse(response);
        setLoading(false);
        return responseData;
      } catch (err) {
        setLoading(false);
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
        throw err;
      }
    },

    put: async <T,>(url: string, data?: any): Promise<T> => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`${baseUrl}${url}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
          body: data ? JSON.stringify(data) : undefined,
        });
        const responseData = await handleResponse(response);
        setLoading(false);
        return responseData;
      } catch (err) {
        setLoading(false);
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
        throw err;
      }
    },

    delete: async <T,>(url: string): Promise<T> => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`${baseUrl}${url}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
          },
        });
        const data = await handleResponse(response);
        setLoading(false);
        return data;
      } catch (err) {
        setLoading(false);
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
        throw err;
      }
    },
  };

  return (
    <ApiContext.Provider value={{ api, loading, error }}>
      {children}
    </ApiContext.Provider>
  );
};
```

### 7.2 Project Context

```typescript
// src/contexts/ProjectContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useApi } from './ApiContext';

interface Project {
  id: string;
  name: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

interface ProjectContextType {
  projects: Project[];
  currentProject: Project | null;
  loadProjects: () => Promise<void>;
  setCurrentProject: (project: Project | null) => void;
  createProject: (project: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Project>;
  updateProject: (id: string, project: Partial<Project>) => Promise<Project>;
  deleteProject: (id: string) => Promise<boolean>;
  loading: boolean;
  error: string | null;
}

const ProjectContext = createContext<ProjectContextType | null>(null);

export const useProject = () => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};

export const useProjectContext = useContext(ProjectContext);

interface ProjectProviderProps {
  children: ReactNode;
}

export const ProjectProvider: React.FC<ProjectProviderProps> = ({ children }) => {
  const { api } = useApi();
  const [projects, setProjects] = useState<Project[]>([]);
  const [currentProject, setCurrentProject] = useState<Project | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const loadProjects = async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.get<{ success: boolean; data: Project[] }>('/projects');
      if (response.success) {
        setProjects(response.data);
        // If we have projects but no current project, set the first one as current
        if (response.data.length > 0 && !currentProject) {
          setCurrentProject(response.data[0]);
        }
      } else {
        setError('Failed to load projects');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const createProject = async (project: Omit<Project, 'id' | 'createdAt' | 'updatedAt'>): Promise<Project> => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.post<{ success: boolean; data: Project }>('/projects', project);
      if (response.success) {
        setProjects([...projects, response.data]);
        return response.data;
      } else {
        throw new Error('Failed to create project');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const updateProject = async (id: string, project: Partial<Project>): Promise<Project> => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.put<{ success: boolean; data: Project }>(`/projects/${id}`, project);
      if (response.success) {
        const updatedProjects = projects.map((p) => (p.id === id ? response.data : p));
        setProjects(updatedProjects);
        if (currentProject && currentProject.id === id) {
          setCurrentProject(response.data);
        }
        return response.data;
      } else {
        throw new Error('Failed to update project');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const deleteProject = async (id: string): Promise<boolean> => {
    setLoading(true);
    setError(null);
    try {
      const response = await api.delete<{ success: boolean }>(`/projects/${id}`);
      if (response.success) {
        const updatedProjects = projects.filter((p) => p.id !== id);
        setProjects(updatedProjects);
        if (currentProject && currentProject.id === id) {
          setCurrentProject(updatedProjects.length > 0 ? updatedProjects[0] : null);
        }
        return true;
      } else {
        throw new Error('Failed to delete project');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadProjects();
  }, []);

  return (
    <ProjectContext.Provider
      value={{
        projects,
        currentProject,
        loadProjects,
        setCurrentProject,
        createProject,
        updateProject,
        deleteProject,
        loading,
        error,
      }}
    >
      {children}
    </ProjectContext.Provider>
  );
};
```

### 7.3 Auth Context

```typescript
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';

interface User {
  id: string;
  username: string;
  email: string;
}

interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  loading: boolean;
  error: string | null;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(localStorage.getItem('token'));
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const checkAuth = async () => {
      const storedToken = localStorage.getItem('token');
      if (storedToken) {
        setLoading(true);
        try {
          const response = await fetch('/api/auth/user', {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${storedToken}`,
            },
          });

          if (response.ok) {
            const userData = await response.json();
            setUser(userData);
            setToken(storedToken);
          } else {
            // Token is invalid or expired
            localStorage.removeItem('token');
            setToken(null);
            setUser(null);
          }
        } catch (err) {
          localStorage.removeItem('token');
          setToken(null);
          setUser(null);
          const errorMessage = err instanceof Error ? err.message : 'Authentication error';
          setError(errorMessage);
        } finally {
          setLoading(false);
        }
      }
    };

    checkAuth();
  }, []);

  const login = async (username: string, password: string) => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const data = await response.json();
        localStorage.setItem('token', data.token);
        setToken(data.token);
        setUser(data.user);
      } else {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Login failed');
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown login error';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
    setUser(null);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        token,
        isAuthenticated: !!token,
        login,
        logout,
        loading,
        error,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};
```

## 8. Fix Component Issues

### 8.1 Fix RequestBuilder.tsx

```typescript
// src/components/api/RequestBuilder.tsx
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Button, 
  FormControl, 
  InputLabel, 
  MenuItem, 
  Select,
  SelectChangeEvent, 
  TextField, 
  Typography, 
  Paper, 
  Grid,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

interface RequestBuilderProps {
  initialValues?: {
    url: string;
    method: string;
    headers: { key: string; value: string }[];
    params: { key: string; value: string }[];
    body: string;
  };
  onExecute: (request: any) => void;
}

const RequestBuilder: React.FC<RequestBuilderProps> = ({ initialValues, onExecute }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();

  const [url, setUrl] = useState(initialValues?.url || '');
  const [method, setMethod] = useState(initialValues?.method || 'GET');
  const [headers, setHeaders] = useState<{ key: string; value: string }[]>(
    initialValues?.headers || [{ key: '', value: '' }]
  );
  const [params, setParams] = useState<{ key: string; value: string }[]>(
    initialValues?.params || [{ key: '', value: '' }]
  );
  const [body, setBody] = useState(initialValues?.body || '');

  const handleMethodChange = (event: SelectChangeEvent) => {
    setMethod(event.target.value);
  };

  const handleAddHeader = () => {
    setHeaders([...headers, { key: '', value: '' }]);
  };

  const handleRemoveHeader = (index: number) => {
    const newHeaders = [...headers];
    newHeaders.splice(index, 1);
    setHeaders(newHeaders);
  };

  const handleHeaderChange = (index: number, field: 'key' | 'value', value: string) => {
    const newHeaders = [...headers];
    newHeaders[index][field] = value;
    setHeaders(newHeaders);
  };

  const handleAddParam = () => {
    setParams([...params, { key: '', value: '' }]);
  };

  const handleRemoveParam = (index: number) => {
    const newParams = [...params];
    newParams.splice(index, 1);
    setParams(newParams);
  };

  const handleParamChange = (index: number, field: 'key' | 'value', value: string) => {
    const newParams = [...params];
    newParams[index][field] = value;
    setParams(newParams);
  };

  const buildRequest = () => {
    // Convert headers array to object
    const headersObj: { [key: string]: string } = {};
    headers.forEach((h) => {
      if (h.key.trim()) {
        headersObj[h.key] = h.value;
      }
    });

    // Convert params array to object
    const paramsObj: { [key: string]: string } = {};
    params.forEach((p) => {
      if (p.key.trim()) {
        paramsObj[p.key] = p.value;
      }
    });

    // Build URL with query parameters
    let fullUrl = url;
    if (Object.keys(paramsObj).length > 0) {
      const queryString = new URLSearchParams(paramsObj).toString();
      fullUrl += (url.includes('?') ? '&' : '?') + queryString;
    }

    return {
      url: fullUrl,
      method,
      headers: headersObj,
      body: ['POST', 'PUT', 'PATCH'].includes(method) ? body : undefined,
    };
  };

  const handleExecute = () => {
    try {
      if (!url) {
        throw new Error('URL is required');
      }

      const request = buildRequest();
      onExecute(request);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Error preparing request';
      enqueueSnackbar(errorMessage, { variant: 'error' });
    }
  };

  return (
    <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        Request Builder
      </Typography>

      <Grid container spacing={3}>
        <Grid item xs={9}>
          <TextField
            fullWidth
            label="URL"
            value={url}
            onChange={(e) => setUrl(e.target.value)}
            margin="normal"
            placeholder="https://api.example.com/endpoint"
            required
          />
        </Grid>
        <Grid item xs={3}>
          <FormControl fullWidth margin="normal">
            <InputLabel>Method</InputLabel>
            <Select value={method} label="Method" onChange={handleMethodChange}>
              <MenuItem value="GET">GET</MenuItem>
              <MenuItem value="POST">POST</MenuItem>
              <MenuItem value="PUT">PUT</MenuItem>
              <MenuItem value="DELETE">DELETE</MenuItem>
              <MenuItem value="PATCH">PATCH</MenuItem>
              <MenuItem value="HEAD">HEAD</MenuItem>
              <MenuItem value="OPTIONS">OPTIONS</MenuItem>
            </Select>
          </FormControl>
        </Grid>
      </Grid>

      <Box sx={{ mt: 3 }}>
        <Typography variant="subtitle1" gutterBottom>
          Headers
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Key</TableCell>
                <TableCell>Value</TableCell>
                <TableCell width="50px"></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {headers.map((header, index) => (
                <TableRow key={index}>
                  <TableCell>
                    <TextField
                      fullWidth
                      size="small"
                      value={header.key}
                      onChange={(e) => handleHeaderChange(index, 'key', e.target.value)}
                      placeholder="Content-Type"
                    />
                  </TableCell>
                  <TableCell>
                    <TextField
                      fullWidth
                      size="small"
                      value={header.value}
                      onChange={(e) => handleHeaderChange(index, 'value', e.target.value)}
                      placeholder="application/json"
                    />
                  </TableCell>
                  <TableCell>
                    <IconButton size="small" color="error" onClick={() => handleRemoveHeader(index)}>
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        <Button startIcon={<AddIcon />} onClick={handleAddHeader} sx={{ mt: 1 }}>
          Add Header
        </Button>
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography variant="subtitle1" gutterBottom>
          Query Parameters
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Key</TableCell>
                <TableCell>Value</TableCell>
                <TableCell width="50px"></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {params.map((param, index) => (
                <TableRow key={index}>
                  <TableCell>
                    <TextField
                      fullWidth
                      size="small"
                      value={param.key}
                      onChange={(e) => handleParamChange(index, 'key', e.target.value)}
                      placeholder="page"
                    />
                  </TableCell>
                  <TableCell>
                    <TextField
                      fullWidth
                      size="small"
                      value={param.value}
                      onChange={(e) => handleParamChange(index, 'value', e.target.value)}
                      placeholder="1"
                    />
                  </TableCell>
                  <TableCell>
                    <IconButton size="small" color="error" onClick={() => handleRemoveParam(index)}>
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        <Button startIcon={<AddIcon />} onClick={handleAddParam} sx={{ mt: 1 }}>
          Add Parameter
        </Button>
      </Box>

      {['POST', 'PUT', 'PATCH'].includes(method) && (
        <Box sx={{ mt: 3 }}>
          <Typography variant="subtitle1" gutterBottom>
            Request Body
          </Typography>
          <TextField
            fullWidth
            multiline
            rows={5}
            value={body}
            onChange={(e) => setBody(e.target.value)}
            placeholder='{"key": "value"}'
          />
        </Box>
      )}

      <Box sx={{ mt: 3, display: 'flex', justifyContent: 'flex-end' }}>
        <Button variant="contained" color="primary" onClick={handleExecute}>
          Execute
        </Button>
      </Box>
    </Paper>
  );
};

export default RequestBuilder;
```

### 8.2 Fix ResponseViewer.tsx

```typescript
// src/components/api/ResponseViewer.tsx
import React, { useState } from 'react';
import {
  Box,
  Paper,
  Typography,
  Tab,
  Tabs,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  CircularProgress,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import JSONPretty from 'react-json-pretty';
import 'react-json-pretty/themes/monikai.css';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`response-tabpanel-${index}`}
      aria-labelledby={`response-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
}

interface ResponseViewerProps {
  response?: {
    status: number;
    statusText: string;
    headers: { [key: string]: string };
    body: any;
    time: number;
  };
  loading?: boolean;
  error?: string;
}

const ResponseViewer: React.FC<ResponseViewerProps> = ({ response, loading, error }) => {
  const [activeTab, setActiveTab] = useState(0);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };

  const formatBody = (body: any) => {
    if (!body) return null;

    try {
      // If it's already an object, use it directly
      if (typeof body === 'object') {
        return <JSONPretty id="json-pretty" data={body} />;
      }

      // Try to parse as JSON
      const parsed = JSON.parse(body);
      return <JSONPretty id="json-pretty" data={parsed} />;
    } catch (e) {
      // If not JSON, return as is
      return (
        <Box component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
          {body}
        </Box>
      );
    }
  };

  if (loading) {
    return (
      <Paper elevation={3} sx={{ p: 3, mt: 3, display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 200 }}>
        <CircularProgress />
      </Paper>
    );
  }

  if (error) {
    return (
      <Paper elevation={3} sx={{ p: 3, mt: 3 }}>
        <Box display="flex" alignItems="center" sx={{ mb: 2 }}>
          <ErrorIcon color="error" sx={{ mr: 1 }} />
          <Typography variant="h6" color="error">
            Error
          </Typography>
        </Box>
        <Typography color="error">{error}</Typography>
      </Paper>
    );
  }

  if (!response) {
    return (
      <Paper elevation={3} sx={{ p: 3, mt: 3 }}>
        <Typography variant="body1" color="textSecondary">
          No response data available. Execute a request to see results.
        </Typography>
      </Paper>
    );
  }

  const isSuccess = response.status >= 200 && response.status < 300;

  return (
    <Paper elevation={3} sx={{ p: 3, mt: 3 }}>
      <Box display="flex" alignItems="center" sx={{ mb: 2 }}>
        {isSuccess ? (
          <CheckCircleIcon color="success" sx={{ mr: 1 }} />
        ) : (
          <ErrorIcon color="error" sx={{ mr: 1 }} />
        )}
        <Typography variant="h6">
          Response
        </Typography>
        <Chip
          label={`${response.status} ${response.statusText}`}
          color={isSuccess ? 'success' : 'error'}
          size="small"
          sx={{ ml: 2 }}
        />
        <Chip
          label={`${response.time} ms`}
          color="default"
          size="small"
          sx={{ ml: 1 }}
        />
      </Box>

      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs value={activeTab} onChange={handleTabChange} aria-label="response tabs">
          <Tab label="Body" id="response-tab-0" aria-controls="response-tabpanel-0" />
          <Tab label="Headers" id="response-tab-1" aria-controls="response-tabpanel-1" />
        </Tabs>
      </Box>

      <TabPanel value={activeTab} index={0}>
        {formatBody(response.body)}
      </TabPanel>

      <TabPanel value={activeTab} index={1}>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell width="40%">
                  <Typography variant="subtitle2">Header</Typography>
                </TableCell>
                <TableCell>
                  <Typography variant="subtitle2">Value</Typography>
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {Object.entries(response.headers).map(([header, value]) => (
                <TableRow key={header}>
                  <TableCell>{header}</TableCell>
                  <TableCell>{value}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </TabPanel>
    </Paper>
  );
};

export default ResponseViewer;
```

### 8.3 Fix FeatureEditor.tsx

```typescript
// src/components/bdd/FeatureEditor.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  Paper,
  Typography,
  Divider,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import { useApi } from '../../contexts/ApiContext';
import { useProject } from '../../contexts/ProjectContext';

interface Feature {
  id: string;
  name: string;
  description: string;
  scenarios: Scenario[];
}

interface Scenario {
  id: string;
  name: string;
  steps: Step[];
}

interface Step {
  id: string;
  type: 'Given' | 'When' | 'Then' | 'And' | 'But';
  text: string;
}

const FeatureEditor: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProject();
  
  const [feature, setFeature] = useState<Feature | null>(null);
  const [features, setFeatures] = useState<Feature[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedFeatureId, setSelectedFeatureId] = useState<string>('');
  
  const [openDialog, setOpenDialog] = useState(false);
  const [dialogType, setDialogType] = useState<'feature' | 'scenario' | 'step'>('feature');
  const [dialogTitle, setDialogTitle] = useState('');
  const [dialogAction, setDialogAction] = useState<'add' | 'edit'>('add');
  
  const [featureForm, setFeatureForm] = useState({ name: '', description: '' });
  const [scenarioForm, setScenarioForm] = useState({ name: '' });
  const [stepForm, setStepForm] = useState({ type: 'Given' as Step['type'], text: '' });
  
  const [editingItem, setEditingItem] = useState<{ id: string; scenarioId?: string }>({ id: '' });

  useEffect(() => {
    if (currentProject) {
      loadFeatures();
    }
  }, [currentProject]);

  const loadFeatures = async () => {
    if (!currentProject) return;
    
    setLoading(true);
    try {
      const response = await api.get<{ success: boolean; data: Feature[] }>(`/bdd/features?projectId=${currentProject.id}`);
      if (response.success) {
        setFeatures(response.data);
        if (response.data.length > 0) {
          setSelectedFeatureId(response.data[0].id);
          loadFeature(response.data[0].id);
        }
      }
    } catch (error) {
      console.error('Error loading features:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadFeature = async (featureId: string) => {
    setLoading(true);
    try {
      const response = await api.get<{ success: boolean; data: Feature }>(`/bdd/features/${featureId}`);
      if (response.success) {
        setFeature(response.data);
      }
    } catch (error) {
      console.error('Error loading feature:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleFeatureChange = (event: SelectChangeEvent) => {
    const featureId = event.target.value;
    setSelectedFeatureId(featureId);
    loadFeature(featureId);
  };

  const openAddFeatureDialog = () => {
    setDialogType('feature');
    setDialogTitle('Add Feature');
    setDialogAction('add');
    setFeatureForm({ name: '', description: '' });
    setOpenDialog(true);
  };

  const openEditFeatureDialog = () => {
    if (!feature) return;
    
    setDialogType('feature');
    setDialogTitle('Edit Feature');
    setDialogAction('edit');
    setFeatureForm({ name: feature.name, description: feature.description });
    setEditingItem({ id: feature.id });
    setOpenDialog(true);
  };

  const openAddScenarioDialog = () => {
    setDialogType('scenario');
    setDialogTitle('Add Scenario');
    setDialogAction('add');
    setScenarioForm({ name: '' });
    setOpenDialog(true);
  };

  const openEditScenarioDialog = (scenario: Scenario) => {
    setDialogType('scenario');
    setDialogTitle('Edit Scenario');
    setDialogAction('edit');
    setScenarioForm({ name: scenario.name });
    setEditingItem({ id: scenario.id });
    setOpenDialog(true);
  };

  const openAddStepDialog = (scenarioId: string) => {
    setDialogType('step');
    setDialogTitle('Add Step');
    setDialogAction('add');
    setStepForm({ type: 'Given', text: '' });
    setEditingItem({ id: '', scenarioId });
    setOpenDialog(true);
  };

  const openEditStepDialog = (step: Step, scenarioId: string) => {
    setDialogType('step');
    setDialogTitle('Edit Step');
    setDialogAction('edit');
    setStepForm({ type: step.type, text: step.text });
    setEditingItem({ id: step.id, scenarioId });
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
  };

  const handleSaveFeature = async () => {
    if (!currentProject || !featureForm.name) return;
    
    try {
      if (dialogAction === 'add') {
        const response = await api.post<{ success: boolean; data: Feature }>('/bdd/features', {
          projectId: currentProject.id,
          name: featureForm.name,
          description: featureForm.description,
        });
        
        if (response.success) {
          setFeatures([...features, response.data]);
          setSelectedFeatureId(response.data.id);
          setFeature(response.data);
        }
      } else {
        const response = await api.put<{ success: boolean; data: Feature }>(`/bdd/features/${editingItem.id}`, {
          name: featureForm.name,
          description: featureForm.description,
        });
        
        if (response.success) {
          setFeatures(features.map(f => f.id === editingItem.id ? response.data : f));
          setFeature(response.data);
        }
      }
    } catch (error) {
      console.error('Error saving feature:', error);
    } finally {
      setOpenDialog(false);
    }
  };

  const handleSaveScenario = async () => {
    if (!feature || !scenarioForm.name) return;
    
    try {
      if (dialogAction === 'add') {
        const response = await api.post<{ success: boolean; data: Scenario }>('/bdd/scenarios', {
          featureId: feature.id,
          name: scenarioForm.name,
        });
        
        if (response.success) {
          const updatedFeature = {
            ...feature,
            scenarios: [...feature.scenarios, response.data],
          };
          setFeature(updatedFeature);
        }
      } else {
        const response = await api.put<{ success: boolean; data: Scenario }>(`/bdd/scenarios/${editingItem.id}`, {
          name: scenarioForm.name,
        });
        
        if (response.success) {
          const updatedFeature = {
            ...feature,
            scenarios: feature.scenarios.map(s => s.id === editingItem.id ? response.data : s),
          };
          setFeature(updatedFeature);
        }
      }
    } catch (error) {
      console.error('Error saving scenario:', error);
    } finally {
      setOpenDialog(false);
    }
  };

  const handleSaveStep = async () => {
    if (!feature || !editingItem.scenarioId || !stepForm.text) return;
    
    try {
      if (dialogAction === 'add') {
        const response = await api.post<{ success: boolean; data: Step }>('/bdd/steps', {
          scenarioId: editingItem.scenarioId,
          type: stepForm.type,
          text: stepForm.text,
        });
        
        if (response.success) {
          const updatedFeature = {
            ...feature,
            scenarios: feature.scenarios.map(s => {
              if (s.id === editingItem.scenarioId) {
                return {
                  ...s,
                  steps: [...s.steps, response.data],
                };
              }
              return s;
            }),
          };
          setFeature(updatedFeature);
        }
      } else {
        const response = await api.put<{ success: boolean; data: Step }>(`/bdd/steps/${editingItem.id}`, {
          type: stepForm.type,
          text: stepForm.text,
        });
        
        if (response.success) {
          const updatedFeature = {
            ...feature,
            scenarios: feature.scenarios.map(s => {
              if (s.id === editingItem.scenarioId) {
                return {
                  ...s,
                  steps: s.steps.map(step => step.id === editingItem.id ? response.data : step),
                };
              }
              return s;
            }),
          };
          setFeature(updatedFeature);
        }
      }
    } catch (error) {
      console.error('Error saving step:', error);
    } finally {
      setOpenDialog(false);
    }
  };

  const handleDeleteScenario = async (scenarioId: string) => {
    if (!feature) return;
    
    try {
      const response = await api.delete<{ success: boolean }>(`/bdd/scenarios/${scenarioId}`);
      if (response.success) {
        const updatedFeature = {
          ...feature,
          scenarios: feature.scenarios.filter(s => s.id !== scenarioId),
        };
        setFeature(updatedFeature);
      }
    } catch (error) {
      console.error('Error deleting scenario:', error);
    }
  };

  const handleDeleteStep = async (stepId: string, scenarioId: string) => {
    if (!feature) return;
    
    try {
      const response = await api.delete<{ success: boolean }>(`/bdd/steps/${stepId}`);
      if (response.success) {
        const updatedFeature = {
          ...feature,
          scenarios: feature.scenarios.map(s => {
            if (s.id === scenarioId) {
              return {
                ...s,
                steps: s.steps.filter(step => step.id !== stepId),
              };
            }
            return s;
          }),
        };
        setFeature(updatedFeature);
      }
    } catch (error) {
      console.error('Error deleting step:', error);
    }
  };

  const handleGenerateTestCase = async (scenarioId: string) => {
    try {
      const response = await api.post<{ success: boolean; data: string }>(`/bdd/generate-test/${scenarioId}`);
      if (response.success) {
        // Handle test case generation success
        // You might want to navigate to the generated test case or show a notification
      }
    } catch (error) {
      console.error('Error generating test case:', error);
    }
  };

  const renderDialog = () => {
    switch (dialogType) {
      case 'feature':
        return (
          <>
            <DialogContent>
              <TextField
                autoFocus
                margin="dense"
                label="Feature Name"
                fullWidth
                value={featureForm.name}
                onChange={(e) => setFeatureForm({ ...featureForm, name: e.target.value })}
                required
              />
              <TextField
                margin="dense"
                label="Description"
                fullWidth
                multiline
                rows={4}
                value={featureForm.description}
                onChange={(e) => setFeatureForm({ ...featureForm, description: e.target.value })}
                helperText="Describe the purpose of this feature"
              />
            </DialogContent>
            <DialogActions>
              <Button onClick={handleCloseDialog}>Cancel</Button>
              <Button onClick={handleSaveFeature} color="primary">Save</Button>
            </DialogActions>
          </>
        );
      
      case 'scenario':
        return (
          <>
            <DialogContent>
              <TextField
                autoFocus
                margin="dense"
                label="Scenario Name"
                fullWidth
                value={scenarioForm.name}
                onChange={(e) => setScenarioForm({ ...scenarioForm, name: e.target.value })}
                required
              />
            </DialogContent>
            <DialogActions>
              <Button onClick={handleCloseDialog}>Cancel</Button>
              <Button onClick={handleSaveScenario} color="primary">Save</Button>
            </DialogActions>
          </>
        );
      
      case 'step':
        return (
          <>
            <DialogContent>
              <FormControl fullWidth margin="dense">
                <InputLabel>Step Type</InputLabel>
                <Select
                  value={stepForm.type}
                  label="Step Type"
                  onChange={(e) => setStepForm({ ...stepForm, type: e.target.value as Step['type'] })}
                >
                  <MenuItem value="Given">Given</MenuItem>
                  <MenuItem value="When">When</MenuItem>
                  <MenuItem value="Then">Then</MenuItem>
                  <MenuItem value="And">And</MenuItem>
                  <MenuItem value="But">But</MenuItem>
                </Select>
              </FormControl>
              <TextField
                autoFocus
                margin="dense"
                label="Step Text"
                fullWidth
                value={stepForm.text}
                onChange={(e) => setStepForm({ ...stepForm, text: e.target.value })}
                required
                placeholder="I am on the homepage"
              />
            </DialogContent>
            <DialogActions>
              <Button onClick={handleCloseDialog}>Cancel</Button>
              <Button onClick={handleSaveStep} color="primary">Save</Button>
            </DialogActions>
          </>
        );
    }
  };

  return (
    <Box>
      <Paper elevation={2} sx={{ p: 2, mb: 3 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h5">BDD Feature Editor</Typography>
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={openAddFeatureDialog}
          >
            New Feature
          </Button>
        </Box>

        {features.length > 0 ? (
          <Box display="flex" alignItems="center">
            <FormControl sx={{ minWidth: 300, mr: 2 }}>
              <InputLabel>Select Feature</InputLabel>
              <Select
                value={selectedFeatureId}
                label="Select Feature"
                onChange={handleFeatureChange}
              >
                {features.map((feature) => (
                  <MenuItem key={feature.id} value={feature.id}>
                    {feature.name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
            {feature && (
              <Button
                variant="outlined"
                startIcon={<EditIcon />}
                onClick={openEditFeatureDialog}
              >
                Edit Feature
              </Button>
            )}
          </Box>
        ) : (
          <Typography color="textSecondary">
            No features available. Create your first feature to get started.
          </Typography>
        )}
      </Paper>

      {feature && (
        <Paper elevation={2} sx={{ p: 3 }}>
          <Box mb={3}>
            <Typography variant="h6">{feature.name}</Typography>
            <Typography variant="body2" color="textSecondary">
              {feature.description}
            </Typography>
          </Box>

          <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
            <Typography variant="subtitle1">Scenarios</Typography>
            <Button
              variant="outlined"
              startIcon={<AddIcon />}
              onClick={openAddScenarioDialog}
            >
              Add Scenario
            </Button>
          </Box>

          {feature.scenarios.length === 0 ? (
            <Typography color="textSecondary">
              No scenarios yet. Add your first scenario to build your feature.
            </Typography>
          ) : (
            feature.scenarios.map((scenario) => (
              <Paper key={scenario.id} elevation={1} sx={{ p: 2, mb: 2 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                  <Typography variant="subtitle1">
                    <strong>Scenario:</strong> {scenario.name}
                  </Typography>
                  <Box>
                    <IconButton
                      size="small"
                      color="primary"
                      onClick={() => openEditScenarioDialog(scenario)}
                    >
                      <EditIcon fontSize="small" />
                    </IconButton>
                    <IconButton
                      size="small"
                      color="error"
                      onClick={() => handleDeleteScenario(scenario.id)}
                    >
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                    <IconButton
                      size="small"
                      color="success"
                      onClick={() => handleGenerateTestCase(scenario.id)}
                      title="Generate Test Case"
                    >
                      <PlayArrowIcon fontSize="small" />
                    </IconButton>
                  </Box>
                </Box>

                <List dense>
                  {scenario.steps.map((step) => (
                    <ListItem
                      key={step.id}
                      secondaryAction={
                        <Box>
                          <IconButton
                            edge="end"
                            size="small"
                            onClick={() => openEditStepDialog(step, scenario.id)}
                          >
                            <EditIcon fontSize="small" />
                          </IconButton>
                          <IconButton
                            edge="end"
                            size="small"
                            color="error"
                            onClick={() => handleDeleteStep(step.id, scenario.id)}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </Box>
                      }
                    >
                      <ListItemText primary={`${step.type} ${step.text}`} />
                    </ListItem>
                  ))}
                </List>

                <Button
                  size="small"
                  startIcon={<AddIcon />}
                  onClick={() => openAddStepDialog(scenario.id)}
                  sx={{ mt: 1 }}
                >
                  Add Step
                </Button>
              </Paper>
            ))
          )}
        </Paper>
      )}

      <Dialog open={openDialog} onClose={handleCloseDialog}>
        <DialogTitle>{dialogTitle}</DialogTitle>
        {renderDialog()}
      </Dialog>
    </Box>
  );
};

export default FeatureEditor;
```

### 8.4 Fix GitIntegration.tsx

```typescript
// src/components/integration/GitIntegration.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  Paper,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Checkbox,
  Grid,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  IconButton,
  CircularProgress,
  Alert,
} from '@mui/material';
import FolderIcon from '@mui/icons-material/Folder';
import InsertDriveFileIcon from '@mui/icons-material/InsertDriveFile';
import SyncIcon from '@mui/icons-material/Sync';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { useApi } from '../../contexts/ApiContext';
import { useProject } from '../../contexts/ProjectContext';

interface GitConfig {
  id: string;
  projectId: string;
  repoUrl: string;
  branch: string;
  username: string;
  password: string;
  privateKey: string;
  useCredentials: boolean;
  useSSH: boolean;
  autoSync: boolean;
  syncInterval: number;
  lastSyncTime: string;
  status: 'CONNECTED' | 'DISCONNECTED' | 'ERROR';
}

interface GitFile {
  name: string;
  path: string;
  type: 'file' | 'directory';
  status: 'ADDED' | 'MODIFIED' | 'DELETED' | 'UNCHANGED';
}

const GitIntegration: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProject();
  
  const [loading, setLoading] = useState(false);
  const [syncLoading, setSyncLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  
  const [gitConfig, setGitConfig] = useState<GitConfig | null>(null);
  const [branches, setBranches] = useState<string[]>([]);
  const [files, setFiles] = useState<GitFile[]>([]);
  
  const [showPassword, setShowPassword] = useState(false);
  
  // Form state
  const [repoUrl, setRepoUrl] = useState('');
  const [branch, setBranch] = useState('main');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [privateKey, setPrivateKey] = useState('');
  const [useCredentials, setUseCredentials] = useState(true);
  const [useSSH, setUseSSH] = useState(false);
  const [autoSync, setAutoSync] = useState(false);
  const [syncInterval, setSyncInterval] = useState(60);

  useEffect(() => {
    if (currentProject) {
      loadGitConfig();
    }
  }, [currentProject]);

  const loadGitConfig = async () => {
    if (!currentProject) return;
    
    setLoading(true);
    try {
      const response = await api.get<{ success: boolean; data: GitConfig[] }>(`/integrations/git?projectId=${currentProject.id}`);
      if (response.success && response.data.length > 0) {
        const config = response.data[0];
        setGitConfig(config);
        setRepoUrl(config.repoUrl);
        setBranch(config.branch);
        setUsername(config.username);
        setPassword(config.password);
        setPrivateKey(config.privateKey);
        setUseCredentials(config.useCredentials);
        setUseSSH(config.useSSH);
        setAutoSync(config.autoSync);
        setSyncInterval(config.syncInterval);
        
        // Load branches and files
        loadBranches(config.id);
        loadFiles(config.id);
      }
    } catch (error) {
      console.error('Error loading Git config:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to load Git configuration';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const loadBranches = async (configId: string) => {
    try {
      const response = await api.get<{ success: boolean; data: string[] }>(`/integrations/git/${configId}/branches`);
      if (response.success) {
        setBranches(response.data);
      }
    } catch (error) {
      console.error('Error loading branches:', error);
    }
  };

  const loadFiles = async (configId: string) => {
    try {
      const response = await api.get<{ success: boolean; data: GitFile[] }>(`/integrations/git/${configId}/files`);
      if (response.success) {
        setFiles(response.data);
      }
    } catch (error) {
      console.error('Error loading files:', error);
    }
  };

  const handleSaveConfig = async () => {
    if (!currentProject) return;
    
    setLoading(true);
    setError(null);
    setSuccess(null);
    
    try {
      const configData = {
        projectId: currentProject.id,
        repoUrl,
        branch,
        username,
        password,
        privateKey,
        useCredentials,
        useSSH,
        autoSync,
        syncInterval,
      };
      
      let response;
      if (gitConfig) {
        response = await api.put<{ success: boolean; data: GitConfig }>(`/integrations/git/${gitConfig.id}`, configData);
      } else {
        response = await api.post<{ success: boolean; data: GitConfig }>('/integrations/git', configData);
      }
      
      if (response.success) {
        setGitConfig(response.data);
        setSuccess('Git configuration saved successfully');
        
        // Load branches and files
        loadBranches(response.data.id);
        loadFiles(response.data.id);
      }
    } catch (error) {
      console.error('Error saving Git config:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to save Git configuration';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const handleSync = async () => {
    if (!gitConfig) return;
    
    setSyncLoading(true);
    setError(null);
    setSuccess(null);
    
    try {
      const response = await api.post<{ success: boolean }>(`/integrations/git/${gitConfig.id}/sync`, { branch: gitConfig.branch });
      if (response.success) {
        setSuccess('Repository synchronized successfully');
        loadFiles(gitConfig.id);
      }
    } catch (error) {
      console.error('Error syncing repository:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to synchronize repository';
      setError(errorMessage);
    } finally {
      setSyncLoading(false);
    }
  };

  const handleBranchChange = async (newBranch: string) => {
    if (!gitConfig) return;
    
    setBranch(newBranch);
    setSyncLoading(true);
    setError(null);
    
    try {
      const response = await api.post<{ success: boolean }>(`/integrations/git/${gitConfig.id}/switch-branch`, { branch: newBranch });
      if (response.success) {
        // Update gitConfig with new branch
        setGitConfig({ ...gitConfig, branch: newBranch });
        loadFiles(gitConfig.id);
      }
    } catch (error) {
      console.error('Error switching branch:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to switch branch';
      setError(errorMessage);
    } finally {
      setSyncLoading(false);
    }
  };

  const renderFileList = () => {
    if (files.length === 0) {
      return (
        <Typography color="textSecondary" sx={{ mt: 2 }}>
          No files available. Sync repository to view files.
        </Typography>
      );
    }
    
    return (
      <List dense sx={{ mt: 2 }}>
        {files.map((file) => (
          <ListItem
            key={file.path}
            secondaryAction={
              file.status !== 'UNCHANGED' && (
                <Chip
                  label={file.status}
                  color={
                    file.status === 'ADDED'
                      ? 'success'
                      : file.status === 'MODIFIED'
                      ? 'warning'
                      : file.status === 'DELETED'
                      ? 'error'
                      : 'default'
                  }
                  size="small"
                />
              )
            }
          >
            <ListItemIcon>
              {file.type === 'directory' ? <FolderIcon /> : <InsertDriveFileIcon />}
            </ListItemIcon>
            <ListItemText primary={file.name} secondary={file.path} />
          </ListItem>
        ))}
      </List>
    );
  };

  return (
    <Box>
      <Paper elevation={2} sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" gutterBottom>
          Git Integration
        </Typography>
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        
        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            {success}
          </Alert>
        )}
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Repository URL"
              value={repoUrl}
              onChange={(e) => setRepoUrl(e.target.value)}
              placeholder="https://github.com/username/repository.git"
              required
            />
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <FormControlLabel
              control={
                <Checkbox
                  checked={useCredentials}
                  onChange={(e) => setUseCredentials(e.target.checked)}
                />
              }
              label="Use Credentials"
            />
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <FormControlLabel
              control={
                <Checkbox
                  checked={useSSH}
                  onChange={(e) => setUseSSH(e.target.checked)}
                />
              }
              label="Use SSH"
            />
          </Grid>
          
          {useCredentials && !useSSH && (
            <>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="Username"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  type={showPassword ? 'text' : 'password'}
                  label="Password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  InputProps={{
                    endAdornment: (
                      <Button
                        onClick={() => setShowPassword(!showPassword)}
                        sx={{ position: 'absolute', right: 8 }}
                      >
                        {showPassword ? 'Hide' : 'Show'}
                      </Button>
                    ),
                  }}
                />
              </Grid>
            </>
          )}
          
          {useSSH && (
            <Grid item xs={12}>
              <TextField
                fullWidth
                multiline
                rows={4}
                label="SSH Private Key"
                value={privateKey}
                onChange={(e) => setPrivateKey(e.target.value)}
              />
            </Grid>
          )}
          
          <Grid item xs={12} sm={6}>
            <FormControlLabel
              control={
                <Checkbox
                  checked={autoSync}
                  onChange={(e) => setAutoSync(e.target.checked)}
                />
              }
              label="Auto Sync"
            />
          </Grid>
          
          {autoSync && (
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="number"
                label="Sync Interval (minutes)"
                value={syncInterval}
                onChange={(e) => setSyncInterval(parseInt(e.target.value))}
                inputProps={{ min: 5, max: 1440 }}
              />
            </Grid>
          )}
          
          <Grid item xs={12}>
            <Box display="flex" justifyContent="flex-end">
              <Button
                variant="contained"
                color="primary"
                onClick={handleSaveConfig}
                disabled={loading}
              >
                {loading ? <CircularProgress size={24} /> : 'Save Configuration'}
              </Button>
            </Box>
          </Grid>
        </Grid>
      </Paper>
      
      {gitConfig && (
        <Paper elevation={2} sx={{ p: 3 }}>
          <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
            <Typography variant="h6">Repository Files</Typography>
            <Box>
              <FormControl sx={{ minWidth: 120, mr: 2 }}>
                <InputLabel>Branch</InputLabel>
                <Select
                  value={branch}
                  label="Branch"
                  onChange={(e) => handleBranchChange(e.target.value)}
                  size="small"
                >
                  {branches.map((branchName) => (
                    <MenuItem key={branchName} value={branchName}>
                      {branchName}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
              
              <Button
                variant="outlined"
                startIcon={<SyncIcon />}
                onClick={handleSync}
                disabled={syncLoading}
              >
                {syncLoading ? <CircularProgress size={24} /> : 'Sync'}
              </Button>
            </Box>
          </Box>
          
          <Divider />
          
          {syncLoading ? (
            <Box display="flex" justifyContent="center" alignItems="center" sx={{ my: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            renderFileList()
          )}
        </Paper>
      )}
    </Box>
  );
};

export default GitIntegration;
```

### 8.5 Fix TestCaseForm.tsx

```typescript
// src/components/testcase/TestCaseForm.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  Paper,
  Typography,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
  Divider,
} from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import { useApi } from '../../contexts/ApiContext';
import { useProject } from '../../contexts/ProjectContext';
import StepList from './StepList';

interface TestStep {
  id: string;
  sequence: number;
  type: string;
  action: string;
  target: string;
  value: string;
  description: string;
}

interface TestCase {
  id: string;
  name: string;
  description: string;
  tags: string[];
  projectId: string;
  steps: TestStep[];
}

interface TestCaseFormProps {
  testCaseId?: string;
  onSave?: (testCase: TestCase) => void;
}

const TestCaseForm: React.FC<TestCaseFormProps> = ({ testCaseId, onSave }) => {
  const { api } = useApi();
  const { currentProject } = useProject();
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState('');
  const [steps, setSteps] = useState<TestStep[]>([]);
  
  const [nameError, setNameError] = useState('');

  useEffect(() => {
    if (testCaseId) {
      loadTestCase();
    }
  }, [testCaseId]);

  const loadTestCase = async () => {
    if (!testCaseId) return;
    
    setLoading(true);
    try {
      const response = await api.get<{ success: boolean; data: TestCase }>(`/testcases/${testCaseId}`);
      if (response.success) {
        const testCase = response.data;
        setName(testCase.name);
        setDescription(testCase.description);
        setTags(testCase.tags || []);
        setSteps(testCase.steps || []);
      }
    } catch (error) {
      console.error('Error loading test case:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to load test case';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    // Validation
    if (!name.trim()) {
      setNameError('Test case name is required');
      return;
    }
    setNameError('');
    
    if (!currentProject) {
      setError('No project selected');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const testCaseData = {
        name,
        description,
        tags,
        projectId: currentProject.id,
        steps,
      };
      
      let response;
      if (testCaseId) {
        response = await api.put<{ success: boolean; data: TestCase }>(`/testcases/${testCaseId}`, testCaseData);
      } else {
        response = await api.post<{ success: boolean; data: TestCase }>('/testcases', testCaseData);
      }
      
      if (response.success) {
        if (onSave) {
          onSave(response.data);
        }
      } else {
        setError('Failed to save test case');
      }
    } catch (error) {
      console.error('Error saving test case:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to save test case';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const handleExecute = async () => {
    if (!testCaseId) {
      setError('Save the test case before executing');
      return;
    }
    
    try {
      await api.post(`/executions`, {
        testCaseIds: [testCaseId],
        projectId: currentProject?.id,
      });
      // Navigate to execution monitor or show success message
    } catch (error) {
      console.error('Error executing test case:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to execute test case';
      setError(errorMessage);
    }
  };

  const handleAddTag = () => {
    if (tagInput.trim() && !tags.includes(tagInput.trim())) {
      setTags([...tags, tagInput.trim()]);
      setTagInput('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setTags(tags.filter(tag => tag !== tagToRemove));
  };

  const handleStepsChange = (updatedSteps: TestStep[]) => {
    setSteps(updatedSteps);
  };

  return (
    <Box>
      <Paper elevation={2} sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" gutterBottom>
          {testCaseId ? 'Edit Test Case' : 'Create Test Case'}
        </Typography>
        
        {error && (
          <Typography color="error" sx={{ mb: 2 }}>
            {error}
          </Typography>
        )}
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Test Case Name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              error={!!nameError}
              helperText={nameError}
              required
            />
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              fullWidth
              multiline
              rows={3}
              label="Description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Describe the purpose and expected behavior of this test case"
            />
          </Grid>
          
          <Grid item xs={12}>
            <Box sx={{ mb: 1 }}>
              <Typography variant="subtitle2">Tags</Typography>
            </Box>
            <Box display="flex" alignItems="center">
              <TextField
                sx={{ flexGrow: 1, mr: 1 }}
                label="Add Tag"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    handleAddTag();
                  }
                }}
              />
              <Button variant="outlined" onClick={handleAddTag}>
                Add
              </Button>
            </Box>
            <Box sx={{ mt: 1, display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {tags.map((tag) => (
                <Chip
                  key={tag}
                  label={tag}
                  onDelete={() => handleRemoveTag(tag)}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              ))}
            </Box>
          </Grid>
        </Grid>
        
        <Box sx={{ mt: 3, display: 'flex', justifyContent: 'space-between' }}>
          <Button
            variant="contained"
            color="primary"
            startIcon={<SaveIcon />}
            onClick={handleSave}
            disabled={loading}
          >
            Save Test Case
          </Button>
          
          {testCaseId && (
            <Button
              variant="outlined"
              color="success"
              startIcon={<PlayArrowIcon />}
              onClick={handleExecute}
            >
              Execute
            </Button>
          )}
        </Box>
      </Paper>
      
      <Paper elevation={2} sx={{ p: 3 }}>
        <Typography variant="h6" gutterBottom>
          Test Steps
        </Typography>
        <Divider sx={{ mb: 2 }} />
        
        <StepList
          steps={steps}
          onChange={handleStepsChange}
          disabled={loading}
        />
      </Paper>
    </Box>
  );
};

export default TestCaseForm;
```

### 8.6 Fix StepList.tsx

```typescript
// src/components/testcase/StepList.tsx
import React, { useState } from 'react';
import {
  Box,
  Button,
  TextField,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Typography,
  Paper,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import MouseIcon from '@mui/icons-material/Mouse';
import KeyboardIcon from '@mui/icons-material/Keyboard';
import VisibilityIcon from '@mui/icons-material/Visibility';
import NavigationIcon from '@mui/icons-material/Navigation';
import WaitIcon from '@mui/icons-material/HourglassEmpty';
import CustomIcon from '@mui/icons-material/Code';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';

interface TestStep {
  id: string;
  sequence: number;
  type: string;
  action: string;
  target: string;
  value: string;
  description: string;
}

interface StepListProps {
  steps: TestStep[];
  onChange: (steps: TestStep[]) => void;
  disabled?: boolean;
}

const StepList: React.FC<StepListProps> = ({ steps, onChange, disabled = false }) => {
  const [open, setOpen] = useState(false);
  const [currentStep, setCurrentStep] = useState<TestStep | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  
  const getActionIcon = (action: string) => {
    switch (action) {
      case 'click':
      case 'doubleClick':
      case 'rightClick':
      case 'hover':
        return <MouseIcon fontSize="small" />;
      case 'type':
      case 'keyPress':
      case 'clear':
        return <KeyboardIcon fontSize="small" />;
      case 'navigate':
      case 'back':
      case 'forward':
      case 'refresh':
        return <NavigationIcon fontSize="small" />;
      case 'assert':
      case 'verifyText':
      case 'verifyAttribute':
      case 'verifyVisible':
        return <VisibilityIcon fontSize="small" />;
      case 'wait':
      case 'waitForElement':
      case 'waitForNavigation':
        return <WaitIcon fontSize="small" />;
      default:
        return <CustomIcon fontSize="small" />;
    }
  };
  
  const defaultStep: TestStep = {
    id: '',
    sequence: steps.length + 1,
    type: 'browser',
    action: 'click',
    target: '',
    value: '',
    description: '',
  };
  
  const handleOpenDialog = (step: TestStep | null = null, edit: boolean = false) => {
    setCurrentStep(step || { ...defaultStep, id: `new-${Date.now()}` });
    setIsEditing(edit);
    setOpen(true);
  };
  
  const handleCloseDialog = () => {
    setOpen(false);
    setCurrentStep(null);
  };
  
  const handleSaveStep = () => {
    if (!currentStep) return;
    
    const updatedSteps = [...steps];
    const index = updatedSteps.findIndex(s => s.id === currentStep.id);
    
    if (index >= 0) {
      // Update existing step
      updatedSteps[index] = currentStep;
    } else {
      // Add new step
      updatedSteps.push(currentStep);
    }
    
    // Reorder sequences
    const reorderedSteps = updatedSteps.map((step, idx) => ({
      ...step,
      sequence: idx + 1,
    }));
    
    onChange(reorderedSteps);
    handleCloseDialog();
  };
  
  const handleDeleteStep = (stepId: string) => {
    const updatedSteps = steps.filter(s => s.id !== stepId);
    
    // Reorder sequences
    const reorderedSteps = updatedSteps.map((step, idx) => ({
      ...step,
      sequence: idx + 1,
    }));
    
    onChange(reorderedSteps);
  };
  
  const handleMoveStep = (stepId: string, direction: 'up' | 'down') => {
    const stepIndex = steps.findIndex(s => s.id === stepId);
    if (
      (direction === 'up' && stepIndex === 0) ||
      (direction === 'down' && stepIndex === steps.length - 1)
    ) {
      return;
    }
    
    const updatedSteps = [...steps];
    const targetIndex = direction === 'up' ? stepIndex - 1 : stepIndex + 1;
    
    // Swap steps
    [updatedSteps[stepIndex], updatedSteps[targetIndex]] = [
      updatedSteps[targetIndex],
      updatedSteps[stepIndex],
    ];
    
    // Reorder sequences
    const reorderedSteps = updatedSteps.map((step, idx) => ({
      ...step,
      sequence: idx + 1,
    }));
    
    onChange(reorderedSteps);
  };
  
  const handleDragEnd = (result: any) => {
    if (!result.destination) return;
    
    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;
    
    if (sourceIndex === destinationIndex) return;
    
    const updatedSteps = [...steps];
    const [movedStep] = updatedSteps.splice(sourceIndex, 1);
    updatedSteps.splice(destinationIndex, 0, movedStep);
    
    // Reorder sequences
    const reorderedSteps = updatedSteps.map((step, idx) => ({
      ...step,
      sequence: idx + 1,
    }));
    
    onChange(reorderedSteps);
  };
  
  return (
    <Box>
      <Box sx={{ mb: 2, display: 'flex', justifyContent: 'flex-end' }}>
        <Button
          variant="outlined"
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
          disabled={disabled}
        >
          Add Step
        </Button>
      </Box>
      
      {steps.length === 0 ? (
        <Typography color="textSecondary" align="center" sx={{ py: 3 }}>
          No steps added yet. Click "Add Step" to start building your test case.
        </Typography>
      ) : (
        <DragDropContext onDragEnd={handleDragEnd}>
          <Droppable droppableId="test-steps">
            {(provided) => (
              <TableContainer component={Paper} ref={provided.innerRef} {...provided.droppableProps}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell width="50px">Seq</TableCell>
                      <TableCell>Action</TableCell>
                      <TableCell>Target</TableCell>
                      <TableCell>Value</TableCell>
                      <TableCell>Description</TableCell>
                      <TableCell width="120px">Actions</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {steps.map((step, index) => (
                      <Draggable
                        key={step.id}
                        draggableId={step.id}
                        index={index}
                        isDragDisabled={disabled}
                      >
                        {(provided) => (
                          <TableRow
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                            hover
                          >
                            <TableCell>{step.sequence}</TableCell>
                            <TableCell>
                              <Box display="flex" alignItems="center">
                                {getActionIcon(step.action)}
                                <Typography sx={{ ml: 1 }}>{step.action}</Typography>
                              </Box>
                            </TableCell>
                            <TableCell>{step.target}</TableCell>
                            <TableCell>{step.value}</TableCell>
                            <TableCell>{step.description}</TableCell>
                            <TableCell>
                              <IconButton
                                size="small"
                                onClick={() => handleMoveStep(step.id, 'up')}
                                disabled={index === 0 || disabled}
                              >
                                <ArrowUpwardIcon fontSize="small" />
                              </IconButton>
                              <IconButton
                                size="small"
                                onClick={() => handleMoveStep(step.id, 'down')}
                                disabled={index === steps.length - 1 || disabled}
                              >
                                <ArrowDownwardIcon fontSize="small" />
                              </IconButton>
                              <IconButton
                                size="small"
                                onClick={() => handleOpenDialog(step, true)}
                                disabled={disabled}
                              >
                                <EditIcon fontSize="small" />
                              </IconButton>
                              <IconButton
                                size="small"
                                color="error"
                                onClick={() => handleDeleteStep(step.id)}
                                disabled={disabled}
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        )}
                      </Draggable>
                    ))}
                    {provided.placeholder}
                  </TableBody>
                </Table>
              </TableContainer>
            )}
          </Droppable>
        </DragDropContext>
      )}
      
      <Dialog open={open} onClose={handleCloseDialog} maxWidth="md" fullWidth>
        <DialogTitle>{isEditing ? 'Edit Step' : 'Add Step'}</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Step Type</InputLabel>
                <Select
                  value={currentStep?.type || 'browser'}
                  label="Step Type"
                  onChange={(e) => setCurrentStep(prev => prev ? { ...prev, type: e.target.value } : null)}
                >
                  <MenuItem value="browser">Browser</MenuItem>
                  <MenuItem value="assertion">Assertion</MenuItem>
                  <MenuItem value="wait">Wait</MenuItem>
                  <MenuItem value="data">Data</MenuItem>
                  <MenuItem value="custom">Custom</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Action</InputLabel>
                <Select
                  value={currentStep?.action || 'click'}
                  label="Action"
                  onChange={(e) => setCurrentStep(prev => prev ? { ...prev, action: e.target.value } : null)}
                >
                  {currentStep?.type === 'browser' && (
                    <>
                      <MenuItem value="click">Click</MenuItem>
                      <MenuItem value="doubleClick">Double Click</MenuItem>
                      <MenuItem value="rightClick">Right Click</MenuItem>
                      <MenuItem value="type">Type</MenuItem>
                      <MenuItem value="clear">Clear</MenuItem>
                      <MenuItem value="select">Select</MenuItem>
                      <MenuItem value="check">Check</MenuItem>
                      <MenuItem value="uncheck">Uncheck</MenuItem>
                      <MenuItem value="hover">Hover</MenuItem>
                      <MenuItem value="navigate">Navigate</MenuItem>
                      <MenuItem value="back">Go Back</MenuItem>
                      <MenuItem value="forward">Go Forward</MenuItem>
                      <MenuItem value="refresh">Refresh</MenuItem>
                    </>
                  )}
                  
                  {currentStep?.type === 'assertion' && (
                    <>
                      <MenuItem value="assert">Assert</MenuItem>
                      <MenuItem value="verifyText">Verify Text</MenuItem>
                      <MenuItem value="verifyValue">Verify Value</MenuItem>
                      <MenuItem value="verifyAttribute">Verify Attribute</MenuItem>
                      <MenuItem value="verifyVisible">Verify Visible</MenuItem>
                      <MenuItem value="verifyNotVisible">Verify Not Visible</MenuItem>
                      <MenuItem value="verifyEnabled">Verify Enabled</MenuItem>
                      <MenuItem value="verifyDisabled">Verify Disabled</MenuItem>
                    </>
                  )}
                  
                  {currentStep?.type === 'wait' && (
                    <>
                      <MenuItem value="wait">Wait (ms)</MenuItem>
                      <MenuItem value="waitForElement">Wait For Element</MenuItem>
                      <MenuItem value="waitForNavigation">Wait For Navigation</MenuItem>
                      <MenuItem value="waitForVisible">Wait For Visible</MenuItem>
                      <MenuItem value="waitForNotVisible">Wait For Not Visible</MenuItem>
                    </>
                  )}
                  
                  {currentStep?.type === 'data' && (
                    <>
                      <MenuItem value="storeText">Store Text</MenuItem>
                      <MenuItem value="storeAttribute">Store Attribute</MenuItem>
                      <MenuItem value="storeValue">Store Value</MenuItem>
                      <MenuItem value="setVariable">Set Variable</MenuItem>
                    </>
                  )}
                  
                  {currentStep?.type === 'custom' && (
                    <>
                      <MenuItem value="executeScript">Execute Script</MenuItem>
                      <MenuItem value="takeScreenshot">Take Screenshot</MenuItem>
                    </>
                  )}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Target"
                value={currentStep?.target || ''}
                onChange={(e) => setCurrentStep(prev => prev ? { ...prev, target: e.target.value } : null)}
                placeholder={currentStep?.type === 'browser' ? 'CSS Selector or XPath' : 'Target'}
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Value"
                value={currentStep?.value || ''}
                onChange={(e) => setCurrentStep(prev => prev ? { ...prev, value: e.target.value } : null)}
                placeholder={
                  currentStep?.action === 'type'
                    ? 'Text to type'
                    : currentStep?.action === 'select'
                    ? 'Option value'
                    : currentStep?.action === 'assert' || currentStep?.action.startsWith('verify')
                    ? 'Expected value'
                    : currentStep?.action === 'navigate'
                    ? 'URL'
                    : 'Value (if needed)'
                }
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                value={currentStep?.description || ''}
                onChange={(e) => setCurrentStep(prev => prev ? { ...prev, description: e.target.value } : null)}
                placeholder="Describe what this step does (optional)"
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button onClick={handleSaveStep} color="primary">
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default StepList;
```

## 9. Fix Missing Packages and Dependencies

Update your package.json with the missing dependencies:

```json
{
  "name": "cs-testforge-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.11.16",
    "@mui/material": "^5.13.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.27",
    "@types/react": "^18.2.6",
    "@types/react-beautiful-dnd": "^13.1.4",
    "@types/react-dom": "^18.2.4",
    "notistack": "^3.0.1",
    "react": "^18.2.0",
    "react-beautiful-dnd": "^13.1.1",
    "react-dom": "^18.2.0",
    "react-json-pretty": "^2.2.0",
    "react-router-dom": "^6.11.1",
    "react-scripts": "5.0.1",
    "react-toastify": "^9.1.2",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

## 10. App Entry Point Configuration

Let's create a proper App.tsx configuration with all contexts and React Router setup:

```typescript
// src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { SnackbarProvider } from 'notistack';

// Context Providers
import { AuthProvider } from './contexts/AuthContext';
import { ApiProvider } from './contexts/ApiContext';
import { ProjectProvider } from './contexts/ProjectContext';

// Layout Components
import MainLayout from './layouts/MainLayout';
import LoginPage from './pages/LoginPage';

// Auth Guard
import AuthGuard from './components/common/AuthGuard';

// Pages
import DashboardPage from './pages/DashboardPage';
import ProjectsPage from './pages/ProjectsPage';
import TestCasesPage from './pages/TestCasesPage';
import TestSuitesPage from './pages/TestSuitesPage';
import RecorderPage from './pages/RecorderPage';
import ApiTestingPage from './pages/ApiTestingPage';
import BDDTestingPage from './pages/BDDTestingPage';
import ExecutionsPage from './pages/ExecutionsPage';
import ReportsPage from './pages/ReportsPage';
import IntegrationsPage from './pages/IntegrationsPage';
import SettingsPage from './pages/SettingsPage';

// Theme configuration
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
    background: {
      default: '#f5f5f5',
    },
  },
  typography: {
    fontFamily: [
      '-apple-system',
      'BlinkMacSystemFont',
      '"Segoe UI"',
      'Roboto',
      '"Helvetica Neue"',
      'Arial',
      'sans-serif',
    ].join(','),
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
  },
});

const App: React.FC = () => {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <SnackbarProvider maxSnack={3}>
        <AuthProvider>
          <ApiProvider>
            <ProjectProvider>
              <Router>
                <Routes>
                  <Route path="/login" element={<LoginPage />} />
                  
                  <Route path="/" element={<AuthGuard><MainLayout /></AuthGuard>}>
                    <Route index element={<Navigate to="/dashboard" replace />} />
                    <Route path="dashboard" element={<DashboardPage />} />
                    <Route path="projects" element={<ProjectsPage />} />
                    <Route path="testcases" element={<TestCasesPage />} />
                    <Route path="testsuites" element={<TestSuitesPage />} />
                    <Route path="recorder" element={<RecorderPage />} />
                    <Route path="api-testing" element={<ApiTestingPage />} />
                    <Route path="bdd-testing" element={<BDDTestingPage />} />
                    <Route path="executions" element={<ExecutionsPage />} />
                    <Route path="reports" element={<ReportsPage />} />
                    <Route path="integrations" element={<IntegrationsPage />} />
                    <Route path="settings" element={<SettingsPage />} />
                  </Route>
                  
                  <Route path="*" element={<Navigate to="/" replace />} />
                </Routes>
              </Router>
            </ProjectProvider>
          </ApiProvider>
        </AuthProvider>
      </SnackbarProvider>
    </ThemeProvider>
  );
};

export default App;
```

## 11. AuthGuard Component

```typescript
// src/components/common/AuthGuard.tsx
import React, { ReactNode } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import { CircularProgress, Box } from '@mui/material';

interface AuthGuardProps {
  children: ReactNode;
}

const AuthGuard: React.FC<AuthGuardProps> = ({ children }) => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    // Redirect to login page with return url
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export default AuthGuard;
```

## 12. MainLayout Component

```typescript
// src/layouts/MainLayout.tsx
import React, { useState } from 'react';
import { Outlet, useNavigate, useLocation } from 'react-router-dom';
import {
  AppBar,
  Box,
  CssBaseline,
  Divider,
  Drawer,
  IconButton,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Typography,
  Avatar,
  Menu,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import DashboardIcon from '@mui/icons-material/Dashboard';
import FolderIcon from '@mui/icons-material/Folder';
import PlaylistAddCheckIcon from '@mui/icons-material/PlaylistAddCheck';
import ViewListIcon from '@mui/icons-material/ViewList';
import VideocamIcon from '@mui/icons-material/Videocam';
import HttpIcon from '@mui/icons-material/Http';
import SubjectIcon from '@mui/icons-material/Subject';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import AssessmentIcon from '@mui/icons-material/Assessment';
import IntegrationInstructionsIcon from '@mui/icons-material/IntegrationInstructions';
import SettingsIcon from '@mui/icons-material/Settings';
import LogoutIcon from '@mui/icons-material/Logout';
import { useAuth } from '../contexts/AuthContext';
import { useProject } from '../contexts/ProjectContext';

const drawerWidth = 240;

const menuItems = [
  { text: 'Dashboard', icon: <DashboardIcon />, path: '/dashboard' },
  { text: 'Projects', icon: <FolderIcon />, path: '/projects' },
  { text: 'Test Cases', icon: <PlaylistAddCheckIcon />, path: '/testcases' },
  { text: 'Test Suites', icon: <ViewListIcon />, path: '/testsuites' },
  { text: 'Recorder', icon: <VideocamIcon />, path: '/recorder' },
  { text: 'API Testing', icon: <HttpIcon />, path: '/api-testing' },
  { text: 'BDD Testing', icon: <SubjectIcon />, path: '/bdd-testing' },
  { text: 'Executions', icon: <PlayArrowIcon />, path: '/executions' },
  { text: 'Reports', icon: <AssessmentIcon />, path: '/reports' },
  { text: 'Integrations', icon: <IntegrationInstructionsIcon />, path: '/integrations' },
  { text: 'Settings', icon: <SettingsIcon />, path: '/settings' },
];

const MainLayout: React.FC = () => {
  const { user, logout } = useAuth();
  const { projects, currentProject, setCurrentProject } = useProject();
  const navigate = useNavigate();
  const location = useLocation();
  
  const [mobileOpen, setMobileOpen] = useState(false);
  const [userMenuAnchorEl, setUserMenuAnchorEl] = useState<null | HTMLElement>(null);
  
  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };
  
  const handleUserMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setUserMenuAnchorEl(event.currentTarget);
  };
  
  const handleUserMenuClose = () => {
    setUserMenuAnchorEl(null);
  };
  
  const handleLogout = () => {
    handleUserMenuClose();
    logout();
    navigate('/login');
  };
  
  const handleProjectChange = (event: React.ChangeEvent<{ value: unknown }>) => {
    const projectId = event.target.value as string;
    const project = projects.find(p => p.id === projectId);
    if (project) {
      setCurrentProject(project);
    }
  };
  
  const drawer = (
    <div>
      <Toolbar sx={{ justifyContent: 'center' }}>
        <Typography variant="h6" noWrap component="div">
          CS TestForge
        </Typography>
      </Toolbar>
      <Divider />
      
      {projects.length > 0 && (
        <Box sx={{ p: 2 }}>
          <FormControl fullWidth size="small">
            <InputLabel>Project</InputLabel>
            <Select
              value={currentProject?.id || ''}
              label="Project"
              onChange={handleProjectChange}
            >
              {projects.map((project) => (
                <MenuItem key={project.id} value={project.id}>
                  {project.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
      )}
      
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              selected={location.pathname === item.path}
              onClick={() => {
                navigate(item.path);
                setMobileOpen(false);
              }}
            >
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
      </List>
    </div>
  );

  return (
    <Box sx={{ display: 'flex' }}>
      <CssBaseline />
      <AppBar
        position="fixed"
        sx={{
          width: { sm: `calc(100% - ${drawerWidth}px)` },
          ml: { sm: `${drawerWidth}px` },
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { sm: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            {currentProject ? currentProject.name : 'CS TestForge'}
          </Typography>
          
          {user && (
            <Box>
              <IconButton
                onClick={handleUserMenuOpen}
                color="inherit"
                edge="end"
              >
                <Avatar sx={{ width: 32, height: 32 }}>
                  {user.username.charAt(0).toUpperCase()}
                </Avatar>
              </IconButton>
              <Menu
                anchorEl={userMenuAnchorEl}
                open={Boolean(userMenuAnchorEl)}
                onClose={handleUserMenuClose}
              >
                <MenuItem disabled>
                  <Typography variant="body2">{user.username}</Typography>
                </MenuItem>
                <Divider />
                <MenuItem onClick={handleLogout}>
                  <ListItemIcon>
                    <LogoutIcon fontSize="small" />
                  </ListItemIcon>
                  <ListItemText>Logout</ListItemText>
                </MenuItem>
              </Menu>
            </Box>
          )}
        </Toolbar>
      </AppBar>
      
      <Box
        component="nav"
        sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile
          }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          {drawer}
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', sm: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>
      
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { sm: `calc(100% - ${drawerWidth}px)` },
          backgroundColor: 'background.default',
          minHeight: '100vh',
        }}
      >
        <Toolbar /> {/*

```typescript
// src/components/execution/ExecutionMonitor.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Paper,
  Typography,
  LinearProgress,
  Grid,
  Card,
  CardContent,
  Chip,
  Divider,
  IconButton,
  Tooltip,
  Button,
  List,
  ListItem,
  ListItemText,
  Accordion,
  AccordionSummary,
  AccordionDetails,
} from '@mui/material';
import HelpIcon from '@mui/icons-material/Help';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import StopIcon from '@mui/icons-material/Stop';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import AlarmIcon from '@mui/icons-material/Alarm';
import { useApi } from '../../contexts/ApiContext';

interface WebSocketHook {
  connected: boolean;
  subscribe: (topic: string, callback: (data: any) => void) => void;
  unsubscribe: (topic: string) => void;
}

// Mock useWebSocket hook implementation
const useWebSocket = (serverUrl: string): WebSocketHook => {
  const [connected, setConnected] = useState(false);
  const subscribers = React.useRef<Map<string, ((data: any) => void)[]>>(new Map());

  useEffect(() => {
    // Simulate connection
    setConnected(true);
    
    return () => {
      // Cleanup on unmount
      setConnected(false);
    };
  }, [serverUrl]);

  const subscribe = useCallback((topic: string, callback: (data: any) => void) => {
    const topicSubscribers = subscribers.current.get(topic) || [];
    subscribers.current.set(topic, [...topicSubscribers, callback]);
  }, []);

  const unsubscribe = useCallback((topic: string) => {
    subscribers.current.delete(topic);
  }, []);

  return { connected, subscribe, unsubscribe };
};

interface ExecutionStatus {
  executionId: string;
  status: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'ABORTED';
  progress: number;
  startTime: string;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  currentTest?: {
    id: string;
    name: string;
    status: 'RUNNING' | 'PASSED' | 'FAILED' | 'SKIPPED';
  };
}

interface TestResult {
  id: string;
  name: string;
  status: 'PASSED' | 'FAILED' | 'SKIPPED';
  duration: number;
  steps: StepResult[];
}

interface StepResult {
  id: string;
  description: string;
  status: 'PASSED' | 'FAILED' | 'SKIPPED';
  duration: number;
  error?: string;
  screenshot?: string;
}

interface ExecutionSummary {
  id: string;
  projectId: string;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  totalDurationMs: number;
  startTime: string;
  endTime: string;
  status: 'RUNNING' | 'COMPLETED' | 'ABORTED' | 'FAILED';
}

interface ExecutionMonitorProps {
  executionId: string;
  onClose?: () => void;
}

const ExecutionMonitor: React.FC<ExecutionMonitorProps> = ({ executionId, onClose }) => {
  const { api } = useApi();
  const { connected, subscribe, unsubscribe } = useWebSocket(`ws://localhost:8080/ws/execution/${executionId}`);
  
  const [executionStatus, setExecutionStatus] = useState<ExecutionStatus | null>(null);
  const [testResults, setTestResults] = useState<TestResult[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchExecutionStatus = useCallback(async () => {
    try {
      const response = await api.get<{ success: boolean; data: ExecutionSummary }>(`/executions/${executionId}`);
      if (response.success) {
        const data = response.data;
        setExecutionStatus({
          executionId: data.id,
          status: data.status,
          progress: calculateProgress(data),
          startTime: data.startTime,
          totalTests: data.totalTests,
          passedTests: data.passedTests,
          failedTests: data.failedTests,
          skippedTests: data.skippedTests,
        });
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch execution status';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }, [api, executionId]);

  const fetchTestResults = useCallback(async () => {
    try {
      const response = await api.get<{ success: boolean; data: TestResult[] }>(`/executions/${executionId}/results`);
      if (response.success) {
        setTestResults(response.data);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch test results';
      setError(errorMessage);
    }
  }, [api, executionId]);

  const calculateProgress = (summary: ExecutionSummary): number => {
    const completedTests = summary.passedTests + summary.failedTests + summary.skippedTests;
    return summary.totalTests > 0 ? (completedTests / summary.totalTests) * 100 : 0;
  };

  const handleExecutionUpdate = useCallback((data: any) => {
    setExecutionStatus(prevStatus => {
      if (!prevStatus) return data;
      return { ...prevStatus, ...data };
    });
    
    if (data.status === 'COMPLETED' || data.status === 'ABORTED' || data.status === 'FAILED') {
      fetchTestResults();
    }
  }, [fetchTestResults]);

  const handleTestResultUpdate = useCallback((data: TestResult) => {
    setTestResults(prevResults => {
      const index = prevResults.findIndex(result => result.id === data.id);
      if (index >= 0) {
        const updatedResults = [...prevResults];
        updatedResults[index] = data;
        return updatedResults;
      }
      return [...prevResults, data];
    });
  }, []);

  useEffect(() => {
    fetchExecutionStatus();
    fetchTestResults();
    
    if (connected) {
      subscribe(`/topic/execution/${executionId}/status`, handleExecutionUpdate);
      subscribe(`/topic/execution/${executionId}/test-results`, handleTestResultUpdate);
    }
    
    return () => {
      if (connected) {
        unsubscribe(`/topic/execution/${executionId}/status`);
        unsubscribe(`/topic/execution/${executionId}/test-results`);
      }
    };
  }, [executionId, connected, subscribe, unsubscribe, fetchExecutionStatus, fetchTestResults, handleExecutionUpdate, handleTestResultUpdate]);

  const stopExecution = async () => {
    try {
      await api.post(`/executions/${executionId}/stop`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to stop execution';
      setError(errorMessage);
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PASSED':
        return 'success';
      case 'FAILED':
        return 'error';
      case 'SKIPPED':
        return 'warning';
      case 'RUNNING':
        return 'info';
      default:
        return 'default';
    }
  };

  const formatDuration = (ms: number) => {
    if (ms < 1000) return `${ms}ms`;
    const seconds = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
  };

  if (loading) {
    return (
      <Paper elevation={3} sx={{ p: 3 }}>
        <Typography variant="h6" gutterBottom>
          Loading Execution Status...
        </Typography>
        <LinearProgress />
      </Paper>
    );
  }

  if (error) {
    return (
      <Paper elevation={3} sx={{ p: 3 }}>
        <Typography variant="h6" color="error" gutterBottom>
          Error Loading Execution
        </Typography>
        <Typography>{error}</Typography>
        {onClose && (
          <Button onClick={onClose} sx={{ mt: 2 }}>
            Close
          </Button>
        )}
      </Paper>
    );
  }

  if (!executionStatus) {
    return (
      <Paper elevation={3} sx={{ p: 3 }}>
        <Typography variant="h6" gutterBottom>
          Execution Not Found
        </Typography>
        {onClose && (
          <Button onClick={onClose} sx={{ mt: 2 }}>
            Close
          </Button>
        )}
      </Paper>
    );
  }

  return (
    <Paper elevation={3} sx={{ p: 3 }}>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h5">
          Execution Monitor
          <Tooltip title="Real-time monitoring of test execution progress and results">
            <IconButton size="small">
              <HelpIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Typography>
        {executionStatus.status === 'RUNNING' ? (
          <Button
            variant="contained"
            color="error"
            startIcon={<StopIcon />}
            onClick={stopExecution}
          >
            Stop Execution
          </Button>
        ) : (
          onClose && (
            <Button variant="outlined" onClick={onClose}>
              Close
            </Button>
          )
        )}
      </Box>

      <Grid container spacing={2} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card variant="outlined">
            <CardContent>
              <Typography variant="subtitle2" color="textSecondary">
                Status
              </Typography>
              <Box display="flex" alignItems="center">
                <Chip
                  label={executionStatus.status}
                  color={
                    executionStatus.status === 'COMPLETED'
                      ? 'success'
                      : executionStatus.status === 'FAILED'
                      ? 'error'
                      : executionStatus.status === 'ABORTED'
                      ? 'warning'
                      : 'info'
                  }
                  size="small"
                  sx={{ mr: 1 }}
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card variant="outlined">
            <CardContent>
              <Typography variant="subtitle2" color="textSecondary">
                Progress
              </Typography>
              <Box>
                <Typography variant="h6">
                  {Math.round(executionStatus.progress)}%
                </Typography>
                <LinearProgress
                  variant="determinate"
                  value={executionStatus.progress}
                  color={
                    executionStatus.status === 'FAILED'
                      ? 'error'
                      : executionStatus.status === 'ABORTED'
                      ? 'warning'
                      : 'primary'
                  }
                />
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card variant="outlined">
            <CardContent>
              <Typography variant="subtitle2" color="textSecondary">
                Results
              </Typography>
              <Box display="flex" alignItems="center" justifyContent="space-between">
                <Box display="flex" alignItems="center">
                  <CheckCircleIcon color="success" fontSize="small" sx={{ mr: 0.5 }} />
                  <Typography variant="body2">{executionStatus.passedTests}</Typography>
                </Box>
                <Box display="flex" alignItems="center">
                  <ErrorIcon color="error" fontSize="small" sx={{ mr: 0.5 }} />
                  <Typography variant="body2">{executionStatus.failedTests}</Typography>
                </Box>
                <Box display="flex" alignItems="center">
                  <AlarmIcon color="disabled" fontSize="small" sx={{ mr: 0.5 }} />
                  <Typography variant="body2">{executionStatus.skippedTests}</Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card variant="outlined">
            <CardContent>
              <Typography variant="subtitle2" color="textSecondary">
                Total Tests
              </Typography>
              <Typography variant="h6">{executionStatus.totalTests}</Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {executionStatus.currentTest && executionStatus.status === 'RUNNING' && (
        <Paper variant="outlined" sx={{ p: 2, mb: 3 }}>
          <Typography variant="subtitle1" gutterBottom>
            Currently Running
          </Typography>
          <Box display="flex" alignItems="center">
            <PlayArrowIcon color="primary" sx={{ mr: 1 }} />
            <Typography>{executionStatus.currentTest.name}</Typography>
            <Chip
              label={executionStatus.currentTest.status}
              color={getStatusColor(executionStatus.currentTest.status)}
              size="small"
              sx={{ ml: 1 }}
            />
          </Box>
        </Paper>
      )}

      <Box sx={{ mb: 2 }}>
        <Typography variant="h6" gutterBottom>
          Test Results
        </Typography>
        <Divider sx={{ mb: 2 }} />

        {testResults.length === 0 ? (
          <Typography color="textSecondary">No test results available yet.</Typography>
        ) : (
          testResults.map((test) => (
            <Accordion key={test.id} elevation={0} sx={{ border: '1px solid rgba(0, 0, 0, 0.12)', mb: 1 }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box display="flex" alignItems="center" width="100%">
                  <Typography sx={{ flexGrow: 1 }}>{test.name}</Typography>
                  <Chip
                    label={test.status}
                    color={getStatusColor(test.status)}
                    size="small"
                    sx={{ mr: 1 }}
                  />
                  <Typography variant="caption" color="textSecondary">
                    {formatDuration(test.duration)}
                  </Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <List dense disablePadding>
                  {test.steps.map((step) => (
                    <ListItem key={step.id} divider>
                      <ListItemText
                        primary={
                          <Box display="flex" alignItems="center">
                            <Typography variant="body2">
                              {step.description}
                            </Typography>
                            <Chip
                              label={step.status}
                              color={getStatusColor(step.status)}
                              size="small"
                              sx={{ ml: 1 }}
                            />
                          </Box>
                        }
                        secondary={
                          <>
                            <Typography variant="caption" color="textSecondary">
                              Duration: {formatDuration(step.duration)}
                            </Typography>
                            {step.error && (
                              <Typography variant="caption" color="error" display="block">
                                Error: {step.error}
                              </Typography>
                            )}
                            {step.screenshot && (
                              <Box mt={1}>
                                <img
                                  src={`data:image/png;base64,${step.screenshot}`}
                                  alt="Step screenshot"
                                  style={{ maxWidth: '100%', maxHeight: '200px', border: '1px solid #ddd' }}
                                />
                              </Box>
                            )}
                          </>
                        }
                      />
                    </ListItem>
                  ))}
                </List>
              </AccordionDetails>
            </Accordion>
          ))
        )}
      </Box>
    </Paper>
  );
};

export default ExecutionMonitor;

