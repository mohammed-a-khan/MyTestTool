// src/components/recorder/ElementInspector.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemText,
  Grid,
  Tabs,
  Tab,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  ContentCopy as CopyIcon,
  Check as CheckIcon,
  MouseOutlined as MouseIcon,
  CodeOutlined as CodeIcon,
  LabelOutlined as LabelIcon,
  TextFieldsOutlined as TextIcon,
  CropFree as CropIcon,
  Refresh as RefreshIcon,
  ErrorOutline as ErrorIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Element Inspector Component
 * Allows inspecting elements in the browser and generating selectors
 */
const ElementInspector = ({ sessionId, onElementSelected, onSelectorChosen }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [inspecting, setInspecting] = useState(false);
  const [loading, setLoading] = useState(false);
  const [hoveredElement, setHoveredElement] = useState(null);
  const [selectedElement, setSelectedElement] = useState(null);
  const [selectors, setSelectors] = useState({});
  const [currentTab, setCurrentTab] = useState(0);
  const [previewHtml, setPreviewHtml] = useState(null);
  const [previewVisible, setPreviewVisible] = useState(false);
  
  // Start element inspection
  const startInspection = async () => {
    if (!sessionId) {
      enqueueSnackbar('No active recording session', { variant: 'error' });
      return;
    }
    
    try {
      setLoading(true);
      setInspecting(true);
      
      // Tell the backend to start inspection mode
      await api.post(`/recorder/sessions/${sessionId}/inspect/start`);
      
      setLoading(false);
      
      // Poll for element updates
      pollForElementUpdates();
    } catch (error) {
      console.error('Error starting inspection:', error);
      setLoading(false);
      setInspecting(false);
      enqueueSnackbar('Failed to start element inspection', { variant: 'error' });
    }
  };
  
  // Stop element inspection
  const stopInspection = async () => {
    if (!sessionId) return;
    
    try {
      setLoading(true);
      
      // Tell the backend to stop inspection mode
      await api.post(`/recorder/sessions/${sessionId}/inspect/stop`);
      
      setInspecting(false);
      setLoading(false);
    } catch (error) {
      console.error('Error stopping inspection:', error);
      setInspecting(false);
      setLoading(false);
      enqueueSnackbar('Failed to stop element inspection', { variant: 'error' });
    }
  };
  
  // Poll for element updates
  const pollForElementUpdates = () => {
    if (!sessionId || !inspecting) return;
    
    const intervalId = setInterval(async () => {
      if (!inspecting) {
        clearInterval(intervalId);
        return;
      }
      
      try {
        // Get current hovered element
        const response = await api.get(`/recorder/sessions/${sessionId}/inspect/element`);
        setHoveredElement(response.data);
      } catch (error) {
        console.error('Error polling for element updates:', error);
        // Don't stop inspection on polling errors
      }
    }, 200); // Poll every 200ms
    
    // Cleanup interval on component unmount
    return () => clearInterval(intervalId);
  };
  
  // Handle element selection
  const selectElement = async () => {
    if (!hoveredElement || !sessionId) return;
    
    try {
      setLoading(true);
      
      // Stop inspection
      await api.post(`/recorder/sessions/${sessionId}/inspect/stop`);
      
      // Generate selectors for the element
      const response = await api.post(
        `/recorder/sessions/${sessionId}/inspect/selectors`,
        { elementInfo: hoveredElement }
      );
      
      setSelectors(response.data || {});
      setSelectedElement(hoveredElement);
      setInspecting(false);
      
      // Notify parent component
      if (onElementSelected) {
        onElementSelected(hoveredElement);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error selecting element:', error);
      setInspecting(false);
      setLoading(false);
      enqueueSnackbar('Failed to select element', { variant: 'error' });
    }
  };
  
  // Choose a selector
  const chooseSelector = (type, selector) => {
    // Notify parent component
    if (onSelectorChosen) {
      onSelectorChosen(selector, type);
    }
    
    enqueueSnackbar(`Selector "${type}" chosen`, { variant: 'success' });
  };
  
  // Copy selector to clipboard
  const copySelector = (selector) => {
    navigator.clipboard.writeText(selector)
      .then(() => {
        enqueueSnackbar('Selector copied to clipboard', { variant: 'success' });
      })
      .catch((error) => {
        console.error('Error copying selector:', error);
        enqueueSnackbar('Failed to copy selector', { variant: 'error' });
      });
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Preview HTML
  const previewElementHtml = async () => {
    if (!selectedElement || !sessionId) return;
    
    try {
      setLoading(true);
      
      // Get element HTML
      const response = await api.post(
        `/recorder/sessions/${sessionId}/inspect/html`,
        { elementInfo: selectedElement }
      );
      
      setPreviewHtml(response.data.html || '');
      setPreviewVisible(true);
      setLoading(false);
    } catch (error) {
      console.error('Error getting element HTML:', error);
      setLoading(false);
      enqueueSnackbar('Failed to get element HTML', { variant: 'error' });
    }
  };
  
  // Close preview
  const closePreview = () => {
    setPreviewVisible(false);
    setPreviewHtml(null);
  };
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Stop inspection if component unmounts
      if (inspecting && sessionId) {
        api.post(`/recorder/sessions/${sessionId}/inspect/stop`)
          .catch(error => {
            console.error('Error stopping inspection on unmount:', error);
          });
      }
    };
  }, [api, inspecting, sessionId]);
  
  // Check if there's a selected element
  const hasSelectedElement = selectedElement !== null;
  
  // Render inspector UI
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title="Element Inspector" 
          subheader={
            inspecting 
              ? "Hover over elements in the browser and click to select" 
              : "Start inspection to select an element"
          }
        />
        <Divider />
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
            {!inspecting ? (
              <Button
                variant="contained"
                color="primary"
                startIcon={<MouseIcon />}
                onClick={startInspection}
                disabled={loading || !sessionId}
              >
                {loading ? <CircularProgress size={24} /> : 'Start Inspection'}
              </Button>
            ) : (
              <Box sx={{ display: 'flex', gap: 2 }}>
                <Button
                  variant="contained"
                  color="secondary"
                  onClick={selectElement}
                  disabled={loading || !hoveredElement}
                >
                  {loading ? <CircularProgress size={24} /> : 'Select Element'}
                </Button>
                <Button
                  variant="outlined"
                  color="error"
                  onClick={stopInspection}
                  disabled={loading}
                >
                  {loading ? <CircularProgress size={24} /> : 'Cancel'}
                </Button>
              </Box>
            )}
          </Box>
          
          {inspecting && hoveredElement && (
            <Paper variant="outlined" sx={{ p: 2, mb: 2 }}>
              <Typography variant="subtitle2" gutterBottom>
                Hovered Element
              </Typography>
              
              <Grid container spacing={1}>
                <Grid item xs={12} sm={6}>
                  <Typography variant="body2">
                    <strong>Tag:</strong> {hoveredElement.tagName}
                  </Typography>
                </Grid>
                
                {hoveredElement.attributes?.id && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>ID:</strong> {hoveredElement.attributes.id}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.attributes?.class && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>Class:</strong> {hoveredElement.attributes.class}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.attributes?.name && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>Name:</strong> {hoveredElement.attributes.name}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.textContent && (
                  <Grid item xs={12}>
                    <Typography variant="body2" noWrap>
                      <strong>Text:</strong> {hoveredElement.textContent}
                    </Typography>
                  </Grid>
                )}
              </Grid>
            </Paper>
          )}
          
          {hasSelectedElement && (
            <Box>
              <Tabs
                value={currentTab}
                onChange={handleTabChange}
                variant="fullWidth"
                sx={{ mb: 2 }}
              >
                <Tab label="Selectors" />
                <Tab label="Attributes" />
                <Tab label="Details" />
              </Tabs>
              
              {currentTab === 0 && (
                <TableContainer component={Paper} variant="outlined">
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Type</TableCell>
                        <TableCell>Selector</TableCell>
                        <TableCell>Actions</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {Object.entries(selectors).length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={3} align="center">
                            <Typography variant="body2" color="text.secondary">
                              No selectors available
                            </Typography>
                          </TableCell>
                        </TableRow>
                      ) : (
                        Object.entries(selectors).map(([type, selector]) => (
                          <TableRow key={type}>
                            <TableCell>
                              <Chip 
                                label={type} 
                                size="small" 
                                color={
                                  type === 'id' ? 'success' :
                                  type === 'data-testid' ? 'primary' :
                                  type === 'xpath' ? 'warning' :
                                  type === 'css' ? 'info' :
                                  'default'
                                }
                              />
                            </TableCell>
                            <TableCell>
                              <Typography 
                                variant="body2" 
                                sx={{ 
                                  fontFamily: 'monospace',
                                  whiteSpace: 'nowrap',
                                  overflow: 'hidden',
                                  textOverflow: 'ellipsis',
                                  maxWidth: '200px'
                                }}
                              >
                                {selector}
                              </Typography>
                            </TableCell>
                            <TableCell>
                              <Tooltip title="Use This Selector">
                                <IconButton 
                                  size="small" 
                                  color="primary"
                                  onClick={() => chooseSelector(type, selector)}
                                >
                                  <CheckIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                              <Tooltip title="Copy to Clipboard">
                                <IconButton 
                                  size="small"
                                  onClick={() => copySelector(selector)}
                                >
                                  <CopyIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
              
              {currentTab === 1 && (
                <TableContainer component={Paper} variant="outlined">
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Attribute</TableCell>
                        <TableCell>Value</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {selectedElement.attributes && Object.entries(selectedElement.attributes).length > 0 ? (
                        Object.entries(selectedElement.attributes).map(([name, value]) => (
                          <TableRow key={name}>
                            <TableCell>{name}</TableCell>
                            <TableCell>{value}</TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={2} align="center">
                            <Typography variant="body2" color="text.secondary">
                              No attributes available
                            </Typography>
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
              
              {currentTab === 2 && (
                <Box>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <Paper variant="outlined" sx={{ p: 2 }}>
                        <Typography variant="subtitle2" gutterBottom>
                          Element Properties
                        </Typography>
                        <List dense disablePadding>
                          <ListItem disableGutters>
                            <ListItemText 
                              primary="Tag Name" 
                              secondary={selectedElement.tagName} 
                            />
                          </ListItem>
                          
                          <ListItem disableGutters>
                            <ListItemText 
                              primary="Visible" 
                              secondary={selectedElement.visible ? 'Yes' : 'No'} 
                            />
                          </ListItem>
                          
                          {selectedElement.boundingBox && (
                            <>
                              <ListItem disableGutters>
                                <ListItemText 
                                  primary="Position" 
                                  secondary={
                                    `X: ${Math.round(selectedElement.boundingBox.x)}, ` +
                                    `Y: ${Math.round(selectedElement.boundingBox.y)}`
                                  } 
                                />
                              </ListItem>
                              
                              <ListItem disableGutters>
                                <ListItemText 
                                  primary="Size" 
                                  secondary={
                                    `Width: ${Math.round(selectedElement.boundingBox.width)}px, ` +
                                    `Height: ${Math.round(selectedElement.boundingBox.height)}px`
                                  } 
                                />
                              </ListItem>
                            </>
                          )}
                          
                          {selectedElement.zIndex !== undefined && (
                            <ListItem disableGutters>
                              <ListItemText 
                                primary="Z-Index" 
                                secondary={selectedElement.zIndex} 
                              />
                            </ListItem>
                          )}
                        </List>
                      </Paper>
                    </Grid>
                    
                    <Grid item xs={12} sm={6}>
                      <Paper variant="outlined" sx={{ p: 2 }}>
                        <Typography variant="subtitle2" gutterBottom>
                          Content
                        </Typography>
                        
                        {selectedElement.textContent ? (
                          <Typography 
                            variant="body2" 
                            sx={{ 
                              wordBreak: 'break-word',
                              maxHeight: '100px',
                              overflow: 'auto'
                            }}
                          >
                            {selectedElement.textContent}
                          </Typography>
                        ) : (
                          <Typography variant="body2" color="text.secondary">
                            No text content
                          </Typography>
                        )}
                        
                        <Box sx={{ mt: 2 }}>
                          <Button
                            size="small"
                            startIcon={<CodeIcon />}
                            onClick={previewElementHtml}
                            disabled={loading}
                          >
                            View HTML
                          </Button>
                        </Box>
                      </Paper>
                    </Grid>
                  </Grid>
                </Box>
              )}
            </Box>
          )}
        </CardContent>
      </Card>
      
      {/* HTML Preview Dialog */}
      <Dialog
        open={previewVisible}
        onClose={closePreview}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Element HTML</DialogTitle>
        <DialogContent>
          <Paper
            sx={{
              p: 2,
              maxHeight: '400px',
              overflow: 'auto',
              backgroundColor: '#f5f5f5',
              fontFamily: 'monospace',
              fontSize: '14px',
              whiteSpace: 'pre-wrap'
            }}
          >
            {previewHtml || 'No HTML available'}
          </Paper>
        </DialogContent>
        <DialogActions>
          <Button onClick={closePreview}>Close</Button>
          <Button 
            onClick={() => {
              if (previewHtml) {
                navigator.clipboard.writeText(previewHtml);
                enqueueSnackbar('HTML copied to clipboard', { variant: 'success' });
              }
            }}
            disabled={!previewHtml}
          >
            Copy HTML
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ElementInspector;


// src/components/recorder/SelectorGenerator.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  FormControlLabel,
  Switch,
  Grid,
  Tabs,
  Tab,
  CircularProgress,
  Alert,
  LinearProgress
} from '@mui/material';
import {
  ContentCopy as CopyIcon,
  Check as CheckIcon,
  RefreshOutlined as RefreshIcon,
  VerifiedOutlined as VerifiedIcon,
  ErrorOutline as ErrorIcon,
  LabelOutlined as LabelIcon,
  TextFieldsOutlined as TextIcon,
  InboxOutlined as GenerateIcon,
  EditOutlined as EditIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Selector Generator Component
 * Generates and tests different types of selectors for elements
 */
const SelectorGenerator = ({ sessionId, initialSelector, initialElement, onSelectorChosen }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [selector, setSelector] = useState(initialSelector || '');
  const [selectorType, setSelectorType] = useState('css');
  const [generatedSelectors, setGeneratedSelectors] = useState({});
  const [testResults, setTestResults] = useState({});
  const [customSelectors, setCustomSelectors] = useState([]);
  const [elementInfo, setElementInfo] = useState(initialElement || null);
  const [currentTab, setCurrentTab] = useState(0);
  const [editMode, setEditMode] = useState(false);
  const [includeUnique, setIncludeUnique] = useState(true);
  const [includeRobust, setIncludeRobust] = useState(true);
  
  // Update state when props change
  useEffect(() => {
    if (initialSelector) {
      setSelector(initialSelector);
    }
    
    if (initialElement) {
      setElementInfo(initialElement);
    }
  }, [initialSelector, initialElement]);
  
  // Generate selectors for element
  const generateSelectors = async () => {
    if (!elementInfo || !sessionId) {
      enqueueSnackbar('No element selected', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Generate selectors for the element
      const response = await api.post(
        `/recorder/sessions/${sessionId}/selectors/generate`,
        { 
          elementInfo, 
          includeUnique,
          includeRobust
        }
      );
      
      const generated = response.data || {};
      setGeneratedSelectors(generated);
      
      // Test generated selectors
      testSelectors(generated);
      
      setLoading(false);
    } catch (error) {
      console.error('Error generating selectors:', error);
      setLoading(false);
      enqueueSnackbar('Failed to generate selectors', { variant: 'error' });
    }
  };
  
  // Test selectors
  const testSelectors = async (selectorsToTest = null) => {
    if (!sessionId) return;
    
    const selectorsMap = selectorsToTest || generatedSelectors;
    if (!selectorsMap || Object.keys(selectorsMap).length === 0) return;
    
    try {
      setLoading(true);
      
      // Test all selectors
      const response = await api.post(
        `/recorder/sessions/${sessionId}/selectors/test`,
        { selectors: selectorsMap }
      );
      
      setTestResults(response.data || {});
      setLoading(false);
    } catch (error) {
      console.error('Error testing selectors:', error);
      setLoading(false);
      enqueueSnackbar('Failed to test selectors', { variant: 'error' });
    }
  };
  
  // Test a single selector
  const testSelector = async (selectorToTest) => {
    if (!sessionId || !selectorToTest) return;
    
    try {
      setLoading(true);
      
      // Test the selector
      const response = await api.post(
        `/recorder/sessions/${sessionId}/selectors/test`,
        { selectors: { custom: selectorToTest } }
      );
      
      const newResults = { 
        ...testResults,
        ...response.data
      };
      
      setTestResults(newResults);
      setLoading(false);
      
      return newResults.custom;
    } catch (error) {
      console.error('Error testing selector:', error);
      setLoading(false);
      enqueueSnackbar('Failed to test selector', { variant: 'error' });
      return null;
    }
  };
  
  // Add custom selector
  const addCustomSelector = async () => {
    if (!selector) {
      enqueueSnackbar('Please enter a selector', { variant: 'warning' });
      return;
    }
    
    // Test the selector first
    const result = await testSelector(selector);
    
    if (result) {
      // Add to custom selectors
      setCustomSelectors([
        ...customSelectors,
        {
          type: selectorType,
          selector,
          result
        }
      ]);
      
      // Clear input
      setSelector('');
      
      enqueueSnackbar('Custom selector added', { variant: 'success' });
    }
  };
  
  // Remove custom selector
  const removeCustomSelector = (index) => {
    const newSelectors = [...customSelectors];
    newSelectors.splice(index, 1);
    setCustomSelectors(newSelectors);
  };
  
  // Choose a selector
  const chooseSelector = (selector) => {
    // Notify parent component
    if (onSelectorChosen) {
      onSelectorChosen(selector);
    }
    
    enqueueSnackbar('Selector chosen', { variant: 'success' });
  };
  
  // Copy selector to clipboard
  const copySelector = (selector) => {
    navigator.clipboard.writeText(selector)
      .then(() => {
        enqueueSnackbar('Selector copied to clipboard', { variant: 'success' });
      })
      .catch((error) => {
        console.error('Error copying selector:', error);
        enqueueSnackbar('Failed to copy selector', { variant: 'error' });
      });
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Optimize selector
  const optimizeSelector = async () => {
    if (!selector || !sessionId) {
      enqueueSnackbar('Please enter a selector to optimize', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Optimize the selector
      const response = await api.post(
        `/recorder/sessions/${sessionId}/selectors/optimize`,
        { 
          selector,
          elementInfo
        }
      );
      
      if (response.data && response.data.optimized) {
        setSelector(response.data.optimized);
        
        // Test the optimized selector
        await testSelector(response.data.optimized);
        
        enqueueSnackbar('Selector optimized', { variant: 'success' });
      } else {
        enqueueSnackbar('Could not optimize selector further', { variant: 'info' });
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error optimizing selector:', error);
      setLoading(false);
      enqueueSnackbar('Failed to optimize selector', { variant: 'error' });
    }
  };
  
  // Check if there's an element
  const hasElement = elementInfo !== null;
  
  // Get test result status
  const getTestStatus = (result) => {
    if (!result) return 'unknown';
    
    if (result.unique && result.found) {
      return 'unique';
    } else if (result.found) {
      return 'found';
    } else {
      return 'notFound';
    }
  };
  
  // Get status chip color
  const getStatusColor = (status) => {
    switch (status) {
      case 'unique':
        return 'success';
      case 'found':
        return 'warning';
      case 'notFound':
        return 'error';
      default:
        return 'default';
    }
  };
  
  // Get status label
  const getStatusLabel = (status) => {
    switch (status) {
      case 'unique':
        return 'Unique';
      case 'found':
        return 'Multiple';
      case 'notFound':
        return 'Not Found';
      default:
        return 'Unknown';
    }
  };
  
  // Generate selectors on component mount if we have an element
  useEffect(() => {
    if (elementInfo && sessionId && Object.keys(generatedSelectors).length === 0) {
      generateSelectors();
    }
  }, [elementInfo, sessionId]);
  
  // Render generator UI
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title="Selector Generator" 
          subheader={
            hasElement 
              ? `Generating selectors for ${elementInfo.tagName} element`
              : "No element selected"
          }
          action={
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <FormControlLabel
                control={
                  <Switch
                    checked={includeUnique}
                    onChange={(e) => setIncludeUnique(e.target.checked)}
                    size="small"
                  />
                }
                label="Unique"
                sx={{ mr: 1 }}
              />
              <FormControlLabel
                control={
                  <Switch
                    checked={includeRobust}
                    onChange={(e) => setIncludeRobust(e.target.checked)}
                    size="small"
                  />
                }
                label="Robust"
              />
            </Box>
          }
        />
        <Divider />
        <CardContent>
          {hasElement && (
            <Box>
              <Tabs
                value={currentTab}
                onChange={handleTabChange}
                variant="fullWidth"
                sx={{ mb: 2 }}
              >
                <Tab label="Generated Selectors" />
                <Tab label="Custom Selector" />
              </Tabs>
              
              {currentTab === 0 && (
                <Box>
                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                    <Button
                      variant="outlined"
                      startIcon={<RefreshIcon />}
                      onClick={generateSelectors}
                      disabled={loading}
                    >
                      {loading ? <CircularProgress size={24} /> : 'Regenerate'}
                    </Button>
                  </Box>
                  
                  {loading && <LinearProgress sx={{ mb: 2 }} />}
                  
                  <TableContainer component={Paper} variant="outlined">
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell>Type</TableCell>
                          <TableCell>Selector</TableCell>
                          <TableCell>Status</TableCell>
                          <TableCell>Actions</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {Object.entries(generatedSelectors).length === 0 ? (
                          <TableRow>
                            <TableCell colSpan={4} align="center">
                              <Typography variant="body2" color="text.secondary">
                                No selectors generated yet
                              </Typography>
                            </TableCell>
                          </TableRow>
                        ) : (
                          Object.entries(generatedSelectors).map(([type, selector]) => {
                            const result = testResults[type];
                            const status = getTestStatus(result);
                            
                            return (
                              <TableRow key={type}>
                                <TableCell>
                                  <Chip 
                                    label={type} 
                                    size="small" 
                                    color={
                                      type === 'id' ? 'success' :
                                      type === 'data-testid' ? 'primary' :
                                      type === 'xpath' ? 'warning' :
                                      type === 'css' ? 'info' :
                                      'default'
                                    }
                                  />
                                </TableCell>
                                <TableCell>
                                  <Typography 
                                    variant="body2" 
                                    sx={{ 
                                      fontFamily: 'monospace',
                                      whiteSpace: 'nowrap',
                                      overflow: 'hidden',
                                      textOverflow: 'ellipsis',
                                      maxWidth: '200px'
                                    }}
                                  >
                                    {selector}
                                  </Typography>
                                </TableCell>
                                <TableCell>
                                  <Chip 
                                    label={getStatusLabel(status)} 
                                    size="small" 
                                    color={getStatusColor(status)}
                                    icon={
                                      status === 'unique' ? <VerifiedIcon /> :
                                      status === 'notFound' ? <ErrorIcon /> :
                                      null
                                    }
                                  />
                                </TableCell>
                                <TableCell>
                                  <Tooltip title="Use This Selector">
                                    <IconButton 
                                      size="small" 
                                      color="primary"
                                      onClick={() => chooseSelector(selector)}
                                      disabled={status === 'notFound'}
                                    >
                                      <CheckIcon fontSize="small" />
                                    </IconButton>
                                  </Tooltip>
                                  <Tooltip title="Copy to Clipboard">
                                    <IconButton 
                                      size="small"
                                      onClick={() => copySelector(selector)}
                                    >
                                      <CopyIcon fontSize="small" />
                                    </IconButton>
                                  </Tooltip>
                                  <Tooltip title="Edit">
                                    <IconButton 
                                      size="small"
                                      onClick={() => {
                                        setSelector(selector);
                                        setSelectorType(type === 'xpath' ? 'xpath' : 'css');
                                        setCurrentTab(1);
                                        setEditMode(true);
                                      }}
                                    >
                                      <EditIcon fontSize="small" />
                                    </IconButton>
                                  </Tooltip>
                                </TableCell>
                              </TableRow>
                            );
                          })
                        )}
                      </TableBody>
                    </Table>
                  </TableContainer>
                  
                  {/* Custom Selectors Table */}
                  {customSelectors.length > 0 && (
                    <Box sx={{ mt: 3 }}>
                      <Typography variant="subtitle1" gutterBottom>
                        Custom Selectors
                      </Typography>
                      
                      <TableContainer component={Paper} variant="outlined">
                        <Table size="small">
                          <TableHead>
                            <TableRow>
                              <TableCell>Type</TableCell>
                              <TableCell>Selector</TableCell>
                              <TableCell>Status</TableCell>
                              <TableCell>Actions</TableCell>
                            </TableRow>
                          </TableHead>
                          <TableBody>
                            {customSelectors.map((custom, index) => {
                              const status = getTestStatus(custom.result);
                              
                              return (
                                <TableRow key={index}>
                                  <TableCell>
                                    <Chip 
                                      label={custom.type} 
                                      size="small" 
                                      color={
                                        custom.type === 'xpath' ? 'warning' : 'info'
                                      }
                                    />
                                  </TableCell>
                                  <TableCell>
                                    <Typography 
                                      variant="body2" 
                                      sx={{ 
                                        fontFamily: 'monospace',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        maxWidth: '200px'
                                      }}
                                    >
                                      {custom.selector}
                                    </Typography>
                                  </TableCell>
                                  <TableCell>
                                    <Chip 
                                      label={getStatusLabel(status)} 
                                      size="small" 
                                      color={getStatusColor(status)}
                                      icon={
                                        status === 'unique' ? <VerifiedIcon /> :
                                        status === 'notFound' ? <ErrorIcon /> :
                                        null
                                      }
                                    />
                                  </TableCell>
                                  <TableCell>
                                    <Tooltip title="Use This Selector">
                                      <IconButton 
                                        size="small" 
                                        color="primary"
                                        onClick={() => chooseSelector(custom.selector)}
                                        disabled={status === 'notFound'}
                                      >
                                        <CheckIcon fontSize="small" />
                                      </IconButton>
                                    </Tooltip>
                                    <Tooltip title="Copy to Clipboard">
                                      <IconButton 
                                        size="small"
                                        onClick={() => copySelector(custom.selector)}
                                      >
                                        <CopyIcon fontSize="small" />
                                      </IconButton>
                                    </Tooltip>
                                    <Tooltip title="Remove">
                                      <IconButton 
                                        size="small"
                                        color="error"
                                        onClick={() => removeCustomSelector(index)}
                                      >
                                        <ErrorIcon fontSize="small" />
                                      </IconButton>
                                    </Tooltip>
                                  </TableCell>
                                </TableRow>
                              );
                            })}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Box>
                  )}
                </Box>
              )}
              
              {currentTab === 1 && (
                <Box>
                  <Grid container spacing={2} alignItems="center">
                    <Grid item xs={12} sm={8}>
                      <TextField
                        fullWidth
                        label="Custom Selector"
                        value={selector}
                        onChange={(e) => setSelector(e.target.value)}
                        placeholder="Enter CSS selector or XPath"
                        variant="outlined"
                        disabled={loading}
                      />
                    </Grid>
                    
                    <Grid item xs={12} sm={4}>
                      <TextField
                        select
                        fullWidth
                        label="Selector Type"
                        value={selectorType}
                        onChange={(e) => setSelectorType(e.target.value)}
                        disabled={loading}
                        SelectProps={{
                          native: true
                        }}
                      >
                        <option value="css">CSS</option>
                        <option value="xpath">XPath</option>
                      </TextField>
                    </Grid>
                    
                    <Grid item xs={12}>
                      <Box sx={{ display: 'flex', gap: 1 }}>
                        <Button
                          variant="contained"
                          color="primary"
                          onClick={addCustomSelector}
                          disabled={loading || !selector}
                          startIcon={<CheckIcon />}
                        >
                          {loading ? <CircularProgress size={24} /> : (editMode ? 'Update' : 'Add')}
                        </Button>
                        
                        <Button
                          variant="outlined"
                          onClick={optimizeSelector}
                          disabled={loading || !selector}
                          startIcon={<RefreshIcon />}
                        >
                          Optimize
                        </Button>
                        
                        <Button
                          variant="outlined"
                          color="secondary"
                          onClick={() => testSelector(selector)}
                          disabled={loading || !selector}
                          startIcon={<VerifiedIcon />}
                        >
                          Test
                        </Button>
                      </Box>
                    </Grid>
                  </Grid>
                  
                  {/* Selector test results */}
                  {testResults.custom && (
                    <Alert 
                      severity={
                        testResults.custom.unique ? 'success' :
                        testResults.custom.found ? 'warning' :
                        'error'
                      }
                      sx={{ mt: 2 }}
                    >
                      {testResults.custom.unique && 'Selector is unique and matches exactly one element.'}
                      {testResults.custom.found && !testResults.custom.unique && 
                        `Selector matches ${testResults.custom.count} elements. Consider making it more specific.`}
                      {!testResults.custom.found && 'Selector does not match any elements.'}
                    </Alert>
                  )}
                </Box>
              )}
            </Box>
          )}
          
          {!hasElement && (
            <Alert severity="info">
              Please select an element first using the Element Inspector.
            </Alert>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default SelectorGenerator;


// src/components/recorder/AssertionPanel.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  FormControlLabel,
  Switch,
  Grid,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  CircularProgress,
  Alert,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction
} from '@mui/material';
import {
  VerifiedUser as VerifiedIcon,
  RemoveCircleOutline as RemoveIcon,
  AddCircleOutline as AddIcon,
  CheckCircleOutline as CheckIcon,
  ErrorOutline as ErrorIcon,
  VisibilityOutlined as VisibilityIcon,
  TextFieldsOutlined as TextIcon,
  FormatListNumberedOutlined as ListIcon,
  CodeOutlined as CodeIcon,
  EditOutlined as EditIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Assertion Panel Component
 * Allows creating and managing assertions for test recording
 */
const AssertionPanel = ({ sessionId, elementInfo, selector, onAssertionAdded }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [assertionType, setAssertionType] = useState('visible');
  const [expectedValue, setExpectedValue] = useState('');
  const [propertyName, setPropertyName] = useState('');
  const [comparisonType, setComparisonType] = useState('equals');
  const [assertions, setAssertions] = useState([]);
  const [currentValues, setCurrentValues] = useState({});
  const [testResult, setTestResult] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [editingAssertion, setEditingAssertion] = useState(null);
  
  // Load assertions on component mount
  useEffect(() => {
    if (sessionId) {
      loadAssertions();
    }
  }, [sessionId]);
  
  // Get current values when element or selector changes
  useEffect(() => {
    if (sessionId && selector) {
      getCurrentValues();
    }
  }, [sessionId, selector, elementInfo]);
  
  // Reset form when assertion type changes
  useEffect(() => {
    setExpectedValue('');
    setPropertyName('');
    
    // Set expected value based on current values
    if (assertionType === 'text' && currentValues.text) {
      setExpectedValue(currentValues.text);
    } else if (assertionType === 'value' && currentValues.value) {
      setExpectedValue(currentValues.value);
    } else if (assertionType === 'attribute' && propertyName && currentValues.attributes) {
      setExpectedValue(currentValues.attributes[propertyName] || '');
    }
  }, [assertionType, propertyName, currentValues]);
  
  // Load assertions
  const loadAssertions = async () => {
    try {
      setLoading(true);
      
      const response = await api.get(`/recorder/sessions/${sessionId}/assertions`);
      
      setAssertions(response.data || []);
      setLoading(false);
    } catch (error) {
      console.error('Error loading assertions:', error);
      setLoading(false);
      enqueueSnackbar('Failed to load assertions', { variant: 'error' });
    }
  };
  
  // Get current values
  const getCurrentValues = async () => {
    if (!selector) return;
    
    try {
      setLoading(true);
      
      const response = await api.post(
        `/recorder/sessions/${sessionId}/elements/properties`,
        { selector }
      );
      
      setCurrentValues(response.data || {});
      setLoading(false);
    } catch (error) {
      console.error('Error getting element properties:', error);
      setLoading(false);
      enqueueSnackbar('Failed to get element properties', { variant: 'error' });
    }
  };
  
  // Create assertion
  const createAssertion = async () => {
    if (!selector) {
      enqueueSnackbar('Please provide a selector', { variant: 'warning' });
      return;
    }
    
    // Validate expected value
    if (assertionType !== 'visible' && !expectedValue && assertionType !== 'not-visible') {
      enqueueSnackbar('Please provide an expected value', { variant: 'warning' });
      return;
    }
    
    // Validate property name for attribute assertions
    if (assertionType === 'attribute' && !propertyName) {
      enqueueSnackbar('Please provide an attribute name', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      const assertion = {
        type: assertionType,
        selector,
        expectedValue,
        propertyName: assertionType === 'attribute' ? propertyName : undefined,
        comparisonType: ['text', 'value', 'attribute'].includes(assertionType) ? comparisonType : undefined
      };
      
      // Create or update assertion
      let response;
      
      if (editMode && editingAssertion) {
        response = await api.put(
          `/recorder/sessions/${sessionId}/assertions/${editingAssertion.id}`,
          assertion
        );
        
        enqueueSnackbar('Assertion updated', { variant: 'success' });
      } else {
        response = await api.post(
          `/recorder/sessions/${sessionId}/assertions`,
          assertion
        );
        
        enqueueSnackbar('Assertion added', { variant: 'success' });
      }
      
      // Reset form
      resetForm();
      
      // Reload assertions
      await loadAssertions();
      
      // Notify parent
      if (onAssertionAdded) {
        onAssertionAdded(response.data);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error creating assertion:', error);
      setLoading(false);
      enqueueSnackbar('Failed to create assertion', { variant: 'error' });
    }
  };
  
  // Delete assertion
  const deleteAssertion = async (assertionId) => {
    try {
      setLoading(true);
      
      await api.delete(`/recorder/sessions/${sessionId}/assertions/${assertionId}`);
      
      // Reload assertions
      await loadAssertions();
      
      enqueueSnackbar('Assertion deleted', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error deleting assertion:', error);
      setLoading(false);
      enqueueSnackbar('Failed to delete assertion', { variant: 'error' });
    }
  };
  
  // Test assertion
  const testAssertion = async () => {
    if (!selector) {
      enqueueSnackbar('Please provide a selector', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      const assertion = {
        type: assertionType,
        selector,
        expectedValue,
        propertyName: assertionType === 'attribute' ? propertyName : undefined,
        comparisonType: ['text', 'value', 'attribute'].includes(assertionType) ? comparisonType : undefined
      };
      
      const response = await api.post(
        `/recorder/sessions/${sessionId}/assertions/test`,
        assertion
      );
      
      setTestResult(response.data);
      setLoading(false);
    } catch (error) {
      console.error('Error testing assertion:', error);
      setLoading(false);
      enqueueSnackbar('Failed to test assertion', { variant: 'error' });
    }
  };
  
  // Edit assertion
  const editAssertion = (assertion) => {
    setAssertionType(assertion.type);
    setExpectedValue(assertion.expectedValue || '');
    setPropertyName(assertion.propertyName || '');
    setComparisonType(assertion.comparisonType || 'equals');
    setEditMode(true);
    setEditingAssertion(assertion);
  };
  
  // Reset form
  const resetForm = () => {
    setAssertionType('visible');
    setExpectedValue('');
    setPropertyName('');
    setComparisonType('equals');
    setEditMode(false);
    setEditingAssertion(null);
    setTestResult(null);
  };
  
  // Get assertion description
  const getAssertionDescription = (assertion) => {
    switch (assertion.type) {
      case 'visible':
        return `Element should be visible`;
      case 'not-visible':
        return `Element should not be visible`;
      case 'text':
        return `Text ${getComparisonText(assertion.comparisonType)} "${assertion.expectedValue}"`;
      case 'value':
        return `Value ${getComparisonText(assertion.comparisonType)} "${assertion.expectedValue}"`;
      case 'attribute':
        return `Attribute ${assertion.propertyName} ${getComparisonText(assertion.comparisonType)} "${assertion.expectedValue}"`;
      case 'count':
        return `Element count should be ${assertion.expectedValue}`;
      case 'css-property':
        return `CSS property ${assertion.propertyName} ${getComparisonText(assertion.comparisonType)} "${assertion.expectedValue}"`;
      default:
        return `Unknown assertion`;
    }
  };
  
  // Get comparison text
  const getComparisonText = (comparison) => {
    switch (comparison) {
      case 'equals':
        return 'should equal';
      case 'contains':
        return 'should contain';
      case 'startsWith':
        return 'should start with';
      case 'endsWith':
        return 'should end with';
      case 'matches':
        return 'should match regex';
      default:
        return 'should be';
    }
  };
  
  // Get assertion icon
  const getAssertionIcon = (type) => {
    switch (type) {
      case 'visible':
      case 'not-visible':
        return <VisibilityIcon />;
      case 'text':
        return <TextIcon />;
      case 'value':
        return <TextIcon />;
      case 'attribute':
        return <CodeIcon />;
      case 'count':
        return <ListIcon />;
      case 'css-property':
        return <CodeIcon />;
      default:
        return <VerifiedIcon />;
    }
  };
  
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title={editMode ? "Edit Assertion" : "Add Assertion"} 
          subheader={
            selector 
              ? `Creating assertion for selector: ${selector}`
              : "Select an element and provide a selector first"
          }
        />
        <Divider />
        <CardContent>
          {!selector ? (
            <Alert severity="info">
              Please select an element and provide a selector first.
            </Alert>
          ) : (
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <FormControl fullWidth>
                  <InputLabel>Assertion Type</InputLabel>
                  <Select
                    value={assertionType}
                    onChange={(e) => setAssertionType(e.target.value)}
                    label="Assertion Type"
                    disabled={loading}
                  >
                    <MenuItem value="visible">Element is Visible</MenuItem>
                    <MenuItem value="not-visible">Element is Not Visible</MenuItem>
                    <MenuItem value="text">Element Text</MenuItem>
                    <MenuItem value="value">Element Value</MenuItem>
                    <MenuItem value="attribute">Element Attribute</MenuItem>
                    <MenuItem value="count">Element Count</MenuItem>
                    <MenuItem value="css-property">CSS Property</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              {assertionType === 'attribute' && (
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Attribute Name"
                    value={propertyName}
                    onChange={(e) => setPropertyName(e.target.value)}
                    disabled={loading}
                    placeholder="e.g., id, class, data-testid"
                  />
                </Grid>
              )}
              
              {assertionType === 'css-property' && (
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="CSS Property"
                    value={propertyName}
                    onChange={(e) => setPropertyName(e.target.value)}
                    disabled={loading}
                    placeholder="e.g., color, display, font-size"
                  />
                </Grid>
              )}
              
              {['text', 'value', 'attribute', 'css-property'].includes(assertionType) && (
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Comparison</InputLabel>
                    <Select
                      value={comparisonType}
                      onChange={(e) => setComparisonType(e.target.value)}
                      label="Comparison"
                      disabled={loading}
                    >
                      <MenuItem value="equals">Equals</MenuItem>
                      <MenuItem value="contains">Contains</MenuItem>
                      <MenuItem value="startsWith">Starts With</MenuItem>
                      <MenuItem value="endsWith">Ends With</MenuItem>
                      <MenuItem value="matches">Matches Regex</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              )}
              
              {assertionType !== 'visible' && assertionType !== 'not-visible' && (
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Expected Value"
                    value={expectedValue}
                    onChange={(e) => setExpectedValue(e.target.value)}
                    disabled={loading}
                    multiline={assertionType === 'text'}
                    rows={assertionType === 'text' ? 2 : 1}
                  />
                </Grid>
              )}
              
              {/* Current value display */}
              {['text', 'value', 'attribute'].includes(assertionType) && (
                <Grid item xs={12}>
                  <Typography variant="subtitle2" gutterBottom>
                    Current Value:
                  </Typography>
                  <Paper 
                    variant="outlined" 
                    sx={{ 
                      p: 1,
                      backgroundColor: '#f5f5f5',
                      fontFamily: 'monospace',
                      minHeight: '24px',
                      maxHeight: '100px',
                      overflow: 'auto'
                    }}
                  >
                    {assertionType === 'text' && currentValues.text}
                    {assertionType === 'value' && currentValues.value}
                    {assertionType === 'attribute' && propertyName && 
                      currentValues.attributes && currentValues.attributes[propertyName]}
                    {assertionType === 'attribute' && (!propertyName || !currentValues.attributes) && 
                      'Please specify an attribute name'}
                  </Paper>
                </Grid>
              )}
              
              {/* Test result */}
              {testResult && (
                <Grid item xs={12}>
                  <Alert 
                    severity={testResult.passed ? 'success' : 'error'}
                    sx={{ mt: 1 }}
                  >
                    {testResult.passed ? 'Assertion passed' : `Assertion failed: ${testResult.message}`}
                  </Alert>
                </Grid>
              )}
              
              <Grid item xs={12}>
                <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
                  {editMode && (
                    <Button
                      color="secondary"
                      onClick={resetForm}
                      disabled={loading}
                    >
                      Cancel
                    </Button>
                  )}
                  
                  <Button
                    variant="outlined"
                    onClick={testAssertion}
                    disabled={loading || 
                      (assertionType === 'attribute' && !propertyName) ||
                      (assertionType === 'css-property' && !propertyName)}
                    startIcon={<VerifiedIcon />}
                  >
                    Test
                  </Button>
                  
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={createAssertion}
                    disabled={loading || 
                      (assertionType === 'attribute' && !propertyName) ||
                      (assertionType === 'css-property' && !propertyName)}
                    startIcon={editMode ? <EditIcon /> : <AddIcon />}
                  >
                    {loading ? <CircularProgress size={24} /> : (editMode ? 'Update' : 'Add Assertion')}
                  </Button>
                </Box>
              </Grid>
            </Grid>
          )}
        </CardContent>
      </Card>
      
      {/* Assertions List */}
      <Card>
        <CardHeader 
          title="Assertions" 
          subheader={`${assertions.length} assertion${assertions.length !== 1 ? 's' : ''}`}
        />
        <Divider />
        <CardContent>
          {assertions.length === 0 ? (
            <Typography variant="body2" color="text.secondary" align="center">
              No assertions yet. Add an assertion using the form above.
            </Typography>
          ) : (
            <List>
              {assertions.map((assertion, index) => (
                <ListItem 
                  key={assertion.id} 
                  divider={index < assertions.length - 1}
                  sx={{
                    backgroundColor: assertion.type === 'visible' ? 'rgba(33, 150, 243, 0.05)' :
                                      assertion.type === 'text' ? 'rgba(76, 175, 80, 0.05)' :
                                      'transparent'
                  }}
                >
                  <ListItemIcon>
                    {getAssertionIcon(assertion.type)}
                  </ListItemIcon>
                  <ListItemText
                    primary={getAssertionDescription(assertion)}
                    secondary={
                      <Typography variant="caption" component="span">
                        Selector: <code>{assertion.selector}</code>
                      </Typography>
                    }
                  />
                  <ListItemSecondaryAction>
                    <Tooltip title="Edit">
                      <IconButton 
                        edge="end" 
                        onClick={() => editAssertion(assertion)}
                        disabled={loading}
                      >
                        <EditIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete">
                      <IconButton 
                        edge="end" 
                        onClick={() => deleteAssertion(assertion.id)}
                        disabled={loading}
                      >
                        <RemoveIcon />
                      </IconButton>
                    </Tooltip>
                  </ListItemSecondaryAction>
                </ListItem>
              ))}
            </List>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default AssertionPanel;


// src/components/recorder/WaitConditionPanel.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  Grid,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  CircularProgress,
  Alert,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  Slider
} from '@mui/material';
import {
  RemoveCircleOutline as RemoveIcon,
  AddCircleOutline as AddIcon,
  TimerOutlined as TimerIcon,
  VisibilityOutlined as VisibilityIcon,
  TextFieldsOutlined as TextIcon,
  NavigateNextOutlined as NavigateIcon,
  EditOutlined as EditIcon,
  DeleteOutline as DeleteIcon,
  HourglassEmptyOutlined as HourglassIcon,
  CheckCircleOutline as CheckIcon,
  ErrorOutline as ErrorIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Wait Condition Panel Component
 * Allows creating and managing wait conditions for test recording
 */
const WaitConditionPanel = ({ sessionId, selector, onWaitConditionAdded }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [waitType, setWaitType] = useState('element');
  const [timeout, setTimeout] = useState(5000);
  const [waitConditions, setWaitConditions] = useState([]);
  const [testResult, setTestResult] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [editingCondition, setEditingCondition] = useState(null);
  const [expectedText, setExpectedText] = useState('');
  const [waitForOption, setWaitForOption] = useState('present');
  
  // Load wait conditions on component mount
  useEffect(() => {
    if (sessionId) {
      loadWaitConditions();
    }
  }, [sessionId]);
  
  // Load wait conditions
  const loadWaitConditions = async () => {
    try {
      setLoading(true);
      
      const response = await api.get(`/recorder/sessions/${sessionId}/wait-conditions`);
      
      setWaitConditions(response.data || []);
      setLoading(false);
    } catch (error) {
      console.error('Error loading wait conditions:', error);
      setLoading(false);
      enqueueSnackbar('Failed to load wait conditions', { variant: 'error' });
    }
  };
  
  // Create wait condition
  const createWaitCondition = async () => {
    if (waitType === 'element' && !selector) {
      enqueueSnackbar('Please provide a selector for element wait condition', { variant: 'warning' });
      return;
    }
    
    if (waitType === 'text' && !expectedText) {
      enqueueSnackbar('Please provide expected text for text wait condition', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      const waitCondition = {
        type: waitType,
        timeout,
        selector: waitType === 'element' ? selector : undefined,
        expectedText: waitType === 'text' ? expectedText : undefined,
        option: waitType === 'element' ? waitForOption : undefined
      };
      
      // Create or update wait condition
      let response;
      
      if (editMode && editingCondition) {
        response = await api.put(
          `/recorder/sessions/${sessionId}/wait-conditions/${editingCondition.id}`,
          waitCondition
        );
        
        enqueueSnackbar('Wait condition updated', { variant: 'success' });
      } else {
        response = await api.post(
          `/recorder/sessions/${sessionId}/wait-conditions`,
          waitCondition
        );
        
        enqueueSnackbar('Wait condition added', { variant: 'success' });
      }
      
      // Reset form
      resetForm();
      
      // Reload wait conditions
      await loadWaitConditions();
      
      // Notify parent
      if (onWaitConditionAdded) {
        onWaitConditionAdded(response.data);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error creating wait condition:', error);
      setLoading(false);
      enqueueSnackbar('Failed to create wait condition', { variant: 'error' });
    }
  };
  
  // Delete wait condition
  const deleteWaitCondition = async (conditionId) => {
    try {
      setLoading(true);
      
      await api.delete(`/recorder/sessions/${sessionId}/wait-conditions/${conditionId}`);
      
      // Reload wait conditions
      await loadWaitConditions();
      
      enqueueSnackbar('Wait condition deleted', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error deleting wait condition:', error);
      setLoading(false);
      enqueueSnackbar('Failed to delete wait condition', { variant: 'error' });
    }
  };
  
  // Test wait condition
  const testWaitCondition = async () => {
    if (waitType === 'element' && !selector) {
      enqueueSnackbar('Please provide a selector for element wait condition', { variant: 'warning' });
      return;
    }
    
    if (waitType === 'text' && !expectedText) {
      enqueueSnackbar('Please provide expected text for text wait condition', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      setTestResult(null);
      
      const waitCondition = {
        type: waitType,
        timeout: 2000, // Use shorter timeout for testing
        selector: waitType === 'element' ? selector : undefined,
        expectedText: waitType === 'text' ? expectedText : undefined,
        option: waitType === 'element' ? waitForOption : undefined
      };
      
      const response = await api.post(
        `/recorder/sessions/${sessionId}/wait-conditions/test`,
        waitCondition
      );
      
      setTestResult(response.data);
      setLoading(false);
    } catch (error) {
      console.error('Error testing wait condition:', error);
      setLoading(false);
      setTestResult({
        success: false,
        message: error.response?.data?.message || 'Failed to test wait condition'
      });
    }
  };
  
  // Edit wait condition
  const editWaitCondition = (condition) => {
    setWaitType(condition.type);
    setTimeout(condition.timeout);
    
    if (condition.type === 'element') {
      setWaitForOption(condition.option || 'present');
    }
    
    if (condition.type === 'text') {
      setExpectedText(condition.expectedText || '');
    }
    
    setEditMode(true);
    setEditingCondition(condition);
  };
  
  // Reset form
  const resetForm = () => {
    setWaitType('element');
    setTimeout(5000);
    setExpectedText('');
    setWaitForOption('present');
    setEditMode(false);
    setEditingCondition(null);
    setTestResult(null);
  };
  
  // Format timeout
  const formatTimeout = (ms) => {
    if (ms < 1000) {
      return `${ms}ms`;
    }
    return `${(ms / 1000).toFixed(1)}s`;
  };
  
  // Get wait condition description
  const getWaitConditionDescription = (condition) => {
    switch (condition.type) {
      case 'element':
        return `Wait for element to be ${condition.option || 'present'} (${formatTimeout(condition.timeout)})`;
      case 'navigation':
        return `Wait for navigation to complete (${formatTimeout(condition.timeout)})`;
      case 'text':
        return `Wait for text "${condition.expectedText}" (${formatTimeout(condition.timeout)})`;
      case 'timeout':
        return `Wait for ${formatTimeout(condition.timeout)}`;
      default:
        return `Unknown wait condition (${formatTimeout(condition.timeout)})`;
    }
  };
  
  // Get condition icon
  const getConditionIcon = (type) => {
    switch (type) {
      case 'element':
        return <VisibilityIcon />;
      case 'navigation':
        return <NavigateIcon />;
      case 'text':
        return <TextIcon />;
      case 'timeout':
        return <TimerIcon />;
      default:
        return <HourglassIcon />;
    }
  };
  
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title={editMode ? "Edit Wait Condition" : "Add Wait Condition"} 
          subheader="Configure waiting for specific conditions during test execution"
        />
        <Divider />
        <CardContent>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Wait Type</InputLabel>
                <Select
                  value={waitType}
                  onChange={(e) => setWaitType(e.target.value)}
                  label="Wait Type"
                  disabled={loading}
                >
                  <MenuItem value="element">Wait for Element</MenuItem>
                  <MenuItem value="navigation">Wait for Navigation</MenuItem>
                  <MenuItem value="text">Wait for Text</MenuItem>
                  <MenuItem value="timeout">Fixed Timeout</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            {waitType === 'element' && (
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Wait For</InputLabel>
                  <Select
                    value={waitForOption}
                    onChange={(e) => setWaitForOption(e.target.value)}
                    label="Wait For"
                    disabled={loading}
                  >
                    <MenuItem value="present">Element to be Present</MenuItem>
                    <MenuItem value="visible">Element to be Visible</MenuItem>
                    <MenuItem value="clickable">Element to be Clickable</MenuItem>
                    <MenuItem value="not-present">Element to be Not Present</MenuItem>
                    <MenuItem value="not-visible">Element to be Not Visible</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            )}
            
            {waitType === 'text' && (
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Expected Text"
                  value={expectedText}
                  onChange={(e) => setExpectedText(e.target.value)}
                  disabled={loading}
                />
              </Grid>
            )}
            
            <Grid item xs={12}>
              <Typography id="timeout-slider" gutterBottom>
                Timeout: {formatTimeout(timeout)}
              </Typography>
              <Slider
                value={timeout}
                onChange={(e, newValue) => setTimeout(newValue)}
                min={1000}
                max={60000}
                step={1000}
                valueLabelDisplay="auto"
                valueLabelFormat={formatTimeout}
                disabled={loading}
                aria-labelledby="timeout-slider"
              />
            </Grid>
            
            {/* Current element info */}
            {waitType === 'element' && (
              <Grid item xs={12}>
                <Box sx={{ p: 2, bgcolor: '#f5f5f5', borderRadius: 1 }}>
                  <Typography variant="subtitle2" gutterBottom>
                    Element Selector:
                  </Typography>
                  <Typography variant="body2" fontFamily="monospace">
                    {selector || 'No selector provided'}
                  </Typography>
                </Box>
              </Grid>
            )}
            
            {/* Test result */}
            {testResult && (
              <Grid item xs={12}>
                <Alert 
                  severity={testResult.success ? 'success' : 'error'}
                  sx={{ mt: 1 }}
                >
                  {testResult.success 
                    ? 'Wait condition satisfied' 
                    : `Wait condition failed: ${testResult.message}`}
                </Alert>
              </Grid>
            )}
            
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
                {editMode && (
                  <Button
                    color="secondary"
                    onClick={resetForm}
                    disabled={loading}
                  >
                    Cancel
                  </Button>
                )}
                
                <Button
                  variant="outlined"
                  onClick={testWaitCondition}
                  disabled={loading || (waitType === 'element' && !selector) || (waitType === 'text' && !expectedText)}
                  startIcon={<CheckIcon />}
                >
                  Test
                </Button>
                
                <Button
                  variant="contained"
                  color="primary"
                  onClick={createWaitCondition}
                  disabled={loading || (waitType === 'element' && !selector) || (waitType === 'text' && !expectedText)}
                  startIcon={editMode ? <EditIcon /> : <AddIcon />}
                >
                  {loading ? <CircularProgress size={24} /> : (editMode ? 'Update' : 'Add Condition')}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
      
      {/* Wait Conditions List */}
      <Card>
        <CardHeader 
          title="Wait Conditions" 
          subheader={`${waitConditions.length} condition${waitConditions.length !== 1 ? 's' : ''}`}
        />
        <Divider />
        <CardContent>
          {waitConditions.length === 0 ? (
            <Typography variant="body2" color="text.secondary" align="center">
              No wait conditions yet. Add a condition using the form above.
            </Typography>
          ) : (
            <List>
              {waitConditions.map((condition, index) => (
                <ListItem 
                  key={condition.id} 
                  divider={index < waitConditions.length - 1}
                  sx={{
                    backgroundColor: condition.type === 'element' ? 'rgba(33, 150, 243, 0.05)' :
                                      condition.type === 'timeout' ? 'rgba(156, 39, 176, 0.05)' :
                                      'transparent'
                  }}
                >
                  <ListItemIcon>
                    {getConditionIcon(condition.type)}
                  </ListItemIcon>
                  <ListItemText
                    primary={getWaitConditionDescription(condition)}
                    secondary={
                      condition.type === 'element' && condition.selector ? (
                        <Typography variant="caption" component="span">
                          Selector: <code>{condition.selector}</code>
                        </Typography>
                      ) : null
                    }
                  />
                  <ListItemSecondaryAction>
                    <Tooltip title="Edit">
                      <IconButton 
                        edge="end" 
                        onClick={() => editWaitCondition(condition)}
                        disabled={loading}
                      >
                        <EditIcon />
                      </IconButton>
                    </Tooltip>
                    <Tooltip title="Delete">
                      <IconButton 
                        edge="end" 
                        onClick={() => deleteWaitCondition(condition.id)}
                        disabled={loading}
                      >
                        <DeleteIcon />
                      </IconButton>
                    </Tooltip>
                  </ListItemSecondaryAction>
                </ListItem>
              ))}
            </List>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default WaitConditionPanel;


// src/components/recorder/DataInputPanel.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  Grid,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  CircularProgress,
  Alert,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  ListItemSecondaryAction,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Switch,
  FormControlLabel
} from '@mui/material';
import {
  AddCircleOutline as AddIcon,
  RemoveCircleOutline as RemoveIcon,
  FormatListBulleted as ListIcon,
  TextFields as TextIcon,
  Functions as FunctionIcon,
  DateRange as DateIcon,
  Email as EmailIcon,
  Person as PersonIcon,
  Phone as PhoneIcon,
  CreditCard as CreditCardIcon,
  EditOutlined as EditIcon,
  DeleteOutline as DeleteIcon,
  KeyboardTab as TabIcon,
  Dangerous as ErrorIcon,
  SaveOutlined as SaveIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Data Input Panel Component
 * Manages test data inputs for form filling and test parameterization
 */
const DataInputPanel = ({ sessionId, selector, onDataInputAdded }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [dataInputs, setDataInputs] = useState([]);
  const [inputType, setInputType] = useState('text');
  const [dataValue, setDataValue] = useState('');
  const [fieldName, setFieldName] = useState('');
  const [dataSets, setDataSets] = useState([]);
  const [currentDataSet, setCurrentDataSet] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [editingInput, setEditingInput] = useState(null);
  const [pressSpecialKey, setPressSpecialKey] = useState(false);
  const [specialKey, setSpecialKey] = useState('Tab');
  
  // Template generators
  const dataTemplates = {
    firstName: ['John', 'Jane', 'Michael', 'Sarah', 'David', 'Emily'],
    lastName: ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis'],
    email: ['test@example.com', 'user@test.org', 'sample@mail.com'],
    phone: ['123-456-7890', '(555) 123-4567', '555-987-6543'],
    address: ['123 Main St', '456 Elm Avenue', '789 Oak Drive'],
    creditCard: ['4111111111111111', '5555555555554444', '378282246310005'],
    date: [
      new Date().toISOString().split('T')[0],
      new Date(Date.now() + 86400000).toISOString().split('T')[0]
    ]
  };
  
  // Special keys for keyboard input
  const specialKeys = [
    'Tab', 'Enter', 'Escape', 'Backspace', 'Delete', 
    'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
    'Home', 'End', 'PageUp', 'PageDown'
  ];
  
  // Load data inputs on component mount
  useEffect(() => {
    if (sessionId) {
      loadDataInputs();
      loadDataSets();
    }
  }, [sessionId]);
  
  // Load data inputs
  const loadDataInputs = async () => {
    try {
      setLoading(true);
      
      const response = await api.get(`/recorder/sessions/${sessionId}/data-inputs`);
      
      setDataInputs(response.data || []);
      setLoading(false);
    } catch (error) {
      console.error('Error loading data inputs:', error);
      setLoading(false);
      enqueueSnackbar('Failed to load data inputs', { variant: 'error' });
    }
  };
  
  // Load data sets
  const loadDataSets = async () => {
    try {
      const response = await api.get(`/projects/${sessionId.split('-')[0]}/data-sets`);
      
      setDataSets(response.data || []);
    } catch (error) {
      console.error('Error loading data sets:', error);
      enqueueSnackbar('Failed to load data sets', { variant: 'error' });
    }
  };
  
  // Create data input
  const createDataInput = async () => {
    if (!selector && inputType !== 'special-key') {
      enqueueSnackbar('Please provide a selector for data input', { variant: 'warning' });
      return;
    }
    
    if (inputType === 'special-key' && !specialKey) {
      enqueueSnackbar('Please select a special key', { variant: 'warning' });
      return;
    }
    
    if (inputType !== 'special-key' && !dataValue) {
      enqueueSnackbar('Please provide a data value', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      const dataInput = {
        type: inputType,
        selector: inputType !== 'special-key' ? selector : undefined,
        value: inputType === 'special-key' ? specialKey : dataValue,
        name: fieldName || undefined
      };
      
      // Create or update data input
      let response;
      
      if (editMode && editingInput) {
        response = await api.put(
          `/recorder/sessions/${sessionId}/data-inputs/${editingInput.id}`,
          dataInput
        );
        
        enqueueSnackbar('Data input updated', { variant: 'success' });
      } else {
        response = await api.post(
          `/recorder/sessions/${sessionId}/data-inputs`,
          dataInput
        );
        
        enqueueSnackbar('Data input added', { variant: 'success' });
      }
      
      // Reset form
      resetForm();
      
      // Reload data inputs
      await loadDataInputs();
      
      // Notify parent
      if (onDataInputAdded) {
        onDataInputAdded(response.data);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error creating data input:', error);
      setLoading(false);
      enqueueSnackbar('Failed to create data input', { variant: 'error' });
    }
  };
  
  // Delete data input
  const deleteDataInput = async (inputId) => {
    try {
      setLoading(true);
      
      await api.delete(`/recorder/sessions/${sessionId}/data-inputs/${inputId}`);
      
      // Reload data inputs
      await loadDataInputs();
      
      enqueueSnackbar('Data input deleted', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error deleting data input:', error);
      setLoading(false);
      enqueueSnackbar('Failed to delete data input', { variant: 'error' });
    }
  };
  
  // Edit data input
  const editDataInput = (input) => {
    setInputType(input.type);
    setDataValue(input.value || '');
    setFieldName(input.name || '');
    
    if (input.type === 'special-key') {
      setPressSpecialKey(true);
      setSpecialKey(input.value);
    } else {
      setPressSpecialKey(false);
    }
    
    setEditMode(true);
    setEditingInput(input);
  };
  
  // Reset form
  const resetForm = () => {
    setInputType('text');
    setDataValue('');
    setFieldName('');
    setPressSpecialKey(false);
    setSpecialKey('Tab');
    setEditMode(false);
    setEditingInput(null);
  };
  
  // Generate template value
  const generateTemplateValue = (template) => {
    if (!dataTemplates[template]) return '';
    
    const values = dataTemplates[template];
    const randomValue = values[Math.floor(Math.random() * values.length)];
    
    setDataValue(randomValue);
  };
  
  // Save data set
  const saveDataSet = async () => {
    if (dataInputs.length === 0) {
      enqueueSnackbar('No data inputs to save', { variant: 'warning' });
      return;
    }
    
    const name = prompt('Enter a name for this data set:');
    
    if (!name) return;
    
    try {
      setLoading(true);
      
      const dataSet = {
        name,
        projectId: sessionId.split('-')[0],
        inputs: dataInputs
      };
      
      const response = await api.post(`/projects/${dataSet.projectId}/data-sets`, dataSet);
      
      // Reload data sets
      await loadDataSets();
      
      enqueueSnackbar('Data set saved', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error saving data set:', error);
      setLoading(false);
      enqueueSnackbar('Failed to save data set', { variant: 'error' });
    }
  };
  
  // Load data set
  const loadDataSet = (dataSetId) => {
    const dataSet = dataSets.find(ds => ds.id === dataSetId);
    
    if (!dataSet) {
      enqueueSnackbar('Data set not found', { variant: 'error' });
      return;
    }
    
    setCurrentDataSet(dataSet);
    
    // Confirm before overwriting existing data inputs
    if (dataInputs.length > 0) {
      if (!window.confirm('This will replace your current data inputs. Continue?')) {
        return;
      }
    }
    
    // Apply data set to session
    applyDataSet(dataSet);
  };
  
  // Apply data set to session
  const applyDataSet = async (dataSet) => {
    try {
      setLoading(true);
      
      // Delete existing data inputs
      await api.delete(`/recorder/sessions/${sessionId}/data-inputs`);
      
      // Add data set inputs
      for (const input of dataSet.inputs) {
        await api.post(
          `/recorder/sessions/${sessionId}/data-inputs`,
          {
            type: input.type,
            selector: input.selector,
            value: input.value,
            name: input.name
          }
        );
      }
      
      // Reload data inputs
      await loadDataInputs();
      
      enqueueSnackbar('Data set applied', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error applying data set:', error);
      setLoading(false);
      enqueueSnackbar('Failed to apply data set', { variant: 'error' });
    }
  };
  
  // Get input icon
  const getInputIcon = (type) => {
    switch (type) {
      case 'text':
        return <TextIcon />;
      case 'number':
        return <FunctionIcon />;
      case 'date':
        return <DateIcon />;
      case 'email':
        return <EmailIcon />;
      case 'name':
        return <PersonIcon />;
      case 'phone':
        return <PhoneIcon />;
      case 'credit-card':
        return <CreditCardIcon />;
      case 'special-key':
        return <TabIcon />;
      default:
        return <TextIcon />;
    }
  };
  
  // Get input description
  const getInputDescription = (input) => {
    if (input.type === 'special-key') {
      return `Press ${input.value} key`;
    }
    
    let description = `Enter ${input.type}`;
    if (input.name) {
      description += ` (${input.name})`;
    }
    
    return description;
  };
  
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title={editMode ? "Edit Data Input" : "Add Data Input"} 
          subheader="Define test data for form fields and inputs"
          action={
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <FormControlLabel
                control={
                  <Switch
                    checked={pressSpecialKey}
                    onChange={(e) => setPressSpecialKey(e.target.checked)}
                    disabled={loading}
                  />
                }
                label="Special Key"
              />
              
              {dataInputs.length > 0 && (
                <Button
                  startIcon={<SaveIcon />}
                  onClick={saveDataSet}
                  disabled={loading}
                  sx={{ ml: 2 }}
                >
                  Save Set
                </Button>
              )}
            </Box>
          }
        />
        <Divider />
        <CardContent>
          <Grid container spacing={2}>
            {!pressSpecialKey ? (
              // Regular data input form
              <>
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Input Type</InputLabel>
                    <Select
                      value={inputType}
                      onChange={(e) => setInputType(e.target.value)}
                      label="Input Type"
                      disabled={loading}
                    >
                      <MenuItem value="text">Text</MenuItem>
                      <MenuItem value="number">Number</MenuItem>
                      <MenuItem value="date">Date</MenuItem>
                      <MenuItem value="email">Email</MenuItem>
                      <MenuItem value="name">Name</MenuItem>
                      <MenuItem value="phone">Phone</MenuItem>
                      <MenuItem value="credit-card">Credit Card</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Field Name (Optional)"
                    value={fieldName}
                    onChange={(e) => setFieldName(e.target.value)}
                    placeholder="e.g., Username, Email, Password"
                    disabled={loading}
                  />
                </Grid>
                
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Data Value"
                    value={dataValue}
                    onChange={(e) => setDataValue(e.target.value)}
                    multiline={inputType === 'text'}
                    rows={inputType === 'text' ? 2 : 1}
                    type={inputType === 'number' ? 'number' : 'text'}
                    disabled={loading}
                  />
                </Grid>
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                    {/* Template buttons based on input type */}
                    {inputType === 'text' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => setDataValue(Math.random().toString(36).substring(2, 10))}
                      >
                        Random Text
                      </Button>
                    )}
                    
                    {inputType === 'number' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => setDataValue(Math.floor(Math.random() * 1000).toString())}
                      >
                        Random Number
                      </Button>
                    )}
                    
                    {inputType === 'date' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => generateTemplateValue('date')}
                      >
                        Today's Date
                      </Button>
                    )}
                    
                    {inputType === 'email' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => generateTemplateValue('email')}
                      >
                        Sample Email
                      </Button>
                    )}
                    
                    {inputType === 'name' && (
                      <>
                        <Button 
                          size="small" 
                          variant="outlined" 
                          onClick={() => generateTemplateValue('firstName')}
                        >
                          First Name
                        </Button>
                        <Button 
                          size="small" 
                          variant="outlined" 
                          onClick={() => generateTemplateValue('lastName')}
                        >
                          Last Name
                        </Button>
                      </>
                    )}
                    
                    {inputType === 'phone' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => generateTemplateValue('phone')}
                      >
                        Sample Phone
                      </Button>
                    )}
                    
                    {inputType === 'credit-card' && (
                      <Button 
                        size="small" 
                        variant="outlined" 
                        onClick={() => generateTemplateValue('creditCard')}
                      >
                        Sample Card
                      </Button>
                    )}
                  </Box>
                </Grid>
              </>
            ) : (
              // Special key input form
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Special Key</InputLabel>
                  <Select
                    value={specialKey}
                    onChange={(e) => setSpecialKey(e.target.value)}
                    label="Special Key"
                    disabled={loading}
                  >
                    {specialKeys.map(key => (
                      <MenuItem key={key} value={key}>{key}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
            )}
            
            {/* Current element info */}
            {!pressSpecialKey && (
              <Grid item xs={12}>
                <Box sx={{ p: 2, bgcolor: '#f5f5f5', borderRadius: 1 }}>
                  <Typography variant="subtitle2" gutterBottom>
                    Target Element:
                  </Typography>
                  <Typography variant="body2" fontFamily="monospace">
                    {selector || 'No element selected'}
                  </Typography>
                </Box>
              </Grid>
            )}
            
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', gap: 1, justifyContent: 'flex-end' }}>
                {editMode && (
                  <Button
                    color="secondary"
                    onClick={resetForm}
                    disabled={loading}
                  >
                    Cancel
                  </Button>
                )}
                
                <Button
                  variant="contained"
                  color="primary"
                  onClick={createDataInput}
                  disabled={loading || 
                    (!pressSpecialKey && (!selector || !dataValue)) || 
                    (pressSpecialKey && !specialKey)}
                  startIcon={editMode ? <EditIcon /> : <AddIcon />}
                >
                  {loading ? <CircularProgress size={24} /> : (editMode ? 'Update' : 'Add Input')}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
      
      {/* Data Sets */}
      {dataSets.length > 0 && (
        <Card sx={{ mb: 3 }}>
          <CardHeader title="Saved Data Sets" />
          <Divider />
          <CardContent>
            <Grid container spacing={1}>
              {dataSets.map(dataSet => (
                <Grid item key={dataSet.id}>
                  <Chip
                    label={dataSet.name}
                    onClick={() => loadDataSet(dataSet.id)}
                    color={currentDataSet?.id === dataSet.id ? 'primary' : 'default'}
                    clickable
                  />
                </Grid>
              ))}
            </Grid>
          </CardContent>
        </Card>
      )}
      
      {/* Data Inputs List */}
      <Card>
        <CardHeader 
          title="Data Inputs" 
          subheader={`${dataInputs.length} input${dataInputs.length !== 1 ? 's' : ''}`}
        />
        <Divider />
        <CardContent>
          {dataInputs.length === 0 ? (
            <Typography variant="body2" color="text.secondary" align="center">
              No data inputs yet. Add inputs using the form above.
            </Typography>
          ) : (
            <TableContainer component={Paper} variant="outlined">
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell>Type</TableCell>
                    <TableCell>Description</TableCell>
                    <TableCell>Value</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {dataInputs.map((input) => (
                    <TableRow key={input.id}>
                      <TableCell>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          {getInputIcon(input.type)}
                          <Typography variant="body2" sx={{ ml: 1 }}>
                            {input.type}
                          </Typography>
                        </Box>
                      </TableCell>
                      <TableCell>{getInputDescription(input)}</TableCell>
                      <TableCell>
                        <Typography 
                          variant="body2" 
                          sx={{ 
                            fontFamily: 'monospace',
                            whiteSpace: 'nowrap',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            maxWidth: '150px'
                          }}
                        >
                          {input.value}
                        </Typography>
                      </TableCell>
                      <TableCell>
                        <Tooltip title="Edit">
                          <IconButton 
                            size="small" 
                            onClick={() => editDataInput(input)}
                            disabled={loading}
                          >
                            <EditIcon fontSize="small" />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Delete">
                          <IconButton 
                            size="small"
                            color="error"
                            onClick={() => deleteDataInput(input.id)}
                            disabled={loading}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </Tooltip>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default DataInputPanel;


// src/components/recorder/RecorderPanel.tsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Typography,
  Paper,
  Tabs,
  Tab,
  Divider,
  Button,
  IconButton,
  CircularProgress,
  Grid,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  AppBar,
  Toolbar,
  Drawer,
  Badge,
  Alert,
  Chip,
  Tooltip
} from '@mui/material';
import {
  PlayArrow as PlayIcon,
  Stop as StopIcon,
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Add as AddIcon,
  Check as CheckIcon,
  Close as CloseIcon,
  Visibility as VisibilityIcon,
  Code as CodeIcon,
  Pause as PauseIcon,
  VerifiedUser as VerifiedIcon,
  Timer as TimerIcon,
  DataObject as DataIcon,
  Menu as MenuIcon,
  ArrowBack as BackIcon
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

// Import recorder components
import RecorderClient from './RecorderClient';
import ElementInspector from './ElementInspector';
import SelectorGenerator from './SelectorGenerator';
import AssertionPanel from './AssertionPanel';
import WaitConditionPanel from './WaitConditionPanel';
import DataInputPanel from './DataInputPanel';

/**
 * Recorder Panel Component
 * Main component for test recording functionality
 */
const RecorderPanel = () => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  const { projectId } = useParams();
  const navigate = useNavigate();
  
  const [loading, setLoading] = useState(false);
  const [currentTab, setCurrentTab] = useState(0);
  const [recordingSession, setRecordingSession] = useState(null);
  const [recording, setRecording] = useState(false);
  const [selectedElement, setSelectedElement] = useState(null);
  const [selector, setSelector] = useState('');
  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
  const [testName, setTestName] = useState('');
  const [testDescription, setTestDescription] = useState('');
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [elementCount, setElementCount] = useState(0);
  const [assertionCount, setAssertionCount] = useState(0);
  const [waitCount, setWaitCount] = useState(0);
  const [dataInputCount, setDataInputCount] = useState(0);
  
  // Use refs to keep track of session
  const sessionRef = useRef(recordingSession);
  
  // Update session ref when session changes
  useEffect(() => {
    sessionRef.current = recordingSession;
  }, [recordingSession]);
  
  // Define tab items
  const tabItems = [
    { label: 'Record', icon: <PlayIcon /> },
    { label: 'Elements', icon: <VisibilityIcon /> },
    { label: 'Selectors', icon: <CodeIcon /> },
    { label: 'Assertions', icon: <VerifiedIcon /> },
    { label: 'Wait', icon: <TimerIcon /> },
    { label: 'Data', icon: <DataIcon /> }
  ];
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Handle element selection
  const handleElementSelected = (element) => {
    setSelectedElement(element);
    
    // Auto-generate selector
    generateSelector(element);
    
    // Auto-switch to selectors tab
    setCurrentTab(2);
  };
  
  // Handle selector choice
  const handleSelectorChosen = (selectedSelector) => {
    setSelector(selectedSelector);
    
    // Auto-switch to assertions tab
    setCurrentTab(3);
  };
  
  // Generate selector
  const generateSelector = async (element) => {
    if (!element || !recordingSession) return;
    
    try {
      setLoading(true);
      
      const response = await api.post(
        `/recorder/sessions/${recordingSession.id}/selectors/generate`,
        { elementInfo: element, includeUnique: true }
      );
      
      // Get the best selector
      const selectors = response.data || {};
      
      if (selectors.id) {
        setSelector(selectors.id);
      } else if (selectors['data-testid']) {
        setSelector(selectors['data-testid']);
      } else if (selectors.css) {
        setSelector(selectors.css);
      } else if (Object.keys(selectors).length > 0) {
        // Get first available selector
        setSelector(Object.values(selectors)[0]);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error generating selector:', error);
      setLoading(false);
      enqueueSnackbar('Failed to generate selector', { variant: 'error' });
    }
  };
  
  // Save as test case
  const saveAsTestCase = async () => {
    if (!testName.trim()) {
      enqueueSnackbar('Please enter a test name', { variant: 'warning' });
      return;
    }
    
    if (!recordingSession) {
      enqueueSnackbar('No active recording session', { variant: 'error' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Save as test case
      const response = await api.post(
        `/recorder/sessions/${recordingSession.id}/save`,
        {
          name: testName,
          description: testDescription,
          projectId
        }
      );
      
      const testCaseId = response.data.id;
      
      setSaveDialogOpen(false);
      
      enqueueSnackbar('Test case created successfully', { variant: 'success' });
      
      // Navigate to the test case
      navigate(`/projects/${projectId}/test-cases/${testCaseId}`);
    } catch (error) {
      console.error('Error saving test case:', error);
      setLoading(false);
      enqueueSnackbar('Failed to save test case', { variant: 'error' });
    }
  };
  
  // Handle steps recorded
  const handleStepsRecorded = (steps) => {
    setRecordedSteps(steps);
    updateStatistics();
  };
  
  // Handle assertion added
  const handleAssertionAdded = (assertion) => {
    updateStatistics();
  };
  
  // Handle wait condition added
  const handleWaitConditionAdded = (waitCondition) => {
    updateStatistics();
  };
  
  // Handle data input added
  const handleDataInputAdded = (dataInput) => {
    updateStatistics();
  };
  
  // Update statistics
  const updateStatistics = async () => {
    if (!recordingSession) return;
    
    try {
      const response = await api.get(`/recorder/sessions/${recordingSession.id}/statistics`);
      
      const stats = response.data || {};
      
      setElementCount(stats.elementSelectionCount || 0);
      setAssertionCount(stats.assertionCount || 0);
      setWaitCount(stats.waitConditionCount || 0);
      setDataInputCount(stats.dataInputCount || 0);
    } catch (error) {
      console.error('Error updating statistics:', error);
    }
  };
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Cleanup function
      const cleanupSession = async () => {
        if (sessionRef.current) {
          try {
            // Stop recording if active
            await api.post(`/recorder/sessions/${sessionRef.current.id}/stop`);
          } catch (error) {
            console.error('Error cleaning up session:', error);
          }
        }
      };
      
      cleanupSession();
    };
  }, [api]);
  
  // Render content based on current tab
  const renderTabContent = () => {
    if (!recordingSession) {
      return (
        <Box sx={{ p: 3, textAlign: 'center' }}>
          <Alert severity="info">
            Start recording using the recorder tab.
          </Alert>
        </Box>
      );
    }
    
    switch (currentTab) {
      case 0: // Record
        return (
          <RecorderClient 
            sessionId={recordingSession.id} 
            onStepsRecorded={handleStepsRecorded} 
          />
        );
      case 1: // Elements
        return (
          <ElementInspector 
            sessionId={recordingSession.id} 
            onElementSelected={handleElementSelected} 
            onSelectorChosen={handleSelectorChosen} 
          />
        );
      case 2: // Selectors
        return (
          <SelectorGenerator 
            sessionId={recordingSession.id} 
            initialSelector={selector}
            initialElement={selectedElement}
            onSelectorChosen={handleSelectorChosen}
          />
        );
      case 3: // Assertions
        return (
          <AssertionPanel 
            sessionId={recordingSession.id} 
            elementInfo={selectedElement}
            selector={selector}
            onAssertionAdded={handleAssertionAdded}
          />
        );
      case 4: // Wait
        return (
          <WaitConditionPanel 
            sessionId={recordingSession.id}
            selector={selector}
            onWaitConditionAdded={handleWaitConditionAdded}
          />
        );
      case 5: // Data
        return (
          <DataInputPanel 
            sessionId={recordingSession.id}
            selector={selector}
            onDataInputAdded={handleDataInputAdded}
          />
        );
      default:
        return null;
    }
  };
  
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* App Bar */}
      <AppBar position="sticky" color="default" elevation={0}>
        <Toolbar>
          <IconButton
            edge="start"
            color="inherit"
            onClick={() => navigate(`/projects/${projectId}`)}
            sx={{ mr: 2 }}
          >
            <BackIcon />
          </IconButton>
          
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Test Recorder
          </Typography>
          
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {/* Statistics Chips */}
            <Tooltip title="Elements">
              <Chip 
                icon={<VisibilityIcon />} 
                label={elementCount} 
                color="primary" 
                size="small" 
                sx={{ mr: 1 }} 
              />
            </Tooltip>
            
            <Tooltip title="Assertions">
              <Chip 
                icon={<VerifiedIcon />} 
                label={assertionCount} 
                color="success" 
                size="small" 
                sx={{ mr: 1 }} 
              />
            </Tooltip>
            
            <Tooltip title="Wait Conditions">
              <Chip 
                icon={<TimerIcon />} 
                label={waitCount} 
                color="warning" 
                size="small" 
                sx={{ mr: 1 }} 
              />
            </Tooltip>
            
            <Tooltip title="Data Inputs">
              <Chip 
                icon={<DataIcon />} 
                label={dataInputCount} 
                color="info" 
                size="small" 
                sx={{ mr: 2 }} 
              />
            </Tooltip>
            
            {/* Save Button */}
            <Button
              variant="contained"
              color="primary"
              startIcon={<SaveIcon />}
              disabled={!recordingSession || loading}
              onClick={() => setSaveDialogOpen(true)}
            >
              Save Test
            </Button>
            
            {/* Menu Button */}
            <IconButton
              color="inherit"
              onClick={() => setDrawerOpen(true)}
              sx={{ ml: 2 }}
            >
              <MenuIcon />
            </IconButton>
          </Box>
        </Toolbar>
        
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          variant="fullWidth"
          scrollButtons="auto"
        >
          {tabItems.map((item, index) => (
            <Tab 
              key={index} 
              icon={item.icon} 
              label={item.label} 
              disabled={!recordingSession && index > 0}
            />
          ))}
        </Tabs>
      </AppBar>
      
      {/* Main Content */}
      <Box sx={{ 
        flexGrow: 1, 
        overflow: 'auto',
        p: 2,
        bgcolor: 'background.default'
      }}>
        {loading && <LinearProgress />}
        
        {renderTabContent()}
      </Box>
      
      {/* Save Dialog */}
      <Dialog
        open={saveDialogOpen}
        onClose={() => setSaveDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Save Test Case</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Test Name"
            fullWidth
            value={testName}
            onChange={(e) => setTestName(e.target.value)}
            required
          />
          <TextField
            margin="dense"
            label="Description"
            fullWidth
            multiline
            rows={3}
            value={testDescription}
            onChange={(e) => setTestDescription(e.target.value)}
          />
          
          <Box sx={{ mt: 2 }}>
            <Alert severity="info">
              This will create a new test case with {recordedSteps?.length || 0} recorded steps,
              {' '}{assertionCount} assertions, {waitCount} wait conditions, and {dataInputCount} data inputs.
            </Alert>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialogOpen(false)}>Cancel</Button>
          <Button 
            onClick={saveAsTestCase} 
            variant="contained" 
            color="primary"
            disabled={loading || !testName.trim()}
          >
            {loading ? <CircularProgress size={24} /> : 'Save Test Case'}
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Side Drawer */}
      <Drawer
        anchor="right"
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
      >
        <Box sx={{ width: 250, p: 2 }}>
          <Typography variant="h6" gutterBottom>
            Recorder Options
          </Typography>
          <Divider sx={{ mb: 2 }} />
          
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={() => {
                // Reload the page
                window.location.reload();
              }}
            >
              Reset Recorder
            </Button>
            
            <Button
              variant="outlined"
              color="secondary"
              startIcon={<BackIcon />}
              onClick={() => navigate(`/projects/${projectId}`)}
            >
              Exit Recorder
            </Button>
          </Box>
        </Box>
      </Drawer>
    </Box>
  );
};

export default RecorderPanel;


// src/components/api/RequestBuilder.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  Grid,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  CircularProgress,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Tab,
  Tabs,
  Collapse,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Switch,
  FormControlLabel
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Send as SendIcon,
  Save as SaveIcon,
  Code as CodeIcon,
  ExpandMore as ExpandMoreIcon,
  ContentCopy as CopyIcon,
  Edit as EditIcon,
  PlayArrow as PlayArrowIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';
import CodeEditor from '../CodeEditor';

/**
 * API Request Builder Component
 * Builds and sends API requests for testing
 */
const RequestBuilder = ({ 
  projectId, 
  initialRequest = null, 
  onRequestSent = null, 
  onSave = null,
  readOnly = false
}) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [currentTab, setCurrentTab] = useState(0);
  const [request, setRequest] = useState({
    method: 'GET',
    url: '',
    headers: [],
    queryParams: [],
    pathParams: [],
    body: '',
    bodyType: 'application/json',
    auth: {
      type: 'none',
      username: '',
      password: '',
      token: '',
      key: '',
      value: ''
    }
  });
  
  // Initialize from initial request if provided
  useEffect(() => {
    if (initialRequest) {
      setRequest({
        ...initialRequest,
        headers: initialRequest.headers || [],
        queryParams: initialRequest.queryParams || [],
        pathParams: initialRequest.pathParams || [],
        body: initialRequest.body || '',
        bodyType: initialRequest.bodyType || 'application/json',
        auth: initialRequest.auth || {
          type: 'none',
          username: '',
          password: '',
          token: '',
          key: '',
          value: ''
        }
      });
    }
  }, [initialRequest]);
  
  // Tabs for different request parts
  const tabs = [
    { label: "URL & Method" },
    { label: "Headers" },
    { label: "Params" },
    { label: "Body" },
    { label: "Auth" }
  ];
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Update request field
  const updateRequest = (field, value) => {
    setRequest({
      ...request,
      [field]: value
    });
  };
  
  // Add header
  const addHeader = () => {
    setRequest({
      ...request,
      headers: [...request.headers, { key: '', value: '' }]
    });
  };
  
  // Update header
  const updateHeader = (index, field, value) => {
    const updatedHeaders = [...request.headers];
    updatedHeaders[index] = {
      ...updatedHeaders[index],
      [field]: value
    };
    
    setRequest({
      ...request,
      headers: updatedHeaders
    });
  };
  
  // Remove header
  const removeHeader = (index) => {
    const updatedHeaders = [...request.headers];
    updatedHeaders.splice(index, 1);
    
    setRequest({
      ...request,
      headers: updatedHeaders
    });
  };
  
  // Add query parameter
  const addQueryParam = () => {
    setRequest({
      ...request,
      queryParams: [...request.queryParams, { key: '', value: '' }]
    });
  };
  
  // Update query parameter
  const updateQueryParam = (index, field, value) => {
    const updatedParams = [...request.queryParams];
    updatedParams[index] = {
      ...updatedParams[index],
      [field]: value
    };
    
    setRequest({
      ...request,
      queryParams: updatedParams
    });
  };
  
  // Remove query parameter
  const removeQueryParam = (index) => {
    const updatedParams = [...request.queryParams];
    updatedParams.splice(index, 1);
    
    setRequest({
      ...request,
      queryParams: updatedParams
    });
  };
  
  // Add path parameter
  const addPathParam = () => {
    setRequest({
      ...request,
      pathParams: [...request.pathParams, { key: '', value: '' }]
    });
  };
  
  // Update path parameter
  const updatePathParam = (index, field, value) => {
    const updatedParams = [...request.pathParams];
    updatedParams[index] = {
      ...updatedParams[index],
      [field]: value
    };
    
    setRequest({
      ...request,
      pathParams: updatedParams
    });
  };
  
  // Remove path parameter
  const removePathParam = (index) => {
    const updatedParams = [...request.pathParams];
    updatedParams.splice(index, 1);
    
    setRequest({
      ...request,
      pathParams: updatedParams
    });
  };
  
  // Update authentication
  const updateAuth = (field, value) => {
    setRequest({
      ...request,
      auth: {
        ...request.auth,
        [field]: value
      }
    });
  };
  
  // Send the request
  const sendRequest = async () => {
    if (!request.url) {
      enqueueSnackbar('Please enter a URL', { variant: 'warning' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Format request for sending
      const requestData = formatRequest();
      
      // Send request to the API testing service
      const response = await api.post(`/projects/${projectId}/api-tests/execute`, requestData);
      
      // Notify parent component
      if (onRequestSent) {
        onRequestSent(response.data, requestData);
      }
      
      enqueueSnackbar('Request sent successfully', { variant: 'success' });
      setLoading(false);
    } catch (error) {
      console.error('Error sending request:', error);
      setLoading(false);
      
      if (onRequestSent) {
        onRequestSent({
          success: false,
          error: error.message,
          status: error.response?.status,
          statusText: error.response?.statusText,
          data: error.response?.data
        }, request);
      }
      
      enqueueSnackbar('Failed to send request', { variant: 'error' });
    }
  };
  
  // Format request for sending
  const formatRequest = () => {
    // Process URL with path parameters
    let processedUrl = request.url;
    
    // Replace path parameters in URL
    request.pathParams.forEach(param => {
      if (param.key && param.value) {
        processedUrl = processedUrl.replace(`{${param.key}}`, param.value);
      }
    });
    
    // Build query string from parameters
    const queryString = request.queryParams
      .filter(param => param.key)
      .map(param => `${encodeURIComponent(param.key)}=${encodeURIComponent(param.value || '')}`)
      .join('&');
    
    // Add query string to URL if present
    if (queryString) {
      processedUrl += (processedUrl.includes('?') ? '&' : '?') + queryString;
    }
    
    // Build headers object from array
    const headers = {};
    request.headers.forEach(header => {
      if (header.key) {
        headers[header.key] = header.value || '';
      }
    });
    
    // Add content type header if not present
    if (!headers['Content-Type'] && request.body && request.bodyType) {
      headers['Content-Type'] = request.bodyType;
    }
    
    // Add authentication headers
    if (request.auth.type === 'basic') {
      headers['Authorization'] = `Basic ${btoa(`${request.auth.username}:${request.auth.password}`)}`;
    } else if (request.auth.type === 'bearer') {
      headers['Authorization'] = `Bearer ${request.auth.token}`;
    } else if (request.auth.type === 'api-key') {
      if (request.auth.key) {
        headers[request.auth.key] = request.auth.value || '';
      }
    }
    
    // Build final request object
    const formattedRequest = {
      method: request.method,
      url: processedUrl,
      headers,
      body: request.body || undefined,
      bodyType: request.bodyType
    };
    
    return formattedRequest;
  };
  
  // Save the request
  const saveRequest = () => {
    if (onSave) {
      onSave(request);
    }
  };
  
  // Render URL and Method tab content
  const renderUrlMethodTab = () => {
    return (
      <Grid container spacing={2}>
        <Grid item xs={12} sm={3}>
          <FormControl fullWidth disabled={readOnly}>
            <InputLabel>Method</InputLabel>
            <Select
              value={request.method}
              onChange={(e) => updateRequest('method', e.target.value)}
              label="Method"
            >
              <MenuItem value="GET">GET</MenuItem>
              <MenuItem value="POST">POST</MenuItem>
              <MenuItem value="PUT">PUT</MenuItem>
              <MenuItem value="DELETE">DELETE</MenuItem>
              <MenuItem value="PATCH">PATCH</MenuItem>
              <MenuItem value="HEAD">HEAD</MenuItem>
              <MenuItem value="OPTIONS">OPTIONS</MenuItem>
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} sm={9}>
          <TextField
            fullWidth
            label="URL"
            value={request.url}
            onChange={(e) => updateRequest('url', e.target.value)}
            placeholder="https://api.example.com/resource"
            disabled={readOnly}
          />
        </Grid>
      </Grid>
    );
  };
  
  // Render Headers tab content
  const renderHeadersTab = () => {
    return (
      <Box>
        <TableContainer component={Paper} variant="outlined">
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Key</TableCell>
                <TableCell>Value</TableCell>
                {!readOnly && <TableCell width="50px">Action</TableCell>}
              </TableRow>
            </TableHead>
            <TableBody>
              {request.headers.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={readOnly ? 2 : 3} align="center">
                    <Typography variant="body2" color="textSecondary">
                      No headers added yet
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                request.headers.map((header, index) => (
                  <TableRow key={index}>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={header.key}
                        onChange={(e) => updateHeader(index, 'key', e.target.value)}
                        placeholder="Header Name"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={header.value}
                        onChange={(e) => updateHeader(index, 'value', e.target.value)}
                        placeholder="Header Value"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    {!readOnly && (
                      <TableCell>
                        <IconButton
                          size="small"
                          onClick={() => removeHeader(index)}
                          color="error"
                        >
                          <DeleteIcon fontSize="small" />
                        </IconButton>
                      </TableCell>
                    )}
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        {!readOnly && (
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
            <Button
              startIcon={<AddIcon />}
              onClick={addHeader}
              variant="outlined"
              size="small"
            >
              Add Header
            </Button>
          </Box>
        )}
      </Box>
    );
  };
  
  // Render Parameters tab content
  const renderParamsTab = () => {
    return (
      <Box>
        <Typography variant="subtitle1" gutterBottom>
          Query Parameters
        </Typography>
        
        <TableContainer component={Paper} variant="outlined" sx={{ mb: 3 }}>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Key</TableCell>
                <TableCell>Value</TableCell>
                {!readOnly && <TableCell width="50px">Action</TableCell>}
              </TableRow>
            </TableHead>
            <TableBody>
              {request.queryParams.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={readOnly ? 2 : 3} align="center">
                    <Typography variant="body2" color="textSecondary">
                      No query parameters added yet
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                request.queryParams.map((param, index) => (
                  <TableRow key={index}>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={param.key}
                        onChange={(e) => updateQueryParam(index, 'key', e.target.value)}
                        placeholder="Parameter Name"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={param.value}
                        onChange={(e) => updateQueryParam(index, 'value', e.target.value)}
                        placeholder="Parameter Value"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    {!readOnly && (
                      <TableCell>
                        <IconButton
                          size="small"
                          onClick={() => removeQueryParam(index)}
                          color="error"
                        >
                          <DeleteIcon fontSize="small" />
                        </IconButton>
                      </TableCell>
                    )}
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        {!readOnly && (
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 3 }}>
            <Button
              startIcon={<AddIcon />}
              onClick={addQueryParam}
              variant="outlined"
              size="small"
            >
              Add Query Parameter
            </Button>
          </Box>
        )}
        
        <Typography variant="subtitle1" gutterBottom>
          Path Parameters
        </Typography>
        
        <TableContainer component={Paper} variant="outlined">
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Key</TableCell>
                <TableCell>Value</TableCell>
                {!readOnly && <TableCell width="50px">Action</TableCell>}
              </TableRow>
            </TableHead>
            <TableBody>
              {request.pathParams.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={readOnly ? 2 : 3} align="center">
                    <Typography variant="body2" color="textSecondary">
                      No path parameters added yet
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                request.pathParams.map((param, index) => (
                  <TableRow key={index}>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={param.key}
                        onChange={(e) => updatePathParam(index, 'key', e.target.value)}
                        placeholder="Parameter Name"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    <TableCell>
                      <TextField
                        fullWidth
                        size="small"
                        value={param.value}
                        onChange={(e) => updatePathParam(index, 'value', e.target.value)}
                        placeholder="Parameter Value"
                        variant="standard"
                        disabled={readOnly}
                      />
                    </TableCell>
                    {!readOnly && (
                      <TableCell>
                        <IconButton
                          size="small"
                          onClick={() => removePathParam(index)}
                          color="error"
                        >
                          <DeleteIcon fontSize="small" />
                        </IconButton>
                      </TableCell>
                    )}
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        {!readOnly && (
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end' }}>
            <Button
              startIcon={<AddIcon />}
              onClick={addPathParam}
              variant="outlined"
              size="small"
            >
              Add Path Parameter
            </Button>
          </Box>
        )}
      </Box>
    );
  };
  
  // Render Body tab content
  const renderBodyTab = () => {
    return (
      <Box>
        <FormControl fullWidth sx={{ mb: 2 }} disabled={readOnly}>
          <InputLabel>Content Type</InputLabel>
          <Select
            value={request.bodyType}
            onChange={(e) => updateRequest('bodyType', e.target.value)}
            label="Content Type"
          >
            <MenuItem value="application/json">JSON</MenuItem>
            <MenuItem value="application/xml">XML</MenuItem>
            <MenuItem value="text/plain">Plain Text</MenuItem>
            <MenuItem value="application/x-www-form-urlencoded">Form URL Encoded</MenuItem>
            <MenuItem value="multipart/form-data">Multipart Form Data</MenuItem>
          </Select>
        </FormControl>
        
        <Box sx={{ mb: 2 }}>
          <CodeEditor
            language={
              request.bodyType === 'application/json' ? 'json' :
              request.bodyType === 'application/xml' ? 'xml' :
              'text'
            }
            value={request.body}
            onChange={(value) => updateRequest('body', value)}
            height="200px"
            readOnly={readOnly}
          />
        </Box>
        
        {!readOnly && request.bodyType === 'application/json' && (
          <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
            <Button
              size="small"
              onClick={() => {
                try {
                  const formattedJson = JSON.stringify(JSON.parse(request.body || '{}'), null, 2);
                  updateRequest('body', formattedJson);
                } catch (e) {
                  enqueueSnackbar('Invalid JSON format', { variant: 'error' });
                }
              }}
            >
              Format JSON
            </Button>
          </Box>
        )}
      </Box>
    );
  };
  
  // Render Authentication tab content
  const renderAuthTab = () => {
    return (
      <Box>
        <FormControl fullWidth sx={{ mb: 3 }} disabled={readOnly}>
          <InputLabel>Authentication Type</InputLabel>
          <Select
            value={request.auth.type}
            onChange={(e) => updateAuth('type', e.target.value)}
            label="Authentication Type"
          >
            <MenuItem value="none">No Authentication</MenuItem>
            <MenuItem value="basic">Basic Auth</MenuItem>
            <MenuItem value="bearer">Bearer Token</MenuItem>
            <MenuItem value="api-key">API Key</MenuItem>
          </Select>
        </FormControl>
        
        {request.auth.type === 'basic' && (
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Username"
                value={request.auth.username}
                onChange={(e) => updateAuth('username', e.target.value)}
                disabled={readOnly}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Password"
                type="password"
                value={request.auth.password}
                onChange={(e) => updateAuth('password', e.target.value)}
                disabled={readOnly}
              />
            </Grid>
          </Grid>
        )}
        
        {request.auth.type === 'bearer' && (
          <TextField
            fullWidth
            label="Token"
            value={request.auth.token}
            onChange={(e) => updateAuth('token', e.target.value)}
            disabled={readOnly}
          />
        )}
        
        {request.auth.type === 'api-key' && (
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Header Name"
                value={request.auth.key}
                onChange={(e) => updateAuth('key', e.target.value)}
                placeholder="X-API-Key"
                disabled={readOnly}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="API Key"
                value={request.auth.value}
                onChange={(e) => updateAuth('value', e.target.value)}
                disabled={readOnly}
              />
            </Grid>
          </Grid>
        )}
      </Box>
    );
  };
  
  // Render current tab content
  const renderTabContent = () => {
    switch (currentTab) {
      case 0:
        return renderUrlMethodTab();
      case 1:
        return renderHeadersTab();
      case 2:
        return renderParamsTab();
      case 3:
        return renderBodyTab();
      case 4:
        return renderAuthTab();
      default:
        return null;
    }
  };
  
  return (
    <Box>
      <Card variant="outlined">
        <CardHeader
          title="Request Builder"
          action={
            <Box sx={{ display: 'flex' }}>
              {onSave && !readOnly && (
                <Button
                  startIcon={<SaveIcon />}
                  onClick={saveRequest}
                  sx={{ mr: 1 }}
                  disabled={loading}
                >
                  Save
                </Button>
              )}
              
              <Button
                variant="contained"
                color="primary"
                startIcon={loading ? <CircularProgress size={24} /> : <SendIcon />}
                onClick={sendRequest}
                disabled={loading || !request.url}
              >
                Send
              </Button>
            </Box>
          }
        />
        <Divider />
        <CardContent>
          <Box>
            <Tabs
              value={currentTab}
              onChange={handleTabChange}
              variant="scrollable"
              scrollButtons="auto"
              sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}
            >
              {tabs.map((tab, index) => (
                <Tab key={index} label={tab.label} />
              ))}
            </Tabs>
            
            {renderTabContent()}
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default RequestBuilder;


// src/components/api/ResponseViewer.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Divider,
  Tooltip,
  Card,
  CardContent,
  CardHeader,
  Grid,
  Tabs,
  Tab,
  CircularProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  IconButton,
  Alert
} from '@mui/material';
import {
  ContentCopy as CopyIcon,
  Code as CodeIcon,
  Description as HeadersIcon,
  Schedule as TimingIcon,
  SaveAlt as SaveIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import CodeEditor from '../CodeEditor';

/**
 * API Response Viewer Component
 * Displays API response data with formatting and analysis
 */
const ResponseViewer = ({ response, request = null, loading = false }) => {
  const { enqueueSnackbar } = useSnackbar();
  
  const [currentTab, setCurrentTab] = useState(0);
  const [formattedBody, setFormattedBody] = useState('');
  const [bodyLanguage, setBodyLanguage] = useState('json');
  
  // Process response when it changes
  useEffect(() => {
    if (response) {
      processResponse();
    }
  }, [response]);
  
  // Process and format the response
  const processResponse = () => {
    if (!response || !response.data) return;
    
    // Format the response body based on content type
    const contentType = response.headers?.['content-type'] || '';
    
    if (contentType.includes('application/json')) {
      try {
        const formatted = JSON.stringify(response.data, null, 2);
        setFormattedBody(formatted);
        setBodyLanguage('json');
      } catch (error) {
        setFormattedBody(String(response.data));
        setBodyLanguage('text');
      }
    } else if (contentType.includes('application/xml') || contentType.includes('text/xml')) {
      setFormattedBody(String(response.data));
      setBodyLanguage('xml');
    } else if (contentType.includes('text/html')) {
      setFormattedBody(String(response.data));
      setBodyLanguage('html');
    } else {
      setFormattedBody(String(response.data));
      setBodyLanguage('text');
    }
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Copy to clipboard
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text)
      .then(() => {
        enqueueSnackbar('Copied to clipboard', { variant: 'success' });
      })
      .catch(error => {
        console.error('Error copying to clipboard:', error);
        enqueueSnackbar('Failed to copy to clipboard', { variant: 'error' });
      });
  };
  
  // Save response as file
  const saveAsFile = () => {
    if (!response) return;
    
    try {
      const contentType = response.headers?.['content-type'] || 'text/plain';
      const fileExtension = getFileExtension(contentType);
      const fileName = `response_${new Date().getTime()}.${fileExtension}`;
      
      // Create a blob from the response data
      const blob = new Blob([formattedBody], { type: contentType });
      
      // Create a download link
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      
      // Trigger the download
      document.body.appendChild(link);
      link.click();
      
      // Clean up
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      enqueueSnackbar('Response saved to file', { variant: 'success' });
    } catch (error) {
      console.error('Error saving file:', error);
      enqueueSnackbar('Failed to save response', { variant: 'error' });
    }
  };
  
  // Get file extension based on content type
  const getFileExtension = (contentType) => {
    if (contentType.includes('application/json')) {
      return 'json';
    } else if (contentType.includes('application/xml') || contentType.includes('text/xml')) {
      return 'xml';
    } else if (contentType.includes('text/html')) {
      return 'html';
    } else if (contentType.includes('text/plain')) {
      return 'txt';
    } else {
      return 'txt';
    }
  };
  
  // Format headers for display
  const formatHeaders = (headers) => {
    if (!headers) return [];
    
    return Object.entries(headers).map(([key, value]) => ({
      name: key,
      value: value
    }));
  };
  
  // Get response status color
  const getStatusColor = (status) => {
    if (!status) return 'default';
    
    if (status >= 200 && status < 300) {
      return 'success';
    } else if (status >= 300 && status < 400) {
      return 'info';
    } else if (status >= 400 && status < 500) {
      return 'warning';
    } else if (status >= 500) {
      return 'error';
    } else {
      return 'default';
    }
  };
  
  // Get response time color
  const getTimeColor = (time) => {
    if (!time) return 'default';
    
    if (time < 300) {
      return 'success';
    } else if (time < 1000) {
      return 'info';
    } else if (time < 3000) {
      return 'warning';
    } else {
      return 'error';
    }
  };
  
  // Render status information
  const renderStatusInfo = () => {
    if (!response) return null;
    
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Chip
          label={`Status: ${response.status} ${response.statusText || ''}`}
          color={getStatusColor(response.status)}
          sx={{ mr: 2, fontWeight: 'bold' }}
        />
        
        {response.duration !== undefined && (
          <Chip
            label={`Time: ${response.duration}ms`}
            color={getTimeColor(response.duration)}
            icon={<TimingIcon />}
          />
        )}
      </Box>
    );
  };
  
  // Render body tab content
  const renderBodyTab = () => {
    if (!response) {
      return (
        <Box sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="body2" color="textSecondary">
            No response available
          </Typography>
        </Box>
      );
    }
    
    return (
      <Box>
        <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
          <Tooltip title="Copy Response">
            <IconButton onClick={() => copyToClipboard(formattedBody)}>
              <CopyIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Save as File">
            <IconButton onClick={saveAsFile}>
              <SaveIcon />
            </IconButton>
          </Tooltip>
        </Box>
        
        <CodeEditor
          language={bodyLanguage}
          value={formattedBody}
          height="400px"
          readOnly={true}
        />
      </Box>
    );
  };
  
  // Render headers tab content
  const renderHeadersTab = () => {
    if (!response || !response.headers) {
      return (
        <Box sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="body2" color="textSecondary">
            No headers available
          </Typography>
        </Box>
      );
    }
    
    const headers = formatHeaders(response.headers);
    
    return (
      <TableContainer component={Paper} variant="outlined">
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Header</TableCell>
              <TableCell>Value</TableCell>
              <TableCell width="50px">Action</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {headers.length === 0 ? (
              <TableRow>
                <TableCell colSpan={3} align="center">
                  <Typography variant="body2" color="textSecondary">
                    No headers found
                  </Typography>
                </TableCell>
              </TableRow>
            ) : (
              headers.map((header, index) => (
                <TableRow key={index}>
                  <TableCell>
                    <Typography variant="body2" fontWeight="bold">
                      {header.name}
                    </Typography>
                  </TableCell>
                  <TableCell>
                    <Typography variant="body2" sx={{ wordBreak: 'break-all' }}>
                      {header.value}
                    </Typography>
                  </TableCell>
                  <TableCell>
                    <IconButton
                      size="small"
                      onClick={() => copyToClipboard(header.value)}
                    >
                      <CopyIcon fontSize="small" />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };
  
  // Render request information tab content
  const renderRequestTab = () => {
    if (!request) {
      return (
        <Box sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="body2" color="textSecondary">
            No request information available
          </Typography>
        </Box>
      );
    }
    
    return (
      <Box>
        <Typography variant="subtitle1" gutterBottom>
          Request Details
        </Typography>
        
        <TableContainer component={Paper} variant="outlined" sx={{ mb: 3 }}>
          <Table size="small">
            <TableBody>
              <TableRow>
                <TableCell width="100px">
                  <Typography variant="body2" fontWeight="bold">
                    Method
                  </Typography>
                </TableCell>
                <TableCell>
                  <Chip
                    label={request.method}
                    color={
                      request.method === 'GET' ? 'primary' :
                      request.method === 'POST' ? 'success' :
                      request.method === 'PUT' ? 'warning' :
                      request.method === 'DELETE' ? 'error' :
                      'default'
                    }
                    size="small"
                  />
                </TableCell>
              </TableRow>
              <TableRow>
                <TableCell>
                  <Typography variant="body2" fontWeight="bold">
                    URL
                  </Typography>
                </TableCell>
                <TableCell>
                  <Typography variant="body2" sx={{ wordBreak: 'break-all' }}>
                    {request.url}
                  </Typography>
                </TableCell>
              </TableRow>
              {request.body && (
                <TableRow>
                  <TableCell>
                    <Typography variant="body2" fontWeight="bold">
                      Body
                    </Typography>
                  </TableCell>
                  <TableCell>
                    <Box sx={{ maxHeight: '150px', overflow: 'auto' }}>
                      <pre style={{ margin: 0, fontFamily: 'monospace', fontSize: '12px' }}>
                        {typeof request.body === 'string' 
                          ? request.body 
                          : JSON.stringify(request.body, null, 2)}
                      </pre>
                    </Box>
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        {request.headers && Object.keys(request.headers).length > 0 && (
          <>
            <Typography variant="subtitle1" gutterBottom>
              Request Headers
            </Typography>
            
            <TableContainer component={Paper} variant="outlined">
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell>Header</TableCell>
                    <TableCell>Value</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {Object.entries(request.headers).map(([key, value], index) => (
                    <TableRow key={index}>
                      <TableCell>
                        <Typography variant="body2" fontWeight="bold">
                          {key}
                        </Typography>
                      </TableCell>
                      <TableCell>
                        <Typography variant="body2" sx={{ wordBreak: 'break-all' }}>
                          {value}
                        </Typography>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </>
        )}
      </Box>
    );
  };
  
  // Show loading state
  if (loading) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <CircularProgress size={40} sx={{ mb: 2 }} />
        <Typography>Sending request...</Typography>
      </Box>
    );
  }
  
  // Show empty state if no response
  if (!response) {
    return (
      <Card variant="outlined">
        <CardHeader title="Response" />
        <Divider />
        <CardContent>
          <Box sx={{ p: 2, textAlign: 'center' }}>
            <Typography variant="body1" color="textSecondary">
              Send a request to see the response
            </Typography>
          </Box>
        </CardContent>
      </Card>
    );
  }
  
  // Show error state if there was a request error
  if (response.error) {
    return (
      <Card variant="outlined">
        <CardHeader title="Response" />
        <Divider />
        <CardContent>
          <Alert severity="error" sx={{ mb: 2 }}>
            <Typography variant="subtitle1">Request Failed</Typography>
            <Typography variant="body2">{response.error}</Typography>
          </Alert>
          
          {response.status && (
            <Box sx={{ mb: 2 }}>
              <Chip
                label={`Status: ${response.status} ${response.statusText || ''}`}
                color="error"
              />
            </Box>
          )}
          
          {renderRequestTab()}
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card variant="outlined">
      <CardHeader 
        title="Response" 
        subheader={
          request 
            ? `${request.method} ${request.url}` 
            : undefined
        }
      />
      <Divider />
      <CardContent>
        {renderStatusInfo()}
        
        <Box>
          <Tabs
            value={currentTab}
            onChange={handleTabChange}
            variant="scrollable"
            scrollButtons="auto"
            sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}
          >
            <Tab label="Body" icon={<CodeIcon />} iconPosition="start" />
            <Tab label="Headers" icon={<HeadersIcon />} iconPosition="start" />
            <Tab label="Request" icon={<TimingIcon />} iconPosition="start" />
          </Tabs>
          
          <Box sx={{ mt: 2 }}>
            {currentTab === 0 && renderBodyTab()}
            {currentTab === 1 && renderHeadersTab()}
            {currentTab === 2 && renderRequestTab()}
          </Box>
        </Box>
      </CardContent>
    </Card>
  );
};

export default ResponseViewer;


// src/components/bdd/FeatureEditor.tsx
import React, { useState, useEffect } from 'react';
import { Box, Paper, Typography, TextField, Button, Grid, IconButton, Tooltip } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { CodeEditor } from '../common/CodeEditor';
import { useApiContext } from '../../contexts/ApiContext';
import { useProjectContext } from '../../contexts/ProjectContext';
import ScenarioBuilder from './ScenarioBuilder';
import { toast } from 'react-toastify';

interface Feature {
  id: string;
  name: string;
  description: string;
  content: string;
  projectId: string;
  scenarios: Scenario[];
}

interface Scenario {
  id: string;
  name: string;
  steps: Step[];
}

interface Step {
  id: string;
  type: 'Given' | 'When' | 'Then' | 'And' | 'But';
  text: string;
}

const FeatureEditor: React.FC<{
  featureId?: string;
  onSave?: (feature: Feature) => void;
}> = ({ featureId, onSave }) => {
  const { api } = useApiContext();
  const { currentProject } = useProjectContext();
  
  const [feature, setFeature] = useState<Feature>({
    id: '',
    name: '',
    description: '',
    content: '',
    projectId: currentProject?.id || '',
    scenarios: []
  });
  
  const [editorContent, setEditorContent] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  
  useEffect(() => {
    if (featureId) {
      loadFeature(featureId);
    }
  }, [featureId]);
  
  useEffect(() => {
    if (feature.content) {
      setEditorContent(feature.content);
    } else {
      // Create default feature file template
      const defaultContent = `Feature: ${feature.name || 'New Feature'}
  ${feature.description || 'Description of the feature'}
  
  Scenario: Example scenario
    Given I am on the homepage
    When I click the login button
    Then I should see the login form`;
      
      setEditorContent(defaultContent);
      setFeature(prev => ({ ...prev, content: defaultContent }));
    }
  }, [feature.name, feature.description]);
  
  const loadFeature = async (id: string) => {
    try {
      const response = await api.get(`/api/bdd/features/${id}`);
      setFeature(response.data);
    } catch (error) {
      toast.error('Failed to load feature');
      console.error('Error loading feature:', error);
    }
  };
  
  const handleContentChange = (value: string) => {
    setEditorContent(value);
    setFeature(prev => ({ ...prev, content: value }));
  };
  
  const parseFeatureContent = () => {
    // This is a simplified parser - a real implementation would be more robust
    const lines = editorContent.split('\n');
    const scenarios: Scenario[] = [];
    
    let currentScenario: Scenario | null = null;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (trimmedLine.startsWith('Scenario:')) {
        if (currentScenario) {
          scenarios.push(currentScenario);
        }
        
        currentScenario = {
          id: Math.random().toString(36).substring(2, 9),
          name: trimmedLine.substring('Scenario:'.length).trim(),
          steps: []
        };
      } else if (currentScenario) {
        const stepMatch = trimmedLine.match(/^(Given|When|Then|And|But)\s+(.+)$/i);
        if (stepMatch) {
          currentScenario.steps.push({
            id: Math.random().toString(36).substring(2, 9),
            type: stepMatch[1] as Step['type'],
            text: stepMatch[2]
          });
        }
      }
    }
    
    if (currentScenario && currentScenario.steps.length > 0) {
      scenarios.push(currentScenario);
    }
    
    return scenarios;
  };
  
  const handleParseClick = () => {
    const scenarios = parseFeatureContent();
    setFeature(prev => ({ ...prev, scenarios }));
    setIsEditing(true);
  };
  
  const handleSaveFeature = async () => {
    if (!feature.name) {
      toast.error('Feature name is required');
      return;
    }
    
    setIsSaving(true);
    
    try {
      let response;
      
      if (feature.id) {
        response = await api.put(`/api/bdd/features/${feature.id}`, feature);
      } else {
        response = await api.post('/api/bdd/features', {
          ...feature,
          projectId: currentProject?.id
        });
      }
      
      toast.success('Feature saved successfully');
      
      if (onSave) {
        onSave(response.data);
      }
    } catch (error) {
      toast.error('Failed to save feature');
      console.error('Error saving feature:', error);
    } finally {
      setIsSaving(false);
    }
  };
  
  const handleAddScenario = () => {
    const newScenarios = [...feature.scenarios, {
      id: Math.random().toString(36).substring(2, 9),
      name: 'New Scenario',
      steps: []
    }];
    
    setFeature(prev => ({ ...prev, scenarios: newScenarios }));
  };
  
  const handleDeleteScenario = (scenarioId: string) => {
    const newScenarios = feature.scenarios.filter(s => s.id !== scenarioId);
    setFeature(prev => ({ ...prev, scenarios: newScenarios }));
  };
  
  const handleScenarioChange = (changedScenario: Scenario) => {
    const newScenarios = feature.scenarios.map(s => 
      s.id === changedScenario.id ? changedScenario : s
    );
    
    setFeature(prev => ({ ...prev, scenarios: newScenarios }));
  };
  
  const regenerateFeatureContent = () => {
    let content = `Feature: ${feature.name}\n  ${feature.description}\n\n`;
    
    feature.scenarios.forEach(scenario => {
      content += `  Scenario: ${scenario.name}\n`;
      
      scenario.steps.forEach(step => {
        content += `    ${step.type} ${step.text}\n`;
      });
      
      content += '\n';
    });
    
    setEditorContent(content);
    setFeature(prev => ({ ...prev, content }));
  };
  
  return (
    <Box sx={{ width: '100%', mb: 4 }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" gutterBottom>
          {featureId ? 'Edit Feature' : 'Create New Feature'}
        </Typography>
        
        <Grid container spacing={2} sx={{ mb: 3 }}>
          <Grid item xs={12} md={6}>
            <TextField
              label="Feature Name"
              fullWidth
              variant="outlined"
              value={feature.name}
              onChange={(e) => setFeature(prev => ({ ...prev, name: e.target.value }))}
              required
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField
              label="Description"
              fullWidth
              variant="outlined"
              value={feature.description}
              onChange={(e) => setFeature(prev => ({ ...prev, description: e.target.value }))}
            />
          </Grid>
        </Grid>
        
        {!isEditing ? (
          <>
            <Typography variant="h6" gutterBottom>
              Feature File Content
            </Typography>
            <Box sx={{ mb: 2, height: '300px' }}>
              <CodeEditor
                language="gherkin"
                value={editorContent}
                onChange={handleContentChange}
                height="100%"
              />
            </Box>
            <Button 
              variant="contained" 
              color="primary" 
              onClick={handleParseClick}
              sx={{ mr: 1 }}
            >
              Parse & Edit Scenarios
            </Button>
          </>
        ) : (
          <>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6">
                Scenarios
              </Typography>
              <Button 
                variant="outlined" 
                startIcon={<AddIcon />} 
                onClick={handleAddScenario}
              >
                Add Scenario
              </Button>
            </Box>
            
            {feature.scenarios.map((scenario, index) => (
              <Paper key={scenario.id} sx={{ p: 2, mb: 2, position: 'relative' }}>
                <IconButton
                  size="small"
                  color="error"
                  onClick={() => handleDeleteScenario(scenario.id)}
                  sx={{ position: 'absolute', top: 8, right: 8 }}
                >
                  <DeleteIcon />
                </IconButton>
                
                <ScenarioBuilder
                  scenario={scenario}
                  onChange={handleScenarioChange}
                />
              </Paper>
            ))}
            
            <Box sx={{ display: 'flex', mt: 3 }}>
              <Button 
                variant="outlined" 
                onClick={() => {
                  regenerateFeatureContent();
                  setIsEditing(false);
                }}
                sx={{ mr: 1 }}
              >
                Switch to Text Editor
              </Button>
              <Button 
                variant="contained" 
                color="primary" 
                onClick={handleSaveFeature} 
                disabled={isSaving}
              >
                Save Feature
              </Button>
            </Box>
          </>
        )}
      </Paper>
    </Box>
  );
};

export default FeatureEditor;


// src/components/bdd/ScenarioBuilder.tsx
import React, { useState } from 'react';
import { Box, TextField, Typography, Button, Select, MenuItem, IconButton, Grid, FormControl, InputLabel } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import { SelectChangeEvent } from '@mui/material/Select';

interface Step {
  id: string;
  type: 'Given' | 'When' | 'Then' | 'And' | 'But';
  text: string;
}

interface Scenario {
  id: string;
  name: string;
  steps: Step[];
}

interface ScenarioBuilderProps {
  scenario: Scenario;
  onChange: (scenario: Scenario) => void;
}

const ScenarioBuilder: React.FC<ScenarioBuilderProps> = ({ scenario, onChange }) => {
  const [stepType, setStepType] = useState<Step['type']>('Given');
  const [stepText, setStepText] = useState('');
  
  const handleScenarioNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange({
      ...scenario,
      name: e.target.value
    });
  };
  
  const handleStepTypeChange = (e: SelectChangeEvent<Step['type']>) => {
    setStepType(e.target.value as Step['type']);
  };
  
  const handleStepTextChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setStepText(e.target.value);
  };
  
  const handleAddStep = () => {
    if (!stepText.trim()) return;
    
    const newStep: Step = {
      id: Math.random().toString(36).substring(2, 9),
      type: stepType,
      text: stepText.trim()
    };
    
    onChange({
      ...scenario,
      steps: [...scenario.steps, newStep]
    });
    
    // Reset step text but keep the type for convenience
    setStepText('');
  };
  
  const handleDeleteStep = (stepId: string) => {
    onChange({
      ...scenario,
      steps: scenario.steps.filter(step => step.id !== stepId)
    });
  };
  
  const handleMoveStep = (stepId: string, direction: 'up' | 'down') => {
    const currentIndex = scenario.steps.findIndex(step => step.id === stepId);
    if (currentIndex === -1) return;
    
    const newSteps = [...scenario.steps];
    
    if (direction === 'up' && currentIndex > 0) {
      // Swap with previous item
      [newSteps[currentIndex - 1], newSteps[currentIndex]] = 
      [newSteps[currentIndex], newSteps[currentIndex - 1]];
    } else if (direction === 'down' && currentIndex < newSteps.length - 1) {
      // Swap with next item
      [newSteps[currentIndex], newSteps[currentIndex + 1]] = 
      [newSteps[currentIndex + 1], newSteps[currentIndex]];
    }
    
    onChange({
      ...scenario,
      steps: newSteps
    });
  };
  
  const handleUpdateStep = (stepId: string, field: keyof Step, value: string) => {
    onChange({
      ...scenario,
      steps: scenario.steps.map(step => 
        step.id === stepId 
          ? { ...step, [field]: field === 'type' ? value as Step['type'] : value }
          : step
      )
    });
  };
  
  return (
    <Box>
      <TextField
        label="Scenario Name"
        fullWidth
        variant="outlined"
        value={scenario.name}
        onChange={handleScenarioNameChange}
        sx={{ mb: 3 }}
      />
      
      <Typography variant="subtitle1" gutterBottom>
        Steps
      </Typography>
      
      {scenario.steps.length === 0 ? (
        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
          No steps added yet. Add your first step below.
        </Typography>
      ) : (
        <Box sx={{ mb: 3 }}>
          {scenario.steps.map((step, index) => (
            <Grid container spacing={1} key={step.id} sx={{ mb: 1, alignItems: 'center' }}>
              <Grid item xs={2}>
                <FormControl fullWidth size="small">
                  <Select
                    value={step.type}
                    onChange={(e) => handleUpdateStep(step.id, 'type', e.target.value)}
                  >
                    <MenuItem value="Given">Given</MenuItem>
                    <MenuItem value="When">When</MenuItem>
                    <MenuItem value="Then">Then</MenuItem>
                    <MenuItem value="And">And</MenuItem>
                    <MenuItem value="But">But</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={8}>
                <TextField
                  fullWidth
                  size="small"
                  value={step.text}
                  onChange={(e) => handleUpdateStep(step.id, 'text', e.target.value)}
                />
              </Grid>
              <Grid item xs={2}>
                <Box sx={{ display: 'flex' }}>
                  <IconButton 
                    size="small" 
                    disabled={index === 0}
                    onClick={() => handleMoveStep(step.id, 'up')}
                  >
                    <ArrowUpwardIcon fontSize="small" />
                  </IconButton>
                  <IconButton 
                    size="small"
                    disabled={index === scenario.steps.length - 1}
                    onClick={() => handleMoveStep(step.id, 'down')}
                  >
                    <ArrowDownwardIcon fontSize="small" />
                  </IconButton>
                  <IconButton 
                    size="small" 
                    color="error"
                    onClick={() => handleDeleteStep(step.id)}
                  >
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                </Box>
              </Grid>
            </Grid>
          ))}
        </Box>
      )}
      
      <Box sx={{ display: 'flex', mt: 2 }}>
        <FormControl sx={{ width: '120px', mr: 1 }}>
          <InputLabel id="step-type-label">Step Type</InputLabel>
          <Select
            labelId="step-type-label"
            value={stepType}
            label="Step Type"
            onChange={handleStepTypeChange}
            size="small"
          >
            <MenuItem value="Given">Given</MenuItem>
            <MenuItem value="When">When</MenuItem>
            <MenuItem value="Then">Then</MenuItem>
            <MenuItem value="And">And</MenuItem>
            <MenuItem value="But">But</MenuItem>
          </Select>
        </FormControl>
        
        <TextField
          label="Step Text"
          variant="outlined"
          size="small"
          fullWidth
          value={stepText}
          onChange={handleStepTextChange}
          sx={{ mr: 1 }}
          placeholder="Enter step description"
        />
        
        <Button
          variant="contained"
          color="primary"
          startIcon={<AddIcon />}
          onClick={handleAddStep}
          disabled={!stepText.trim()}
        >
          Add
        </Button>
      </Box>
    </Box>
  );
};

export default ScenarioBuilder;

// src/components/selfHealing/HealingHistory.tsx
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  IconButton,
  Tooltip,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Collapse,
  TextField,
  CircularProgress
} from '@mui/material';
import HistoryIcon from '@mui/icons-material/History';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import VisibilityIcon from '@mui/icons-material/Visibility';
import RestoreIcon from '@mui/icons-material/Restore';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import { useApiContext } from '../../contexts/ApiContext';
import { useProjectContext } from '../../contexts/ProjectContext';
import { toast } from 'react-toastify';
import SelectorOptimizer from './SelectorOptimizer';

interface HealingRecord {
  id: string;
  testCaseId: string;
  testCaseName: string;
  stepId: string;
  stepIndex: number;
  stepName: string;
  originalSelector: string;
  healedSelector: string;
  timestamp: string;
  successful: boolean;
  healingScore: number;
  healingMethod: string;
  approved: boolean;
  screenshots: {
    before: string;
    after: string;
  };
}

interface ExpandableRowProps {
  row: HealingRecord;
  onApprove: (recordId: string, approve: boolean) => void;
  onRestore: (recordId: string) => void;
}

const ExpandableRow: React.FC<ExpandableRowProps> = ({ row, onApprove, onRestore }) => {
  const [open, setOpen] = useState(false);
  const [viewingScreenshots, setViewingScreenshots] = useState(false);
  
  return (
    <>
      <TableRow sx={{ '& > *': { borderBottom: 'unset' } }}>
        <TableCell>
          <IconButton
            size="small"
            onClick={() => setOpen(!open)}
          >
            {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
          </IconButton>
        </TableCell>
        <TableCell component="th" scope="row">
          {row.testCaseName}
        </TableCell>
        <TableCell>{row.stepName}</TableCell>
        <TableCell>
          <Chip 
            label={row.successful ? 'Successful' : 'Failed'} 
            color={row.successful ? 'success' : 'error'} 
            size="small"
            icon={row.successful ? <CheckCircleOutlineIcon /> : <ErrorOutlineIcon />}
          />
        </TableCell>
        <TableCell>{row.healingMethod}</TableCell>
        <TableCell>{row.healingScore.toFixed(2)}</TableCell>
        <TableCell>
          {new Date(row.timestamp).toLocaleString()}
        </TableCell>
        <TableCell>
          <Box sx={{ display: 'flex' }}>
            <Tooltip title="View Screenshots">
              <IconButton 
                size="small" 
                onClick={() => setViewingScreenshots(true)}
              >
                <VisibilityIcon fontSize="small" />
              </IconButton>
            </Tooltip>
            
            {!row.approved && row.successful && (
              <Tooltip title="Approve Healing">
                <IconButton 
                  size="small" 
                  color="success"
                  onClick={() => onApprove(row.id, true)}
                >
                  <CheckCircleOutlineIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
            
            {row.approved && (
              <Tooltip title="Restore Original">
                <IconButton 
                  size="small" 
                  color="warning"
                  onClick={() => onRestore(row.id)}
                >
                  <RestoreIcon fontSize="small" />
                </IconButton>
              </Tooltip>
            )}
          </Box>
        </TableCell>
      </TableRow>
      
      <TableRow>
        <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={8}>
          <Collapse in={open} timeout="auto" unmountOnExit>
            <Box sx={{ margin: 1, p: 2, backgroundColor: 'background.paper' }}>
              <Typography variant="h6" gutterBottom component="div">
                Selector Details
              </Typography>
              
              <Box sx={{ display: 'flex', mb: 2 }}>
                <TextField
                  label="Original Selector"
                  value={row.originalSelector}
                  fullWidth
                  InputProps={{ readOnly: true }}
                  variant="outlined"
                  size="small"
                  sx={{ mr: 2 }}
                />
                
                <TextField
                  label="Healed Selector"
                  value={row.healedSelector}
                  fullWidth
                  InputProps={{ readOnly: true }}
                  variant="outlined"
                  size="small"
                  color={row.successful ? "success" : "error"}
                />
              </Box>
            </Box>
          </Collapse>
        </TableCell>
      </TableRow>
      
      <Dialog
        open={viewingScreenshots}
        onClose={() => setViewingScreenshots(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Before and After Screenshots</DialogTitle>
        <DialogContent>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Box>
              <Typography variant="subtitle1">Before Healing</Typography>
              {row.screenshots?.before ? (
                <img 
                  src={row.screenshots.before} 
                  alt="Before healing" 
                  style={{ maxWidth: '100%', border: '1px solid #ccc' }}
                />
              ) : (
                <Typography color="text.secondary">No screenshot available</Typography>
              )}
            </Box>
            
            <Box>
              <Typography variant="subtitle1">After Healing</Typography>
              {row.screenshots?.after ? (
                <img 
                  src={row.screenshots.after} 
                  alt="After healing" 
                  style={{ maxWidth: '100%', border: '1px solid #ccc' }}
                />
              ) : (
                <Typography color="text.secondary">No screenshot available</Typography>
              )}
            </Box>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setViewingScreenshots(false)}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

const HealingHistory: React.FC = () => {
  const { api } = useApiContext();
  const { currentProject } = useProjectContext();
  
  const [healingRecords, setHealingRecords] = useState<HealingRecord[]>([]);
  const [loading, setLoading] = useState(true);
  const [showOptimizer, setShowOptimizer] = useState(false);
  const [selectedRecord, setSelectedRecord] = useState<HealingRecord | null>(null);
  
  useEffect(() => {
    if (currentProject?.id) {
      loadHealingHistory();
    }
  }, [currentProject]);
  
  const loadHealingHistory = async () => {
    try {
      setLoading(true);
      const response = await api.get(`/api/self-healing/history?projectId=${currentProject?.id}`);
      setHealingRecords(response.data);
    } catch (error) {
      console.error('Error loading healing history:', error);
      toast.error('Failed to load healing history');
    } finally {
      setLoading(false);
    }
  };
  
  const handleApproveHealing = async (recordId: string, approve: boolean) => {
    try {
      await api.post(`/api/self-healing/approve/${recordId}`, { approve });
      
      // Update local state
      setHealingRecords(prevRecords => 
        prevRecords.map(record => 
          record.id === recordId 
            ? { ...record, approved: approve }
            : record
        )
      );
      
      toast.success('Healing decision saved');
    } catch (error) {
      console.error('Error approving healing:', error);
      toast.error('Failed to approve healing');
    }
  };
  
  const handleRestoreOriginal = async (recordId: string) => {
    try {
      await api.post(`/api/self-healing/restore/${recordId}`);
      
      // Update local state
      setHealingRecords(prevRecords => 
        prevRecords.map(record => 
          record.id === recordId 
            ? { ...record, approved: false }
            : record
        )
      );
      
      toast.success('Original selector restored');
    } catch (error) {
      console.error('Error restoring original selector:', error);
      toast.error('Failed to restore original selector');
    }
  };
  
  const handleOptimizerOpen = (record: HealingRecord) => {
    setSelectedRecord(record);
    setShowOptimizer(true);
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography variant="h5" sx={{ display: 'flex', alignItems: 'center' }}>
            <HistoryIcon sx={{ mr: 1 }} /> Healing History
          </Typography>
          <Button 
            variant="outlined" 
            onClick={loadHealingHistory}
          >
            Refresh
          </Button>
        </Box>
        
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        ) : healingRecords.length === 0 ? (
          <Typography color="text.secondary" sx={{ textAlign: 'center', p: 4 }}>
            No healing events recorded yet. Run tests to generate healing history.
          </Typography>
        ) : (
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell />
                  <TableCell>Test Case</TableCell>
                  <TableCell>Step</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Method</TableCell>
                  <TableCell>Score</TableCell>
                  <TableCell>Timestamp</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {healingRecords.map((record) => (
                  <ExpandableRow
                    key={record.id}
                    row={record}
                    onApprove={handleApproveHealing}
                    onRestore={handleRestoreOriginal}
                  />
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        )}
      </Paper>
      
      {selectedRecord && (
        <Dialog 
          open={showOptimizer} 
          onClose={() => setShowOptimizer(false)}
          fullWidth
          maxWidth="md"
        >
          <DialogTitle>Optimize Selector</DialogTitle>
          <DialogContent>
            <SelectorOptimizer 
              selector={selectedRecord.healedSelector} 
              testCaseId={selectedRecord.testCaseId}
              stepId={selectedRecord.stepId}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setShowOptimizer(false)}>Close</Button>
          </DialogActions>
        </Dialog>
      )}
    </Box>
  );
};

export default HealingHistory;


// src/components/selfHealing/SelectorOptimizer.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  TextField,
  Button,
  Typography,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Divider,
  Paper,
  CircularProgress,
  Chip,
  IconButton,
  Tooltip,
  LinearProgress,
  Grid,
  FormControlLabel,
  Switch
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import RefreshIcon from '@mui/icons-material/Refresh';
import SaveIcon from '@mui/icons-material/Save';
import MemoryIcon from '@mui/icons-material/Memory';
import { useApiContext } from '../../contexts/ApiContext';
import { toast } from 'react-toastify';
import { CodeEditor } from '../common/CodeEditor';

interface SelectorOptimization {
  selector: string;
  type: string;
  score: number;
  robustness: number;
  performance: number;
  readability: number;
  reasons: string[];
}

interface SelectorOptimizerProps {
  selector: string;
  testCaseId?: string;
  stepId?: string;
  onSave?: (selector: string) => void;
}

const SelectorOptimizer: React.FC<SelectorOptimizerProps> = ({ 
  selector: initialSelector,
  testCaseId,
  stepId,
  onSave
}) => {
  const { api } = useApiContext();
  
  const [selector, setSelector] = useState(initialSelector);
  const [generating, setGenerating] = useState(false);
  const [optimizations, setOptimizations] = useState<SelectorOptimization[]>([]);
  const [selectedOptimization, setSelectedOptimization] = useState<SelectorOptimization | null>(null);
  const [saving, setSaving] = useState(false);
  const [includeAI, setIncludeAI] = useState(true);
  const [verifyAll, setVerifyAll] = useState(false);
  const [verifying, setVerifying] = useState(false);
  const [verificationResults, setVerificationResults] = useState<Record<string, boolean>>({});
  
  useEffect(() => {
    if (initialSelector) {
      setSelector(initialSelector);
    }
  }, [initialSelector]);
  
  const handleOptimize = async () => {
    if (!selector.trim()) {
      toast.error('Please enter a selector to optimize');
      return;
    }
    
    try {
      setGenerating(true);
      setOptimizations([]);
      setSelectedOptimization(null);
      
      const response = await api.post('/api/self-healing/optimize-selector', {
        selector,
        testCaseId,
        stepId,
        includeAI
      });
      
      setOptimizations(response.data);
      
      if (response.data.length > 0) {
        setSelectedOptimization(response.data[0]);
      } else {
        toast.info('No optimizations could be generated');
      }
    } catch (error) {
      console.error('Error optimizing selector:', error);
      toast.error('Failed to optimize selector');
    } finally {
      setGenerating(false);
    }
  };
  
  const handleVerify = async (optimizationSelector: string) => {
    if (!testCaseId || !stepId) {
      toast.warning('Cannot verify selector without test case and step information');
      return;
    }
    
    try {
      setVerifying(true);
      
      const response = await api.post('/api/self-healing/verify-selector', {
        selector: optimizationSelector,
        testCaseId,
        stepId
      });
      
      setVerificationResults(prev => ({
        ...prev,
        [optimizationSelector]: response.data.valid
      }));
      
      toast.info(response.data.valid 
        ? 'Selector verified successfully' 
        : 'Selector verification failed');
    } catch (error) {
      console.error('Error verifying selector:', error);
      toast.error('Failed to verify selector');
    } finally {
      setVerifying(false);
    }
  };
  
  const handleVerifyAll = async () => {
    if (!testCaseId || !stepId) {
      toast.warning('Cannot verify selectors without test case and step information');
      return;
    }
    
    try {
      setVerifying(true);
      
      const results: Record<string, boolean> = {};
      
      for (const opt of optimizations) {
        try {
          const response = await api.post('/api/self-healing/verify-selector', {
            selector: opt.selector,
            testCaseId,
            stepId
          });
          
          results[opt.selector] = response.data.valid;
        } catch {
          results[opt.selector] = false;
        }
      }
      
      setVerificationResults(results);
      
      const validCount = Object.values(results).filter(Boolean).length;
      toast.info(`Verified ${validCount} out of ${optimizations.length} selectors`);
    } catch (error) {
      console.error('Error verifying selectors:', error);
      toast.error('Failed to verify selectors');
    } finally {
      setVerifying(false);
    }
  };
  
  const handleSaveSelector = async () => {
    if (!selectedOptimization) return;
    if (!testCaseId || !stepId) {
      if (onSave) {
        onSave(selectedOptimization.selector);
        toast.success('Selector saved');
      } else {
        toast.warning('Cannot save selector without test case and step information');
      }
      return;
    }
    
    try {
      setSaving(true);
      
      await api.post('/api/self-healing/update-selector', {
        selector: selectedOptimization.selector,
        testCaseId,
        stepId
      });
      
      toast.success('Selector updated successfully');
      
      if (onSave) {
        onSave(selectedOptimization.selector);
      }
    } catch (error) {
      console.error('Error saving selector:', error);
      toast.error('Failed to save selector');
    } finally {
      setSaving(false);
    }
  };
  
  const handleCopyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success('Copied to clipboard');
  };
  
  const renderScore = (score: number) => {
    let color = 'error';
    if (score >= 80) color = 'success';
    else if (score >= 60) color = 'warning';
    
    return (
      <Chip 
        label={`${score}%`} 
        color={color as 'error' | 'success' | 'warning'} 
        size="small"
        sx={{ minWidth: 60 }}
      />
    );
  };
  
  return (
    <Box>
      <Box sx={{ mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Original Selector
        </Typography>
        <TextField
          fullWidth
          variant="outlined"
          value={selector}
          onChange={(e) => setSelector(e.target.value)}
          InputProps={{
            endAdornment: (
              <IconButton onClick={() => handleCopyToClipboard(selector)}>
                <ContentCopyIcon fontSize="small" />
              </IconButton>
            )
          }}
        />
      </Box>
      
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <FormControlLabel
            control={
              <Switch
                checked={includeAI}
                onChange={(e) => setIncludeAI(e.target.checked)}
              />
            }
            label="Include AI optimizations"
          />
          <FormControlLabel
            control={
              <Switch
                checked={verifyAll}
                onChange={(e) => setVerifyAll(e.target.checked)}
                disabled={!testCaseId || !stepId}
              />
            }
            label="Verify optimizations"
          />
        </Box>
        <Button
          variant="contained"
          onClick={handleOptimize}
          disabled={generating || !selector.trim()}
          startIcon={generating ? <CircularProgress size={20} /> : <RefreshIcon />}
        >
          {generating ? 'Generating...' : 'Generate Optimizations'}
        </Button>
      </Box>
      
      {generating ? (
        <Box sx={{ width: '100%', mt: 2 }}>
          <LinearProgress />
          <Typography variant="body2" sx={{ mt: 1, textAlign: 'center' }}>
            Analyzing selector and generating optimizations...
          </Typography>
        </Box>
      ) : optimizations.length > 0 ? (
        <Grid container spacing={2}>
          <Grid item xs={12} md={5}>
            <Typography variant="subtitle1" gutterBottom>
              Available Optimizations
            </Typography>
            <Paper variant="outlined" sx={{ height: 300, overflow: 'auto' }}>
              <List dense>
                {optimizations.map((opt, index) => (
                  <React.Fragment key={index}>
                    <ListItem
                      button
                      selected={selectedOptimization?.selector === opt.selector}
                      onClick={() => setSelectedOptimization(opt)}
                    >
                      <ListItemIcon>
                        {opt.type === 'AI' ? (
                          <MemoryIcon color="primary" />
                        ) : (
                          <CheckCircleIcon color="success" />
                        )}
                      </ListItemIcon>
                      <ListItemText
                        primary={`${opt.type}: ${opt.selector.substring(0, 25)}${opt.selector.length > 25 ? '...' : ''}`}
                        secondary={
                          <Box sx={{ display: 'flex', gap: 1, mt: 0.5 }}>
                            {renderScore(opt.score)}
                            {verificationResults[opt.selector] !== undefined && (
                              <Chip
                                label={verificationResults[opt.selector] ? 'Valid' : 'Invalid'}
                                color={verificationResults[opt.selector] ? 'success' : 'error'}
                                size="small"
                              />
                            )}
                          </Box>
                        }
                      />
                      {testCaseId && stepId && !verifyAll && (
                        <Tooltip title="Verify Selector">
                          <IconButton
                            size="small"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleVerify(opt.selector);
                            }}
                            disabled={verifying}
                          >
                            {verifying ? (
                              <CircularProgress size={16} />
                            ) : (
                              <RefreshIcon fontSize="small" />
                            )}
                          </IconButton>
                        </Tooltip>
                      )}
                    </ListItem>
                    {index < optimizations.length - 1 && <Divider />}
                  </React.Fragment>
                ))}
              </List>
            </Paper>
            
            {verifyAll && testCaseId && stepId && (
              <Button
                variant="outlined"
                fullWidth
                sx={{ mt: 1 }}
                onClick={handleVerifyAll}
                disabled={verifying || optimizations.length === 0}
                startIcon={verifying ? <CircularProgress size={20} /> : <RefreshIcon />}
              >
                {verifying ? 'Verifying...' : 'Verify All Selectors'}
              </Button>
            )}
          </Grid>
          
          <Grid item xs={12} md={7}>
            {selectedOptimization && (
              <Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="subtitle1">
                    Selected Optimization
                  </Typography>
                  <Box>
                    <Button
                      variant="contained"
                      size="small"
                      startIcon={saving ? <CircularProgress size={16} /> : <SaveIcon />}
                      onClick={handleSaveSelector}
                      disabled={saving}
                      sx={{ mr: 1 }}
                    >
                      Save
                    </Button>
                    <Button
                      variant="outlined"
                      size="small"
                      startIcon={<ContentCopyIcon />}
                      onClick={() => handleCopyToClipboard(selectedOptimization.selector)}
                    >
                      Copy
                    </Button>
                  </Box>
                </Box>
                
                <TextField
                  label="Optimized Selector"
                  value={selectedOptimization.selector}
                  fullWidth
                  variant="outlined"
                  InputProps={{ readOnly: true }}
                  sx={{ mb: 2 }}
                />
                
                <Box sx={{ mb: 2 }}>
                  <Typography variant="body2" gutterBottom>
                    Optimization Type: <Chip label={selectedOptimization.type} size="small" />
                  </Typography>
                  <Typography variant="body2" gutterBottom>
                    Overall Score: {renderScore(selectedOptimization.score)}
                  </Typography>
                  
                  <Box sx={{ mt: 1 }}>
                    <Grid container spacing={1}>
                      <Grid item xs={4}>
                        <Typography variant="caption">Robustness</Typography>
                        <LinearProgress 
                          variant="determinate" 
                          value={selectedOptimization.robustness} 
                          color={selectedOptimization.robustness >= 70 ? "success" : "warning"}
                          sx={{ height: 8, borderRadius: 1 }}
                        />
                      </Grid>
                      <Grid item xs={4}>
                        <Typography variant="caption">Performance</Typography>
                        <LinearProgress 
                          variant="determinate" 
                          value={selectedOptimization.performance} 
                          color={selectedOptimization.performance >= 70 ? "success" : "warning"}
                          sx={{ height: 8, borderRadius: 1 }}
                        />
                      </Grid>
                      <Grid item xs={4}>
                        <Typography variant="caption">Readability</Typography>
                        <LinearProgress 
                          variant="determinate" 
                          value={selectedOptimization.readability} 
                          color={selectedOptimization.readability >= 70 ? "success" : "warning"}
                          sx={{ height: 8, borderRadius: 1 }}
                        />
                      </Grid>
                    </Grid>
                  </Box>
                </Box>
                
                <Typography variant="subtitle2">Optimization Reasoning</Typography>
                <Paper variant="outlined" sx={{ p: 1, maxHeight: 150, overflow: 'auto' }}>
                  <List dense disablePadding>
                    {selectedOptimization.reasons.map((reason, index) => (
                      <ListItem key={index} disablePadding sx={{ py: 0.5 }}>
                        <ListItemText 
                          primary={`${index + 1}. ${reason}`} 
                          primaryTypographyProps={{ variant: 'body2' }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Box>
            )}
          </Grid>
        </Grid>
      ) : (
        <Box sx={{ textAlign: 'center', p: 3, color: 'text.secondary' }}>
          Click "Generate Optimizations" to analyze and improve your selector
        </Box>
      )}
    </Box>
  );
};

export default SelectorOptimizer;

Healing Rules Component:
----------------------------

// src/components/selfHealing/HealingRules.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Button,
  TextField,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Switch,
  CircularProgress,
  Chip,
  Tooltip,
  Divider,
  Grid,
  Slider
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import { useApiContext } from '../../contexts/ApiContext';
import { useProjectContext } from '../../contexts/ProjectContext';
import { toast } from 'react-toastify';
import { CodeEditor } from '../common/CodeEditor';

interface HealingRule {
  id: string;
  name: string;
  description: string;
  projectId: string;
  enabled: boolean;
  priority: number;
  ruleType: 'attribute' | 'similarity' | 'structure' | 'custom' | 'ml';
  matchCriteria: string;
  transformLogic: string;
  testCaseFilter?: string;
  elementTypeFilter?: string[];
  config?: {
    similarityThreshold?: number;
    useAI?: boolean;
    waitTimeAfterHealing?: number;
    applyToAll?: boolean;
  };
  createdAt: string;
  updatedAt: string;
}

const defaultRule: Omit<HealingRule, 'id' | 'createdAt' | 'updatedAt'> = {
  name: '',
  description: '',
  projectId: '',
  enabled: true,
  priority: 50,
  ruleType: 'attribute',
  matchCriteria: '',
  transformLogic: '',
  elementTypeFilter: ['button', 'input', 'a', 'select'],
  config: {
    similarityThreshold: 80,
    useAI: false,
    waitTimeAfterHealing: 500,
    applyToAll: false
  }
};

const RULE_TYPE_DESCRIPTIONS = {
  attribute: 'Rebuilds selectors by modifying their attributes',
  similarity: 'Uses element text and tag similarity to find matches',
  structure: 'Uses DOM structure and proximity to locate elements',
  custom: 'Uses custom JavaScript logic for advanced healing',
  ml: 'Uses machine learning to predict best selector alternatives'
};

const HealingRules: React.FC = () => {
  const { api } = useApiContext();
  const { currentProject } = useProjectContext();
  
  const [rules, setRules] = useState<HealingRule[]>([]);
  const [loading, setLoading] = useState(true);
  const [openDialog, setOpenDialog] = useState(false);
  const [currentRule, setCurrentRule] = useState<Omit<HealingRule, 'id' | 'createdAt' | 'updatedAt'>>(defaultRule);
  const [isEditing, setIsEditing] = useState(false);
  const [editingRuleId, setEditingRuleId] = useState<string | null>(null);
  const [testCases, setTestCases] = useState<{id: string, name: string}[]>([]);
  const [helpDialogOpen, setHelpDialogOpen] = useState(false);
  const [helpTopic, setHelpTopic] = useState<string>('');
  
  useEffect(() => {
    if (currentProject?.id) {
      loadRules();
      loadTestCases();
      setCurrentRule(prev => ({ ...prev, projectId: currentProject.id }));
    }
  }, [currentProject]);
  
  const loadRules = async () => {
    try {
      setLoading(true);
      const response = await api.get(`/api/self-healing/rules?projectId=${currentProject?.id}`);
      setRules(response.data);
    } catch (error) {
      console.error('Error loading healing rules:', error);
      toast.error('Failed to load healing rules');
    } finally {
      setLoading(false);
    }
  };
  
  const loadTestCases = async () => {
    try {
      const response = await api.get(`/api/test-cases?projectId=${currentProject?.id}`);
      setTestCases(response.data.map((tc: any) => ({ id: tc.id, name: tc.name })));
    } catch (error) {
      console.error('Error loading test cases:', error);
    }
  };
  
  const handleOpenDialog = (rule?: HealingRule) => {
    if (rule) {
      const { id, createdAt, updatedAt, ...ruleData } = rule;
      setCurrentRule(ruleData);
      setIsEditing(true);
      setEditingRuleId(id);
    } else {
      setCurrentRule({
        ...defaultRule,
        projectId: currentProject?.id || ''
      });
      setIsEditing(false);
      setEditingRuleId(null);
    }
    setOpenDialog(true);
  };
  
  const handleCloseDialog = () => {
    setOpenDialog(false);
  };
  
  const handleSaveRule = async () => {
    if (!currentRule.name.trim()) {
      toast.error('Rule name is required');
      return;
    }
    
    try {
      let response;
      
      if (isEditing && editingRuleId) {
        response = await api.put(`/api/self-healing/rules/${editingRuleId}`, currentRule);
        toast.success('Rule updated successfully');
        
        // Update rule in the list
        setRules(prevRules => 
          prevRules.map(rule => 
            rule.id === editingRuleId ? response.data : rule
          )
        );
      } else {
        response = await api.post('/api/self-healing/rules', currentRule);
        toast.success('Rule created successfully');
        
        // Add new rule to the list
        setRules(prevRules => [...prevRules, response.data]);
      }
      
      handleCloseDialog();
    } catch (error) {
      console.error('Error saving rule:', error);
      toast.error('Failed to save rule');
    }
  };
  
  const handleDeleteRule = async (id: string) => {
    if (window.confirm('Are you sure you want to delete this rule?')) {
      try {
        await api.delete(`/api/self-healing/rules/${id}`);
        toast.success('Rule deleted successfully');
        
        // Remove rule from the list
        setRules(prevRules => prevRules.filter(rule => rule.id !== id));
      } catch (error) {
        console.error('Error deleting rule:', error);
        toast.error('Failed to delete rule');
      }
    }
  };
  
  const handleToggleRule = async (id: string, enabled: boolean) => {
    try {
      await api.patch(`/api/self-healing/rules/${id}/toggle`, { enabled });
      
      // Update rule status in the list
      setRules(prevRules => 
        prevRules.map(rule => 
          rule.id === id ? { ...rule, enabled } : rule
        )
      );
      
      toast.success(`Rule ${enabled ? 'enabled' : 'disabled'} successfully`);
    } catch (error) {
      console.error('Error toggling rule:', error);
      toast.error('Failed to update rule status');
    }
  };
  
  const handleTestRule = async (ruleId: string) => {
    try {
      const response = await api.post(`/api/self-healing/rules/${ruleId}/test`);
      
      if (response.data.success) {
        toast.success('Rule test successful: ' + response.data.message);
      } else {
        toast.warning('Rule test failed: ' + response.data.message);
      }
    } catch (error) {
      console.error('Error testing rule:', error);
      toast.error('Failed to test rule');
    }
  };
  
  const handleElementTypeFilterChange = (event: any) => {
    setCurrentRule(prev => ({
      ...prev,
      elementTypeFilter: event.target.value as string[]
    }));
  };
  
  const showHelp = (topic: string) => {
    setHelpTopic(topic);
    setHelpDialogOpen(true);
  };
  
  const getHelpContent = () => {
    switch (helpTopic) {
      case 'ruleType':
        return (
          <Box>
            <Typography variant="h6" gutterBottom>Rule Types</Typography>
            <Typography variant="body2" paragraph>
              Different rule types use different strategies to heal broken selectors:
            </Typography>
            
            {Object.entries(RULE_TYPE_DESCRIPTIONS).map(([type, desc]) => (
              <Box key={type} sx={{ mb: 2 }}>
                <Typography variant="subtitle2">{type.charAt(0).toUpperCase() + type.slice(1)}</Typography>
                <Typography variant="body2">{desc}</Typography>
              </Box>
            ))}
            
            <Typography variant="subtitle2" sx={{ mt: 2 }}>Best Practices</Typography>
            <Typography variant="body2">
              Start with attribute-based rules for simplicity, then add similarity and structure-based rules.
              Only use custom rules when you need complex logic that other rule types can't handle.
            </Typography>
          </Box>
        );
        
      case 'matchCriteria':
        return (
          <Box>
            <Typography variant="h6" gutterBottom>Match Criteria</Typography>
            <Typography variant="body2" paragraph>
              Match criteria determines when this rule should be applied. The format depends on the rule type:
            </Typography>
            
            <Typography variant="subtitle2">Attribute Rules</Typography>
            <Typography variant="body2" paragraph>
              Use JavaScript object with attribute matching patterns:
            </Typography>
            <Box sx={{ mb: 2, bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`{
  "id": "contains:product-",
  "class": "matches:btn-.*",
  "type": "equals:button"
}`}
              </pre>
            </Box>
            
            <Typography variant="subtitle2">Similarity Rules</Typography>
            <Typography variant="body2" paragraph>
              Specify text content or structure patterns to match:
            </Typography>
            <Box sx={{ mb: 2, bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`{
  "textContent": "contains:Log in",
  "tagName": "equals:button"
}`}
              </pre>
            </Box>
            
            <Typography variant="subtitle2">Custom Rules</Typography>
            <Typography variant="body2">
              For custom rules, use a JavaScript function returning true/false:
            </Typography>
            <Box sx={{ bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`function(selector, element, page) {
  return selector.includes('#') && 
         element.tagName === 'BUTTON';
}`}
              </pre>
            </Box>
          </Box>
        );
        
      case 'transformLogic':
        return (
          <Box>
            <Typography variant="h6" gutterBottom>Transform Logic</Typography>
            <Typography variant="body2" paragraph>
              This defines how to transform a broken selector into a working one:
            </Typography>
            
            <Typography variant="subtitle2">Attribute Rules</Typography>
            <Typography variant="body2" paragraph>
              Specify attribute transformations:
            </Typography>
            <Box sx={{ mb: 2, bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`{
  "id": "remove", 
  "class": "replace:old-class:new-class",
  "data-testid": "add:login-btn"
}`}
              </pre>
            </Box>
            
            <Typography variant="subtitle2">Similarity/Structure Rules</Typography>
            <Typography variant="body2" paragraph>
              Configure how to prioritize element characteristics:
            </Typography>
            <Box sx={{ mb: 2, bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`{
  "textWeight": 0.7,
  "tagWeight": 0.2,
  "structureWeight": 0.1,
  "requireSameTag": true
}`}
              </pre>
            </Box>
            
            <Typography variant="subtitle2">Custom Rules</Typography>
            <Typography variant="body2">
              For custom rules, use a function that returns the new selector:
            </Typography>
            <Box sx={{ bgcolor: 'background.paper', p: 1, borderRadius: 1 }}>
              <pre style={{ margin: 0 }}>
{`function(brokenSelector, page) {
  // Extract element ID
  const id = brokenSelector.match(/id=['"]([^'"]+)['"]/);
  if (!id) return null;
  
  // Create new selector with data-testid
  return \`[data-testid="\${id[1]}"]\`;
}`}
              </pre>
            </Box>
          </Box>
        );
        
      default:
        return (
          <Typography>Select a topic to see help information.</Typography>
        );
    }
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h5">Self-Healing Rules</Typography>
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => handleOpenDialog()}
          >
            Add New Rule
          </Button>
        </Box>
        
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        ) : rules.length === 0 ? (
          <Box sx={{ textAlign: 'center', p: 4, color: 'text.secondary' }}>
            <Typography paragraph>
              No self-healing rules defined yet.
            </Typography>
            <Typography>
              Rules help automatically fix broken selectors during test execution.
            </Typography>
          </Box>
        ) : (
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Type</TableCell>
                  <TableCell>Priority</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Last Updated</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {rules.map((rule) => (
                  <TableRow key={rule.id}>
                    <TableCell>
                      <Typography variant="body2">{rule.name}</Typography>
                      {rule.description && (
                        <Typography variant="caption" color="text.secondary">
                          {rule.description}
                        </Typography>
                      )}
                    </TableCell>
                    <TableCell>
                      <Chip 
                        label={rule.ruleType.charAt(0).toUpperCase() + rule.ruleType.slice(1)} 
                        size="small"
                        color={
                          rule.ruleType === 'custom' 
                            ? 'warning' 
                            : rule.ruleType === 'ml' 
                              ? 'info' 
                              : 'default'
                        }
                      />
                    </TableCell>
                    <TableCell>{rule.priority}</TableCell>
                    <TableCell>
                      <FormControlLabel
                        control={
                          <Switch
                            size="small"
                            checked={rule.enabled}
                            onChange={(e) => handleToggleRule(rule.id, e.target.checked)}
                          />
                        }
                        label={rule.enabled ? 'Enabled' : 'Disabled'}
                      />
                    </TableCell>
                    <TableCell>
                      {new Date(rule.updatedAt).toLocaleDateString()}
                    </TableCell>
                    <TableCell>
                      <IconButton size="small" onClick={() => handleOpenDialog(rule)} sx={{ mr: 1 }}>
                        <EditIcon fontSize="small" />
                      </IconButton>
                      <IconButton size="small" onClick={() => handleTestRule(rule.id)} sx={{ mr: 1 }}>
                        <PlayArrowIcon fontSize="small" />
                      </IconButton>
                      <IconButton size="small" color="error" onClick={() => handleDeleteRule(rule.id)}>
                        <DeleteIcon fontSize="small" />
                      </IconButton>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        )}
      </Paper>
      
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>{isEditing ? 'Edit Rule' : 'Create New Rule'}</DialogTitle>
        <DialogContent dividers>
          {renderRuleForm()}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button variant="contained" onClick={handleSaveRule}>
            {isEditing ? 'Update' : 'Create'}
          </Button>
        </DialogActions>
      </Dialog>
      
      <Dialog
        open={helpDialogOpen}
        onClose={() => setHelpDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Help: {helpTopic.charAt(0).toUpperCase() + helpTopic.slice(1)}</DialogTitle>
        <DialogContent dividers>
          {getHelpContent()}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setHelpDialogOpen(false)}>Close</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

const renderRuleForm = () => {
    return (
      <>
        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <TextField
              label="Rule Name"
              fullWidth
              required
              value={currentRule.name}
              onChange={(e) => setCurrentRule(prev => ({ ...prev, name: e.target.value }))}
              margin="normal"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField
              label="Description"
              fullWidth
              value={currentRule.description}
              onChange={(e) => setCurrentRule(prev => ({ ...prev, description: e.target.value }))}
              margin="normal"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControl fullWidth margin="normal">
              <InputLabel id="rule-type-label">Rule Type</InputLabel>
              <Select
                labelId="rule-type-label"
                value={currentRule.ruleType}
                label="Rule Type"
                onChange={(e) => setCurrentRule(prev => ({ ...prev, ruleType: e.target.value as HealingRule['ruleType'] }))}
                endAdornment={
                  <IconButton 
                    size="small" 
                    sx={{ mr: 2 }}
                    onClick={() => showHelp('ruleType')}
                  >
                    <HelpOutlineIcon fontSize="small" />
                  </IconButton>
                }
              >
                <MenuItem value="attribute">Attribute Based</MenuItem>
                <MenuItem value="similarity">Similarity Based</MenuItem>
                <MenuItem value="structure">Structure Based</MenuItem>
                <MenuItem value="custom">Custom Logic</MenuItem>
                <MenuItem value="ml">Machine Learning</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          <Grid item xs={12} md={6}>
            <Typography 
              variant="body2" 
              color="text.secondary" 
              sx={{ mt: 2 }}
            >
              {RULE_TYPE_DESCRIPTIONS[currentRule.ruleType]}
            </Typography>
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControl fullWidth margin="normal">
              <InputLabel id="element-type-label">Element Types</InputLabel>
              <Select
                labelId="element-type-label"
                multiple
                value={currentRule.elementTypeFilter || []}
                label="Element Types"
                onChange={(e) => setCurrentRule(prev => ({
                  ...prev,
                  elementTypeFilter: e.target.value as string[]
                }))}
                renderValue={(selected) => (
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                    {(selected as string[]).map((value) => (
                      <Chip key={value} label={value} size="small" />
                    ))}
                  </Box>
                )}
              >
                <MenuItem value="a">Links (a)</MenuItem>
                <MenuItem value="button">Buttons</MenuItem>
                <MenuItem value="input">Input Fields</MenuItem>
                <MenuItem value="select">Dropdowns</MenuItem>
                <MenuItem value="div">Divs</MenuItem>
                <MenuItem value="span">Spans</MenuItem>
                <MenuItem value="img">Images</MenuItem>
                <MenuItem value="table">Tables</MenuItem>
                <MenuItem value="*">All Elements</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          <Grid item xs={12} md={6}>
            <Box sx={{ mt: 4 }}>
              <Typography gutterBottom>
                Priority (Higher runs first)
              </Typography>
              <Slider
                value={currentRule.priority}
                onChange={(_, value) => setCurrentRule(prev => ({ ...prev, priority: value as number }))}
                min={0}
                max={100}
                step={5}
                valueLabelDisplay="auto"
                marks={[
                  { value: 0, label: 'Low' },
                  { value: 50, label: 'Med' },
                  { value: 100, label: 'High' }
                ]}
              />
            </Box>
          </Grid>
        </Grid>
        
        <Divider sx={{ my: 3 }} />
        
        <Typography variant="subtitle1" gutterBottom>
          Match Criteria
          <Tooltip title="Show help">
            <IconButton size="small" onClick={() => showHelp('matchCriteria')}>
              <HelpOutlineIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Typography>
        <Typography variant="body2" color="text.secondary" gutterBottom>
          Define when this rule should be applied to a broken selector
        </Typography>
        
        <Box sx={{ height: 200, mb: 3 }}>
          <CodeEditor
            language="json"
            value={currentRule.matchCriteria}
            onChange={(value) => setCurrentRule(prev => ({ ...prev, matchCriteria: value }))}
            height="100%"
          />
        </Box>
        
        <Typography variant="subtitle1" gutterBottom>
          Transform Logic
          <Tooltip title="Show help">
            <IconButton size="small" onClick={() => showHelp('transformLogic')}>
              <HelpOutlineIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Typography>
        <Typography variant="body2" color="text.secondary" gutterBottom>
          Define how to transform a broken selector into a working one
        </Typography>
        
        <Box sx={{ height: 200, mb: 3 }}>
          <CodeEditor
            language={currentRule.ruleType === 'custom' ? 'javascript' : 'json'}
            value={currentRule.transformLogic}
            onChange={(value) => setCurrentRule(prev => ({ ...prev, transformLogic: value }))}
            height="100%"
          />
        </Box>
        
        <Divider sx={{ my: 3 }} />
        
        <Typography variant="subtitle1" gutterBottom>
          Additional Configuration
        </Typography>
        
        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <FormControlLabel
              control={
                <Switch
                  checked={currentRule.enabled}
                  onChange={(e) => setCurrentRule(prev => ({ ...prev, enabled: e.target.checked }))}
                />
              }
              label="Rule Enabled"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControlLabel
              control={
                <Switch
                  checked={currentRule.config?.useAI || false}
                  onChange={(e) => setCurrentRule(prev => ({
                    ...prev,
                    config: { ...prev.config, useAI: e.target.checked }
                  }))}
                />
              }
              label="Use AI to enhance healing (when available)"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControlLabel
              control={
                <Switch
                  checked={currentRule.config?.applyToAll || false}
                  onChange={(e) => setCurrentRule(prev => ({
                    ...prev,
                    config: { ...prev.config, applyToAll: e.target.checked }
                  }))}
                />
              }
              label="Apply to all similar elements when healing"
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField
              label="Wait time after healing (ms)"
              type="number"
              fullWidth
              value={currentRule.config?.waitTimeAfterHealing || 500}
              onChange={(e) => setCurrentRule(prev => ({
                ...prev,
                config: { ...prev.config, waitTimeAfterHealing: parseInt(e.target.value) }
              }))}
              margin="normal"
            />
          </Grid>
          {currentRule.ruleType === 'similarity' && (
            <Grid item xs={12} md={6}>
              <Box sx={{ width: '100%' }}>
                <Typography gutterBottom>
                  Similarity Threshold (%)
                </Typography>
                <Slider
                  value={currentRule.config?.similarityThreshold || 80}
                  onChange={(_, value) => setCurrentRule(prev => ({
                    ...prev,
                    config: { ...prev.config, similarityThreshold: value as number }
                  }))}
                  min={50}
                  max={100}
                  step={5}
                  valueLabelDisplay="auto"
                  marks={[
                    { value: 50, label: '50%' },
                    { value: 80, label: '80%' },
                    { value: 100, label: '100%' }
                  ]}
                />
              </Box>
            </Grid>
          )}
        </Grid>
      </>
    );
  };


// src/components/nlp/TextToTest.tsx
import React, { useState } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  CircularProgress,
  Chip,
  Stepper,
  Step,
  StepLabel,
  Card,
  CardContent,
  Grid,
  FormControlLabel,
  Switch,
  Alert,
  Divider,
  IconButton,
  Tooltip
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import DeleteIcon from '@mui/icons-material/Delete';
import ChatIcon from '@mui/icons-material/Chat';
import SettingsIcon from '@mui/icons-material/Settings';
import LightbulbIcon from '@mui/icons-material/Lightbulb';
import CodeIcon from '@mui/icons-material/Code';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import { useApiContext } from '../../contexts/ApiContext';
import { useProjectContext } from '../../contexts/ProjectContext';
import { toast } from 'react-toastify';
import NLPResults from './NLPResults';
import StepMapping from './StepMapping';

interface TestDescription {
  id: string;
  input: string;
  testType: string;
  generationStatus: 'pending' | 'processing' | 'complete' | 'error';
  generatedSteps: GeneratedStep[];
  error?: string;
  createdAt: string;
}

interface GeneratedStep {
  id: string;
  order: number;
  description: string;
  action: string;
  selector?: string;
  value?: string;
  assertions?: string[];
  confidence: number;
  alternatives?: string[];
}

const TextToTest: React.FC = () => {
  const { api } = useApiContext();
  const { currentProject } = useProjectContext();
  
  const [description, setDescription] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [activeStep, setActiveStep] = useState(0);
  const [testDescriptions, setTestDescriptions] = useState<TestDescription[]>([]);
  const [selectedTest, setSelectedTest] = useState<TestDescription | null>(null);
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [options, setOptions] = useState({
    includeAssertions: true,
    optimizeSelectors: true,
    generateScreenshots: false,
    testType: 'e2e'
  });
  
  const handleGenerateTest = async () => {
    if (!description.trim()) {
      toast.error('Please enter a test description');
      return;
    }
    
    try {
      setIsGenerating(true);
      setActiveStep(0);
      
      // Create initial test description record
      const initialResponse = await api.post('/api/nlp/generate-test', {
        description: description.trim(),
        projectId: currentProject?.id,
        options
      });
      
      const newTest: TestDescription = initialResponse.data;
      
      // Add to test descriptions
      setTestDescriptions(prev => [newTest, ...prev]);
      setSelectedTest(newTest);
      
      // Start monitoring the generation process
      let testData = newTest;
      let attempts = 0;
      const maxAttempts = 30; // Maximum polling attempts
      
      const pollStatus = async () => {
        if (attempts >= maxAttempts) {
          toast.error('Test generation is taking longer than expected');
          return;
        }
        
        try {
          const statusResponse = await api.get(`/api/nlp/generation-status/${testData.id}`);
          testData = statusResponse.data;
          
          // Update the test in the list
          setTestDescriptions(prev => 
            prev.map(test => test.id === testData.id ? testData : test)
          );
          
          setSelectedTest(testData);
          
          if (testData.generationStatus === 'complete') {
            setActiveStep(1);
            toast.success('Test generation completed successfully');
          } else if (testData.generationStatus === 'error') {
            toast.error(`Test generation failed: ${testData.error || 'Unknown error'}`);
          } else if (testData.generationStatus === 'processing') {
            attempts++;
            setTimeout(pollStatus, 2000); // Poll every 2 seconds
          }
        } catch (error) {
          console.error('Error polling test generation status:', error);
          attempts++;
          setTimeout(pollStatus, 3000); // Retry with longer interval on error
        }
      };
      
      // Start polling
      setTimeout(pollStatus, 1000);
    } catch (error) {
      console.error('Error generating test:', error);
      toast.error('Failed to start test generation');
    } finally {
      setIsGenerating(false);
    }
  };
  
  const handleDeleteTest = async (testId: string) => {
    if (window.confirm('Are you sure you want to delete this test?')) {
      try {
        await api.delete(`/api/nlp/test-description/${testId}`);
        
        setTestDescriptions(prev => prev.filter(test => test.id !== testId));
        
        if (selectedTest?.id === testId) {
          setSelectedTest(null);
          setActiveStep(0);
        }
        
        toast.success('Test deleted successfully');
      } catch (error) {
        console.error('Error deleting test:', error);
        toast.error('Failed to delete test');
      }
    }
  };
  
  const handleSelectTest = (test: TestDescription) => {
    setSelectedTest(test);
    setActiveStep(test.generationStatus === 'complete' ? 1 : 0);
  };
  
  const handleNextStep = () => {
    setActiveStep((prevStep) => prevStep + 1);
  };
  
  const handleBackStep = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };
  
  const renderStepContent = () => {
    switch (activeStep) {
      case 0:
        return (
          <Box sx={{ mt: 3 }}>
            <Typography variant="h6" gutterBottom>
              Test Description
            </Typography>
            <TextField
              label="Describe what you want to test in natural language"
              fullWidth
              multiline
              rows={3}
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="E.g., Test the login functionality with valid credentials, verify redirection to dashboard"
              disabled={isGenerating}
              sx={{ mb: 2 }}
            />
            
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Button
                variant="text"
                startIcon={showAdvanced ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                onClick={() => setShowAdvanced(!showAdvanced)}
              >
                {showAdvanced ? 'Hide' : 'Show'} Advanced Options
              </Button>
              
              <Button
                variant="contained"
                color="primary"
                startIcon={isGenerating ? <CircularProgress size={20} /> : <SendIcon />}
                onClick={handleGenerateTest}
                disabled={isGenerating || !description.trim()}
              >
                {isGenerating ? 'Generating...' : 'Generate Test'}
              </Button>
            </Box>
            
            {showAdvanced && (
              <Paper variant="outlined" sx={{ p: 2, mb: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Advanced Options
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={options.includeAssertions}
                          onChange={(e) => setOptions(prev => ({ ...prev, includeAssertions: e.target.checked }))}
                        />
                      }
                      label="Include Assertions"
                    />
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={options.optimizeSelectors}
                          onChange={(e) => setOptions(prev => ({ ...prev, optimizeSelectors: e.target.checked }))}
                        />
                      }
                      label="Optimize Selectors"
                    />
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={options.generateScreenshots}
                          onChange={(e) => setOptions(prev => ({ ...prev, generateScreenshots: e.target.checked }))}
                        />
                      }
                      label="Generate Example Screenshots"
                    />
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={options.testType === 'e2e'}
                          onChange={(e) => setOptions(prev => ({ 
                            ...prev, 
                            testType: e.target.checked ? 'e2e' : 'api' 
                          }))}
                        />
                      }
                      label="End-to-end Test (vs API Test)"
                    />
                  </Grid>
                </Grid>
              </Paper>
            )}
            
            {testDescriptions.length > 0 && (
              <Box sx={{ mt: 4 }}>
                <Typography variant="subtitle1" gutterBottom>
                  Recent Test Generations
                </Typography>
                <Box sx={{ maxHeight: 300, overflow: 'auto' }}>
                  {testDescriptions.map((test) => (
                    <Card 
                      key={test.id} 
                      sx={{ 
                        mb: 1, 
                        cursor: 'pointer',
                        border: selectedTest?.id === test.id ? '2px solid primary.main' : 'none'
                      }}
                      onClick={() => handleSelectTest(test)}
                    >
                      <CardContent sx={{ py: 1, '&:last-child': { pb: 1 } }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <Box>
                            <Typography variant="subtitle2" noWrap sx={{ maxWidth: 300 }}>
                              {test.input.substring(0, 50)}{test.input.length > 50 ? '...' : ''}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              {new Date(test.createdAt).toLocaleString()}
                            </Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            <Chip 
                              label={test.generationStatus} 
                              size="small"
                              color={
                                test.generationStatus === 'complete' ? 'success' :
                                test.generationStatus === 'error' ? 'error' :
                                'warning'
                              }
                              sx={{ mr: 1 }}
                            />
                            <Tooltip title="Delete">
                              <IconButton 
                                size="small" 
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleDeleteTest(test.id);
                                }}
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  ))}
                </Box>
              </Box>
            )}
          </Box>
        );
        
      case 1:
        return (
          <Box sx={{ mt: 3 }}>
            {selectedTest && (
              <NLPResults 
                test={selectedTest}
                onNext={handleNextStep}
              />
            )}
          </Box>
        );
        
      case 2:
        return (
          <Box sx={{ mt: 3 }}>
            {selectedTest && (
              <StepMapping
                test={selectedTest}
                projectId={currentProject?.id || ''}
              />
            )}
          </Box>
        );
        
      default:
        return null;
    }
  };
  
  const steps = ['Describe Test', 'Review Generated Steps', 'Map to Test Case'];
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" sx={{ display: 'flex', alignItems: 'center', mb: 4 }}>
          <LightbulbIcon sx={{ mr: 1 }} /> Text to Test Automation
        </Typography>
        
        <Alert severity="info" sx={{ mb: 3 }}>
          Describe what you want to test in natural language, and we'll generate a test case with steps for you.
        </Alert>
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {renderStepContent()}
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
          <Button
            disabled={activeStep === 0}
            onClick={handleBackStep}
          >
            Back
          </Button>
          <Button
            variant="contained"
            disabled={
              (activeStep === 0 && (isGenerating || !description.trim())) ||
              (activeStep === 1 && !selectedTest) ||
              activeStep === steps.length - 1
            }
            onClick={handleNextStep}
          >
            {activeStep === steps.length - 1 ? 'Finish' : 'Next'}
          </Button>
        </Box>
      </Paper>
    </Box>
  );
};

export default TextToTest;


// src/components/nlp/NLPResults.tsx
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Paper,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Chip,
  Button,
  Divider,
  Card,
  CardContent,
  Grid,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tooltip,
  Tabs,
  Tab,
  Alert
} from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import CodeIcon from '@mui/icons-material/Code';
import CheckIcon from '@mui/icons-material/Check';
import WarningIcon from '@mui/icons-material/Warning';
import DragIndicatorIcon from '@mui/icons-material/DragIndicator';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { useApiContext } from '../../contexts/ApiContext';
import { toast } from 'react-toastify';
import { CodeEditor } from '../common/CodeEditor';

interface TestDescription {
  id: string;
  input: string;
  testType: string;
  generationStatus: 'pending' | 'processing' | 'complete' | 'error';
  generatedSteps: GeneratedStep[];
  error?: string;
  createdAt: string;
}

interface GeneratedStep {
  id: string;
  order: number;
  description: string;
  action: string;
  selector?: string;
  value?: string;
  assertions?: string[];
  confidence: number;
  alternatives?: string[];
}

interface NLPResultsProps {
  test: TestDescription;
  onNext: () => void;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`nlp-tabpanel-${index}`}
      aria-labelledby={`nlp-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

function a11yProps(index: number) {
  return {
    id: `nlp-tab-${index}`,
    'aria-controls': `nlp-tabpanel-${index}`,
  };
}

const NLPResults: React.FC<NLPResultsProps> = ({ test, onNext }) => {
  const { api } = useApiContext();
  
  const [steps, setSteps] = useState<GeneratedStep[]>([...test.generatedSteps]);
  const [editingStep, setEditingStep] = useState<GeneratedStep | null>(null);
  const [openDialog, setOpenDialog] = useState(false);
  const [modified, setModified] = useState(false);
  const [tabValue, setTabValue] = useState(0);
  const [codePreviewOpen, setCodePreviewOpen] = useState(false);
  const [generatedCode, setGeneratedCode] = useState<string>('');
  
  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  const handleDragEnd = (result: any) => {
    if (!result.destination) return;
    
    const items = Array.from(steps);
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    
    // Update order numbers
    const updatedItems = items.map((item, index) => ({
      ...item,
      order: index + 1
    }));
    
    setSteps(updatedItems);
    setModified(true);
  };
  
  const handleOpenEditDialog = (step: GeneratedStep) => {
    setEditingStep({ ...step });
    setOpenDialog(true);
  };
  
  const handleCloseDialog = () => {
    setOpenDialog(false);
    setEditingStep(null);
  };
  
  const handleAddStep = () => {
    const newStep: GeneratedStep = {
      id: Date.now().toString(),
      order: steps.length + 1,
      description: '',
      action: '',
      confidence: 100,
      assertions: []
    };
    
    setEditingStep(newStep);
    setOpenDialog(true);
  };
  
  const handleSaveStep = () => {
    if (!editingStep) return;
    
    if (!editingStep.description.trim() || !editingStep.action.trim()) {
      toast.error('Description and action are required');
      return;
    }
    
    if (editingStep.id) {
      // Update existing step
      setSteps(prevSteps => 
        prevSteps.map(step => 
          step.id === editingStep.id ? editingStep : step
        )
      );
    } else {
      // Add new step
      setSteps(prevSteps => [...prevSteps, editingStep]);
    }
    
    setModified(true);
    handleCloseDialog();
  };
  
  const handleDeleteStep = (stepId: string) => {
    setSteps(prevSteps => {
      const filteredSteps = prevSteps.filter(step => step.id !== stepId);
      // Reorder remaining steps
      return filteredSteps.map((step, index) => ({
        ...step,
        order: index + 1
      }));
    });
    
    setModified(true);
  };
  
  const handleSaveChanges = async () => {
    try {
      await api.put(`/api/nlp/test-description/${test.id}/steps`, { steps });
      toast.success('Steps updated successfully');
      setModified(false);
    } catch (error) {
      console.error('Error saving steps:', error);
      toast.error('Failed to save steps');
    }
  };
  
  const handleAddAssertion = () => {
    if (!editingStep) return;
    
    setEditingStep({
      ...editingStep,
      assertions: [...(editingStep.assertions || []), '']
    });
  };
  
  const handleUpdateAssertion = (index: number, value: string) => {
    if (!editingStep || !editingStep.assertions) return;
    
    const newAssertions = [...editingStep.assertions];
    newAssertions[index] = value;
    
    setEditingStep({
      ...editingStep,
      assertions: newAssertions
    });
  };
  
  const handleDeleteAssertion = (index: number) => {
    if (!editingStep || !editingStep.assertions) return;
    
    const newAssertions = [...editingStep.assertions];
    newAssertions.splice(index, 1);
    
    setEditingStep({
      ...editingStep,
      assertions: newAssertions
    });
  };
  
  const handleGenerateCode = async () => {
    try {
      const response = await api.post(`/api/nlp/generate-code/${test.id}`, {
        language: 'javascript',
        framework: 'playwright'
      });
      
      setGeneratedCode(response.data.code);
      setCodePreviewOpen(true);
    } catch (error) {
      console.error('Error generating code:', error);
      toast.error('Failed to generate code');
    }
  };
  
  const renderConfidenceChip = (confidence: number) => {
    let color: 'success' | 'warning' | 'error' = 'success';
    if (confidence < 70) color = 'error';
    else if (confidence < 90) color = 'warning';
    
    return (
      <Tooltip title={`${confidence}% confidence in this step`}>
        <Chip
          icon={confidence >= 90 ? <CheckIcon /> : <WarningIcon />}
          label={`${confidence}%`}
          size="small"
          color={color}
        />
      </Tooltip>
    );
  };
  
  const renderStepForm = () => {
    if (!editingStep) return null;
    
    return (
      <>
        <TextField
          label="Step Description"
          fullWidth
          value={editingStep.description}
          onChange={(e) => setEditingStep({ ...editingStep, description: e.target.value })}
          required
          margin="normal"
        />
        
        <TextField
          label="Action"
          fullWidth
          value={editingStep.action}
          onChange={(e) => setEditingStep({ ...editingStep, action: e.target.value })}
          required
          margin="normal"
          helperText="E.g., click, type, navigate, wait, assert"
        />
        
        {(editingStep.action === 'click' || editingStep.action === 'type' || 
          editingStep.action === 'select' || editingStep.action === 'hover') && (
          <TextField
            label="Selector"
            fullWidth
            value={editingStep.selector || ''}
            onChange={(e) => setEditingStep({ ...editingStep, selector: e.target.value })}
            margin="normal"
            helperText="CSS selector or XPath to identify the element"
          />
        )}
        
        {(editingStep.action === 'type' || editingStep.action === 'select') && (
          <TextField
            label="Value"
            fullWidth
            value={editingStep.value || ''}
            onChange={(e) => setEditingStep({ ...editingStep, value: e.target.value })}
            margin="normal"
            helperText="Text to type or value to select"
          />
        )}
        
        <Box sx={{ mt: 3, mb: 2 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
            <Typography variant="subtitle2">Assertions</Typography>
            <Button
              size="small"
              startIcon={<AddIcon />}
              onClick={handleAddAssertion}
            >
              Add Assertion
            </Button>
          </Box>
          
          {editingStep.assertions && editingStep.assertions.map((assertion, index) => (
            <Box key={index} sx={{ display: 'flex', mb: 1 }}>
              <TextField
                fullWidth
                size="small"
                value={assertion}
                onChange={(e) => handleUpdateAssertion(index, e.target.value)}
                placeholder={`Assertion ${index + 1}`}
              />
              <IconButton
                size="small"
                color="error"
                onClick={() => handleDeleteAssertion(index)}
              >
                <DeleteIcon fontSize="small" />
              </IconButton>
            </Box>
          ))}
        </Box>
      </>
    );
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs value={tabValue} onChange={handleTabChange} aria-label="NLP results tabs">
          <Tab label="Generated Steps" {...a11yProps(0)} />
          <Tab label="Raw Input" {...a11yProps(1)} />
        </Tabs>
      </Box>
      
      <TabPanel value={tabValue} index={0}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6">Generated Test Steps</Typography>
          <Box>
            <Button
              variant="outlined"
              startIcon={<CodeIcon />}
              onClick={handleGenerateCode}
              sx={{ mr: 1 }}
            >
              Preview Code
            </Button>
            
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={handleAddStep}
            >
              Add Step
            </Button>
          </Box>
        </Box>
        
        {modified && (
          <Alert severity="warning" sx={{ mb: 2 }} action={
            <Button color="inherit" size="small" onClick={handleSaveChanges}>
              Save Changes
            </Button>
          }>
            You have unsaved changes to the generated steps.
          </Alert>
        )}
        
        <DragDropContext onDragEnd={handleDragEnd}>
          <Droppable droppableId="steps">
            {(provided) => (
              <List 
                {...provided.droppableProps}
                ref={provided.innerRef}
                sx={{ width: '100%', bgcolor: 'background.paper' }}
              >
                {steps.length === 0 ? (
                  <Typography color="text.secondary" sx={{ p: 2, textAlign: 'center' }}>
                    No steps generated. Try adjusting your test description.
                  </Typography>
                ) : (
                  steps.map((step, index) => (
                    <Draggable key={step.id} draggableId={step.id} index={index}>
                      {(provided) => (
                        <Paper
                          ref={provided.innerRef}
                          {...provided.draggableProps}
                          sx={{ mb: 2, border: '1px solid', borderColor: 'divider' }}
                        >
                          <ListItem
                            secondaryAction={
                              <Box>
                                <IconButton edge="end" onClick={() => handleOpenEditDialog(step)}>
                                  <EditIcon />
                                </IconButton>
                                <IconButton edge="end" onClick={() => handleDeleteStep(step.id)}>
                                  <DeleteIcon />
                                </IconButton>
                              </Box>
                            }
                          >
                            <Box {...provided.dragHandleProps} sx={{ mr: 2, display: 'flex', alignItems: 'center' }}>
                              <DragIndicatorIcon color="action" />
                            </Box>
                            <ListItemText
                              primary={
                                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                  <Typography variant="subtitle1" sx={{ mr: 1 }}>
                                    {index + 1}. {step.description}
                                  </Typography>
                                  {renderConfidenceChip(step.confidence)}
                                </Box>
                              }
                              secondary={
                                <Box sx={{ mt: 1 }}>
                                  <Typography variant="body2" component="span" sx={{ display: 'block' }}>
                                    <strong>Action:</strong> {step.action}
                                    {step.selector && <> - <code>{step.selector}</code></>}
                                    {step.value && <> - Value: "{step.value}"</>}
                                  </Typography>
                                  
                                  {step.assertions && step.assertions.length > 0 && (
                                    <Box sx={{ mt: 1 }}>
                                      <Typography variant="body2" component="span">
                                        <strong>Assertions:</strong>
                                      </Typography>
                                      <ul style={{ margin: '4px 0', paddingLeft: '20px' }}>
                                        {step.assertions.map((assertion, i) => (
                                          <li key={i}>
                                            <Typography variant="body2">{assertion}</Typography>
                                          </li>
                                        ))}
                                      </ul>
                                    </Box>
                                  )}
                                </Box>
                              }
                            />
                          </ListItem>
                        </Paper>
                      )}
                    </Draggable>
                  ))
                )}
                {provided.placeholder}
              </List>
            )}
          </Droppable>
        </DragDropContext>
        
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
          <Button
            variant="outlined"
            disabled={!modified}
            onClick={handleSaveChanges}
          >
            Save Changes
          </Button>
          <Button
            variant="contained"
            onClick={onNext}
          >
            Continue to Test Mapping
          </Button>
        </Box>
      </TabPanel>
      
      <TabPanel value={tabValue} index={1}>
        <Card variant="outlined">
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Original Test Description
            </Typography>
            <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
              {test.input}
            </Typography>
          </CardContent>
        </Card>
      </TabPanel>
      
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="md" fullWidth>
        <DialogTitle>{editingStep?.id ? 'Edit Step' : 'Add New Step'}</DialogTitle>
        <DialogContent dividers>
          {renderStepForm()}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button onClick={handleSaveStep} variant="contained">
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      <Dialog open={codePreviewOpen} onClose={() => setCodePreviewOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>Generated Test Code</DialogTitle>
        <DialogContent dividers>
          <Box sx={{ height: 400 }}>
            <CodeEditor
              language="javascript"
              value={generatedCode}
              height="100%"
              readOnly
            />
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCodePreviewOpen(false)}>Close</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default NLPResults;


// src/components/nlp/StepMapping.tsx
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Button, 
  TextField, 
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem, 
  Chip, 
  Grid, 
  List, 
  ListItem, 
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  CircularProgress,
  Tooltip,
  Autocomplete
} from '@mui/material';
import { 
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Save as SaveIcon,
  PlayArrow as RunIcon,
  Check as CheckIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import { useProjects } from '../../contexts/ProjectContext';
import { useApi } from '../../contexts/ApiContext';

// Define types for step mapping
interface StepTemplate {
  id: string;
  name: string;
  description: string;
  nlpPatterns: string[];
  implementation: string;
  parameterMappings: ParameterMapping[];
}

interface ParameterMapping {
  name: string;
  description: string;
  extractionPattern: string;
  defaultValue?: string;
  required: boolean;
}

const StepMapping: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // State for step templates
  const [templates, setTemplates] = useState<StepTemplate[]>([]);
  const [selectedTemplate, setSelectedTemplate] = useState<StepTemplate | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [showDialog, setShowDialog] = useState(false);
  
  // Form state
  const [formData, setFormData] = useState<StepTemplate>({
    id: '',
    name: '',
    description: '',
    nlpPatterns: [],
    implementation: '',
    parameterMappings: []
  });
  
  // Pattern editor state
  const [newPattern, setNewPattern] = useState('');
  const [newParameter, setNewParameter] = useState<ParameterMapping>({
    name: '',
    description: '',
    extractionPattern: '',
    defaultValue: '',
    required: false
  });
  
  // Load templates on component mount
  useEffect(() => {
    if (currentProject?.id) {
      loadTemplates();
    }
  }, [currentProject]);
  
  const loadTemplates = async () => {
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/nlp/step-templates`);
      setTemplates(response.data);
    } catch (error) {
      console.error('Error loading step templates:', error);
    }
  };
  
  const handleSelectTemplate = (template: StepTemplate) => {
    setSelectedTemplate(template);
    setFormData(template);
    setIsEditing(false);
  };
  
  const handleCreateNew = () => {
    setSelectedTemplate(null);
    setFormData({
      id: '',
      name: '',
      description: '',
      nlpPatterns: [],
      implementation: '',
      parameterMappings: []
    });
    setIsEditing(true);
  };
  
  const handleEdit = () => {
    setIsEditing(true);
  };
  
  const handleSave = async () => {
    setIsSaving(true);
    try {
      let response;
      if (formData.id) {
        // Update existing template
        response = await api.put(`/api/projects/${currentProject?.id}/nlp/step-templates/${formData.id}`, formData);
      } else {
        // Create new template
        response = await api.post(`/api/projects/${currentProject?.id}/nlp/step-templates`, formData);
      }
      
      await loadTemplates();
      setSelectedTemplate(response.data);
      setFormData(response.data);
      setIsEditing(false);
    } catch (error) {
      console.error('Error saving step template:', error);
    } finally {
      setIsSaving(false);
    }
  };
  
  const handleDelete = async () => {
    if (!selectedTemplate?.id) return;
    
    try {
      await api.delete(`/api/projects/${currentProject?.id}/nlp/step-templates/${selectedTemplate.id}`);
      await loadTemplates();
      setSelectedTemplate(null);
      setFormData({
        id: '',
        name: '',
        description: '',
        nlpPatterns: [],
        implementation: '',
        parameterMappings: []
      });
    } catch (error) {
      console.error('Error deleting step template:', error);
    }
  };
  
  const handleAddPattern = () => {
    if (!newPattern.trim()) return;
    
    setFormData(prev => ({
      ...prev,
      nlpPatterns: [...prev.nlpPatterns, newPattern.trim()]
    }));
    setNewPattern('');
  };
  
  const handleRemovePattern = (index: number) => {
    setFormData(prev => ({
      ...prev,
      nlpPatterns: prev.nlpPatterns.filter((_, i) => i !== index)
    }));
  };
  
  const handleAddParameter = () => {
    if (!newParameter.name.trim() || !newParameter.extractionPattern.trim()) return;
    
    setFormData(prev => ({
      ...prev,
      parameterMappings: [...prev.parameterMappings, { ...newParameter }]
    }));
    
    setNewParameter({
      name: '',
      description: '',
      extractionPattern: '',
      defaultValue: '',
      required: false
    });
  };
  
  const handleRemoveParameter = (index: number) => {
    setFormData(prev => ({
      ...prev,
      parameterMappings: prev.parameterMappings.filter((_, i) => i !== index)
    }));
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleParameterChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, field: keyof ParameterMapping) => {
    const { value } = e.target;
    setNewParameter(prev => ({
      ...prev,
      [field]: value
    }));
  };
  
  const handleParameterRequiredChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setNewParameter(prev => ({
      ...prev,
      required: e.target.checked
    }));
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h5">Step Mapping Manager</Typography>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AddIcon />}
            onClick={handleCreateNew}
          >
            Create New Template
          </Button>
        </Box>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              <Typography variant="h6" sx={{ mb: 2 }}>Step Templates</Typography>
              <List>
                {templates.length === 0 ? (
                  <ListItem>
                    <ListItemText primary="No templates found" secondary="Create your first template" />
                  </ListItem>
                ) : (
                  templates.map(template => (
                    <ListItem 
                      key={template.id}
                      button
                      selected={selectedTemplate?.id === template.id}
                      onClick={() => handleSelectTemplate(template)}
                    >
                      <ListItemText 
                        primary={template.name} 
                        secondary={template.description.substring(0, 60) + '...'}
                      />
                    </ListItem>
                  ))
                )}
              </List>
            </Paper>
          </Grid>
          
          <Grid item xs={12} md={8}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              {!selectedTemplate && !isEditing ? (
                <Box sx={{ display: 'flex', height: '100%', justifyContent: 'center', alignItems: 'center', flexDirection: 'column' }}>
                  <Typography variant="h6" color="textSecondary">Select a template or create a new one</Typography>
                </Box>
              ) : (
                <Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h6">
                      {isEditing ? (formData.id ? 'Edit Template' : 'New Template') : 'Template Details'}
                    </Typography>
                    <Box>
                      {!isEditing ? (
                        <>
                          <Button 
                            variant="outlined" 
                            color="primary" 
                            startIcon={<EditIcon />}
                            onClick={handleEdit}
                            sx={{ mr: 1 }}
                          >
                            Edit
                          </Button>
                          <Button 
                            variant="outlined" 
                            color="error" 
                            startIcon={<DeleteIcon />}
                            onClick={() => setShowDialog(true)}
                          >
                            Delete
                          </Button>
                        </>
                      ) : (
                        <Button 
                          variant="contained" 
                          color="primary" 
                          startIcon={isSaving ? <CircularProgress size={20} /> : <SaveIcon />}
                          onClick={handleSave}
                          disabled={isSaving}
                        >
                          Save
                        </Button>
                      )}
                    </Box>
                  </Box>
                  
                  <Grid container spacing={2}>
                    <Grid item xs={12}>
                      <TextField 
                        label="Template Name"
                        name="name"
                        value={formData.name}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                        required
                      />
                    </Grid>
                    
                    <Grid item xs={12}>
                      <TextField 
                        label="Description"
                        name="description"
                        value={formData.description}
                        onChange={handleInputChange}
                        fullWidth
                        multiline
                        rows={2}
                        disabled={!isEditing}
                      />
                    </Grid>
                    
                    <Grid item xs={12}>
                      <Typography variant="subtitle1" sx={{ mb: 1 }}>NLP Patterns</Typography>
                      {isEditing && (
                        <Box sx={{ display: 'flex', mb: 2 }}>
                          <TextField 
                            label="New Pattern"
                            value={newPattern}
                            onChange={(e) => setNewPattern(e.target.value)}
                            fullWidth
                            placeholder="e.g., I click on {element}"
                          />
                          <Button 
                            variant="contained" 
                            onClick={handleAddPattern}
                            sx={{ ml: 1 }}
                          >
                            Add
                          </Button>
                        </Box>
                      )}
                      
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {formData.nlpPatterns.map((pattern, index) => (
                          <Chip 
                            key={index}
                            label={pattern}
                            onDelete={isEditing ? () => handleRemovePattern(index) : undefined}
                          />
                        ))}
                        {formData.nlpPatterns.length === 0 && (
                          <Typography variant="body2" color="textSecondary">
                            No patterns defined
                          </Typography>
                        )}
                      </Box>
                    </Grid>
                    
                    <Grid item xs={12}>
                      <Typography variant="subtitle1" sx={{ mb: 1 }}>Implementation Code</Typography>
                      <TextField 
                        name="implementation"
                        value={formData.implementation}
                        onChange={handleInputChange}
                        fullWidth
                        multiline
                        rows={6}
                        disabled={!isEditing}
                        placeholder="JavaScript code that implements this step"
                      />
                    </Grid>
                    
                    <Grid item xs={12}>
                      <Typography variant="subtitle1" sx={{ mb: 1 }}>Parameter Mappings</Typography>
                      {isEditing && (
                        <Paper variant="outlined" sx={{ p: 2, mb: 2 }}>
                          <Grid container spacing={2}>
                            <Grid item xs={12} sm={6}>
                              <TextField 
                                label="Parameter Name"
                                value={newParameter.name}
                                onChange={(e) => handleParameterChange(e, 'name')}
                                fullWidth
                                required
                              />
                            </Grid>
                            <Grid item xs={12} sm={6}>
                              <TextField 
                                label="Extraction Pattern"
                                value={newParameter.extractionPattern}
                                onChange={(e) => handleParameterChange(e, 'extractionPattern')}
                                fullWidth
                                required
                                placeholder="e.g., \\{element\\}"
                              />
                            </Grid>
                            <Grid item xs={12} sm={6}>
                              <TextField 
                                label="Description"
                                value={newParameter.description}
                                onChange={(e) => handleParameterChange(e, 'description')}
                                fullWidth
                              />
                            </Grid>
                            <Grid item xs={12} sm={6}>
                              <TextField 
                                label="Default Value"
                                value={newParameter.defaultValue || ''}
                                onChange={(e) => handleParameterChange(e, 'defaultValue')}
                                fullWidth
                              />
                            </Grid>
                            <Grid item xs={12}>
                              <FormControl fullWidth>
                                <FormControlLabel
                                  control={
                                    <Checkbox
                                      checked={newParameter.required}
                                      onChange={handleParameterRequiredChange}
                                    />
                                  }
                                  label="Required parameter"
                                />
                              </FormControl>
                            </Grid>
                            <Grid item xs={12}>
                              <Button 
                                variant="contained" 
                                color="primary" 
                                onClick={handleAddParameter}
                                fullWidth
                              >
                                Add Parameter
                              </Button>
                            </Grid>
                          </Grid>
                        </Paper>
                      )}
                      
                      <List>
                        {formData.parameterMappings.map((param, index) => (
                          <ListItem key={index}>
                            <ListItemText 
                              primary={param.name}
                              secondary={`${param.description} | Extraction Pattern: ${param.extractionPattern}`}
                            />
                            {isEditing && (
                              <ListItemSecondaryAction>
                                <IconButton edge="end" onClick={() => handleRemoveParameter(index)}>
                                  <DeleteIcon />
                                </IconButton>
                              </ListItemSecondaryAction>
                            )}
                          </ListItem>
                        ))}
                        {formData.parameterMappings.length === 0 && (
                          <ListItem>
                            <ListItemText 
                              primary="No parameters defined" 
                              secondary="Parameters let you extract variables from natural language"
                            />
                          </ListItem>
                        )}
                      </List>
                    </Grid>
                  </Grid>
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
      </Paper>
      
      {/* Confirmation Dialog */}
      <Dialog open={showDialog} onClose={() => setShowDialog(false)}>
        <DialogTitle>Confirm Deletion</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete the template "{selectedTemplate?.name}"?
            This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDialog(false)}>Cancel</Button>
          <Button 
            color="error" 
            onClick={() => {
              handleDelete();
              setShowDialog(false);
            }}
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default StepMapping;


// src/components/integration/GitIntegration.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  Grid,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Switch,
  FormControlLabel,
  Divider,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Tooltip
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Save as SaveIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  GitHub as GitHubIcon,
  History as HistoryIcon,
  Code as CodeIcon,
  Sync as SyncIcon,
  CloudUpload as PushIcon,
  CloudDownload as PullIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';

// Define types for Git integration
interface GitConfig {
  id: string;
  name: string;
  repositoryUrl: string;
  username: string;
  password?: string; // May be empty if already saved securely
  branch: string;
  autoSync: boolean;
  syncFrequency: number; // In minutes
  lastSyncTime?: Date;
  status: 'connected' | 'disconnected' | 'error';
  errorMessage?: string;
}

interface GitOperation {
  timestamp: Date;
  operation: 'push' | 'pull' | 'sync' | 'commit';
  status: 'success' | 'failed';
  message: string;
  branch: string;
  user: string;
}

const GitIntegration: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // Git configurations
  const [gitConfigs, setGitConfigs] = useState<GitConfig[]>([]);
  const [selectedConfig, setSelectedConfig] = useState<GitConfig | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [operationLoading, setOperationLoading] = useState(false);
  
  // Modals
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [showHistoryModal, setShowHistoryModal] = useState(false);
  const [showCommitModal, setShowCommitModal] = useState(false);
  
  // History data
  const [operationHistory, setOperationHistory] = useState<GitOperation[]>([]);
  
  // Form state
  const [formData, setFormData] = useState<GitConfig>({
    id: '',
    name: '',
    repositoryUrl: '',
    username: '',
    password: '',
    branch: 'main',
    autoSync: false,
    syncFrequency: 30,
    status: 'disconnected'
  });
  
  // Commit form
  const [commitMessage, setCommitMessage] = useState('');
  const [commitFiles, setCommitFiles] = useState<string[]>([]);
  const [availableFiles, setAvailableFiles] = useState<string[]>([]);
  
  // Load Git configurations on component mount
  useEffect(() => {
    if (currentProject?.id) {
      loadGitConfigs();
    }
  }, [currentProject]);
  
  const loadGitConfigs = async () => {
    setIsLoading(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/integrations/git`);
      setGitConfigs(response.data);
      
      if (response.data.length > 0 && !selectedConfig) {
        setSelectedConfig(response.data[0]);
      }
    } catch (error) {
      console.error('Error loading Git configurations:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleSelectConfig = (config: GitConfig) => {
    setSelectedConfig(config);
    setFormData(config);
    setIsEditing(false);
  };
  
  const handleCreateNew = () => {
    setSelectedConfig(null);
    setFormData({
      id: '',
      name: '',
      repositoryUrl: '',
      username: '',
      password: '',
      branch: 'main',
      autoSync: false,
      syncFrequency: 30,
      status: 'disconnected'
    });
    setIsEditing(true);
  };
  
  const handleEdit = () => {
    setIsEditing(true);
  };
  
  const handleSaveConfig = async () => {
    setIsLoading(true);
    try {
      let response;
      if (formData.id) {
        // Update existing config
        response = await api.put(`/api/projects/${currentProject?.id}/integrations/git/${formData.id}`, formData);
      } else {
        // Create new config
        response = await api.post(`/api/projects/${currentProject?.id}/integrations/git`, formData);
      }
      
      await loadGitConfigs();
      setSelectedConfig(response.data);
      setFormData(response.data);
      setIsEditing(false);
    } catch (error) {
      console.error('Error saving Git configuration:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleDeleteConfig = async () => {
    if (!selectedConfig?.id) return;
    
    try {
      await api.delete(`/api/projects/${currentProject?.id}/integrations/git/${selectedConfig.id}`);
      await loadGitConfigs();
      setSelectedConfig(null);
      setFormData({
        id: '',
        name: '',
        repositoryUrl: '',
        username: '',
        password: '',
        branch: 'main',
        autoSync: false,
        syncFrequency: 30,
        status: 'disconnected'
      });
      setShowDeleteModal(false);
    } catch (error) {
      console.error('Error deleting Git configuration:', error);
    }
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>) => {
    const name = e.target.name as keyof GitConfig;
    const value = e.target.value;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleToggleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  const handleTestConnection = async () => {
    setOperationLoading(true);
    try {
      const response = await api.post(`/api/projects/${currentProject?.id}/integrations/git/test-connection`, formData);
      
      if (response.data.success) {
        setFormData(prev => ({
          ...prev,
          status: 'connected',
          errorMessage: undefined
        }));
      } else {
        setFormData(prev => ({
          ...prev,
          status: 'error',
          errorMessage: response.data.message || 'Connection failed'
        }));
      }
    } catch (error) {
      console.error('Error testing Git connection:', error);
      setFormData(prev => ({
        ...prev,
        status: 'error',
        errorMessage: 'Connection test failed'
      }));
    } finally {
      setOperationLoading(false);
    }
  };
  
  const loadOperationHistory = async () => {
    if (!selectedConfig?.id) return;
    
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/integrations/git/${selectedConfig.id}/history`);
      setOperationHistory(response.data);
      setShowHistoryModal(true);
    } catch (error) {
      console.error('Error loading operation history:', error);
    }
  };
  
  const handleSyncOperation = async (operation: 'push' | 'pull' | 'sync') => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      const response = await api.post(`/api/projects/${currentProject?.id}/integrations/git/${selectedConfig.id}/${operation}`);
      
      if (response.data.success) {
        // Refresh Git config after operation
        await loadGitConfigs();
      }
    } catch (error) {
      console.error(`Error during ${operation} operation:`, error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const openCommitDialog = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      // Get list of changed files
      const response = await api.get(`/api/projects/${currentProject?.id}/integrations/git/${selectedConfig.id}/status`);
      setAvailableFiles(response.data.changedFiles || []);
      setCommitFiles([]);
      setCommitMessage('');
      setShowCommitModal(true);
    } catch (error) {
      console.error('Error getting Git status:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const handleToggleFileSelection = (file: string) => {
    if (commitFiles.includes(file)) {
      setCommitFiles(prev => prev.filter(f => f !== file));
    } else {
      setCommitFiles(prev => [...prev, file]);
    }
  };
  
  const handleSelectAllFiles = () => {
    setCommitFiles([...availableFiles]);
  };
  
  const handleDeselectAllFiles = () => {
    setCommitFiles([]);
  };
  
  const handleCommit = async () => {
    if (!selectedConfig?.id || commitFiles.length === 0 || !commitMessage.trim()) return;
    
    setOperationLoading(true);
    try {
      await api.post(`/api/projects/${currentProject?.id}/integrations/git/${selectedConfig.id}/commit`, {
        message: commitMessage,
        files: commitFiles
      });
      
      setShowCommitModal(false);
      // Refresh Git config after commit
      await loadGitConfigs();
    } catch (error) {
      console.error('Error committing changes:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <GitHubIcon sx={{ mr: 1 }} />
            <Typography variant="h5">Git Integration</Typography>
          </Box>
          <Box>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={loadGitConfigs}
              sx={{ mr: 1 }}
              disabled={isLoading}
            >
              Refresh
            </Button>
            <Button
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={handleCreateNew}
              disabled={isLoading}
            >
              Add Repository
            </Button>
          </Box>
        </Box>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              <Typography variant="h6" sx={{ mb: 2 }}>Git Repositories</Typography>
              {isLoading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80%' }}>
                  <CircularProgress />
                </Box>
              ) : (
                <List>
                  {gitConfigs.length === 0 ? (
                    <ListItem>
                      <ListItemText primary="No repositories configured" secondary="Add a Git repository to get started" />
                    </ListItem>
                  ) : (
                    gitConfigs.map(config => (
                      <ListItem
                        key={config.id}
                        button
                        selected={selectedConfig?.id === config.id}
                        onClick={() => handleSelectConfig(config)}
                      >
                        <ListItemText
                          primary={config.name}
                          secondary={config.repositoryUrl}
                        />
                        <ListItemSecondaryAction>
                          {config.status === 'connected' ? (
                            <Tooltip title="Connected">
                              <Box component="span" sx={{ color: 'success.main', display: 'flex' }}>●</Box>
                            </Tooltip>
                          ) : config.status === 'error' ? (
                            <Tooltip title="Error">
                              <Box component="span" sx={{ color: 'error.main', display: 'flex' }}>●</Box>
                            </Tooltip>
                          ) : (
                            <Tooltip title="Disconnected">
                              <Box component="span" sx={{ color: 'text.disabled', display: 'flex' }}>●</Box>
                            </Tooltip>
                          )}
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))
                  )}
                </List>
              )}
            </Paper>
          </Grid>
          
          <Grid item xs={12} md={8}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              {!selectedConfig && !isEditing ? (
                <Box sx={{ display: 'flex', height: '100%', justifyContent: 'center', alignItems: 'center', flexDirection: 'column' }}>
                  <Typography variant="h6" color="textSecondary">Select a Git repository or add a new one</Typography>
                </Box>
              ) : (
                <Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h6">
                      {isEditing ? (formData.id ? 'Edit Repository' : 'New Repository') : 'Repository Details'}
                    </Typography>
                    <Box>
                      {!isEditing ? (
                        <>
                          <Button
                            variant="outlined"
                            startIcon={<EditIcon />}
                            onClick={handleEdit}
                            sx={{ mr: 1 }}
                          >
                            Edit
                          </Button>
                          <Button
                            variant="outlined"
                            color="error"
                            startIcon={<DeleteIcon />}
                            onClick={() => setShowDeleteModal(true)}
                          >
                            Delete
                          </Button>
                        </>
                      ) : (
                        <Button
                          variant="contained"
                          color="primary"
                          startIcon={isLoading ? <CircularProgress size={20} /> : <SaveIcon />}
                          onClick={handleSaveConfig}
                          disabled={isLoading}
                        >
                          Save
                        </Button>
                      )}
                    </Box>
                  </Box>
                  
                  {!isEditing && selectedConfig?.status === 'error' && (
                    <Alert severity="error" sx={{ mb: 2 }}>
                      {selectedConfig.errorMessage || 'Error connecting to this repository'}
                    </Alert>
                  )}
                  
                  <Grid container spacing={2}>
                    <Grid item xs={12}>
                      <TextField
                        label="Repository Name"
                        name="name"
                        value={formData.name}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                        required
                      />
                    </Grid>
                    
                    <Grid item xs={12}>
                      <TextField
                        label="Repository URL"
                        name="repositoryUrl"
                        value={formData.repositoryUrl}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                        required
                        placeholder="https://github.com/username/repo.git"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <TextField
                        label="Username"
                        name="username"
                        value={formData.username}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <TextField
                        label="Password/Token"
                        name="password"
                        type="password"
                        value={formData.password || ''}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                        placeholder={formData.id ? '••••••••••••••••' : ''}
                        helperText={formData.id ? 'Leave blank to keep existing password' : 'Use access token for better security'}
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <TextField
                        label="Branch"
                        name="branch"
                        value={formData.branch}
                        onChange={handleInputChange}
                        fullWidth
                        disabled={!isEditing}
                        required
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      {isEditing ? (
                        <FormControlLabel
                          control={
                            <Switch
                              checked={formData.autoSync}
                              onChange={handleToggleChange}
                              name="autoSync"
                            />
                          }
                          label="Auto-sync"
                        />
                      ) : (
                        <Typography variant="body1">
                          Auto-sync: <b>{formData.autoSync ? 'Enabled' : 'Disabled'}</b>
                        </Typography>
                      )}
                    </Grid>
                    
                    {formData.autoSync && (
                      <Grid item xs={12} md={6}>
                        <TextField
                          label="Sync Frequency (minutes)"
                          name="syncFrequency"
                          type="number"
                          value={formData.syncFrequency}
                          onChange={handleInputChange}
                          fullWidth
                          disabled={!isEditing}
                          inputProps={{ min: 5, max: 1440 }}
                        />
                      </Grid>
                    )}
                    
                    {isEditing && (
                      <Grid item xs={12}>
                        <Button
                          variant="outlined"
                          color="primary"
                          onClick={handleTestConnection}
                          disabled={operationLoading}
                          startIcon={operationLoading ? <CircularProgress size={20} /> : null}
                        >
                          Test Connection
                        </Button>
                      </Grid>
                    )}
                    
                    {!isEditing && selectedConfig && (
                      <>
                        <Grid item xs={12}>
                          <Divider sx={{ my: 2 }} />
                          <Typography variant="h6" sx={{ mb: 2 }}>Git Operations</Typography>
                        </Grid>
                        
                        <Grid item xs={12}>
                          <Grid container spacing={2}>
                            <Grid item>
                              <Button
                                variant="outlined"
                                startIcon={<PullIcon />}
                                onClick={() => handleSyncOperation('pull')}
                                disabled={operationLoading}
                              >
                                Pull
                              </Button>
                            </Grid>
                            <Grid item>
                              <Button
                                variant="outlined"
                                startIcon={<PushIcon />}
                                onClick={() => handleSyncOperation('push')}
                                disabled={operationLoading}
                              >
                                Push
                              </Button>
                            </Grid>
                            <Grid item>
                              <Button
                                variant="outlined"
                                startIcon={<SyncIcon />}
                                onClick={() => handleSyncOperation('sync')}
                                disabled={operationLoading}
                              >
                                Sync
                              </Button>
                            </Grid>
                            <Grid item>
                              <Button
                                variant="outlined"
                                startIcon={<CodeIcon />}
                                onClick={openCommitDialog}
                                disabled={operationLoading}
                              >
                                Commit
                              </Button>
                            </Grid>
                            <Grid item>
                              <Button
                                variant="outlined"
                                startIcon={<HistoryIcon />}
                                onClick={loadOperationHistory}
                                disabled={operationLoading}
                              >
                                History
                              </Button>
                            </Grid>
                          </Grid>
                        </Grid>
                        
                        {selectedConfig.lastSyncTime && (
                          <Grid item xs={12}>
                            <Typography variant="body2" color="textSecondary">
                              Last synchronized: {new Date(selectedConfig.lastSyncTime).toLocaleString()}
                            </Typography>
                          </Grid>
                        )}
                      </>
                    )}
                  </Grid>
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
      </Paper>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteModal} onClose={() => setShowDeleteModal(false)}>
        <DialogTitle>Confirm Deletion</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete the Git configuration for "{selectedConfig?.name}"?
            This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDeleteModal(false)}>Cancel</Button>
          <Button
            color="error"
            onClick={handleDeleteConfig}
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* History Dialog */}
      <Dialog
        open={showHistoryModal}
        onClose={() => setShowHistoryModal(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Operation History</DialogTitle>
        <DialogContent>
          {operationHistory.length === 0 ? (
            <Typography>No operation history available.</Typography>
          ) : (
            <List>
              {operationHistory.map((operation, index) => (
                <React.Fragment key={index}>
                  <ListItem>
                    <ListItemText
                      primary={`${operation.operation.toUpperCase()} - ${operation.status === 'success' ? 'Successful' : 'Failed'}`}
                      secondary={
                        <>
                          <Typography component="span" variant="body2">
                            {new Date(operation.timestamp).toLocaleString()}
                          </Typography>
                          <br />
                          <Typography component="span" variant="body2">
                            {operation.message}
                          </Typography>
                          <br />
                          <Typography component="span" variant="body2">
                            Branch: {operation.branch} | User: {operation.user}
                          </Typography>
                        </>
                      }
                    />
                  </ListItem>
                  {index < operationHistory.length - 1 && <Divider />}
                </React.Fragment>
              ))}
            </List>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowHistoryModal(false)}>Close</Button>
        </DialogActions>
      </Dialog>
      
      {/* Commit Dialog */}
      <Dialog
        open={showCommitModal}
        onClose={() => setShowCommitModal(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Commit Changes</DialogTitle>
        <DialogContent>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="Commit Message"
                value={commitMessage}
                onChange={(e) => setCommitMessage(e.target.value)}
                fullWidth
                multiline
                rows={3}
                required
                sx={{ mb: 2, mt: 1 }}
              />
            </Grid>
            
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="subtitle1">Changed Files</Typography>
                <Box>
                  <Button size="small" onClick={handleSelectAllFiles} sx={{ mr: 1 }}>
                    Select All
                  </Button>
                  <Button size="small" onClick={handleDeselectAllFiles}>
                    Deselect All
                  </Button>
                </Box>
              </Box>
              
              {availableFiles.length === 0 ? (
                <Typography variant="body2">No changes detected</Typography>
              ) : (
                <List dense sx={{ maxHeight: '200px', overflow: 'auto', border: '1px solid rgba(0, 0, 0, 0.12)', borderRadius: 1 }}>
                  {availableFiles.map((file, index) => (
                    <ListItem key={index} dense>
                      <FormControlLabel
                        control={
                          <Checkbox
                            checked={commitFiles.includes(file)}
                            onChange={() => handleToggleFileSelection(file)}
                          />
                        }
                        label={file}
                      />
                    </ListItem>
                  ))}
                </List>
              )}
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowCommitModal(false)}>Cancel</Button>
          <Button
            color="primary"
            onClick={handleCommit}
            disabled={commitFiles.length === 0 || !commitMessage.trim() || operationLoading}
            startIcon={operationLoading ? <CircularProgress size={20} /> : null}
          >
            Commit
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default GitIntegration;


// src/components/integration/AzureDevOpsIntegration.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  Grid,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Switch,
  FormControlLabel,
  Divider,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Tooltip,
  Checkbox,
  Tab,
  Tabs
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  Save as SaveIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Assignment as AssignmentIcon,
  BugReport as BugIcon,
  CheckCircle as TestIcon,
  Link as LinkIcon,
  Queue as QueueIcon,
  Sync as SyncIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';

// Define types for ADO integration
interface ADOConfig {
  id: string;
  name: string;
  organizationUrl: string;
  project: string;
  pat: string; // Personal Access Token
  autoSync: boolean;
  syncFrequency: number; // In minutes
  lastSyncTime?: Date;
  status: 'connected' | 'disconnected' | 'error';
  errorMessage?: string;
  syncWorkItems: boolean;
  syncTestCases: boolean;
  syncTestPlans: boolean;
  syncBuilds: boolean;
}

interface ADOProject {
  id: string;
  name: string;
}

interface ADOWorkItem {
  id: number;
  type: string;
  title: string;
  state: string;
  assignedTo?: string;
  createdDate: string;
  priority?: number;
}

interface ADOTestCase {
  id: number;
  title: string;
  state: string;
  automationStatus: string;
  priority: number;
  testPlanId?: number;
  testSuiteId?: number;
}

interface ADOBuild {
  id: number;
  name: string;
  status: string;
  result: string;
  queueTime: string;
  startTime?: string;
  finishTime?: string;
  sourceBranch: string;
  sourceVersion: string;
}

const AzureDevOpsIntegration: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // Tab state
  const [activeTab, setActiveTab] = useState(0);
  
  // ADO configurations
  const [adoConfigs, setAdoConfigs] = useState<ADOConfig[]>([]);
  const [selectedConfig, setSelectedConfig] = useState<ADOConfig | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [operationLoading, setOperationLoading] = useState(false);
  
  // Project selection
  const [availableProjects, setAvailableProjects] = useState<ADOProject[]>([]);
  
  // Data lists
  const [workItems, setWorkItems] = useState<ADOWorkItem[]>([]);
  const [testCases, setTestCases] = useState<ADOTestCase[]>([]);
  const [builds, setBuilds] = useState<ADOBuild[]>([]);
  
  // Link dialog
  const [showLinkDialog, setShowLinkDialog] = useState(false);
  const [selectedWorkItem, setSelectedWorkItem] = useState<ADOWorkItem | null>(null);
  const [linkToTestCase, setLinkToTestCase] = useState('');
  
  // Delete confirmation dialog
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  
  // Import dialog
  const [showImportDialog, setShowImportDialog] = useState(false);
  const [importItems, setImportItems] = useState<ADOTestCase[]>([]);
  const [selectedImportItems, setSelectedImportItems] = useState<number[]>([]);
  
  // Form state
  const [formData, setFormData] = useState<ADOConfig>({
    id: '',
    name: '',
    organizationUrl: '',
    project: '',
    pat: '',
    autoSync: false,
    syncFrequency: 30,
    status: 'disconnected',
    syncWorkItems: true,
    syncTestCases: true,
    syncTestPlans: false,
    syncBuilds: false
  });
  
  // Load ADO configurations on component mount
  useEffect(() => {
    if (currentProject?.id) {
      loadAdoConfigs();
    }
  }, [currentProject]);
  
  // Load data when selected config changes
  useEffect(() => {
    if (selectedConfig?.id && selectedConfig.status === 'connected') {
      loadWorkItems();
      loadTestCases();
      loadBuilds();
    }
  }, [selectedConfig]);
  
  const loadAdoConfigs = async () => {
    setIsLoading(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/integrations/ado`);
      setAdoConfigs(response.data);
      
      if (response.data.length > 0 && !selectedConfig) {
        setSelectedConfig(response.data[0]);
      }
    } catch (error) {
      console.error('Error loading ADO configurations:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleSelectConfig = (config: ADOConfig) => {
    setSelectedConfig(config);
    setFormData(config);
    setIsEditing(false);
  };
  
  const handleCreateNew = () => {
    setSelectedConfig(null);
    setFormData({
      id: '',
      name: '',
      organizationUrl: '',
      project: '',
      pat: '',
      autoSync: false,
      syncFrequency: 30,
      status: 'disconnected',
      syncWorkItems: true,
      syncTestCases: true,
      syncTestPlans: false,
      syncBuilds: false
    });
    setIsEditing(true);
  };
  
  const handleEdit = () => {
    setIsEditing(true);
  };
  
  const handleSaveConfig = async () => {
    setIsLoading(true);
    try {
      let response;
      if (formData.id) {
        // Update existing config
        response = await api.put(`/api/projects/${currentProject?.id}/integrations/ado/${formData.id}`, formData);
      } else {
        // Create new config
        response = await api.post(`/api/projects/${currentProject?.id}/integrations/ado`, formData);
      }
      
      await loadAdoConfigs();
      setSelectedConfig(response.data);
      setFormData(response.data);
      setIsEditing(false);
    } catch (error) {
      console.error('Error saving ADO configuration:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleDeleteConfig = async () => {
    if (!selectedConfig?.id) return;
    
    try {
      await api.delete(`/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}`);
      await loadAdoConfigs();
      setSelectedConfig(null);
      setFormData({
        id: '',
        name: '',
        organizationUrl: '',
        project: '',
        pat: '',
        autoSync: false,
        syncFrequency: 30,
        status: 'disconnected',
        syncWorkItems: true,
        syncTestCases: true,
        syncTestPlans: false,
        syncBuilds: false
      });
      setShowDeleteModal(false);
    } catch (error) {
      console.error('Error deleting ADO configuration:', error);
    }
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>) => {
    const name = e.target.name as keyof ADOConfig;
    const value = e.target.value;
    
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleToggleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  const handleTestConnection = async () => {
    setOperationLoading(true);
    try {
      const response = await api.post(
        `/api/projects/${currentProject?.id}/integrations/ado/test-connection`, 
        formData
      );
      
      if (response.data.success) {
        setFormData(prev => ({
          ...prev,
          status: 'connected',
          errorMessage: undefined
        }));
        
        // Load available projects if connection is successful
        if (response.data.projects) {
          setAvailableProjects(response.data.projects);
        }
      } else {
        setFormData(prev => ({
          ...prev,
          status: 'error',
          errorMessage: response.data.message || 'Connection failed'
        }));
      }
    } catch (error) {
      console.error('Error testing ADO connection:', error);
      setFormData(prev => ({
        ...prev,
        status: 'error',
        errorMessage: 'Connection test failed'
      }));
    } finally {
      setOperationLoading(false);
    }
  };
  
  const loadWorkItems = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      const response = await api.get(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/work-items`
      );
      setWorkItems(response.data);
    } catch (error) {
      console.error('Error loading work items:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const loadTestCases = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      const response = await api.get(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/test-cases`
      );
      setTestCases(response.data);
    } catch (error) {
      console.error('Error loading test cases:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const loadBuilds = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      const response = await api.get(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/builds`
      );
      setBuilds(response.data);
    } catch (error) {
      console.error('Error loading builds:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const handleSyncAll = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      await api.post(`/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/sync`);
      
      // Reload all data
      await Promise.all([
        loadWorkItems(),
        loadTestCases(),
        loadBuilds()
      ]);
      
      // Refresh config to update last sync time
      await loadAdoConfigs();
    } catch (error) {
      console.error('Error syncing with ADO:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const openLinkDialog = (workItem: ADOWorkItem) => {
    setSelectedWorkItem(workItem);
    setLinkToTestCase('');
    setShowLinkDialog(true);
  };
  
  const handleLinkWorkItemToTestCase = async () => {
    if (!selectedConfig?.id || !selectedWorkItem || !linkToTestCase) return;
    
    setOperationLoading(true);
    try {
      await api.post(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/link-work-item`, 
        {
          workItemId: selectedWorkItem.id,
          testCaseId: linkToTestCase
        }
      );
      
      // Reload work items to see the updated links
      await loadWorkItems();
      setShowLinkDialog(false);
    } catch (error) {
      console.error('Error linking work item to test case:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const openImportDialog = async () => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      const response = await api.get(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/importable-test-cases`
      );
      
      setImportItems(response.data);
      setSelectedImportItems([]);
      setShowImportDialog(true);
    } catch (error) {
      console.error('Error loading importable test cases:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const handleToggleImportItem = (id: number) => {
    if (selectedImportItems.includes(id)) {
      setSelectedImportItems(selectedImportItems.filter(item => item !== id));
    } else {
      setSelectedImportItems([...selectedImportItems, id]);
    }
  };
  
  const handleSelectAllImportItems = () => {
    setSelectedImportItems(importItems.map(item => item.id));
  };
  
  const handleDeselectAllImportItems = () => {
    setSelectedImportItems([]);
  };
  
  const handleImportTestCases = async () => {
    if (!selectedConfig?.id || selectedImportItems.length === 0) return;
    
    setOperationLoading(true);
    try {
      await api.post(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/import-test-cases`,
        { testCaseIds: selectedImportItems }
      );
      
      // Reload test cases
      await loadTestCases();
      setShowImportDialog(false);
    } catch (error) {
      console.error('Error importing test cases:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const handleQueueBuild = async (buildId: number) => {
    if (!selectedConfig?.id) return;
    
    setOperationLoading(true);
    try {
      await api.post(
        `/api/projects/${currentProject?.id}/integrations/ado/${selectedConfig.id}/queue-build`,
        { buildId }
      );
      
      // Reload builds
      await loadBuilds();
    } catch (error) {
      console.error('Error queuing build:', error);
    } finally {
      setOperationLoading(false);
    }
  };
  
  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <AssignmentIcon sx={{ mr: 1 }} />
            <Typography variant="h5">Azure DevOps Integration</Typography>
          </Box>
          <Box>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={loadAdoConfigs}
              sx={{ mr: 1 }}
              disabled={isLoading}
            >
              Refresh
            </Button>
            <Button
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={handleCreateNew}
              disabled={isLoading}
            >
              Add Connection
            </Button>
          </Box>
        </Box>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              <Typography variant="h6" sx={{ mb: 2 }}>ADO Connections</Typography>
              {isLoading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80%' }}>
                  <CircularProgress />
                </Box>
              ) : (
                <List>
                  {adoConfigs.length === 0 ? (
                    <ListItem>
                      <ListItemText 
                        primary="No connections configured" 
                        secondary="Add an Azure DevOps connection to get started" 
                      />
                    </ListItem>
                  ) : (
                    adoConfigs.map(config => (
                      <ListItem
                        key={config.id}
                        button
                        selected={selectedConfig?.id === config.id}
                        onClick={() => handleSelectConfig(config)}
                      >
                        <ListItemText
                          primary={config.name}
                          secondary={`${config.organizationUrl} / ${config.project}`}
                        />
                        <ListItemSecondaryAction>
                          {config.status === 'connected' ? (
                            <Tooltip title="Connected">
                              <Box component="span" sx={{ color: 'success.main', display: 'flex' }}>●</Box>
                            </Tooltip>
                          ) : config.status === 'error' ? (
                            <Tooltip title="Error">
                              <Box component="span" sx={{ color: 'error.main', display: 'flex' }}>●</Box>
                            </Tooltip>
                          ) : (
                            <Tooltip title="Disconnected">
                              <Box component="span" sx={{ color: 'text.disabled', display: 'flex' }}>●</Box>
                            </Tooltip>
                          )}
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))
                  )}
                </List>
              )}
            </Paper>
          </Grid>
          
          <Grid item xs={12} md={8}>
            <Paper variant="outlined" sx={{ p: 2, height: '500px', overflow: 'auto' }}>
              {!selectedConfig && !isEditing ? (
                <Box sx={{ display: 'flex', height: '100%', justifyContent: 'center', alignItems: 'center', flexDirection: 'column' }}>
                  <Typography variant="h6" color="textSecondary">Select an ADO connection or add a new one</Typography>
                </Box>
              ) : isEditing ? (
                <Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h6">
                      {formData.id ? 'Edit Connection' : 'New Connection'}
                    </Typography>
                    <Button
                      variant="contained"
                      color="primary"
                      startIcon={isLoading ? <CircularProgress size={20} /> : <SaveIcon />}
                      onClick={handleSaveConfig}
                      disabled={isLoading}
                    >
                      Save
                    </Button>
                  </Box>
                  
                  <Grid container spacing={2}>
                    <Grid item xs={12}>
                      <TextField
                        label="Connection Name"
                        name="name"
                        value={formData.name}
                        onChange={handleInputChange}
                        fullWidth
                        required
                      />
                    </Grid>
                    
                    <Grid item xs={12}>
                      <TextField
                        label="Organization URL"
                        name="organizationUrl"
                        value={formData.organizationUrl}
                        onChange={handleInputChange}
                        fullWidth
                        required
                        placeholder="https://dev.azure.com/organization"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <TextField
                        label="Personal Access Token (PAT)"
                        name="pat"
                        type="password"
                        value={formData.pat}
                        onChange={handleInputChange}
                        fullWidth
                        required
                        placeholder={formData.id ? '••••••••••••••••' : ''}
                        helperText={formData.id ? 'Leave blank to keep existing token' : 'Create a PAT with appropriate scopes'}
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <Box sx={{ mb: 2 }}>
                        <Button
                          variant="outlined"
                          color="primary"
                          onClick={handleTestConnection}
                          disabled={operationLoading || !formData.organizationUrl || !formData.pat}
                          startIcon={operationLoading ? <CircularProgress size={20} /> : null}
                        >
                          Test Connection
                        </Button>
                      </Box>
                      
                      {formData.status === 'connected' && (
                        <Alert severity="success" sx={{ mb: 2 }}>
                          Successfully connected to Azure DevOps
                        </Alert>
                      )}
                      
                      {formData.status === 'error' && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                          {formData.errorMessage || 'Error connecting to Azure DevOps'}
                        </Alert>
                      )}
                    </Grid>
                    
                    <Grid item xs={12}>
                      <FormControl fullWidth>
                        <InputLabel id="ado-project-select-label">Project</InputLabel>
                        <Select
                          labelId="ado-project-select-label"
                          id="ado-project-select"
                          name="project"
                          value={formData.project}
                          onChange={handleInputChange}
                          label="Project"
                          disabled={availableProjects.length === 0}
                        >
                          {availableProjects.map(project => (
                            <MenuItem key={project.id} value={project.name}>
                              {project.name}
                            </MenuItem>
                          ))}
                        </Select>
                      </FormControl>
                    </Grid>
                    
                    <Grid item xs={12}>
                      <Divider sx={{ my: 2 }} />
                      <Typography variant="subtitle1" sx={{ mb: 2 }}>Synchronization Settings</Typography>
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.autoSync}
                            onChange={handleToggleChange}
                            name="autoSync"
                          />
                        }
                        label="Auto-sync"
                      />
                    </Grid>
                    
                    {formData.autoSync && (
                      <Grid item xs={12} md={6}>
                        <TextField
                          label="Sync Frequency (minutes)"
                          name="syncFrequency"
                          type="number"
                          value={formData.syncFrequency}
                          onChange={handleInputChange}
                          fullWidth
                          inputProps={{ min: 5, max: 1440 }}
                        />
                      </Grid>
                    )}
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.syncWorkItems}
                            onChange={handleToggleChange}
                            name="syncWorkItems"
                          />
                        }
                        label="Sync Work Items"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.syncTestCases}
                            onChange={handleToggleChange}
                            name="syncTestCases"
                          />
                        }
                        label="Sync Test Cases"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.syncTestPlans}
                            onChange={handleToggleChange}
                            name="syncTestPlans"
                          />
                        }
                        label="Sync Test Plans"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={formData.syncBuilds}
                            onChange={handleToggleChange}
                            name="syncBuilds"
                          />
                        }
                        label="Sync Builds"
                      />
                    </Grid>
                  </Grid>
                </Box>
              ) : (
                <Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
                    <Typography variant="h6">
                      {selectedConfig?.name} - {selectedConfig?.project}
                    </Typography>
                    <Box>
                      <Button
                        variant="outlined"
                        startIcon={<SyncIcon />}
                        onClick={handleSyncAll}
                        sx={{ mr: 1 }}
                        disabled={operationLoading}
                      >
                        Sync All
                      </Button>
                      <Button
                        variant="outlined"
                        startIcon={<EditIcon />}
                        onClick={handleEdit}
                        sx={{ mr: 1 }}
                      >
                        Edit
                      </Button>
                      <Button
                        variant="outlined"
                        color="error"
                        startIcon={<DeleteIcon />}
                        onClick={() => setShowDeleteModal(true)}
                      >
                        Delete
                      </Button>
                    </Box>
                  </Box>
                  
                  {selectedConfig?.status === 'error' && (
                    <Alert severity="error" sx={{ mb: 2 }}>
                      {selectedConfig.errorMessage || 'Error connecting to this ADO instance'}
                    </Alert>
                  )}
                  
                  {selectedConfig?.lastSyncTime && (
                    <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                      Last synchronized: {new Date(selectedConfig.lastSyncTime).toLocaleString()}
                    </Typography>
                  )}
                  
                  <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                    <Tabs value={activeTab} onChange={handleTabChange} aria-label="ado integration tabs">
                      <Tab label="Work Items" icon={<AssignmentIcon />} iconPosition="start" />
                      <Tab label="Test Cases" icon={<TestIcon />} iconPosition="start" />
                      <Tab label="Builds" icon={<BugIcon />} iconPosition="start" />
                    </Tabs>
                  </Box>
                  
                  {activeTab === 0 && (
                    <Box sx={{ pt: 2 }}>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                        <Typography variant="subtitle1">Work Items</Typography>
                        <Button
                          variant="outlined"
                          size="small"
                          startIcon={<RefreshIcon />}
                          onClick={loadWorkItems}
                          disabled={operationLoading}
                        >
                          Refresh
                        </Button>
                      </Box>
                      
                      {operationLoading ? (
                        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                          <CircularProgress />
                        </Box>
                      ) : workItems.length === 0 ? (
                        <Typography variant="body2" color="textSecondary">
                          No work items found. Sync with Azure DevOps to load work items.
                        </Typography>
                      ) : (
                        <List>
                          {workItems.map(workItem => (
                            <ListItem key={workItem.id} divider>
                              <ListItemText
                                primary={`${workItem.type} #${workItem.id}: ${workItem.title}`}
                                secondary={
                                  <>
                                    <Typography component="span" variant="body2">
                                      State: {workItem.state}
                                      {workItem.assignedTo && ` | Assigned to: ${workItem.assignedTo}`}
                                      {workItem.priority && ` | Priority: ${workItem.priority}`}
                                    </Typography>
                                    <br />
                                    <Typography component="span" variant="body2">
                                      Created: {new Date(workItem.createdDate).toLocaleDateString()}
                                    </Typography>
                                  </>
                                }
                              />
                              <ListItemSecondaryAction>
                                <IconButton edge="end" onClick={() => openLinkDialog(workItem)}>
                                  <LinkIcon />
                                </IconButton>
                              </ListItemSecondaryAction>
                            </ListItem>
                          ))}
                        </List>
                      )}
                    </Box>
                  )}
                  
                  {activeTab === 1 && (
                    <Box sx={{ pt: 2 }}>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                        <Typography variant="subtitle1">Test Cases</Typography>
                        <Box>
                          <Button
                            variant="outlined"
                            size="small"
                            startIcon={<AddIcon />}
                            onClick={openImportDialog}
                            disabled={operationLoading}
                            sx={{ mr: 1 }}
                          >
                            Import
                          </Button>
                          <Button
                            variant="outlined"
                            size="small"
                            startIcon={<RefreshIcon />}
                            onClick={loadTestCases}
                            disabled={operationLoading}
                          >
                            Refresh
                          </Button>
                        </Box>
                      </Box>
                      
                      {operationLoading ? (
                        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                          <CircularProgress />
                        </Box>
                      ) : testCases.length === 0 ? (
                        <Typography variant="body2" color="textSecondary">
                          No test cases found. Import test cases from Azure DevOps.
                        </Typography>
                      ) : (
                        <List>
                          {testCases.map(testCase => (
                            <ListItem key={testCase.id} divider>
                              <ListItemText
                                primary={`Test Case #${testCase.id}: ${testCase.title}`}
                                secondary={
                                  <>
                                    <Typography component="span" variant="body2">
                                      State: {testCase.state} | Automation Status: {testCase.automationStatus}
                                      {testCase.priority && ` | Priority: ${testCase.priority}`}
                                    </Typography>
                                    <br />
                                    <Typography component="span" variant="body2">
                                      {testCase.testPlanId && `Test Plan: ${testCase.testPlanId}`}
                                      {testCase.testSuiteId && ` | Test Suite: ${testCase.testSuiteId}`}
                                    </Typography>
                                  </>
                                }
                              />
                            </ListItem>
                          ))}
                        </List>
                      )}
                    </Box>
                  )}
                  
                  {activeTab === 2 && (
                    <Box sx={{ pt: 2 }}>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                        <Typography variant="subtitle1">Builds</Typography>
                        <Button
                          variant="outlined"
                          size="small"
                          startIcon={<RefreshIcon />}
                          onClick={loadBuilds}
                          disabled={operationLoading}
                        >
                          Refresh
                        </Button>
                      </Box>
                      
                      {operationLoading ? (
                        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                          <CircularProgress />
                        </Box>
                      ) : builds.length === 0 ? (
                        <Typography variant="body2" color="textSecondary">
                          No builds found. Sync with Azure DevOps to load builds.
                        </Typography>
                      ) : (
                        <List>
                          {builds.map(build => (
                            <ListItem key={build.id} divider>
                              <ListItemText
                                primary={`Build #${build.id}: ${build.name}`}
                                secondary={
                                  <>
                                    <Typography component="span" variant="body2">
                                      Status: {build.status} | Result: {build.result}
                                    </Typography>
                                    <br />
                                    <Typography component="span" variant="body2">
                                      Branch: {build.sourceBranch}
                                    </Typography>
                                    <br />
                                    <Typography component="span" variant="body2">
                                      Queued: {new Date(build.queueTime).toLocaleString()}
                                      {build.startTime && ` | Started: ${new Date(build.startTime).toLocaleString()}`}
                                      {build.finishTime && ` | Finished: ${new Date(build.finishTime).toLocaleString()}`}
                                    </Typography>
                                  </>
                                }
                              />
                              <ListItemSecondaryAction>
                                <IconButton 
                                  edge="end" 
                                  onClick={() => handleQueueBuild(build.id)}
                                  disabled={build.status === 'inProgress'}
                                >
                                  <QueueIcon />
                                </IconButton>
                              </ListItemSecondaryAction>
                            </ListItem>
                          ))}
                        </List>
                      )}
                    </Box>
                  )}
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
      </Paper>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteModal} onClose={() => setShowDeleteModal(false)}>
        <DialogTitle>Confirm Deletion</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete the Azure DevOps connection "{selectedConfig?.name}"?
            This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDeleteModal(false)}>Cancel</Button>
          <Button
            color="error"
            onClick={handleDeleteConfig}
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Link Work Item Dialog */}
      <Dialog open={showLinkDialog} onClose={() => setShowLinkDialog(false)}>
        <DialogTitle>Link Work Item to Test Case</DialogTitle>
        <DialogContent>
          <Typography variant="body1" sx={{ mb: 2 }}>
            Link work item #{selectedWorkItem?.id}: {selectedWorkItem?.title} to a test case
          </Typography>
          <TextField
            label="Test Case ID or Name"
            value={linkToTestCase}
            onChange={(e) => setLinkToTestCase(e.target.value)}
            fullWidth
            sx={{ mt: 1 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowLinkDialog(false)}>Cancel</Button>
          <Button
            color="primary"
            onClick={handleLinkWorkItemToTestCase}
            disabled={!linkToTestCase || operationLoading}
          >
            Link
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Import Test Cases Dialog */}
      <Dialog 
        open={showImportDialog} 
        onClose={() => setShowImportDialog(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Import Test Cases from Azure DevOps</DialogTitle>
        <DialogContent>
          <Box sx={{ mb: 2 }}>
            <Typography variant="body1" sx={{ mb: 1 }}>
              Select test cases to import into CSTestForge
            </Typography>
            <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
              <Button size="small" onClick={handleSelectAllImportItems} sx={{ mr: 1 }}>
                Select All
              </Button>
              <Button size="small" onClick={handleDeselectAllImportItems}>
                Deselect All
              </Button>
            </Box>
          </Box>
          
          {importItems.length === 0 ? (
            <Typography variant="body2">
              No importable test cases found in Azure DevOps
            </Typography>
          ) : (
            <List sx={{ maxHeight: '300px', overflow: 'auto' }}>
              {importItems.map(testCase => (
                <ListItem key={testCase.id}>
                  <ListItemText
                    primary={`${testCase.title}`}
                    secondary={`ID: ${testCase.id} | State: ${testCase.state} | Priority: ${testCase.priority}`}
                  />
                  <Checkbox
                    edge="end"
                    checked={selectedImportItems.includes(testCase.id)}
                    onChange={() => handleToggleImportItem(testCase.id)}
                  />
                </ListItem>
              ))}
            </List>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowImportDialog(false)}>Cancel</Button>
          <Button
            color="primary"
            onClick={handleImportTestCases}
            disabled={selectedImportItems.length === 0 || operationLoading}
          >
            Import Selected ({selectedImportItems.length})
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default AzureDevOpsIntegration;


// src/utils/date.ts
/**
 * Date formatter utilities for CSTestForge
 */

/**
 * Formats a date as a human-readable string
 * @param date Date to format
 * @param includeTime Whether to include the time in the formatted string
 * @returns Formatted date string
 */
export const formatDate = (date: Date | string | number | undefined | null, includeTime = false): string => {
  if (!date) return 'N/A';
  
  const dateObj = typeof date === 'object' ? date : new Date(date);
  
  try {
    if (includeTime) {
      return dateObj.toLocaleString(undefined, {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    } else {
      return dateObj.toLocaleDateString(undefined, {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }
  } catch (error) {
    console.error('Error formatting date:', error);
    return 'Invalid Date';
  }
};

/**
 * Formats a duration in milliseconds to a human-readable string
 * @param ms Duration in milliseconds
 * @returns Formatted duration string
 */
export const formatDuration = (ms: number): string => {
  if (!ms || ms < 0) return '0s';
  
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
  
  const parts = [];
  
  if (hours > 0) {
    parts.push(`${hours}h`);
  }
  
  if (minutes > 0) {
    parts.push(`${minutes}m`);
  }
  
  if (seconds > 0 || parts.length === 0) {
    parts.push(`${seconds}s`);
  }
  
  return parts.join(' ');
};

/**
 * Returns a relative time string (e.g., "2 hours ago")
 * @param date Date to calculate relative time from
 * @returns Relative time string
 */
export const getRelativeTime = (date: Date | string | number): string => {
  const dateObj = typeof date === 'object' ? date : new Date(date);
  const now = new Date();
  const diffMs = now.getTime() - dateObj.getTime();
  
  // Convert to seconds
  const diffSec = Math.floor(diffMs / 1000);
  
  if (diffSec < 60) {
    return diffSec <= 1 ? 'just now' : `${diffSec} seconds ago`;
  }
  
  // Convert to minutes
  const diffMin = Math.floor(diffSec / 60);
  
  if (diffMin < 60) {
    return diffMin === 1 ? '1 minute ago' : `${diffMin} minutes ago`;
  }
  
  // Convert to hours
  const diffHours = Math.floor(diffMin / 60);
  
  if (diffHours < 24) {
    return diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
  }
  
  // Convert to days
  const diffDays = Math.floor(diffHours / 24);
  
  if (diffDays < 30) {
    return diffDays === 1 ? '1 day ago' : `${diffDays} days ago`;
  }
  
  // Convert to months
  const diffMonths = Math.floor(diffDays / 30);
  
  if (diffMonths < 12) {
    return diffMonths === 1 ? '1 month ago' : `${diffMonths} months ago`;
  }
  
  // Convert to years
  const diffYears = Math.floor(diffDays / 365);
  return diffYears === 1 ? '1 year ago' : `${diffYears} years ago`;
};

// src/utils/validation.ts
/**
 * Form validation utilities for CSTestForge
 */

/**
 * Validates an email address
 * @param email Email to validate
 * @returns True if the email is valid, false otherwise
 */
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(email);
};

/**
 * Validates a URL
 * @param url URL to validate
 * @returns True if the URL is valid, false otherwise
 */
export const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
};

/**
 * Validates a password against common security requirements
 * @param password Password to validate
 * @returns Object containing validation result and error message
 */
export const validatePassword = (password: string): { isValid: boolean; message: string } => {
  if (password.length < 8) {
    return { isValid: false, message: 'Password must be at least 8 characters long' };
  }
  
  if (!/[A-Z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one uppercase letter' };
  }
  
  if (!/[a-z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one lowercase letter' };
  }
  
  if (!/[0-9]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one number' };
  }
  
  if (!/[^A-Za-z0-9]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one special character' };
  }
  
  return { isValid: true, message: 'Password is valid' };
};

/**
 * Validates that a required field is not empty
 * @param value Value to validate
 * @returns True if the value is not empty, false otherwise
 */
export const isNotEmpty = (value: string | undefined | null): boolean => {
  return !!value && value.trim().length > 0;
};

/**
 * Validates a number is within a specified range
 * @param value Number to validate
 * @param min Minimum allowed value
 * @param max Maximum allowed value
 * @returns True if the number is within range, false otherwise
 */
export const isInRange = (value: number, min: number, max: number): boolean => {
  return value >= min && value <= max;
};

/**
 * Validates a file extension
 * @param filename Filename to validate
 * @param allowedExtensions Array of allowed file extensions
 * @returns True if the file extension is allowed, false otherwise
 */
export const hasValidExtension = (filename: string, allowedExtensions: string[]): boolean => {
  const extension = filename.split('.').pop()?.toLowerCase() || '';
  return allowedExtensions.includes(extension);
};

// src/utils/formatter.ts
/**
 * Text and data formatting utilities for CSTestForge
 */

/**
 * Formats a number with thousand separators
 * @param num Number to format
 * @returns Formatted number string
 */
export const formatNumber = (num: number): string => {
  return new Intl.NumberFormat().format(num);
};

/**
 * Truncates a string to a specified length and adds ellipsis if needed
 * @param str String to truncate
 * @param maxLength Maximum length of the string
 * @returns Truncated string
 */
export const truncateString = (str: string, maxLength: number): string => {
  if (!str || str.length <= maxLength) return str;
  return str.slice(0, maxLength) + '...';
};

/**
 * Converts a camelCase string to Title Case
 * @param camelCase camelCase string
 * @returns Title Case string
 */
export const camelToTitleCase = (camelCase: string): string => {
  if (!camelCase) return '';
  
  // Add space before capital letters and uppercase the first character
  const result = camelCase.replace(/([A-Z])/g, ' $1').replace(/^\w/, c => c.toUpperCase());
  
  return result;
};

/**
 * Converts bytes to a human-readable size
 * @param bytes Size in bytes
 * @param decimals Number of decimal places
 * @returns Formatted size string (e.g., "1.5 MB")
 */
export const formatBytes = (bytes: number, decimals = 2): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
};

/**
 * Formats error messages for display
 * @param error Error object or message
 * @returns Formatted error message
 */
export const formatErrorMessage = (error: any): string => {
  if (!error) return 'An unknown error occurred';
  
  if (typeof error === 'string') return error;
  
  if (error.response && error.response.data && error.response.data.message) {
    return error.response.data.message;
  }
  
  if (error.message) return error.message;
  
  return 'An error occurred';
};

/**
 * Formats a key-value object as HTML attributes
 * @param attributes Object containing HTML attributes
 * @returns String of HTML attributes
 */
export const formatHtmlAttributes = (attributes: Record<string, string | number | boolean>): string => {
  return Object.entries(attributes)
    .map(([key, value]) => {
      if (typeof value === 'boolean') {
        return value ? key : '';
      }
      return `${key}="${value}"`;
    })
    .filter(Boolean)
    .join(' ');
};

// src/utils/object.ts
/**
 * Object manipulation utilities for CSTestForge
 */

/**
 * Deep clones an object
 * @param obj Object to clone
 * @returns Cloned object
 */
export const deepClone = <T>(obj: T): T => {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as any;
  }
  
  if (obj instanceof Array) {
    return obj.map(item => deepClone(item)) as any;
  }
  
  if (obj instanceof Object) {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [key, deepClone(value)])
    ) as any;
  }
  
  return obj;
};

/**
 * Compares two objects for equality
 * @param obj1 First object
 * @param obj2 Second object
 * @returns True if the objects are equal, false otherwise
 */
export const isEqual = (obj1: any, obj2: any): boolean => {
  if (obj1 === obj2) return true;
  
  if (obj1 === null || obj2 === null || typeof obj1 !== 'object' || typeof obj2 !== 'object') {
    return false;
  }
  
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }
  
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  
  if (keys1.length !== keys2.length) return false;
  
  return keys1.every(key => keys2.includes(key) && isEqual(obj1[key], obj2[key]));
};

/**
 * Picks specified properties from an object
 * @param obj Source object
 * @param keys Keys to pick
 * @returns New object with only the specified properties
 */
export const pick = <T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {
  return keys.reduce((result, key) => {
    if (key in obj) {
      result[key] = obj[key];
    }
    return result;
  }, {} as Pick<T, K>);
};

/**
 * Omits specified properties from an object
 * @param obj Source object
 * @param keys Keys to omit
 * @returns New object without the specified properties
 */
export const omit = <T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {
  return Object.keys(obj)
    .filter(key => !keys.includes(key as K))
    .reduce((result, key) => {
      result[key as keyof Omit<T, K>] = obj[key as keyof T] as any;
      return result;
    }, {} as Omit<T, K>);
};

/**
 * Merges multiple objects deeply
 * @param target Target object
 * @param sources Source objects
 * @returns Merged object
 */
export const deepMerge = <T extends object>(target: T, ...sources: Partial<T>[]): T => {
  if (!sources.length) return target;
  
  const source = sources.shift();
  if (source === undefined) return target;
  
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(key => {
      const targetValue = target[key as keyof T];
      const sourceValue = source[key as keyof typeof source];
      
      if (Array.isArray(sourceValue)) {
        if (!Array.isArray(targetValue)) {
          (target as any)[key] = sourceValue;
        } else {
          (target as any)[key] = [...targetValue, ...sourceValue];
        }
      } else if (isObject(sourceValue)) {
        if (!isObject(targetValue)) {
          (target as any)[key] = {};
        }
        deepMerge((target as any)[key], sourceValue);
      } else {
        (target as any)[key] = sourceValue;
      }
    });
  }
  
  return deepMerge(target, ...sources);
};

/**
 * Checks if a value is an object
 * @param item Value to check
 * @returns True if the value is an object, false otherwise
 */
function isObject(item: any): item is object {
  return item !== null && typeof item === 'object' && !Array.isArray(item);
}

// src/types/testcase.ts
/**
 * TypeScript definitions for test cases
 */

export enum TestStepType {
  NAVIGATION = 'navigation',
  CLICK = 'click',
  TYPE = 'type',
  SELECT = 'select',
  ASSERT = 'assert',
  WAIT = 'wait',
  CUSTOM = 'custom',
  SCREENSHOT = 'screenshot',
  API = 'api',
  DATABASE = 'database'
}

export enum AssertionType {
  EQUALS = 'equals',
  CONTAINS = 'contains',
  NOT_EQUALS = 'notEquals',
  NOT_CONTAINS = 'notContains',
  GREATER_THAN = 'greaterThan',
  LESS_THAN = 'lessThan',
  EMPTY = 'empty',
  NOT_EMPTY = 'notEmpty',
  EXISTS = 'exists',
  NOT_EXISTS = 'notExists',
  MATCHES_REGEX = 'matchesRegex'
}

export enum WaitConditionType {
  ELEMENT_VISIBLE = 'elementVisible',
  ELEMENT_INVISIBLE = 'elementInvisible',
  ELEMENT_PRESENT = 'elementPresent',
  ELEMENT_NOT_PRESENT = 'elementNotPresent',
  ELEMENT_CLICKABLE = 'elementClickable',
  ELEMENT_CONTAINS_TEXT = 'elementContainsText',
  PAGE_LOAD = 'pageLoad',
  NAVIGATION = 'navigation',
  NETWORK_IDLE = 'networkIdle',
  CUSTOM = 'custom'
}

export enum TestStatus {
  PASSED = 'passed',
  FAILED = 'failed',
  ERROR = 'error',
  SKIPPED = 'skipped',
  RUNNING = 'running',
  PENDING = 'pending',
  WARNING = 'warning'
}

export interface TestStep {
  id: string;
  name: string;
  description?: string;
  type: TestStepType;
  selector?: string;
  value?: string;
  options?: Record<string, any>;
  assertion?: {
    type: AssertionType;
    target?: string;
    expected?: string;
  };
  waitCondition?: {
    type: WaitConditionType;
    timeout?: number;
    target?: string;
    value?: string;
  };
  screenshot?: boolean;
  disabled?: boolean;
  retryCount?: number;
  timeout?: number;
}

export interface TestCase {
  id: string;
  name: string;
  description?: string;
  tags?: string[];
  steps: TestStep[];
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
  updatedBy?: string;
  automationStatus: 'automated' | 'manual' | 'partial';
  status?: TestStatus;
  lastRun?: {
    id: string;
    status: TestStatus;
    startTime: string;
    endTime?: string;
    duration?: number;
    errorMessage?: string;
  };
  browserSettings?: {
    browser: 'chromium' | 'firefox' | 'webkit';
    viewportWidth?: number;
    viewportHeight?: number;
    headless?: boolean;
    deviceEmulation?: string;
  };
  selfHealing?: boolean;
  priority?: 'low' | 'medium' | 'high' | 'critical';
}

export interface TestSuite {
  id: string;
  name: string;
  description?: string;
  testCases: string[] | TestCase[];
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
  updatedBy?: string;
  tags?: string[];
  status?: TestStatus;
  lastRun?: {
    id: string;
    status: TestStatus;
    startTime: string;
    endTime?: string;
    duration?: number;
    passed: number;
    failed: number;
    skipped: number;
    total: number;
  };
  parallelExecution?: boolean;
  maxRetries?: number;
  timeout?: number;
}

// src/types/project.ts
/**
 * TypeScript definitions for projects
 */

export interface Project {
  id: string;
  name: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
  updatedBy?: string;
  baseUrl?: string;
  environments?: Environment[];
  tags?: string[];
  testCasesCount?: number;
  testSuitesCount?: number;
}

export interface Environment {
  id: string;
  name: string;
  baseUrl: string;
  variables?: Record<string, string>;
  isDefault?: boolean;
}

// src/types/auth.ts
/**
 * TypeScript definitions for authentication
 */

export interface User {
  id: string;
  username: string;
  email: string;
  firstName?: string;
  lastName?: string;
  role: 'admin' | 'user' | 'viewer';
  createdAt: string;
  updatedAt: string;
  lastLogin?: string;
  settings?: UserSettings;
}

export interface UserSettings {
  theme?: 'light' | 'dark' | 'system';
  timeZone?: string;
  dateFormat?: string;
  defaultBrowser?: 'chromium' | 'firefox' | 'webkit';
  notifications?: {
    email?: boolean;
    slack?: boolean;
    testCompleted?: boolean;
    testFailed?: boolean;
  };
}

export interface LoginCredentials {
  username: string;
  password: string;
  rememberMe?: boolean;
}

export interface RegisterData {
  username: string;
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
}

export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  loading: boolean;
  error: string | null;
}

// src/types/api.ts
/**
 * TypeScript definitions for API testing
 */

export enum HttpMethod {
  GET = 'GET',
  POST = 'POST',
  PUT = 'PUT',
  DELETE = 'DELETE',
  PATCH = 'PATCH',
  HEAD = 'HEAD',
  OPTIONS = 'OPTIONS'
}

export enum ApiAuthType {
  NONE = 'none',
  BASIC = 'basic',
  BEARER = 'bearer',
  API_KEY = 'apiKey',
  OAUTH2 = 'oauth2',
  CUSTOM = 'custom'
}

export interface ApiHeader {
  key: string;
  value: string;
  enabled: boolean;
}

export interface ApiParam {
  key: string;
  value: string;
  enabled: boolean;
}

export interface ApiAuth {
  type: ApiAuthType;
  username?: string;
  password?: string;
  token?: string;
  apiKey?: string;
  apiKeyName?: string;
  apiKeyLocation?: 'header' | 'query';
  custom?: Record<string, string>;
}

export interface ApiRequest {
  id: string;
  name: string;
  method: HttpMethod;
  url: string;
  headers: ApiHeader[];
  params: ApiParam[];
  auth: ApiAuth;
  body?: {
    type: 'none' | 'form-data' | 'x-www-form-urlencoded' | 'raw' | 'binary';
    content?: string;
    formData?: Record<string, string | File>;
    contentType?: string;
  };
  description?: string;
  preSendScript?: string;
  postResponseScript?: string;
}

export interface ApiResponse {
  statusCode: number;
  statusText: string;
  headers: Record<string, string>;
  body: string;
  responseTime: number;
  size: number;
  contentType?: string;
}

export interface ApiTest {
  id: string;
  name: string;
  description?: string;
  request: ApiRequest;
  assertions?: {
    id: string;
    name: string;
    target: 'status' | 'body' | 'header' | 'responseTime';
    property?: string;
    assertion: AssertionType;
    expected: string;
    enabled: boolean;
  }[];
  variables?: {
    id: string;
    name: string;
    source: 'body' | 'header' | 'status';
    path?: string;
    enabled: boolean;
  }[];
  createdAt: string;
  updatedAt: string;
  lastRun?: {
    status: TestStatus;
    response?: ApiResponse;
    assertionResults?: {
      assertionId: string;
      passed: boolean;
      actual?: string;
      expected?: string;
      message?: string;
    }[];
    timestamp: string;
  };
}


// src/components/bdd/ScenarioEditor.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  IconButton,
  Grid,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Tooltip,
  Chip,
  Divider,
  Card,
  CardContent,
  CircularProgress
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  PlayArrow as RunIcon,
  Save as SaveIcon,
  ArrowUpward as MoveUpIcon,
  ArrowDownward as MoveDownIcon,
  Code as CodeIcon,
  FormatListBulleted as ListIcon,
  Info as InfoIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';

// Define types for BDD testing
interface Step {
  id: string;
  text: string;
  keyword: 'Given' | 'When' | 'Then' | 'And' | 'But';
  implementation?: string;
  parameters?: Record<string, string>;
}

interface Scenario {
  id: string;
  name: string;
  description?: string;
  steps: Step[];
  tags?: string[];
}

interface Feature {
  id: string;
  name: string;
  description?: string;
  scenarios: Scenario[];
  tags?: string[];
}

interface StepDefinition {
  id: string;
  pattern: string;
  implementation: string;
  description?: string;
}

const ScenarioEditor: React.FC<{
  feature: Feature;
  scenario: Scenario;
  onSave: (scenario: Scenario) => void;
  onCancel: () => void;
}> = ({ feature, scenario, onSave, onCancel }) => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // State
  const [editedScenario, setEditedScenario] = useState<Scenario>({ ...scenario });
  const [currentStep, setCurrentStep] = useState<Step | null>(null);
  const [stepDialogOpen, setStepDialogOpen] = useState(false);
  const [stepImplementationOpen, setStepImplementationOpen] = useState(false);
  const [stepKeyword, setStepKeyword] = useState<Step['keyword']>('Given');
  const [stepText, setStepText] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [currentStepIndex, setCurrentStepIndex] = useState<number>(-1);
  const [stepDefinitions, setStepDefinitions] = useState<StepDefinition[]>([]);
  const [loadingStepDefs, setLoadingStepDefs] = useState(false);
  const [showCodeEditor, setShowCodeEditor] = useState(false);
  const [stepImplementation, setStepImplementation] = useState('');
  const [tagInput, setTagInput] = useState('');
  const [suggestedSteps, setSuggestedSteps] = useState<string[]>([]);
  
  // Load step definitions when component mounts
  useEffect(() => {
    if (currentProject?.id) {
      loadStepDefinitions();
    }
  }, [currentProject]);
  
  const loadStepDefinitions = async () => {
    setLoadingStepDefs(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/bdd/step-definitions`);
      setStepDefinitions(response.data);
    } catch (error) {
      console.error('Error loading step definitions:', error);
    } finally {
      setLoadingStepDefs(false);
    }
  };
  
  const findMatchingStepDefinitions = (text: string) => {
    if (!text.trim()) {
      setSuggestedSteps([]);
      return;
    }
    
    const normalizedText = text.toLowerCase();
    const matches = stepDefinitions
      .filter(def => {
        // Convert regex pattern to plain string to make it easier to match
        const patternAsString = def.pattern
          .replace(/^\^/, '') // Remove starting ^
          .replace(/\$$/, '') // Remove ending $
          .replace(/\([^)]+\)/g, '{param}') // Replace (regex) groups with {param}
          .toLowerCase();
        
        return normalizedText.includes(patternAsString) || patternAsString.includes(normalizedText);
      })
      .map(def => def.pattern);
    
    setSuggestedSteps(matches);
  };
  
  const handleOpenStepDialog = (index: number = -1) => {
    if (index >= 0) {
      // Edit existing step
      const step = editedScenario.steps[index];
      setCurrentStep(step);
      setStepKeyword(step.keyword);
      setStepText(step.text);
      setIsEditing(true);
      setCurrentStepIndex(index);
    } else {
      // Add new step
      setCurrentStep(null);
      setStepKeyword('Given');
      setStepText('');
      setIsEditing(false);
      setCurrentStepIndex(-1);
    }
    setStepDialogOpen(true);
  };
  
  const handleCloseStepDialog = () => {
    setStepDialogOpen(false);
    setCurrentStep(null);
    setStepKeyword('Given');
    setStepText('');
    setSuggestedSteps([]);
  };
  
  const handleOpenImplementationDialog = (step: Step, index: number) => {
    setCurrentStep(step);
    setCurrentStepIndex(index);
    setStepImplementation(step.implementation || '');
    setStepImplementationOpen(true);
  };
  
  const handleCloseImplementationDialog = () => {
    setStepImplementationOpen(false);
    setCurrentStep(null);
    setStepImplementation('');
  };
  
  const handleSaveImplementation = () => {
    if (!currentStep) return;
    
    setEditedScenario(prev => {
      const updatedSteps = [...prev.steps];
      if (currentStepIndex >= 0) {
        updatedSteps[currentStepIndex] = {
          ...updatedSteps[currentStepIndex],
          implementation: stepImplementation
        };
      }
      return { ...prev, steps: updatedSteps };
    });
    
    handleCloseImplementationDialog();
  };
  
  const handleSaveStep = () => {
    if (!stepText.trim()) return;
    
    const newStep: Step = {
      id: currentStep?.id || `step-${Date.now()}`,
      keyword: stepKeyword,
      text: stepText.trim(),
      implementation: currentStep?.implementation || '',
      parameters: currentStep?.parameters || {}
    };
    
    setEditedScenario(prev => {
      const updatedSteps = [...prev.steps];
      if (isEditing && currentStepIndex >= 0) {
        // Update existing step
        updatedSteps[currentStepIndex] = newStep;
      } else {
        // Add new step
        updatedSteps.push(newStep);
      }
      return { ...prev, steps: updatedSteps };
    });
    
    handleCloseStepDialog();
  };
  
  const handleDeleteStep = (index: number) => {
    setEditedScenario(prev => {
      const updatedSteps = [...prev.steps];
      updatedSteps.splice(index, 1);
      return { ...prev, steps: updatedSteps };
    });
  };
  
  const handleMoveStep = (index: number, direction: 'up' | 'down') => {
    if (
      (direction === 'up' && index === 0) ||
      (direction === 'down' && index === editedScenario.steps.length - 1)
    ) {
      return;
    }
    
    setEditedScenario(prev => {
      const updatedSteps = [...prev.steps];
      const newIndex = direction === 'up' ? index - 1 : index + 1;
      [updatedSteps[index], updatedSteps[newIndex]] = [updatedSteps[newIndex], updatedSteps[index]];
      return { ...prev, steps: updatedSteps };
    });
  };
  
  const handleTextChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setStepText(value);
    findMatchingStepDefinitions(value);
  };
  
  const handleAddTag = () => {
    if (!tagInput.trim()) return;
    
    setEditedScenario(prev => {
      const newTags = prev.tags || [];
      if (!newTags.includes(tagInput.trim())) {
        return { ...prev, tags: [...newTags, tagInput.trim()] };
      }
      return prev;
    });
    
    setTagInput('');
  };
  
  const handleDeleteTag = (tag: string) => {
    setEditedScenario(prev => {
      const newTags = prev.tags ? prev.tags.filter(t => t !== tag) : [];
      return { ...prev, tags: newTags };
    });
  };
  
  const handleSaveScenario = () => {
    onSave(editedScenario);
  };
  
  const handleSelectSuggestedStep = (suggestion: string) => {
    setStepText(suggestion);
    setSuggestedSteps([]);
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h5">
            {editedScenario.id ? 'Edit Scenario' : 'New Scenario'}
          </Typography>
          <Box>
            <Button
              variant="outlined"
              onClick={onCancel}
              sx={{ mr: 1 }}
            >
              Cancel
            </Button>
            <Button
              variant="contained"
              color="primary"
              startIcon={<SaveIcon />}
              onClick={handleSaveScenario}
            >
              Save Scenario
            </Button>
          </Box>
        </Box>
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              label="Scenario Name"
              value={editedScenario.name}
              onChange={(e) => setEditedScenario(prev => ({ ...prev, name: e.target.value }))}
              fullWidth
              required
            />
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              label="Description"
              value={editedScenario.description || ''}
              onChange={(e) => setEditedScenario(prev => ({ ...prev, description: e.target.value }))}
              fullWidth
              multiline
              rows={3}
            />
          </Grid>
          
          <Grid item xs={12}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Typography variant="subtitle1" sx={{ mr: 2 }}>Tags</Typography>
              <TextField
                label="Add tag"
                size="small"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                sx={{ mr: 1, flexGrow: 1 }}
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    handleAddTag();
                    e.preventDefault();
                  }
                }}
              />
              <Button
                variant="outlined"
                size="small"
                onClick={handleAddTag}
                startIcon={<AddIcon />}
              >
                Add
              </Button>
            </Box>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
              {(editedScenario.tags || []).map((tag, index) => (
                <Chip
                  key={index}
                  label={tag}
                  onDelete={() => handleDeleteTag(tag)}
                />
              ))}
              {(editedScenario.tags || []).length === 0 && (
                <Typography variant="body2" color="textSecondary">
                  No tags added
                </Typography>
              )}
            </Box>
          </Grid>
          
          <Grid item xs={12}>
            <Divider sx={{ my: 2 }} />
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="subtitle1">Steps</Typography>
              <Button
                variant="outlined"
                size="small"
                startIcon={<AddIcon />}
                onClick={() => handleOpenStepDialog()}
              >
                Add Step
              </Button>
            </Box>
            
            {editedScenario.steps.length === 0 ? (
              <Card variant="outlined">
                <CardContent>
                  <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center' }}>
                    No steps added to this scenario yet.
                    <br />
                    Click "Add Step" to start building your scenario.
                  </Typography>
                </CardContent>
              </Card>
            ) : (
              <List>
                {editedScenario.steps.map((step, index) => (
                  <ListItem
                    key={step.id}
                    sx={{
                      bgcolor: 'background.paper',
                      mb: 1,
                      border: '1px solid',
                      borderColor: 'divider',
                      borderRadius: 1
                    }}
                  >
                    <ListItemText
                      primary={
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <Chip 
                            label={step.keyword} 
                            size="small" 
                            color="primary" 
                            variant="outlined"
                            sx={{ mr: 1, minWidth: 60 }}
                          />
                          <Typography variant="body1">{step.text}</Typography>
                        </Box>
                      }
                      secondary={
                        step.implementation ? (
                          <Tooltip title="This step has a custom implementation">
                            <Chip
                              icon={<CodeIcon />}
                              label="Custom Implementation"
                              size="small"
                              variant="outlined"
                              color="secondary"
                              sx={{ mt: 1 }}
                            />
                          </Tooltip>
                        ) : null
                      }
                    />
                    <ListItemSecondaryAction>
                      <Box>
                        <Tooltip title="Edit step">
                          <IconButton
                            edge="end"
                            onClick={() => handleOpenStepDialog(index)}
                            size="small"
                          >
                            <EditIcon />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Edit implementation">
                          <IconButton
                            edge="end"
                            onClick={() => handleOpenImplementationDialog(step, index)}
                            size="small"
                          >
                            <CodeIcon />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Move up">
                          <span>
                            <IconButton
                              edge="end"
                              onClick={() => handleMoveStep(index, 'up')}
                              disabled={index === 0}
                              size="small"
                            >
                              <MoveUpIcon />
                            </IconButton>
                          </span>
                        </Tooltip>
                        <Tooltip title="Move down">
                          <span>
                            <IconButton
                              edge="end"
                              onClick={() => handleMoveStep(index, 'down')}
                              disabled={index === editedScenario.steps.length - 1}
                              size="small"
                            >
                              <MoveDownIcon />
                            </IconButton>
                          </span>
                        </Tooltip>
                        <Tooltip title="Delete step">
                          <IconButton
                            edge="end"
                            onClick={() => handleDeleteStep(index)}
                            size="small"
                            color="error"
                          >
                            <DeleteIcon />
                          </IconButton>
                        </Tooltip>
                      </Box>
                    </ListItemSecondaryAction>
                  </ListItem>
                ))}
              </List>
            )}
          </Grid>
        </Grid>
      </Paper>
      
      {/* Step Dialog */}
      <Dialog open={stepDialogOpen} onClose={handleCloseStepDialog} maxWidth="md" fullWidth>
        <DialogTitle>{isEditing ? 'Edit Step' : 'Add Step'}</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth>
                <InputLabel id="step-keyword-label">Keyword</InputLabel>
                <Select
                  labelId="step-keyword-label"
                  value={stepKeyword}
                  onChange={(e) => setStepKeyword(e.target.value as Step['keyword'])}
                  label="Keyword"
                >
                  <MenuItem value="Given">Given</MenuItem>
                  <MenuItem value="When">When</MenuItem>
                  <MenuItem value="Then">Then</MenuItem>
                  <MenuItem value="And">And</MenuItem>
                  <MenuItem value="But">But</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={9}>
              <TextField
                label="Step Text"
                value={stepText}
                onChange={handleTextChange}
                fullWidth
                required
                placeholder="I enter {text} into the {field} field"
              />
            </Grid>
            
            {suggestedSteps.length > 0 && (
              <Grid item xs={12}>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>Suggested Steps:</Typography>
                <Paper variant="outlined" sx={{ p: 1 }}>
                  <List dense>
                    {suggestedSteps.map((suggestion, index) => (
                      <ListItem
                        key={index}
                        button
                        onClick={() => handleSelectSuggestedStep(suggestion)}
                      >
                        <ListItemIcon>
                          <ListIcon fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={suggestion} />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Grid>
            )}
            
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <InfoIcon fontSize="small" color="info" sx={{ mr: 1 }} />
                <Typography variant="body2" color="textSecondary">
                  Use {'{parameter}'} syntax to create dynamic parameters in your step.
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseStepDialog}>Cancel</Button>
          <Button 
            onClick={handleSaveStep}
            variant="contained" 
            color="primary"
            disabled={!stepText.trim()}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Implementation Dialog */}
      <Dialog 
        open={stepImplementationOpen} 
        onClose={handleCloseImplementationDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Step Implementation</DialogTitle>
        <DialogContent>
          <Box sx={{ mt: 1 }}>
            <Typography variant="subtitle2" gutterBottom>
              {currentStep?.keyword} {currentStep?.text}
            </Typography>
            
            <TextField
              label="JavaScript Implementation"
              value={stepImplementation}
              onChange={(e) => setStepImplementation(e.target.value)}
              fullWidth
              multiline
              rows={12}
              variant="outlined"
              sx={{ mt: 2, fontFamily: 'monospace' }}
            />
            
            <Box sx={{ mt: 2 }}>
              <Typography variant="body2" color="textSecondary">
                Write JavaScript code that implements this step. You can use the following variables:
              </Typography>
              <List dense>
                <ListItem>
                  <ListItemText 
                    primary="page" 
                    secondary="The Playwright page object" 
                  />
                </ListItem>
                <ListItem>
                  <ListItemText 
                    primary="context" 
                    secondary="The test context, including shared variables" 
                  />
                </ListItem>
                <ListItem>
                  <ListItemText 
                    primary="params" 
                    secondary="Parameters extracted from the step text" 
                  />
                </ListItem>
              </List>
            </Box>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseImplementationDialog}>Cancel</Button>
          <Button 
            onClick={handleSaveImplementation}
            variant="contained" 
            color="primary"
          >
            Save Implementation
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ScenarioEditor;


// src/components/nlp/TextToTest.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  CircularProgress,
  Chip,
  Stepper,
  Step,
  StepLabel,
  Card,
  CardContent,
  Grid,
  FormControlLabel,
  Checkbox,
  Divider,
  Alert,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Menu,
  MenuItem
} from '@mui/material';
import {
  Description as DescriptionIcon,
  CodeOutlined as CodeIcon,
  Transform as TransformIcon,
  Save as SaveIcon,
  PlayArrow as PlayIcon,
  Edit as EditIcon,
  Check as CheckIcon,
  Close as CloseIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  FormatListBulleted as ListIcon,
  ArrowForward as ArrowForwardIcon,
  Settings as SettingsIcon,
  MoreVert as MoreVertIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';
import { TestStep, TestStepType } from '../../types/testcase';

// Define types for NLP processing
interface NLPResult {
  originalText: string;
  extractedSteps: {
    text: string;
    mappedTo: string | null;
    confidence: number;
    suggestedMapping?: string[];
    mappedStep?: TestStep;
  }[];
  userIntent?: string;
  context?: Record<string, string>;
}

interface SavedMapping {
  id: string;
  name: string;
  description?: string;
  nlpPattern: string;
  stepType: TestStepType;
  stepTemplate: Partial<TestStep>;
  examples?: string[];
}

interface NLPSettings {
  extractionMode: 'conservative' | 'aggressive';
  autoMapKnownPatterns: boolean;
  includeAssertions: boolean;
  includeWaits: boolean;
  language: string;
  confidenceThreshold: number;
}

const TextToTest: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // Step state
  const [activeStep, setActiveStep] = useState(0);
  const steps = ['Input Description', 'Extract Steps', 'Map to Test Steps', 'Save Test Case'];
  
  // User input
  const [userText, setUserText] = useState('');
  const [testCaseName, setTestCaseName] = useState('');
  const [testCaseDescription, setTestCaseDescription] = useState('');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState('');
  
  // Processing state
  const [isProcessing, setIsProcessing] = useState(false);
  const [nlpResult, setNlpResult] = useState<NLPResult | null>(null);
  const [extractedSteps, setExtractedSteps] = useState<NLPResult['extractedSteps']>([]);
  const [savedMappings, setSavedMappings] = useState<SavedMapping[]>([]);
  
  // Edit states
  const [editingStepIndex, setEditingStepIndex] = useState<number | null>(null);
  const [editStepText, setEditStepText] = useState('');
  const [showEditDialog, setShowEditDialog] = useState(false);
  
  // Settings
  const [showSettingsDialog, setShowSettingsDialog] = useState(false);
  const [nlpSettings, setNlpSettings] = useState<NLPSettings>({
    extractionMode: 'conservative',
    autoMapKnownPatterns: true,
    includeAssertions: true,
    includeWaits: true,
    language: 'en',
    confidenceThreshold: 0.7
  });
  
  // Menu state
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const [selectedStepIndex, setSelectedStepIndex] = useState<number | null>(null);
  
  // Load saved mappings when component mounts
  useEffect(() => {
    if (currentProject?.id) {
      loadSavedMappings();
    }
  }, [currentProject]);
  
  const loadSavedMappings = async () => {
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/nlp/mappings`);
      setSavedMappings(response.data);
    } catch (error) {
      console.error('Error loading NLP mappings:', error);
    }
  };
  
  const handleProcessText = async () => {
    if (!userText.trim() || !currentProject?.id) return;
    
    setIsProcessing(true);
    try {
      const response = await api.post(`/api/projects/${currentProject.id}/nlp/process`, {
        text: userText,
        settings: nlpSettings
      });
      
      setNlpResult(response.data);
      setExtractedSteps(response.data.extractedSteps);
      
      // Generate a test case name if not already set
      if (!testCaseName) {
        const generatedName = response.data.userIntent || `Test from ${new Date().toLocaleDateString()}`;
        setTestCaseName(generatedName);
      }
      
      // Move to the next step
      setActiveStep(1);
    } catch (error) {
      console.error('Error processing text:', error);
    } finally {
      setIsProcessing(false);
    }
  };
  
  const handleMapSteps = () => {
    // Apply automatic mapping based on confidence
    const mappedSteps = extractedSteps.map(step => {
      if (step.mappedTo) return step;
      
      // Find matching saved mapping with highest confidence
      const mappings = savedMappings.filter(mapping => {
        try {
          const regex = new RegExp(mapping.nlpPattern, 'i');
          return regex.test(step.text);
        } catch (e) {
          return false;
        }
      });
      
      if (mappings.length > 0) {
        // Sort by pattern specificity (length)
        mappings.sort((a, b) => b.nlpPattern.length - a.nlpPattern.length);
        
        return {
          ...step,
          mappedTo: mappings[0].id,
          mappedStep: {
            ...mappings[0].stepTemplate,
            name: step.text
          } as TestStep
        };
      }
      
      return step;
    });
    
    setExtractedSteps(mappedSteps);
    setActiveStep(2);
  };
  
  const handleUpdateMapping = (index: number, mappingId: string | null) => {
    setExtractedSteps(prev => {
      const updated = [...prev];
      if (!mappingId) {
        updated[index] = {
          ...updated[index],
          mappedTo: null,
          mappedStep: undefined
        };
      } else {
        const mapping = savedMappings.find(m => m.id === mappingId);
        if (mapping) {
          updated[index] = {
            ...updated[index],
            mappedTo: mappingId,
            mappedStep: {
              ...mapping.stepTemplate,
              name: updated[index].text
            } as TestStep
          };
        }
      }
      return updated;
    });
  };
  
  const handleDeleteStep = (index: number) => {
    setExtractedSteps(prev => prev.filter((_, i) => i !== index));
  };
  
  const handleOpenEditDialog = (index: number) => {
    setEditingStepIndex(index);
    setEditStepText(extractedSteps[index].text);
    setShowEditDialog(true);
  };
  
  const handleSaveEditedStep = () => {
    if (editingStepIndex === null || !editStepText.trim()) return;
    
    setExtractedSteps(prev => {
      const updated = [...prev];
      updated[editingStepIndex] = {
        ...updated[editingStepIndex],
        text: editStepText
      };
      return updated;
    });
    
    setShowEditDialog(false);
    setEditingStepIndex(null);
    setEditStepText('');
  };
  
  const handleAddTag = () => {
    if (!tagInput.trim()) return;
    
    const newTag = tagInput.trim();
    if (!tags.includes(newTag)) {
      setTags([...tags, newTag]);
    }
    
    setTagInput('');
  };
  
  const handleDeleteTag = (tagToDelete: string) => {
    setTags(tags.filter(tag => tag !== tagToDelete));
  };
  
  const handleSaveTestCase = async () => {
    if (!currentProject?.id || !testCaseName.trim() || extractedSteps.length === 0) return;
    
    setIsProcessing(true);
    try {
      // Create test steps from the mapped extracted steps
      const testSteps = extractedSteps
        .filter(step => step.mappedTo)
        .map(step => step.mappedStep)
        .filter(Boolean) as TestStep[];
      
      // Create the test case
      const testCase = {
        name: testCaseName,
        description: testCaseDescription,
        tags,
        steps: testSteps,
        automationStatus: 'automated',
        selfHealing: true
      };
      
      const response = await api.post(`/api/projects/${currentProject.id}/test-cases`, testCase);
      
      // Success - move to final step
      setActiveStep(3);
    } catch (error) {
      console.error('Error saving test case:', error);
    } finally {
      setIsProcessing(false);
    }
  };
  
  const handleOpenMenu = (event: React.MouseEvent<HTMLElement>, index: number) => {
    setMenuAnchorEl(event.currentTarget);
    setSelectedStepIndex(index);
  };
  
  const handleCloseMenu = () => {
    setMenuAnchorEl(null);
    setSelectedStepIndex(null);
  };
  
  const handleOpenSettingsDialog = () => {
    setShowSettingsDialog(true);
  };
  
  const handleCloseSettingsDialog = () => {
    setShowSettingsDialog(false);
  };
  
  const handleUpdateSettings = () => {
    setShowSettingsDialog(false);
    // If already processed, we might want to reprocess with new settings
    if (nlpResult) {
      handleProcessText();
    }
  };
  
  const handleReset = () => {
    setActiveStep(0);
    setUserText('');
    setTestCaseName('');
    setTestCaseDescription('');
    setTags([]);
    setNlpResult(null);
    setExtractedSteps([]);
  };
  
  const getStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Describe Your Test in Natural Language
            </Typography>
            <TextField
              label="Test Description"
              value={userText}
              onChange={(e) => setUserText(e.target.value)}
              fullWidth
              multiline
              rows={8}
              placeholder="Describe the test steps in plain English. For example: 'Go to the login page. Enter admin@example.com in the username field. Enter password123 in the password field. Click the login button.'"
              sx={{ mb: 3 }}
            />
            <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
              <Button
                variant="outlined"
                onClick={handleOpenSettingsDialog}
                startIcon={<SettingsIcon />}
              >
                NLP Settings
              </Button>
              <Button
                variant="contained"
                color="primary"
                onClick={handleProcessText}
                disabled={!userText.trim() || isProcessing}
                startIcon={isProcessing ? <CircularProgress size={20} /> : <TransformIcon />}
              >
                Process Text
              </Button>
            </Box>
          </Box>
        );
      case 1:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Extracted Steps
            </Typography>
            {extractedSteps.length === 0 ? (
              <Alert severity="warning">
                No steps were extracted from your description. Try providing more detailed instructions or adjust the NLP settings.
              </Alert>
            ) : (
              <>
                <List sx={{ mb: 3 }}>
                  {extractedSteps.map((step, index) => (
                    <ListItem
                      key={index}
                      sx={{
                        mb: 1,
                        border: '1px solid',
                        borderColor: 'divider',
                        borderRadius: 1
                      }}
                    >
                      <ListItemIcon>
                        <Chip
                          label={`#${index + 1}`}
                          size="small"
                          color="primary"
                        />
                      </ListItemIcon>
                      <ListItemText
                        primary={step.text}
                        secondary={`Confidence: ${(step.confidence * 100).toFixed(0)}%`}
                      />
                      <Box>
                        <Tooltip title="Edit step">
                          <IconButton
                            size="small"
                            onClick={() => handleOpenEditDialog(index)}
                          >
                            <EditIcon />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Delete step">
                          <IconButton
                            size="small"
                            color="error"
                            onClick={() => handleDeleteStep(index)}
                          >
                            <DeleteIcon />
                          </IconButton>
                        </Tooltip>
                      </Box>
                    </ListItem>
                  ))}
                </List>
                <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={handleMapSteps}
                    startIcon={<ArrowForwardIcon />}
                  >
                    Continue to Mapping
                  </Button>
                </Box>
              </>
            )}
          </Box>
        );
      case 2:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>
              Map Steps to Test Actions
            </Typography>
            <Grid container spacing={3}>
              <Grid item xs={12} md={8}>
                <List sx={{ mb: 3 }}>
                  {extractedSteps.map((step, index) => (
                    <ListItem
                      key={index}
                      sx={{
                        mb: 1,
                        border: '1px solid',
                        borderColor: step.mappedTo ? 'success.main' : 'divider',
                        borderRadius: 1,
                        bgcolor: step.mappedTo ? 'rgba(76, 175, 80, 0.08)' : 'inherit'
                      }}
                    >
                      <ListItemIcon>
                        <Chip
                          label={`#${index + 1}`}
                          size="small"
                          color="primary"
                        />
                      </ListItemIcon>
                      <ListItemText
                        primary={step.text}
                        secondary={
                          step.mappedTo ? 
                            `Mapped to: ${savedMappings.find(m => m.id === step.mappedTo)?.name || step.mappedTo}` : 
                            'Not mapped yet'
                        }
                      />
                      <Box>
                        <IconButton
                          size="small"
                          onClick={(e) => handleOpenMenu(e, index)}
                        >
                          <MoreVertIcon />
                        </IconButton>
                      </Box>
                    </ListItem>
                  ))}
                </List>
              </Grid>
              
              <Grid item xs={12} md={4}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Test Case Details
                    </Typography>
                    <TextField
                      label="Test Case Name"
                      value={testCaseName}
                      onChange={(e) => setTestCaseName(e.target.value)}
                      fullWidth
                      margin="normal"
                      required
                    />
                    <TextField
                      label="Description"
                      value={testCaseDescription}
                      onChange={(e) => setTestCaseDescription(e.target.value)}
                      fullWidth
                      multiline
                      rows={2}
                      margin="normal"
                    />
                    <Box sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        Tags
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        <TextField
                          label="Add tag"
                          value={tagInput}
                          onChange={(e) => setTagInput(e.target.value)}
                          size="small"
                          sx={{ mr: 1, flexGrow: 1 }}
                          onKeyPress={(e) => {
                            if (e.key === 'Enter') {
                              handleAddTag();
                              e.preventDefault();
                            }
                          }}
                        />
                        <Button
                          size="small"
                          variant="outlined"
                          onClick={handleAddTag}
                          startIcon={<AddIcon />}
                        >
                          Add
                        </Button>
                      </Box>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {tags.map((tag, index) => (
                          <Chip
                            key={index}
                            label={tag}
                            onDelete={() => handleDeleteTag(tag)}
                            size="small"
                          />
                        ))}
                      </Box>
                    </Box>
                  </CardContent>
                </Card>
                
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleSaveTestCase}
                  startIcon={isProcessing ? <CircularProgress size={20} /> : <SaveIcon />}
                  fullWidth
                  sx={{ mt: 2 }}
                  disabled={
                    isProcessing || 
                    !testCaseName.trim() || 
                    extractedSteps.length === 0 ||
                    !extractedSteps.some(step => step.mappedTo)
                  }
                >
                  Save Test Case
                </Button>
              </Grid>
            </Grid>
          </Box>
        );
      case 3:
        return (
          <Box sx={{ textAlign: 'center', py: 4 }}>
            <CheckIcon color="success" sx={{ fontSize: 60, mb: 2 }} />
            <Typography variant="h5" gutterBottom>
              Test Case Created Successfully!
            </Typography>
            <Typography variant="body1" sx={{ mb: 3 }}>
              Your test case "{testCaseName}" has been created with {extractedSteps.filter(s => s.mappedTo).length} steps.
            </Typography>
            <Grid container spacing={2} justifyContent="center">
              <Grid item>
                <Button
                  variant="outlined"
                  onClick={handleReset}
                  startIcon={<DescriptionIcon />}
                >
                  Create Another Test
                </Button>
              </Grid>
              <Grid item>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<PlayIcon />}
                >
                  Run Test Case
                </Button>
              </Grid>
            </Grid>
          </Box>
        );
      default:
        return 'Unknown step';
    }
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h5" sx={{ mb: 3 }}>
          Natural Language Test Generation
        </Typography>
        
        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        <Box sx={{ mt: 3 }}>
          {getStepContent(activeStep)}
        </Box>
        
        {activeStep > 0 && activeStep < 3 && (
          <Box sx={{ display: 'flex', pt: 2 }}>
            <Button
              variant="outlined"
              onClick={() => setActiveStep(activeStep - 1)}
              sx={{ mr: 1 }}
            >
              Back
            </Button>
          </Box>
        )}
      </Paper>
      
      {/* Edit Step Dialog */}
      <Dialog open={showEditDialog} onClose={() => setShowEditDialog(false)}>
        <DialogTitle>Edit Step</DialogTitle>
        <DialogContent>
          <TextField
            label="Step Text"
            value={editStepText}
            onChange={(e) => setEditStepText(e.target.value)}
            fullWidth
            multiline
            rows={3}
            sx={{ mt: 1 }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowEditDialog(false)}>Cancel</Button>
          <Button
            onClick={handleSaveEditedStep}
            variant="contained"
            color="primary"
            disabled={!editStepText.trim()}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* NLP Settings Dialog */}
      <Dialog open={showSettingsDialog} onClose={handleCloseSettingsDialog}>
        <DialogTitle>NLP Processing Settings</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12}>
              <Typography variant="subtitle2" gutterBottom>
                Extraction Mode
              </Typography>
              <FormControlLabel
                control={
                  <Checkbox
                    checked={nlpSettings.extractionMode === 'aggressive'}
                    onChange={(e) => setNlpSettings(prev => ({
                      ...prev,
                      extractionMode: e.target.checked ? 'aggressive' : 'conservative'
                    }))}
                  />
                }
                label="Aggressive (extract more steps, may be less accurate)"
              />
            </Grid>
            
            <Grid item xs={12}>
              <Divider />
            </Grid>
            
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Checkbox
                    checked={nlpSettings.autoMapKnownPatterns}
                    onChange={(e) => setNlpSettings(prev => ({
                      ...prev,
                      autoMapKnownPatterns: e.target.checked
                    }))}
                  />
                }
                label="Automatically map recognized patterns"
              />
            </Grid>
            
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Checkbox
                    checked={nlpSettings.includeAssertions}
                    onChange={(e) => setNlpSettings(prev => ({
                      ...prev,
                      includeAssertions: e.target.checked
                    }))}
                  />
                }
                label="Include assertions in extraction"
              />
            </Grid>
            
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Checkbox
                    checked={nlpSettings.includeWaits}
                    onChange={(e) => setNlpSettings(prev => ({
                      ...prev,
                      includeWaits: e.target.checked
                    }))}
                  />
                }
                label="Include wait conditions in extraction"
              />
            </Grid>
            
            <Grid item xs={12}>
              <Divider />
            </Grid>
            
            <Grid item xs={12} md={6}>
              <TextField
                label="Language"
                value={nlpSettings.language}
                onChange={(e) => setNlpSettings(prev => ({
                  ...prev,
                  language: e.target.value
                }))}
                select
                fullWidth
              >
                <MenuItem value="en">English</MenuItem>
                <MenuItem value="fr">French</MenuItem>
                <MenuItem value="es">Spanish</MenuItem>
                <MenuItem value="de">German</MenuItem>
              </TextField>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <TextField
                label="Confidence Threshold"
                type="number"
                inputProps={{ min: 0, max: 1, step: 0.1 }}
                value={nlpSettings.confidenceThreshold}
                onChange={(e) => setNlpSettings(prev => ({
                  ...prev,
                  confidenceThreshold: parseFloat(e.target.value)
                }))}
                fullWidth
                helperText="Steps below this confidence won't be included (0-1)"
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseSettingsDialog}>Cancel</Button>
          <Button
            onClick={handleUpdateSettings}
            variant="contained"
            color="primary"
          >
            Apply Settings
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Mapping Menu */}
      <Menu
        anchorEl={menuAnchorEl}
        open={Boolean(menuAnchorEl)}
        onClose={handleCloseMenu}
      >
        <MenuItem
          onClick={() => {
            if (selectedStepIndex !== null) {
              handleOpenEditDialog(selectedStepIndex);
            }
            handleCloseMenu();
          }}
        >
          <ListItemIcon>
            <EditIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Edit Step</ListItemText>
        </MenuItem>
        
        <Divider />
        
        <MenuItem
          onClick={() => {
            if (selectedStepIndex !== null) {
              handleUpdateMapping(selectedStepIndex, null);
            }
            handleCloseMenu();
          }}
        >
          <ListItemIcon>
            <CloseIcon fontSize="small" />
          </ListItemIcon>
          <ListItemText>Clear Mapping</ListItemText>
        </MenuItem>
        
        <Divider />
        
        <Typography variant="caption" sx={{ px: 2, py: 1, display: 'block' }}>
          Map to Step Type:
        </Typography>
        
        {savedMappings.slice(0, 10).map((mapping) => (
          <MenuItem
            key={mapping.id}
            onClick={() => {
              if (selectedStepIndex !== null) {
                handleUpdateMapping(selectedStepIndex, mapping.id);
              }
              handleCloseMenu();
            }}
          >
            <ListItemIcon>
              <Chip
                label={mapping.stepType}
                size="small"
                color="primary"
                variant="outlined"
              />
            </ListItemIcon>
            <ListItemText primary={mapping.name} />
          </MenuItem>
        ))}
        
        {savedMappings.length > 10 && (
          <Typography variant="caption" sx={{ px: 2, py: 1, display: 'block', textAlign: 'center' }}>
            {savedMappings.length - 10} more mappings available...
          </Typography>
        )}
      </Menu>
    </Box>
  );
};

export default TextToTest;


// src/components/nlp/NLPResults.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Chip,
  Button,
  Divider,
  Card,
  CardContent,
  Grid,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Menu,
  MenuItem,
  ListItemIcon,
  CircularProgress,
  Collapse,
  Alert,
  Tooltip,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  FormControlLabel,
  Switch
} from '@mui/material';
import {
  Save as SaveIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Visibility as ViewIcon,
  PlayArrow as RunIcon,
  Code as CodeIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  Add as AddIcon,
  History as HistoryIcon,
  Refresh as RefreshIcon,
  MoreVert as MoreVertIcon,
  ContentCopy as CopyIcon,
  Assignment as AssignmentIcon,
  Settings as SettingsIcon,
  Search as SearchIcon,
  FilterList as FilterIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';
import { formatDate, formatDuration } from '../../utils/date';
import { TestStatus } from '../../types/testcase';

// Define types for NLP results
interface Parameter {
  name: string;
  value: string;
  type: string;
}

interface NLPMapping {
  id: string;
  pattern: string;
  stepType: string;
  description: string;
  parameters: Parameter[];
  extractionCount: number;
  lastUsed?: Date;
  createdAt: Date;
  updatedAt: Date;
}

interface ExtractedStep {
  id: string;
  text: string;
  mappingId: string | null;
  confidence: number;
  parameters: Parameter[];
  mappingName?: string;
}

interface NLPProcessResult {
  id: string;
  projectId: string;
  originalText: string;
  extractedSteps: ExtractedStep[];
  testCaseId?: string;
  testCaseName?: string;
  processingTime: number;
  createdAt: Date;
  status: 'completed' | 'failed' | 'partial';
  errorMessage?: string;
}

interface MappingStats {
  totalMappings: number;
  totalExtractions: number;
  unmappedRate: number;
  topMappings: {
    mappingId: string;
    pattern: string;
    count: number;
    percentage: number;
  }[];
}

const NLPResults: React.FC = () => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // Data state
  const [nlpResults, setNlpResults] = useState<NLPProcessResult[]>([]);
  const [mappings, setMappings] = useState<NLPMapping[]>([]);
  const [mappingStats, setMappingStats] = useState<MappingStats | null>(null);
  const [selectedResult, setSelectedResult] = useState<NLPProcessResult | null>(null);
  const [expandedResultIds, setExpandedResultIds] = useState<string[]>([]);
  
  // UI state
  const [loading, setLoading] = useState(false);
  const [statsLoading, setStatsLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const [selectedItemId, setSelectedItemId] = useState<string | null>(null);
  const [showMapping, setShowMapping] = useState(false);
  const [currentMapping, setCurrentMapping] = useState<NLPMapping | null>(null);
  const [showOnlyTestCases, setShowOnlyTestCases] = useState(false);
  
  // Add/Edit mapping dialog
  const [mappingDialogOpen, setMappingDialogOpen] = useState(false);
  const [editMappingId, setEditMappingId] = useState<string | null>(null);
  const [mappingForm, setMappingForm] = useState({
    pattern: '',
    stepType: '',
    description: ''
  });
  
  // Load data when component mounts
  useEffect(() => {
    if (currentProject?.id) {
      loadResults();
      loadMappings();
      loadStats();
    }
  }, [currentProject]);
  
  const loadResults = async () => {
    setLoading(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/nlp/results`);
      setNlpResults(response.data);
      
      // Expand the most recent result by default
      if (response.data.length > 0) {
        setExpandedResultIds([response.data[0].id]);
      }
    } catch (error) {
      console.error('Error loading NLP results:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const loadMappings = async () => {
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/nlp/mappings`);
      setMappings(response.data);
    } catch (error) {
      console.error('Error loading NLP mappings:', error);
    }
  };
  
  const loadStats = async () => {
    setStatsLoading(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/nlp/stats`);
      setMappingStats(response.data);
    } catch (error) {
      console.error('Error loading NLP stats:', error);
    } finally {
      setStatsLoading(false);
    }
  };
  
  const handleRefresh = () => {
    loadResults();
    loadMappings();
    loadStats();
  };
  
  const handleToggleExpand = (resultId: string) => {
    setExpandedResultIds(prev => {
      if (prev.includes(resultId)) {
        return prev.filter(id => id !== resultId);
      } else {
        return [...prev, resultId];
      }
    });
  };
  
  const handleOpenMenu = (event: React.MouseEvent<HTMLElement>, id: string) => {
    setMenuAnchorEl(event.currentTarget);
    setSelectedItemId(id);
  };
  
  const handleCloseMenu = () => {
    setMenuAnchorEl(null);
    setSelectedItemId(null);
  };
  
  const handleDeleteResult = async (id: string) => {
    try {
      await api.delete(`/api/projects/${currentProject?.id}/nlp/results/${id}`);
      setNlpResults(prev => prev.filter(result => result.id !== id));
    } catch (error) {
      console.error('Error deleting NLP result:', error);
    } finally {
      handleCloseMenu();
    }
  };
  
  const handleViewMapping = (mappingId: string) => {
    const mapping = mappings.find(m => m.id === mappingId);
    if (mapping) {
      setCurrentMapping(mapping);
      setShowMapping(true);
    }
    handleCloseMenu();
  };
  
  const handleCreateTestCase = async (resultId: string) => {
    setLoading(true);
    try {
      const result = nlpResults.find(r => r.id === resultId);
      if (!result) return;
      
      // Prepare test case payload
      const testCaseData = {
        name: `Test from NLP ${formatDate(result.createdAt)}`,
        description: `Generated from natural language: "${result.originalText}"`,
        steps: result.extractedSteps
          .filter(step => step.mappingId) // Only include steps with mappings
          .map(step => {
            const mapping = mappings.find(m => m.id === step.mappingId);
            return {
              name: step.text,
              type: mapping?.stepType || 'custom',
              parameters: step.parameters
            };
          })
      };
      
      // Create the test case
      const response = await api.post(`/api/projects/${currentProject?.id}/test-cases`, testCaseData);
      
      // Update the result with the new test case info
      const updatedResults = [...nlpResults];
      const resultIndex = updatedResults.findIndex(r => r.id === resultId);
      if (resultIndex >= 0) {
        updatedResults[resultIndex] = {
          ...updatedResults[resultIndex],
          testCaseId: response.data.id,
          testCaseName: response.data.name
        };
        setNlpResults(updatedResults);
      }
    } catch (error) {
      console.error('Error creating test case:', error);
    } finally {
      setLoading(false);
      handleCloseMenu();
    }
  };
  
  const handleOpenMappingDialog = (id?: string) => {
    if (id) {
      // Edit existing mapping
      const mapping = mappings.find(m => m.id === id);
      if (mapping) {
        setMappingForm({
          pattern: mapping.pattern,
          stepType: mapping.stepType,
          description: mapping.description
        });
        setEditMappingId(id);
      }
    } else {
      // Create new mapping
      setMappingForm({
        pattern: '',
        stepType: '',
        description: ''
      });
      setEditMappingId(null);
    }
    setMappingDialogOpen(true);
    handleCloseMenu();
  };
  
  const handleSaveMapping = async () => {
    try {
      if (editMappingId) {
        // Update existing mapping
        await api.put(`/api/projects/${currentProject?.id}/nlp/mappings/${editMappingId}`, mappingForm);
      } else {
        // Create new mapping
        await api.post(`/api/projects/${currentProject?.id}/nlp/mappings`, mappingForm);
      }
      // Reload mappings
      await loadMappings();
      setMappingDialogOpen(false);
    } catch (error) {
      console.error('Error saving NLP mapping:', error);
    }
  };
  
  const handleDeleteMapping = async (id: string) => {
    try {
      await api.delete(`/api/projects/${currentProject?.id}/nlp/mappings/${id}`);
      loadMappings();
    } catch (error) {
      console.error('Error deleting NLP mapping:', error);
    } finally {
      handleCloseMenu();
    }
  };
  
  const getStatusChip = (status: NLPProcessResult['status']) => {
    switch (status) {
      case 'completed':
        return <Chip size="small" color="success" label="Completed" />;
      case 'failed':
        return <Chip size="small" color="error" label="Failed" />;
      case 'partial':
        return <Chip size="small" color="warning" label="Partial" />;
      default:
        return <Chip size="small" label={status} />;
    }
  };
  
  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return 'success';
    if (confidence >= 0.6) return 'primary';
    if (confidence >= 0.4) return 'warning';
    return 'error';
  };
  
  const filteredResults = nlpResults.filter(result => {
    if (showOnlyTestCases && !result.testCaseId) return false;
    
    if (!searchTerm) return true;
    const lowerSearchTerm = searchTerm.toLowerCase();
    
    return (
      result.originalText.toLowerCase().includes(lowerSearchTerm) ||
      result.testCaseName?.toLowerCase().includes(lowerSearchTerm) ||
      result.extractedSteps.some(step => step.text.toLowerCase().includes(lowerSearchTerm))
    );
  });
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h5">NLP Processing Results</Typography>
          <Box>
            <Button
              variant="outlined"
              startIcon={<RefreshIcon />}
              onClick={handleRefresh}
              sx={{ mr: 1 }}
              disabled={loading}
            >
              Refresh
            </Button>
            <Button
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={() => {/* Navigate to TextToTest component */}}
            >
              New NLP Process
            </Button>
          </Box>
        </Box>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              <TextField
                label="Search"
                variant="outlined"
                size="small"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                sx={{ mr: 2, width: 300 }}
                InputProps={{
                  startAdornment: <SearchIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />
                }}
              />
              <FormControlLabel
                control={
                  <Switch
                    checked={showOnlyTestCases}
                    onChange={(e) => setShowOnlyTestCases(e.target.checked)}
                  />
                }
                label="Show only with test cases"
              />
            </Box>
            
            {loading ? (
              <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                <CircularProgress />
              </Box>
            ) : filteredResults.length === 0 ? (
              <Alert severity="info">
                No NLP processing results found. Try creating a new NLP process or adjusting your search filters.
              </Alert>
            ) : (
              <List>
                {filteredResults.map((result) => (
                  <Card key={result.id} variant="outlined" sx={{ mb: 2 }}>
                    <CardContent sx={{ pb: 1 }}>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Box>
                          <Typography variant="h6" component="div">
                            {result.testCaseName || `NLP Process ${formatDate(result.createdAt)}`}
                          </Typography>
                          <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
                            {getStatusChip(result.status)}
                            <Typography variant="body2" color="text.secondary" sx={{ ml: 2 }}>
                              {formatDate(result.createdAt, true)}
                            </Typography>
                            {result.testCaseId && (
                              <Chip 
                                size="small" 
                                icon={<AssignmentIcon />} 
                                label="Test Case" 
                                color="info" 
                                variant="outlined"
                                sx={{ ml: 1 }}
                              />
                            )}
                          </Box>
                        </Box>
                        <Box>
                          <IconButton
                            onClick={() => handleToggleExpand(result.id)}
                            aria-expanded={expandedResultIds.includes(result.id)}
                          >
                            {expandedResultIds.includes(result.id) ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                          </IconButton>
                          <IconButton onClick={(e) => handleOpenMenu(e, result.id)}>
                            <MoreVertIcon />
                          </IconButton>
                        </Box>
                      </Box>
                      
                      <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                        {result.originalText.length > 100
                          ? `"${result.originalText.substring(0, 100)}..."`
                          : `"${result.originalText}"`}
                      </Typography>
                      
                      <Collapse in={expandedResultIds.includes(result.id)}>
                        <Box sx={{ mt: 2 }}>
                          <Typography variant="subtitle2" gutterBottom>
                            Extracted Steps ({result.extractedSteps.length})
                          </Typography>
                          
                          <List dense>
                            {result.extractedSteps.map((step, index) => (
                              <ListItem
                                key={step.id}
                                sx={{
                                  border: '1px solid',
                                  borderColor: 'divider',
                                  borderRadius: 1,
                                  mb: 1
                                }}
                                secondaryAction={
                                  step.mappingId ? (
                                    <Tooltip title="View mapping">
                                      <IconButton 
                                        edge="end" 
                                        size="small"
                                        onClick={() => handleViewMapping(step.mappingId as string)}
                                      >
                                        <CodeIcon fontSize="small" />
                                      </IconButton>
                                    </Tooltip>
                                  ) : null
                                }
                              >
                                <ListItemText
                                  primary={
                                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                      <Chip
                                        size="small"
                                        label={`#${index + 1}`}
                                        sx={{ mr: 1, minWidth: 36 }}
                                      />
                                      <Typography variant="body2">
                                        {step.text}
                                      </Typography>
                                    </Box>
                                  }
                                  secondary={
                                    <Box sx={{ mt: 0.5 }}>
                                      <Chip
                                        size="small"
                                        label={`${(step.confidence * 100).toFixed(0)}% confidence`}
                                        color={getConfidenceColor(step.confidence)}
                                        variant="outlined"
                                      />
                                      {step.mappingId && (
                                        <Chip
                                          size="small"
                                          label={step.mappingName || 'Mapped'}
                                          color="success"
                                          variant="outlined"
                                          sx={{ ml: 1 }}
                                        />
                                      )}
                                      {!step.mappingId && (
                                        <Chip
                                          size="small"
                                          label="Not mapped"
                                          color="default"
                                          variant="outlined"
                                          sx={{ ml: 1 }}
                                        />
                                      )}
                                    </Box>
                                  }
                                />
                              </ListItem>
                            ))}
                          </List>
                          
                          {result.status === 'failed' && result.errorMessage && (
                            <Alert severity="error" sx={{ mt: 2 }}>
                              {result.errorMessage}
                            </Alert>
                          )}
                          
                          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between' }}>
                            <Typography variant="body2" color="text.secondary">
                              Processing time: {formatDuration(result.processingTime)}
                            </Typography>
                            
                            {!result.testCaseId && (
                              <Button
                                variant="outlined"
                                size="small"
                                startIcon={<AssignmentIcon />}
                                onClick={() => handleCreateTestCase(result.id)}
                                disabled={result.extractedSteps.every(step => !step.mappingId)}
                              >
                                Create Test Case
                              </Button>
                            )}
                          </Box>
                        </Box>
                      </Collapse>
                    </CardContent>
                  </Card>
                ))}
              </List>
            )}
          </Grid>
          
          <Grid item xs={12} md={3}>
            <Card variant="outlined">
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6">Mappings</Typography>
                  <Button
                    variant="outlined"
                    size="small"
                    startIcon={<AddIcon />}
                    onClick={() => handleOpenMappingDialog()}
                  >
                    New
                  </Button>
                </Box>
                
                {statsLoading ? (
                  <Box sx={{ display: 'flex', justifyContent: 'center', py: 2 }}>
                    <CircularProgress size={30} />
                  </Box>
                ) : mappingStats ? (
                  <>
                    <Box sx={{ mb: 2 }}>
                      <Typography variant="body2">
                        Total Mappings: <b>{mappingStats.totalMappings}</b>
                      </Typography>
                      <Typography variant="body2">
                        Total Extractions: <b>{mappingStats.totalExtractions}</b>
                      </Typography>
                      <Typography variant="body2">
                        Unmapped Rate: <b>{(mappingStats.unmappedRate * 100).toFixed(1)}%</b>
                      </Typography>
                    </Box>
                    
                    {mappingStats.topMappings.length > 0 && (
                      <>
                        <Typography variant="subtitle2" gutterBottom>
                          Top Mappings
                        </Typography>
                        <List dense sx={{ maxHeight: 200, overflow: 'auto' }}>
                          {mappingStats.topMappings.map((mapping, index) => (
                            <ListItem
                              key={index}
                              secondaryAction={
                                <Chip
                                  size="small"
                                  label={`${mapping.count} (${(mapping.percentage * 100).toFixed(0)}%)`}
                                />
                              }
                            >
                              <ListItemText
                                primary={mapping.pattern}
                                primaryTypographyProps={{ noWrap: true }}
                              />
                            </ListItem>
                          ))}
                        </List>
                      </>
                    )}
                  </>
                ) : (
                  <Typography variant="body2" color="text.secondary">
                    No mapping statistics available.
                  </Typography>
                )}
              </CardContent>
            </Card>
            
            <Card variant="outlined" sx={{ mt: 2 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Recent Mappings
                </Typography>
                
                {mappings.length === 0 ? (
                  <Typography variant="body2" color="text.secondary">
                    No mappings found. Create your first mapping to get started.
                  </Typography>
                ) : (
                  <List dense sx={{ maxHeight: 300, overflow: 'auto' }}>
                    {mappings.slice(0, 10).map((mapping) => (
                      <ListItem
                        key={mapping.id}
                        secondaryAction={
                          <IconButton
                            edge="end"
                            size="small"
                            onClick={(e) => handleOpenMenu(e, mapping.id)}
                          >
                            <MoreVertIcon fontSize="small" />
                          </IconButton>
                        }
                      >
                        <ListItemText
                          primary={mapping.pattern}
                          secondary={mapping.stepType}
                          primaryTypographyProps={{ noWrap: true }}
                        />
                      </ListItem>
                    ))}
                  </List>
                )}
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Paper>
      
      {/* View Mapping Dialog */}
      <Dialog open={showMapping} onClose={() => setShowMapping(false)} maxWidth="md">
        <DialogTitle>Mapping Details</DialogTitle>
        <DialogContent>
          {currentMapping && (
            <Box sx={{ pt: 1 }}>
              <Grid container spacing={2}>
                <Grid item xs={12}>
                  <Typography variant="subtitle1">Pattern</Typography>
                  <Typography variant="body1" sx={{ fontFamily: 'monospace', bgcolor: 'background.default', p: 1, borderRadius: 1 }}>
                    {currentMapping.pattern}
                  </Typography>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle1">Step Type</Typography>
                  <Chip label={currentMapping.stepType} color="primary" />
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle1">Usage Count</Typography>
                  <Typography variant="body1">{currentMapping.extractionCount} extractions</Typography>
                </Grid>
                
                <Grid item xs={12}>
                  <Typography variant="subtitle1">Description</Typography>
                  <Typography variant="body1">{currentMapping.description || 'No description'}</Typography>
                </Grid>
                
                {currentMapping.parameters.length > 0 && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" gutterBottom>Parameters</Typography>
                    <TableContainer component={Paper} variant="outlined">
                      <Table size="small">
                        <TableHead>
                          <TableRow>
                            <TableCell>Name</TableCell>
                            <TableCell>Type</TableCell>
                            <TableCell>Example Value</TableCell>
                          </TableRow>
                        </TableHead>
                        <TableBody>
                          {currentMapping.parameters.map((param, index) => (
                            <TableRow key={index}>
                              <TableCell>{param.name}</TableCell>
                              <TableCell>{param.type}</TableCell>
                              <TableCell>{param.value || '-'}</TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    </TableContainer>
                  </Grid>
                )}
                
                <Grid item xs={12}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      Created: {formatDate(currentMapping.createdAt, true)}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Last Updated: {formatDate(currentMapping.updatedAt, true)}
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowMapping(false)}>Close</Button>
          <Button 
            variant="outlined" 
            startIcon={<EditIcon />}
            onClick={() => {
              setShowMapping(false);
              if (currentMapping) {
                handleOpenMappingDialog(currentMapping.id);
              }
            }}
          >
            Edit Mapping
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Add/Edit Mapping Dialog */}
      <Dialog open={mappingDialogOpen} onClose={() => setMappingDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>{editMappingId ? 'Edit Mapping' : 'New Mapping'}</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ pt: 1 }}>
            <Grid item xs={12}>
              <TextField
                label="Pattern (RegEx)"
                value={mappingForm.pattern}
                onChange={(e) => setMappingForm(prev => ({ ...prev, pattern: e.target.value }))}
                fullWidth
                required
                helperText="Use regular expression syntax, e.g., 'I click on (.+)' to match 'I click on submit button'"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                label="Step Type"
                value={mappingForm.stepType}
                onChange={(e) => setMappingForm(prev => ({ ...prev, stepType: e.target.value }))}
                fullWidth
                required
                select
              >
                <MenuItem value="click">Click</MenuItem>
                <MenuItem value="type">Type</MenuItem>
                <MenuItem value="navigation">Navigation</MenuItem>
                <MenuItem value="select">Select</MenuItem>
                <MenuItem value="assert">Assertion</MenuItem>
                <MenuItem value="wait">Wait</MenuItem>
                <MenuItem value="custom">Custom</MenuItem>
              </TextField>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                label="Description"
                value={mappingForm.description}
                onChange={(e) => setMappingForm(prev => ({ ...prev, description: e.target.value }))}
                fullWidth
                multiline
                rows={3}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setMappingDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            color="primary"
            onClick={handleSaveMapping}
            disabled={!mappingForm.pattern.trim() || !mappingForm.stepType.trim()}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Context Menu for Results */}
      <Menu
        anchorEl={menuAnchorEl}
        open={Boolean(menuAnchorEl)}
        onClose={handleCloseMenu}
      >
        {selectedItemId && nlpResults.find(r => r.id === selectedItemId) && (
          <>
            {!nlpResults.find(r => r.id === selectedItemId)?.testCaseId && (
              <MenuItem
                onClick={() => handleCreateTestCase(selectedItemId)}
                disabled={nlpResults.find(r => r.id === selectedItemId)?.extractedSteps.every(s => !s.mappingId)}
              >
                <ListItemIcon>
                  <AssignmentIcon fontSize="small" />
                </ListItemIcon>
                <ListItemText>Create Test Case</ListItemText>
              </MenuItem>
            )}
            
            <MenuItem onClick={() => handleDeleteResult(selectedItemId)}>
              <ListItemIcon>
                <DeleteIcon fontSize="small" color="error" />
              </ListItemIcon>
              <ListItemText>Delete</ListItemText>
            </MenuItem>
          </>
        )}
        
        {selectedItemId && mappings.find(m => m.id === selectedItemId) && (
          <>
            <MenuItem onClick={() => handleOpenMappingDialog(selectedItemId)}>
              <ListItemIcon>
                <EditIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText>Edit Mapping</ListItemText>
            </MenuItem>
            
            <MenuItem onClick={() => handleDeleteMapping(selectedItemId)}>
              <ListItemIcon>
                <DeleteIcon fontSize="small" color="error" />
              </ListItemIcon>
              <ListItemText>Delete Mapping</ListItemText>
            </MenuItem>
          </>
        )}
      </Menu>
    </Box>
  );
};

export default NLPResults;


// src/components/recorder/DataInputPanel.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  TextField,
  Button,
  Divider,
  Grid,
  Paper,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Tooltip,
  Switch,
  FormControlLabel,
  Tab,
  Tabs,
  Menu,
  ListItemIcon
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Refresh as RefreshIcon,
  Save as SaveIcon,
  FileCopy as CopyIcon,
  MoreVert as MoreVertIcon,
  FormatListBulleted as ListIcon,
  Functions as FunctionsIcon,
  Code as CodeIcon,
  Storage as StorageIcon,
  Check as CheckIcon,
  PlayArrow as PlayIcon,
  Timeline as TimelineIcon,
  DataArray as DataArrayIcon
} from '@mui/icons-material';
import { useApi } from '../../contexts/ApiContext';
import { useProjects } from '../../contexts/ProjectContext';

// Define types for data input
interface DataVariable {
  id: string;
  name: string;
  type: 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';
  value: string;
  description?: string;
  source?: 'manual' | 'csv' | 'json' | 'api' | 'function';
  sourceDetails?: Record<string, any>;
}

interface DataSet {
  id: string;
  name: string;
  description?: string;
  variables: DataVariable[];
  createdAt: Date;
  updatedAt: Date;
}

interface DataFunction {
  id: string;
  name: string;
  description?: string;
  code: string;
  inputParams: { name: string; type: string }[];
  outputType: string;
}

const DataInputPanel: React.FC<{
  onSelectVariable?: (variable: DataVariable) => void;
  onImportDataSet?: (dataSet: DataSet) => void;
}> = ({ onSelectVariable, onImportDataSet }) => {
  const { api } = useApi();
  const { currentProject } = useProjects();
  
  // Tab state
  const [tabValue, setTabValue] = useState(0);
  
  // Data state
  const [dataSets, setDataSets] = useState<DataSet[]>([]);
  const [selectedDataSet, setSelectedDataSet] = useState<DataSet | null>(null);
  const [dataFunctions, setDataFunctions] = useState<DataFunction[]>([]);
  
  // UI state
  const [isLoading, setIsLoading] = useState(false);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [functionDialogOpen, setFunctionDialogOpen] = useState(false);
  const [currentVariable, setCurrentVariable] = useState<DataVariable | null>(null);
  const [variableDialogOpen, setVariableDialogOpen] = useState(false);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const [selectedItemId, setSelectedItemId] = useState<string | null>(null);
  
  // Form state
  const [dataSetForm, setDataSetForm] = useState({
    name: '',
    description: ''
  });
  
  const [variableForm, setVariableForm] = useState<DataVariable>({
    id: '',
    name: '',
    type: 'string',
    value: '',
    description: '',
    source: 'manual'
  });
  
  const [functionForm, setFunctionForm] = useState<DataFunction>({
    id: '',
    name: '',
    description: '',
    code: 'function generate() {\n  // Return the generated data\n  return "";\n}',
    inputParams: [],
    outputType: 'string'
  });
  
  // Import state
  const [importType, setImportType] = useState<'csv' | 'json' | 'excel'>('csv');
  const [importFile, setImportFile] = useState<File | null>(null);
  const [importOptions, setImportOptions] = useState({
    hasHeader: true,
    delimiter: ',',
    sheet: 'Sheet1',
    firstRowAsKeys: true
  });
  
  // Load data on component mount
  useEffect(() => {
    if (currentProject?.id) {
      loadDataSets();
      loadDataFunctions();
    }
  }, [currentProject]);
  
  const loadDataSets = async () => {
    setIsLoading(true);
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/data/sets`);
      setDataSets(response.data);
      
      if (response.data.length > 0 && !selectedDataSet) {
        setSelectedDataSet(response.data[0]);
      }
    } catch (error) {
      console.error('Error loading data sets:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  const loadDataFunctions = async () => {
    try {
      const response = await api.get(`/api/projects/${currentProject?.id}/data/functions`);
      setDataFunctions(response.data);
    } catch (error) {
      console.error('Error loading data functions:', error);
    }
  };
  
  const handleCreateDataSet = async () => {
    if (!dataSetForm.name.trim()) return;
    
    try {
      const response = await api.post(`/api/projects/${currentProject?.id}/data/sets`, {
        name: dataSetForm.name,
        description: dataSetForm.description,
        variables: []
      });
      
      await loadDataSets();
      setSelectedDataSet(response.data);
      setCreateDialogOpen(false);
      setDataSetForm({ name: '', description: '' });
    } catch (error) {
      console.error('Error creating data set:', error);
    }
  };
  
  const handleDeleteDataSet = async (id: string) => {
    try {
      await api.delete(`/api/projects/${currentProject?.id}/data/sets/${id}`);
      
      if (selectedDataSet?.id === id) {
        setSelectedDataSet(null);
      }
      
      await loadDataSets();
      handleCloseMenu();
    } catch (error) {
      console.error('Error deleting data set:', error);
    }
  };
  
  const handleSaveVariable = async () => {
    if (!selectedDataSet?.id || !variableForm.name.trim()) return;
    
    try {
      let updatedDataSet;
      
      if (variableForm.id) {
        // Update existing variable
        const variables = selectedDataSet.variables.map(v => 
          v.id === variableForm.id ? variableForm : v
        );
        
        updatedDataSet = {
          ...selectedDataSet,
          variables
        };
      } else {
        // Create new variable
        const newVariable = {
          ...variableForm,
          id: `var-${Date.now()}`
        };
        
        updatedDataSet = {
          ...selectedDataSet,
          variables: [...selectedDataSet.variables, newVariable]
        };
      }
      
      await api.put(`/api/projects/${currentProject?.id}/data/sets/${selectedDataSet.id}`, updatedDataSet);
      
      setSelectedDataSet(updatedDataSet);
      setVariableDialogOpen(false);
      setVariableForm({
        id: '',
        name: '',
        type: 'string',
        value: '',
        description: '',
        source: 'manual'
      });
    } catch (error) {
      console.error('Error saving variable:', error);
    }
  };
  
  const handleDeleteVariable = async (variableId: string) => {
    if (!selectedDataSet?.id) return;
    
    try {
      const updatedVariables = selectedDataSet.variables.filter(v => v.id !== variableId);
      
      const updatedDataSet = {
        ...selectedDataSet,
        variables: updatedVariables
      };
      
      await api.put(`/api/projects/${currentProject?.id}/data/sets/${selectedDataSet.id}`, updatedDataSet);
      
      setSelectedDataSet(updatedDataSet);
      handleCloseMenu();
    } catch (error) {
      console.error('Error deleting variable:', error);
    }
  };
  
  const handleSaveFunction = async () => {
    if (!functionForm.name.trim() || !functionForm.code.trim()) return;
    
    try {
      let response;
      
      if (functionForm.id) {
        // Update existing function
        response = await api.put(
          `/api/projects/${currentProject?.id}/data/functions/${functionForm.id}`, 
          functionForm
        );
      } else {
        // Create new function
        response = await api.post(
          `/api/projects/${currentProject?.id}/data/functions`, 
          functionForm
        );
      }
      
      await loadDataFunctions();
      setFunctionDialogOpen(false);
      setFunctionForm({
        id: '',
        name: '',
        description: '',
        code: 'function generate() {\n  // Return the generated data\n  return "";\n}',
        inputParams: [],
        outputType: 'string'
      });
    } catch (error) {
      console.error('Error saving data function:', error);
    }
  };
  
  const handleDeleteFunction = async (id: string) => {
    try {
      await api.delete(`/api/projects/${currentProject?.id}/data/functions/${id}`);
      await loadDataFunctions();
      handleCloseMenu();
    } catch (error) {
      console.error('Error deleting data function:', error);
    }
  };
  
  const handleImportData = async () => {
    if (!importFile) return;
    
    const formData = new FormData();
    formData.append('file', importFile);
    formData.append('type', importType);
    formData.append('options', JSON.stringify(importOptions));
    
    try {
      const response = await api.post(
        `/api/projects/${currentProject?.id}/data/import`, 
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        }
      );
      
      await loadDataSets();
      
      if (response.data.dataSet && onImportDataSet) {
        onImportDataSet(response.data.dataSet);
      }
      
      setImportDialogOpen(false);
      setImportFile(null);
    } catch (error) {
      console.error('Error importing data:', error);
    }
  };
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setImportFile(e.target.files[0]);
    }
  };
  
  const handleOpenVariableDialog = (variable?: DataVariable) => {
    if (variable) {
      // Edit existing variable
      setVariableForm({ ...variable });
      setCurrentVariable(variable);
    } else {
      // Create new variable
      setVariableForm({
        id: '',
        name: '',
        type: 'string',
        value: '',
        description: '',
        source: 'manual'
      });
      setCurrentVariable(null);
    }
    setVariableDialogOpen(true);
  };
  
  const handleOpenFunctionDialog = (func?: DataFunction) => {
    if (func) {
      // Edit existing function
      setFunctionForm({ ...func });
    } else {
      // Create new function
      setFunctionForm({
        id: '',
        name: '',
        description: '',
        code: 'function generate() {\n  // Return the generated data\n  return "";\n}',
        inputParams: [],
        outputType: 'string'
      });
    }
    setFunctionDialogOpen(true);
  };
  
  const handleOpenMenu = (event: React.MouseEvent<HTMLElement>, id: string) => {
    setMenuAnchorEl(event.currentTarget);
    setSelectedItemId(id);
  };
  
  const handleCloseMenu = () => {
    setMenuAnchorEl(null);
    setSelectedItemId(null);
  };
  
  const handleSelectVariable = (variable: DataVariable) => {
    if (onSelectVariable) {
      onSelectVariable(variable);
    }
  };
  
  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  const getTypeIcon = (type: DataVariable['type']) => {
    switch (type) {
      case 'string':
        return 'Aa';
      case 'number':
        return '123';
      case 'boolean':
        return 'T/F';
      case 'date':
        return '📅';
      case 'array':
        return '[...]';
      case 'object':
        return '{...}';
      default:
        return 'Aa';
    }
  };
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper sx={{ p: 2 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6">Test Data</Typography>
          <Box>
            <Button
              variant="outlined"
              size="small"
              startIcon={<RefreshIcon />}
              onClick={loadDataSets}
              sx={{ mr: 1 }}
            >
              Refresh
            </Button>
            <Button
              variant="contained"
              size="small"
              startIcon={<DataArrayIcon />}
              onClick={() => setImportDialogOpen(true)}
              sx={{ mr: 1 }}
            >
              Import
            </Button>
            <Button
              variant="contained"
              size="small"
              startIcon={<AddIcon />}
              onClick={() => setCreateDialogOpen(true)}
            >
              New Set
            </Button>
          </Box>
        </Box>
        
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange} aria-label="data tabs">
            <Tab label="Data Variables" icon={<StorageIcon />} iconPosition="start" />
            <Tab label="Data Functions" icon={<FunctionsIcon />} iconPosition="start" />
          </Tabs>
        </Box>
        
        {tabValue === 0 && (
          <Box sx={{ mt: 2 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={4}>
                <Typography variant="subtitle2" gutterBottom>
                  Data Sets
                </Typography>
                <Paper variant="outlined" sx={{ height: 300, overflow: 'auto' }}>
                  <List dense>
                    {dataSets.length === 0 ? (
                      <ListItem>
                        <ListItemText 
                          primary="No data sets available"
                          secondary="Create a new data set to get started"
                        />
                      </ListItem>
                    ) : (
                      dataSets.map(dataSet => (
                        <ListItem
                          key={dataSet.id}
                          button
                          selected={selectedDataSet?.id === dataSet.id}
                          onClick={() => setSelectedDataSet(dataSet)}
                        >
                          <ListItemIcon>
                            <StorageIcon />
                          </ListItemIcon>
                          <ListItemText
                            primary={dataSet.name}
                            secondary={`${dataSet.variables.length} variables`}
                          />
                          <ListItemSecondaryAction>
                            <IconButton 
                              edge="end" 
                              size="small"
                              onClick={(e) => handleOpenMenu(e, dataSet.id)}
                            >
                              <MoreVertIcon />
                            </IconButton>
                          </ListItemSecondaryAction>
                        </ListItem>
                      ))
                    )}
                  </List>
                </Paper>
              </Grid>
              
              <Grid item xs={12} md={8}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="subtitle2">
                    {selectedDataSet ? `Variables in "${selectedDataSet.name}"` : 'Variables'}
                  </Typography>
                  {selectedDataSet && (
                    <Button
                      variant="outlined"
                      size="small"
                      startIcon={<AddIcon />}
                      onClick={() => handleOpenVariableDialog()}
                    >
                      Add Variable
                    </Button>
                  )}
                </Box>
                
                <Paper variant="outlined" sx={{ height: 300, overflow: 'auto' }}>
                  {!selectedDataSet ? (
                    <Box sx={{ p: 2, textAlign: 'center' }}>
                      <Typography variant="body2" color="textSecondary">
                        Select a data set to view variables
                      </Typography>
                    </Box>
                  ) : selectedDataSet.variables.length === 0 ? (
                    <Box sx={{ p: 2, textAlign: 'center' }}>
                      <Typography variant="body2" color="textSecondary">
                        No variables in this data set
                      </Typography>
                    </Box>
                  ) : (
                    <List dense>
                      {selectedDataSet.variables.map(variable => (
                        <ListItem
                          key={variable.id}
                          button
                          onClick={() => handleSelectVariable(variable)}
                        >
                          <ListItemIcon>
                            <Chip 
                              label={getTypeIcon(variable.type)} 
                              size="small" 
                              variant="outlined"
                            />
                          </ListItemIcon>
                          <ListItemText
                            primary={
                              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <Typography variant="body2" component="span">
                                  {variable.name}
                                </Typography>
                                {variable.source && variable.source !== 'manual' && (
                                  <Chip
                                    label={variable.source}
                                    size="small"
                                    variant="outlined"
                                    sx={{ ml: 1, height: 20 }}
                                  />
                                )}
                              </Box>
                            }
                            secondary={
                              <Typography
                                variant="body2"
                                color="textSecondary"
                                sx={{
                                  whiteSpace: 'nowrap',
                                  overflow: 'hidden',
                                  textOverflow: 'ellipsis',
                                  maxWidth: '100%'
                                }}
                              >
                                {variable.value}
                              </Typography>
                            }
                          />
                          <ListItemSecondaryAction>
                            <IconButton 
                              edge="end" 
                              size="small"
                              onClick={(e) => handleOpenMenu(e, variable.id)}
                            >
                              <MoreVertIcon />
                            </IconButton>
                          </ListItemSecondaryAction>
                        </ListItem>
                      ))}
                    </List>
                  )}
                </Paper>
              </Grid>
            </Grid>
          </Box>
        )}
        
        {tabValue === 1 && (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
              <Typography variant="subtitle2">
                Data Generation Functions
              </Typography>
              <Button
                variant="outlined"
                size="small"
                startIcon={<AddIcon />}
                onClick={() => handleOpenFunctionDialog()}
              >
                Add Function
              </Button>
            </Box>
            
            <Paper variant="outlined" sx={{ height: 300, overflow: 'auto' }}>
              {dataFunctions.length === 0 ? (
                <Box sx={{ p: 2, textAlign: 'center' }}>
                  <Typography variant="body2" color="textSecondary">
                    No data functions available. Create a new function to get started.
                  </Typography>
                </Box>
              ) : (
                <List dense>
                  {dataFunctions.map(func => (
                    <ListItem key={func.id}>
                      <ListItemIcon>
                        <FunctionsIcon />
                      </ListItemIcon>
                      <ListItemText
                        primary={func.name}
                        secondary={func.description || 'No description'}
                      />
                      <ListItemSecondaryAction>
                        <IconButton 
                          edge="end" 
                          size="small"
                          onClick={() => handleOpenFunctionDialog(func)}
                          sx={{ mr: 1 }}
                        >
                          <EditIcon />
                        </IconButton>
                        <IconButton 
                          edge="end" 
                          size="small"
                          onClick={(e) => handleOpenMenu(e, func.id)}
                        >
                          <MoreVertIcon />
                        </IconButton>
                      </ListItemSecondaryAction>
                    </ListItem>
                  ))}
                </List>
              )}
            </Paper>
          </Box>
        )}
      </Paper>
      
      {/* Create Data Set Dialog */}
      <Dialog open={createDialogOpen} onClose={() => setCreateDialogOpen(false)}>
        <DialogTitle>Create Data Set</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12}>
              <TextField
                label="Name"
                fullWidth
                value={dataSetForm.name}
                onChange={(e) => setDataSetForm(prev => ({ ...prev, name: e.target.value }))}
                required
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Description"
                fullWidth
                multiline
                rows={3}
                value={dataSetForm.description}
                onChange={(e) => setDataSetForm(prev => ({ ...prev, description: e.target.value }))}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            color="primary"
            onClick={handleCreateDataSet}
            disabled={!dataSetForm.name.trim()}
          >
            Create
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Variable Dialog */}
      <Dialog 
        open={variableDialogOpen} 
        onClose={() => setVariableDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {variableForm.id ? `Edit Variable: ${variableForm.name}` : 'Add Variable'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Name"
                fullWidth
                value={variableForm.name}
                onChange={(e) => setVariableForm(prev => ({ ...prev, name: e.target.value }))}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Type</InputLabel>
                <Select
                  value={variableForm.type}
                  onChange={(e) => setVariableForm(prev => ({ ...prev, type: e.target.value as any }))}
                  label="Type"
                >
                  <MenuItem value="string">String</MenuItem>
                  <MenuItem value="number">Number</MenuItem>
                  <MenuItem value="boolean">Boolean</MenuItem>
                  <MenuItem value="date">Date</MenuItem>
                  <MenuItem value="array">Array</MenuItem>
                  <MenuItem value="object">Object</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Source</InputLabel>
                <Select
                  value={variableForm.source}
                  onChange={(e) => setVariableForm(prev => ({ ...prev, source: e.target.value as any }))}
                  label="Source"
                >
                  <MenuItem value="manual">Manual Entry</MenuItem>
                  <MenuItem value="csv">CSV File</MenuItem>
                  <MenuItem value="json">JSON File</MenuItem>
                  <MenuItem value="api">API Response</MenuItem>
                  <MenuItem value="function">Generation Function</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                label="Value"
                fullWidth
                multiline
                rows={3}
                value={variableForm.value}
                onChange={(e) => setVariableForm(prev => ({ ...prev, value: e.target.value }))}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                label="Description"
                fullWidth
                value={variableForm.description || ''}
                onChange={(e) => setVariableForm(prev => ({ ...prev, description: e.target.value }))}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setVariableDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            color="primary"
            onClick={handleSaveVariable}
            disabled={!variableForm.name.trim() || !variableForm.value.trim()}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Function Dialog */}
      <Dialog 
        open={functionDialogOpen} 
        onClose={() => setFunctionDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {functionForm.id ? `Edit Function: ${functionForm.name}` : 'Add Function'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Name"
                fullWidth
                value={functionForm.name}
                onChange={(e) => setFunctionForm(prev => ({ ...prev, name: e.target.value }))}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Output Type</InputLabel>
                <Select
                  value={functionForm.outputType}
                  onChange={(e) => setFunctionForm(prev => ({ ...prev, outputType: e.target.value }))}
                  label="Output Type"
                >
                  <MenuItem value="string">String</MenuItem>
                  <MenuItem value="number">Number</MenuItem>
                  <MenuItem value="boolean">Boolean</MenuItem>
                  <MenuItem value="date">Date</MenuItem>
                  <MenuItem value="array">Array</MenuItem>
                  <MenuItem value="object">Object</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                label="Description"
                fullWidth
                value={functionForm.description || ''}
                onChange={(e) => setFunctionForm(prev => ({ ...prev, description: e.target.value }))}
              />
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" gutterBottom>
                Function Code
              </Typography>
              <TextField
                fullWidth
                multiline
                rows={10}
                value={functionForm.code}
                onChange={(e) => setFunctionForm(prev => ({ ...prev, code: e.target.value }))}
                required
                variant="outlined"
                InputProps={{
                  style: { fontFamily: 'monospace' }
                }}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setFunctionDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            color="primary"
            onClick={handleSaveFunction}
            disabled={!functionForm.name.trim() || !functionForm.code.trim()}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Import Dialog */}
      <Dialog 
        open={importDialogOpen} 
        onClose={() => setImportDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Import Data</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Import Type</InputLabel>
                <Select
                  value={importType}
                  onChange={(e) => setImportType(e.target.value as any)}
                  label="Import Type"
                >
                  <MenuItem value="csv">CSV File</MenuItem>
                  <MenuItem value="json">JSON File</MenuItem>
                  <MenuItem value="excel">Excel File</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <Button
                variant="outlined"
                component="label"
                fullWidth
                startIcon={<StorageIcon />}
              >
                {importFile ? importFile.name : 'Select File'}
                <input
                  type="file"
                  hidden
                  accept={
                    importType === 'csv' 
                      ? '.csv' 
                      : importType === 'json' 
                      ? '.json' 
                      : '.xlsx,.xls'
                  }
                  onChange={handleFileChange}
                />
              </Button>
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" gutterBottom>
                Import Options
              </Typography>
              <Paper variant="outlined" sx={{ p: 2 }}>
                {importType === 'csv' && (
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={importOptions.hasHeader}
                            onChange={(e) => setImportOptions(prev => ({ 
                              ...prev, 
                              hasHeader: e.target.checked 
                            }))}
                          />
                        }
                        label="First row as header"
                      />
                    </Grid>
                    <Grid item xs={12} sm={6}>
                      <TextField
                        label="Delimiter"
                        value={importOptions.delimiter}
                        onChange={(e) => setImportOptions(prev => ({ 
                          ...prev, 
                          delimiter: e.target.value 
                        }))}
                        size="small"
                      />
                    </Grid>
                  </Grid>
                )}
                
                {importType === 'excel' && (
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <TextField
                        label="Sheet Name"
                        value={importOptions.sheet}
                        onChange={(e) => setImportOptions(prev => ({ 
                          ...prev, 
                          sheet: e.target.value 
                        }))}
                        size="small"
                      />
                    </Grid>
                    <Grid item xs={12} sm={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            checked={importOptions.firstRowAsKeys}
                            onChange={(e) => setImportOptions(prev => ({ 
                              ...prev, 
                              firstRowAsKeys: e.target.checked 
                            }))}
                          />
                        }
                        label="First row as keys"
                      />
                    </Grid>
                  </Grid>
                )}
              </Paper>
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setImportDialogOpen(false)}>Cancel</Button>
          <Button
            variant="contained"
            color="primary"
            onClick={handleImportData}
            disabled={!importFile}
          >
            Import
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Context Menu */}
      <Menu
        anchorEl={menuAnchorEl}
        open={Boolean(menuAnchorEl)}
        onClose={handleCloseMenu}
      >
        {selectedItemId && dataSets.find(ds => ds.id === selectedItemId) && (
          <MenuItem onClick={() => handleDeleteDataSet(selectedItemId)}>
            <ListItemIcon>
              <DeleteIcon fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText>Delete Data Set</ListItemText>
          </MenuItem>
        )}
        
        {selectedItemId && selectedDataSet?.variables.find(v => v.id === selectedItemId) && (
          <>
            <MenuItem 
              onClick={() => {
                const variable = selectedDataSet.variables.find(v => v.id === selectedItemId);
                if (variable) {
                  handleOpenVariableDialog(variable);
                }
                handleCloseMenu();
              }}
            >
              <ListItemIcon>
                <EditIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText>Edit Variable</ListItemText>
            </MenuItem>
            
            <MenuItem onClick={() => handleDeleteVariable(selectedItemId)}>
              <ListItemIcon>
                <DeleteIcon fontSize="small" color="error" />
              </ListItemIcon>
              <ListItemText>Delete Variable</ListItemText>
            </MenuItem>
          </>
        )}
        
        {selectedItemId && dataFunctions.find(f => f.id === selectedItemId) && (
          <MenuItem onClick={() => handleDeleteFunction(selectedItemId)}>
            <ListItemIcon>
              <DeleteIcon fontSize="small" color="error" />
            </ListItemIcon>
            <ListItemText>Delete Function</ListItemText>
          </MenuItem>
        )}
      </Menu>
    </Box>
  );
};

export default DataInputPanel;



