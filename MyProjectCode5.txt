// src/pages/TestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  Grid,
  CircularProgress,
  Stepper,
  Step,
  StepLabel,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Switch,
  Card,
  CardContent,
  CardActions,
  Divider,
  IconButton,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Alert,
  Breadcrumbs,
  Link,
  Snackbar,
  Tabs,
  Tab
} from '@mui/material';
import {
  PlayArrow as StartIcon,
  Stop as StopIcon,
  Pause as PauseIcon,
  FiberManualRecord as RecordIcon,
  Save as SaveIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Close as CancelIcon,
  Refresh as RefreshIcon,
  Code as CodeIcon,
  Visibility as PreviewIcon,
  NavigateNext as NextIcon,
  NavigateBefore as PrevIcon
} from '@mui/icons-material';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';

// Tab Panel Component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`recorder-tabpanel-${index}`}
      aria-labelledby={`recorder-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
}

const TestRecorder = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { currentProject, createTestCase } = useProject();
  const { get, post } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  // References
  const iframeRef = useRef(null);
  
  // Tab state
  const [tabValue, setTabValue] = useState(0);
  
  // Stepper state
  const [activeStep, setActiveStep] = useState(0);
  const steps = ['Configure', 'Record', 'Edit & Save'];
  
  // Recording state
  const [isRecording, setIsRecording] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [recordingSessionId, setRecordingSessionId] = useState(null);
  const [recordedActions, setRecordedActions] = useState([]);
  const [recordingUrl, setRecordingUrl] = useState('');
  const [loadingRecordingStatus, setLoadingRecordingStatus] = useState(false);
  
  // Configuration state
  const [recorderConfig, setRecorderConfig] = useState({
    baseUrl: '',
    browserType: 'CHROME',
    viewportWidth: 1280,
    viewportHeight: 720,
    headless: false,
    ignoreNavigation: false,
    smartSelector: true,
    recordScreenshots: false,
    recordConsoleLog: true,
    includeAssertions: true
  });
  
  // Test case generation state
  const [testCaseConfig, setTestCaseConfig] = useState({
    name: '',
    description: '',
    tags: [],
    optimizeSteps: true,
    includeComments: true,
    screenshotOnError: true,
    selfHealing: true
  });
  
  // Dialog states
  const [stopDialogOpen, setStopDialogOpen] = useState(false);
  const [discardDialogOpen, setDiscardDialogOpen] = useState(false);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Handle form field changes for recorder config
  const handleConfigChange = (e) => {
    const { name, value, checked, type } = e.target;
    setRecorderConfig(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Handle form field changes for test case config
  const handleTestCaseConfigChange = (e) => {
    const { name, value, checked, type } = e.target;
    setTestCaseConfig(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Start recording session
  const handleStartRecording = async () => {
    if (!recorderConfig.baseUrl) {
      enqueueSnackbar('Please enter a URL to record', { variant: 'error' });
      return;
    }
    
    try {
      setLoadingRecordingStatus(true);
      
      const response = await post(`/projects/${projectId}/recorder/start`, {
        ...recorderConfig
      });
      
      setRecordingSessionId(response.data.id);
      setIsRecording(true);
      setIsPaused(false);
      setRecordingUrl(recorderConfig.baseUrl);
      setActiveStep(1);
      
      enqueueSnackbar('Recording started successfully', { variant: 'success' });
      
      // Set default test case name based on URL
      try {
        const url = new URL(recorderConfig.baseUrl);
        setTestCaseConfig(prev => ({
          ...prev,
          name: `Test for ${url.hostname}`
        }));
      } catch (e) {
        // Invalid URL format, use as is
        setTestCaseConfig(prev => ({
          ...prev,
          name: `Test for ${recorderConfig.baseUrl}`
        }));
      }
      
      // Start polling for recorded actions
      startPollingForActions();
    } catch (error) {
      console.error('Error starting recording:', error);
      enqueueSnackbar('Failed to start recording', { variant: 'error' });
    } finally {
      setLoadingRecordingStatus(false);
    }
  };
  
  // Pause recording
  const handlePauseRecording = async () => {
    if (!recordingSessionId) return;
    
    try {
      setLoadingRecordingStatus(true);
      
      await post(`/projects/${projectId}/recorder/${recordingSessionId}/pause`);
      
      setIsPaused(true);
      enqueueSnackbar('Recording paused', { variant: 'info' });
    } catch (error) {
      console.error('Error pausing recording:', error);
      enqueueSnackbar('Failed to pause recording', { variant: 'error' });
    } finally {
      setLoadingRecordingStatus(false);
    }
  };
  
  // Resume recording
  const handleResumeRecording = async () => {
    if (!recordingSessionId) return;
    
    try {
      setLoadingRecordingStatus(true);
      
      await post(`/projects/${projectId}/recorder/${recordingSessionId}/resume`);
      
      setIsPaused(false);
      enqueueSnackbar('Recording resumed', { variant: 'info' });
    } catch (error) {
      console.error('Error resuming recording:', error);
      enqueueSnackbar('Failed to resume recording', { variant: 'error' });
    } finally {
      setLoadingRecordingStatus(false);
    }
  };
  
  // Show stop recording confirmation dialog
  const handleShowStopDialog = () => {
    setStopDialogOpen(true);
  };
  
  // Stop recording
  const handleStopRecording = async () => {
    if (!recordingSessionId) return;
    
    setStopDialogOpen(false);
    
    try {
      setLoadingRecordingStatus(true);
      
      const response = await post(`/projects/${projectId}/recorder/${recordingSessionId}/stop`);
      
      setIsRecording(false);
      setIsPaused(false);
      setRecordedActions(response.data.actions || []);
      setActiveStep(2);
      
      enqueueSnackbar('Recording completed successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error stopping recording:', error);
      enqueueSnackbar('Failed to stop recording', { variant: 'error' });
    } finally {
      setLoadingRecordingStatus(false);
    }
  };
  
  // Discard recording
  const handleDiscardRecording = () => {
    setDiscardDialogOpen(true);
  };
  
  // Confirm discard recording
  const handleConfirmDiscard = () => {
    setDiscardDialogOpen(false);
    setIsRecording(false);
    setIsPaused(false);
    setRecordingSessionId(null);
    setRecordedActions([]);
    setActiveStep(0);
    enqueueSnackbar('Recording discarded', { variant: 'info' });
  };
  
  // Poll for recorded actions
  const startPollingForActions = () => {
    if (!recordingSessionId) return;
    
    const pollInterval = setInterval(async () => {
      if (!recordingSessionId || !isRecording) {
        clearInterval(pollInterval);
        return;
      }
      
      try {
        const response = await get(`/projects/${projectId}/recorder/${recordingSessionId}/actions`);
        setRecordedActions(response.data || []);
      } catch (error) {
        console.error('Error polling for actions:', error);
        // Don't show error notification for polling
      }
    }, 2000); // Poll every 2 seconds
    
    // Clean up interval on component unmount
    return () => clearInterval(pollInterval);
  };
  
  // Handle edit action
  const handleEditAction = (index, updatedAction) => {
    const newActions = [...recordedActions];
    newActions[index] = {
      ...newActions[index],
      ...updatedAction
    };
    setRecordedActions(newActions);
  };
  
  // Handle delete action
  const handleDeleteAction = (index) => {
    const newActions = [...recordedActions];
    newActions.splice(index, 1);
    setRecordedActions(newActions);
  };
  
  // Generate test case from recorded actions
  const handleGenerateTestCase = async () => {
    if (!testCaseConfig.name.trim()) {
      enqueueSnackbar('Test case name is required', { variant: 'error' });
      return;
    }
    
    if (recordedActions.length === 0) {
      enqueueSnackbar('No actions recorded. Cannot generate test case.', { variant: 'error' });
      return;
    }
    
    try {
      setLoadingRecordingStatus(true);
      
      const response = await post(`/projects/${projectId}/recorder/${recordingSessionId}/generate-test`, {
        ...testCaseConfig
      });
      
      const testCase = response.data;
      
      enqueueSnackbar('Test case generated successfully', { variant: 'success' });
      
      // Navigate to the generated test case
      navigate(`/projects/${projectId}/test-cases/${testCase.id}`);
    } catch (error) {
      console.error('Error generating test case:', error);
      enqueueSnackbar('Failed to generate test case', { variant: 'error' });
    } finally {
      setLoadingRecordingStatus(false);
    }
  };
  
  // Handle next step
  const handleNext = () => {
    if (activeStep === 0) {
      handleStartRecording();
    } else if (activeStep === 1) {
      handleShowStopDialog();
    } else if (activeStep === 2) {
      handleGenerateTestCase();
    }
  };
  
  // Handle back step
  const handleBack = () => {
    if (activeStep === 0) {
      navigate(`/projects/${projectId}/test-cases`);
    } else if (activeStep === 1) {
      handleDiscardRecording();
    } else if (activeStep === 2) {
      setActiveStep(1);
      setIsRecording(true);
      handleResumeRecording();
    }
  };
  
  // Clean up when component unmounts
  useEffect(() => {
    return () => {
      // If there's an active recording session, stop it when leaving the page
      if (recordingSessionId && isRecording) {
        post(`/projects/${projectId}/recorder/${recordingSessionId}/stop`)
          .catch(error => console.error('Error stopping recording on unmount:', error));
      }
    };
  }, [recordingSessionId, isRecording, projectId, post]);
  
  // Recorded action item component
  const RecordedActionItem = ({ action, index, onEdit, onDelete }) => {
    return (
      <Card sx={{ mb: 2 }}>
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
            <Typography variant="subtitle1">
              {index + 1}. {action.action}: {action.target || action.selector || action.value || ''}
            </Typography>
            <Box>
              <Tooltip title="Edit">
                <IconButton onClick={() => onEdit(index, action)}>
                  <EditIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Delete">
                <IconButton onClick={() => onDelete(index)}>
                  <DeleteIcon />
                </IconButton>
              </Tooltip>
            </Box>
          </Box>
          
          {action.selector && (
            <Typography variant="body2" color="textSecondary" sx={{ fontFamily: 'monospace', mb: 1 }}>
              Selector: {action.selector}
            </Typography>
          )}
          
          {action.value && (
            <Typography variant="body2" color="textSecondary">
              Value: {action.value}
            </Typography>
          )}
        </CardContent>
      </Card>
    );
  };
  
  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <Link underline="hover" color="inherit" href="/">
          Dashboard
        </Link>
        <Link
          underline="hover"
          color="inherit"
          href={`/projects/${projectId}`}
        >
          {currentProject?.name}
        </Link>
        <Typography color="text.primary">Test Recorder</Typography>
      </Breadcrumbs>
      
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" component="h1">
          Test Recorder
        </Typography>
        <Box>
          {isRecording && (
            <>
              {isPaused ? (
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<RecordIcon />}
                  onClick={handleResumeRecording}
                  disabled={loadingRecordingStatus}
                  sx={{ mr: 1 }}
                >
                  Resume
                </Button>
              ) : (
                <Button
                  variant="outlined"
                  color="primary"
                  startIcon={<PauseIcon />}
                  onClick={handlePauseRecording}
                  disabled={loadingRecordingStatus}
                  sx={{ mr: 1 }}
                >
                  Pause
                </Button>
              )}
              <Button
                variant="contained"
                color="error"
                startIcon={<StopIcon />}
                onClick={handleShowStopDialog}
                disabled={loadingRecordingStatus}
              >
                Stop Recording
              </Button>
            </>
          )}
        </Box>
      </Box>
      
      {/* Stepper */}
      <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
        {steps.map((label) => (
          <Step key={label}>
            <StepLabel>{label}</StepLabel>
          </Step>
        ))}
      </Stepper>
      
      {/* Main Content */}
      <Paper sx={{ p: 3 }}>
        {activeStep === 0 && (
          <Box>
            <Typography variant="h6" gutterBottom>
              Configure Recording
            </Typography>
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <TextField
                  name="baseUrl"
                  label="URL to Record"
                  value={recorderConfig.baseUrl}
                  onChange={handleConfigChange}
                  fullWidth
                  required
                  placeholder="https://example.com"
                  error={!recorderConfig.baseUrl}
                  helperText={!recorderConfig.baseUrl ? 'URL is required' : ''}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <InputLabel id="browser-type-label">Browser</InputLabel>
                  <Select
                    labelId="browser-type-label"
                    name="browserType"
                    value={recorderConfig.browserType}
                    onChange={handleConfigChange}
                    label="Browser"
                  >
                    <MenuItem value="CHROME">Chrome</MenuItem>
                    <MenuItem value="FIREFOX">Firefox</MenuItem>
                    <MenuItem value="EDGE">Edge</MenuItem>
                    <MenuItem value="SAFARI">Safari</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControlLabel
                  control={
                    <Switch
                      name="headless"
                      checked={recorderConfig.headless}
                      onChange={handleConfigChange}
                    />
                  }
                  label="Run in Headless Mode"
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <TextField
                  name="viewportWidth"
                  label="Viewport Width"
                  type="number"
                  value={recorderConfig.viewportWidth}
                  onChange={handleConfigChange}
                  fullWidth
                  inputProps={{ min: 0 }}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <TextField
                  name="viewportHeight"
                  label="Viewport Height"
                  type="number"
                  value={recorderConfig.viewportHeight}
                  onChange={handleConfigChange}
                  fullWidth
                  inputProps={{ min: 0 }}
                />
              </Grid>
              
              <Grid item xs={12}>
                <Typography variant="subtitle1" gutterBottom>
                  Recording Options
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          name="smartSelector"
                          checked={recorderConfig.smartSelector}
                          onChange={handleConfigChange}
                        />
                      }
                      label="Use Smart Selectors"
                    />
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          name="ignoreNavigation"
                          checked={recorderConfig.ignoreNavigation}
                          onChange={handleConfigChange}
                        />
                      }
                      label="Ignore Navigation Events"
                    />
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          name="recordScreenshots"
                          checked={recorderConfig.recordScreenshots}
                          onChange={handleConfigChange}
                        />
                      }
                      label="Record Screenshots"
                    />
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          name="recordConsoleLog"
                          checked={recorderConfig.recordConsoleLog}
                          onChange={handleConfigChange}
                        />
                      }
                      label="Record Console Logs"
                    />
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <FormControlLabel
                      control={
                        <Switch
                          name="includeAssertions"
                          checked={recorderConfig.includeAssertions}
                          onChange={handleConfigChange}
                        />
                      }
                      label="Include Automatic Assertions"
                    />
                  </Grid>
                </Grid>
              </Grid>
            </Grid>
          </Box>
        )}
        
        {activeStep === 1 && (
          <Box>
            <Typography variant="h6" gutterBottom>
              Recording in Progress
            </Typography>
            
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              <Typography variant="body1" sx={{ mr: 2 }}>
                Recording URL:
              </Typography>
              <Typography
                variant="body1"
                component="code"
                sx={{
                  fontFamily: 'monospace',
                  bgcolor: 'grey.100',
                  p: 1,
                  borderRadius: 1
                }}
              >
                {recordingUrl}
              </Typography>
            </Box>
            
            <Box sx={{ mb: 3 }}>
              <Alert
                severity={isPaused ? 'warning' : 'info'}
                icon={isPaused ? <PauseIcon /> : <RecordIcon color="error" />}
              >
                {isPaused ? 'Recording is paused. Press "Resume" to continue recording.' : 'Recording is active. Interact with the website to record actions.'}
              </Alert>
            </Box>
            
            <Typography variant="subtitle1" gutterBottom>
              Recorded Actions ({recordedActions.length})
            </Typography>
            
            <Box sx={{ maxHeight: 400, overflow: 'auto', mb: 3 }}>
              {recordedActions.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ py: 4 }}>
                  No actions recorded yet. Interact with the website to start recording.
                </Typography>
              ) : (
                recordedActions.map((action, index) => (
                  <RecordedActionItem
                    key={index}
                    action={action}
                    index={index}
                    onEdit={handleEditAction}
                    onDelete={handleDeleteAction}
                  />
                ))
              )}
            </Box>
            
            <Alert severity="info">
              Tip: Use the browser to navigate and interact with the website. Your actions will be recorded automatically.
            </Alert>
          </Box>
        )}
        
        {activeStep === 2 && (
          <Box>
            <Typography variant="h6" gutterBottom>
              Review and Save
            </Typography>
            
            {/* Tabs */}
            <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
              <Tabs value={tabValue} onChange={handleTabChange} aria-label="recorder review tabs">
                <Tab label="Test Case Info" id="recorder-tab-0" />
                <Tab label="Recorded Actions" id="recorder-tab-1" />
              </Tabs>
            </Box>
            
            {/* Test Case Info Tab */}
            <TabPanel value={tabValue} index={0}>
              <Grid container spacing={3}>
                <Grid item xs={12}>
                  <TextField
                    name="name"
                    label="Test Case Name"
                    value={testCaseConfig.name}
                    onChange={handleTestCaseConfigChange}
                    fullWidth
                    required
                    error={!testCaseConfig.name.trim()}
                    helperText={!testCaseConfig.name.trim() ? 'Test case name is required' : ''}
                  />
                </Grid>
                
                <Grid item xs={12}>
                  <TextField
                    name="description"
                    label="Description"
                    value={testCaseConfig.description}
                    onChange={handleTestCaseConfigChange}
                    fullWidth
                    multiline
                    rows={3}
                  />
                </Grid>
                
                <Grid item xs={12}>
                  <Typography variant="subtitle1" gutterBottom>
                    Generation Options
                  </Typography>
                  <Grid container spacing={2}>
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            name="optimizeSteps"
                            checked={testCaseConfig.optimizeSteps}
                            onChange={handleTestCaseConfigChange}
                          />
                        }
                        label="Optimize Steps (Combine and Clean Up)"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            name="includeComments"
                            checked={testCaseConfig.includeComments}
                            onChange={handleTestCaseConfigChange}
                          />
                        }
                        label="Include Descriptive Comments"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            name="screenshotOnError"
                            checked={testCaseConfig.screenshotOnError}
                            onChange={handleTestCaseConfigChange}
                          />
                        }
                        label="Take Screenshot on Error"
                      />
                    </Grid>
                    
                    <Grid item xs={12} md={6}>
                      <FormControlLabel
                        control={
                          <Switch
                            name="selfHealing"
                            checked={testCaseConfig.selfHealing}
                            onChange={handleTestCaseConfigChange}
                          />
                        }
                        label="Enable Self-Healing"
                      />
                    </Grid>
                  </Grid>
                </Grid>
              </Grid>
            </TabPanel>
            
            {/* Recorded Actions Tab */}
            <TabPanel value={tabValue} index={1}>
              <Typography variant="subtitle1" gutterBottom>
                Recorded Actions ({recordedActions.length})
              </Typography>
              
              <Box sx={{ maxHeight: 400, overflow: 'auto' }}>
                {recordedActions.length === 0 ? (
                  <Alert severity="warning">
                    No actions were recorded. Please go back and record some actions.
                  </Alert>
                ) : (
                  recordedActions.map((action, index) => (
                    <RecordedActionItem
                      key={index}
                      action={action}
                      index={index}
                      onEdit={handleEditAction}
                      onDelete={handleDeleteAction}
                    />
                  ))
                )}
              </Box>
            </TabPanel>
          </Box>
        )}
        
        {/* Bottom Navigation */}
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 4 }}>
          <Button onClick={handleBack} startIcon={<PrevIcon />}>
            {activeStep === 0 ? 'Cancel' : activeStep === 1 ? 'Discard' : 'Back to Recording'}
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            onClick={handleNext}
            endIcon={activeStep === 2 ? <SaveIcon /> : <NextIcon />}
            disabled={
              (activeStep === 0 && !recorderConfig.baseUrl) ||
              (activeStep === 2 && !testCaseConfig.name.trim()) ||
              loadingRecordingStatus
            }
          >
            {loadingRecordingStatus ? (
              <CircularProgress size={24} />
            ) : (
              activeStep === 0 ? 'Start Recording' : activeStep === 1 ? 'Stop Recording' : 'Generate Test Case'
            )}
          </Button>
        </Box>
      </Paper>
      
      {/* Stop Recording Dialog */}
      <Dialog
        open={stopDialogOpen}
        onClose={() => setStopDialogOpen(false)}
      >
        <DialogTitle>Stop Recording</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Are you sure you want to stop recording? You can review and edit the recorded actions before generating a test case.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setStopDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleStopRecording} color="error" variant="contained">
            Stop Recording
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Discard Recording Dialog */}
      <Dialog
        open={discardDialogOpen}
        onClose={() => setDiscardDialogOpen(false)}
      >
        <DialogTitle>Discard Recording</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Are you sure you want to discard this recording? All recorded actions will be lost.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDiscardDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleConfirmDiscard} color="error">
            Discard Recording
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default TestRecorder;


// src/pages/ApiTesting.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  IconButton,
  InputAdornment,
  Grid,
  Card,
  CardContent,
  CardActions,
  Divider,
  Chip,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  CircularProgress,
  Breadcrumbs,
  Link,
  Menu,
  MenuItem,
  Tooltip,
  Snackbar,
  Alert
} from '@mui/material';
import {
  Add as AddIcon,
  Search as SearchIcon,
  FilterList as FilterIcon,
  Refresh as RefreshIcon,
  PlayArrow as RunIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  ContentCopy as DuplicateIcon,
  MoreVert as MoreVertIcon,
  CheckCircle as SuccessIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Folder as CollectionIcon,
  Code as CodeIcon,
  Settings as SettingsIcon
} from '@mui/icons-material';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';

// Status chip component
const StatusChip = ({ status }) => {
  let color = 'default';
  let icon = null;
  
  switch (status?.toUpperCase()) {
    case 'SUCCESS':
    case 'PASSED':
      color = 'success';
      icon = <SuccessIcon />;
      break;
    case 'FAILED':
      color = 'error';
      icon = <ErrorIcon />;
      break;
    case 'WARNING':
      color = 'warning';
      icon = <WarningIcon />;
      break;
    default:
      color = 'default';
  }
  
  return (
    <Chip
      icon={icon}
      label={status || 'Unknown'}
      color={color}
      size="small"
    />
  );
};

// HTTP method chip component
const HttpMethodChip = ({ method }) => {
  let color = 'default';
  
  switch (method?.toUpperCase()) {
    case 'GET':
      color = 'info';
      break;
    case 'POST':
      color = 'success';
      break;
    case 'PUT':
      color = 'warning';
      break;
    case 'DELETE':
      color = 'error';
      break;
    case 'PATCH':
      color = 'secondary';
      break;
    default:
      color = 'default';
  }
  
  return (
    <Chip
      label={method || 'UNKNOWN'}
      color={color}
      size="small"
      variant="outlined"
    />
  );
};

const ApiTesting = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { currentProject } = useProject();
  const { get, post, delete: deleteApi } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  // State
  const [loading, setLoading] = useState(true);
  const [apiTests, setApiTests] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredTests, setFilteredTests] = useState([]);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [selectedTest, setSelectedTest] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [actionMenuAnchorEl, setActionMenuAnchorEl] = useState(null);
  const [environments, setEnvironments] = useState([]);
  const [selectedEnvironment, setSelectedEnvironment] = useState(null);
  
  // Load API tests on component mount
  useEffect(() => {
    const fetchApiTests = async () => {
      try {
        setLoading(true);
        
        const [testsResponse, environmentsResponse] = await Promise.all([
          get(`/projects/${projectId}/api-testing`),
          get(`/projects/${projectId}/api-testing/environments`)
        ]);
        
        setApiTests(testsResponse.data || []);
        setEnvironments(environmentsResponse.data || []);
        
        // Set default environment if available
        if (environmentsResponse.data && environmentsResponse.data.length > 0) {
          const defaultEnv = environmentsResponse.data.find(env => env.isDefault) || environmentsResponse.data[0];
          setSelectedEnvironment(defaultEnv);
        }
      } catch (error) {
        console.error('Error loading API tests:', error);
        enqueueSnackbar('Failed to load API tests', { variant: 'error' });
      } finally {
        setLoading(false);
      }
    };
    
    fetchApiTests();
  }, [projectId, get, enqueueSnackbar]);
  
  // Filter API tests when search term changes
  useEffect(() => {
    if (!apiTests) return;
    
    if (!searchTerm.trim()) {
      setFilteredTests(apiTests);
      return;
    }
    
    const lowerSearchTerm = searchTerm.toLowerCase();
    
    const filtered = apiTests.filter(test => 
      test.name.toLowerCase().includes(lowerSearchTerm) ||
      test.description?.toLowerCase().includes(lowerSearchTerm) ||
      test.url?.toLowerCase().includes(lowerSearchTerm) ||
      test.method?.toLowerCase().includes(lowerSearchTerm) ||
      test.tags?.some(tag => tag.toLowerCase().includes(lowerSearchTerm))
    );
    
    setFilteredTests(filtered);
  }, [apiTests, searchTerm]);
  
  // Handle pagination
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  
  // Handle action menu
  const handleActionMenuOpen = (event, test) => {
    setActionMenuAnchorEl(event.currentTarget);
    setSelectedTest(test);
  };
  
  const handleActionMenuClose = () => {
    setActionMenuAnchorEl(null);
  };
  
  // Handle API test actions
  const handleCreateApiTest = () => {
    navigate(`/projects/${projectId}/api-testing/create`);
  };
  
  const handleEditApiTest = (testId) => {
    navigate(`/projects/${projectId}/api-testing/${testId}`);
    handleActionMenuClose();
  };
  
  const handleRunApiTest = async (testId) => {
    try {
      setLoading(true);
      
      const config = selectedEnvironment ? { environmentId: selectedEnvironment.id } : undefined;
      const response = await post(`/projects/${projectId}/api-testing/${testId}/execute`, config);
      
      // Refresh the test list to get updated execution results
      const testsResponse = await get(`/projects/${projectId}/api-testing`);
      setApiTests(testsResponse.data || []);
      
      enqueueSnackbar('API test executed successfully', { variant: 'success' });
      
      // Navigate to test result
      navigate(`/projects/${projectId}/api-testing/${testId}`, {
        state: { executionResult: response.data }
      });
    } catch (error) {
      console.error('Error executing API test:', error);
      enqueueSnackbar('Failed to execute API test', { variant: 'error' });
    } finally {
      setLoading(false);
      handleActionMenuClose();
    }
  };
  
  const handleDuplicateApiTest = async (testId) => {
    try {
      const response = await post(`/projects/${projectId}/api-testing/${testId}/duplicate`);
      
      // Refresh the test list
      const testsResponse = await get(`/projects/${projectId}/api-testing`);
      setApiTests(testsResponse.data || []);
      
      enqueueSnackbar('API test duplicated successfully', { variant: 'success' });
      
      // Navigate to the duplicated test
      navigate(`/projects/${projectId}/api-testing/${response.data.id}`);
    } catch (error) {
      console.error('Error duplicating API test:', error);
      enqueueSnackbar('Failed to duplicate API test', { variant: 'error' });
    } finally {
      handleActionMenuClose();
    }
  };
  
  const handleDeleteClick = (testId) => {
    const test = apiTests.find(t => t.id === testId);
    setSelectedTest(test);
    setDeleteDialogOpen(true);
    handleActionMenuClose();
  };
  
  const handleConfirmDelete = async () => {
    if (!selectedTest) return;
    
    try {
      setLoading(true);
      
      const success = await deleteApi(`/projects/${projectId}/api-testing/${selectedTest.id}`);
      
      if (success) {
        // Remove the deleted test from state
        setApiTests(prev => prev.filter(test => test.id !== selectedTest.id));
        enqueueSnackbar('API test deleted successfully', { variant: 'success' });
      }
    } catch (error) {
      console.error('Error deleting API test:', error);
      enqueueSnackbar('Failed to delete API test', { variant: 'error' });
    } finally {
      setLoading(false);
      setDeleteDialogOpen(false);
      setSelectedTest(null);
    }
  };
  
  const handleRefresh = async () => {
    try {
      setLoading(true);
      
      const response = await get(`/projects/${projectId}/api-testing`);
      setApiTests(response.data || []);
      
      enqueueSnackbar('API tests refreshed', { variant: 'success' });
    } catch (error) {
      console.error('Error refreshing API tests:', error);
      enqueueSnackbar('Failed to refresh API tests', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  const handleEnvironmentChange = (env) => {
    setSelectedEnvironment(env);
    enqueueSnackbar(`Environment switched to ${env.name}`, { variant: 'info' });
  };
  
  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <Link underline="hover" color="inherit" href="/">
          Dashboard
        </Link>
        <Link
          underline="hover"
          color="inherit"
          href={`/projects/${projectId}`}
        >
          {currentProject?.name}
        </Link>
        <Typography color="text.primary">API Testing</Typography>
      </Breadcrumbs>
      
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          API Testing
        </Typography>
        <Box>
          <Button
            variant="outlined"
            color="primary"
            startIcon={<SettingsIcon />}
            onClick={() => navigate(`/projects/${projectId}/api-testing/environments`)}
            sx={{ mr: 1 }}
          >
            Environments
          </Button>
          <Button
            variant="contained"
            color="primary"
            startIcon={<AddIcon />}
            onClick={handleCreateApiTest}
          >
            Create API Test
          </Button>
        </Box>
      </Box>
      
      {/* Action Bar */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={4}>
            <TextField
              placeholder="Search API tests..."
              variant="outlined"
              size="small"
              fullWidth
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Grid>
          
          <Grid item xs={12} md={5}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Typography variant="body2" sx={{ mr: 2 }}>
                Environment:
              </Typography>
              {environments.length === 0 ? (
                <Chip 
                  label="No environments configured"
                  color="warning"
                  size="small"
                  onClick={() => navigate(`/projects/${projectId}/api-testing/environments`)}
                />
              ) : (
                environments.map(env => (
                  <Chip
                    key={env.id}
                    label={env.name}
                    color={selectedEnvironment?.id === env.id ? 'primary' : 'default'}
                    onClick={() => handleEnvironmentChange(env)}
                    sx={{ mr: 1 }}
                  />
                ))
              )}
            </Box>
          </Grid>
          
          <Grid item xs={12} md={3} sx={{ display: 'flex', justifyContent: 'flex-end' }}>
            <Tooltip title="Filter">
              <IconButton>
                <FilterIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Refresh">
              <IconButton onClick={handleRefresh} disabled={loading}>
                {loading ? <CircularProgress size={24} /> : <RefreshIcon />}
              </IconButton>
            </Tooltip>
          </Grid>
        </Grid>
      </Paper>
      
      {/* API Tests Table */}
      <Paper>
        <TableContainer>
          <Table aria-label="api tests table">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Method</TableCell>
                <TableCell>URL</TableCell>
                <TableCell>Last Run</TableCell>
                <TableCell>Status</TableCell>
                <TableCell align="right">Actions</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={6} align="center">
                    <CircularProgress size={40} sx={{ my: 3 }} />
                  </TableCell>
                </TableRow>
              ) : filteredTests.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={6} align="center">
                    <Typography variant="body1" sx={{ py: 3 }}>
                      {searchTerm ? 'No API tests found matching your search' : 'No API tests found. Create your first API test to get started.'}
                    </Typography>
                    {!searchTerm && (
                      <Button
                        variant="contained"
                        color="primary"
                        startIcon={<AddIcon />}
                        onClick={handleCreateApiTest}
                        sx={{ mt: 1 }}
                      >
                        Create API Test
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              ) : (
                filteredTests
                  .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                  .map((test) => (
                    <TableRow key={test.id} hover>
                      <TableCell>
                        <Typography
                          variant="body1"
                          sx={{
                            cursor: 'pointer',
                            '&:hover': { textDecoration: 'underline' }
                          }}
                          onClick={() => handleEditApiTest(test.id)}
                        >
                          {test.name}
                        </Typography>
                        {test.description && (
                          <Typography variant="body2" color="textSecondary">
                            {test.description}
                          </Typography>
                        )}
                      </TableCell>
                      <TableCell>
                        <HttpMethodChip method={test.method} />
                      </TableCell>
                      <TableCell>
                        <Typography 
                          variant="body2" 
                          sx={{ 
                            fontFamily: 'monospace',
                            maxWidth: 250,
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                          }}
                        >
                          {test.url}
                        </Typography>
                      </TableCell>
                      <TableCell>
                        {test.lastRun ? (
                          <Typography variant="body2">
                            {new Date(test.lastRun).toLocaleString()}
                          </Typography>
                        ) : (
                          <Typography variant="body2" color="textSecondary">
                            Never
                          </Typography>
                        )}
                      </TableCell>
                      <TableCell>
                        {test.lastStatus ? (
                          <StatusChip status={test.lastStatus} />
                        ) : (
                          <Typography variant="body2" color="textSecondary">
                            N/A
                          </Typography>
                        )}
                      </TableCell>
                      <TableCell align="right">
                        <Tooltip title="Run">
                          <IconButton
                            color="primary"
                            onClick={() => handleRunApiTest(test.id)}
                          >
                            <RunIcon />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Edit">
                          <IconButton
                            color="primary"
                            onClick={() => handleEditApiTest(test.id)}
                          >
                            <EditIcon />
                          </IconButton>
                        </Tooltip>
                        <IconButton
                          aria-label="more actions"
                          aria-haspopup="true"
                          onClick={(e) => handleActionMenuOpen(e, test)}
                        >
                          <MoreVertIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        <TablePagination
          component="div"
          count={filteredTests.length}
          page={page}
          onPageChange={handleChangePage}
          rowsPerPage={rowsPerPage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          rowsPerPageOptions={[5, 10, 25, 50]}
        />
      </Paper>
      
      {/* Action Menu */}
      <Menu
        anchorEl={actionMenuAnchorEl}
        open={Boolean(actionMenuAnchorEl)}
        onClose={handleActionMenuClose}
      >
        <MenuItem onClick={() => handleEditApiTest(selectedTest?.id)}>
          <EditIcon fontSize="small" sx={{ mr: 1 }} />
          Edit
        </MenuItem>
        <MenuItem onClick={() => handleRunApiTest(selectedTest?.id)}>
          <RunIcon fontSize="small" sx={{ mr: 1 }} />
          Run
        </MenuItem>
        <MenuItem onClick={() => handleDuplicateApiTest(selectedTest?.id)}>
          <DuplicateIcon fontSize="small" sx={{ mr: 1 }} />
          Duplicate
        </MenuItem>
        <MenuItem onClick={() => handleDeleteClick(selectedTest?.id)}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete
        </MenuItem>
      </Menu>
      
      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
      >
        <DialogTitle>Delete API Test</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Are you sure you want to delete the API test "{selectedTest?.name}"?
            This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>
            Cancel
          </Button>
          <Button onClick={handleConfirmDelete} color="error" variant="contained">
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ApiTesting;



// src/pages/DatabaseTesting.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  IconButton,
  Grid,
  Card,
  CardContent,
  CardActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tab,
  Tabs,
  Divider,
  CircularProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Tooltip
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import CodeIcon from '@mui/icons-material/Code';
import StorageIcon from '@mui/icons-material/Storage';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';
import CodeEditor from '../components/CodeEditor';

const DatabaseTesting = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { project } = useProject();
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(true);
  const [queries, setQueries] = useState([]);
  const [currentTab, setCurrentTab] = useState(0);
  const [connections, setConnections] = useState([]);
  const [connectionDialogOpen, setConnectionDialogOpen] = useState(false);
  const [queryDialogOpen, setQueryDialogOpen] = useState(false);
  const [currentConnection, setCurrentConnection] = useState(null);
  const [currentQuery, setCurrentQuery] = useState(null);
  const [executionResults, setExecutionResults] = useState(null);
  const [executingQuery, setExecutingQuery] = useState(false);
  
  const initialConnectionState = {
    name: '',
    type: 'MYSQL', // MYSQL, POSTGRESQL, ORACLE, SQLSERVER, etc.
    host: '',
    port: '',
    database: '',
    username: '',
    password: '',
    connectionString: '',
    properties: {}
  };
  
  const initialQueryState = {
    name: '',
    description: '',
    connectionId: '',
    queryType: 'SELECT', // SELECT, INSERT, UPDATE, DELETE, etc.
    queryText: '',
    parameters: [],
    assertions: []
  };
  
  const [connectionForm, setConnectionForm] = useState(initialConnectionState);
  const [queryForm, setQueryForm] = useState(initialQueryState);
  const [connectionFormErrors, setConnectionFormErrors] = useState({});
  const [queryFormErrors, setQueryFormErrors] = useState({});
  
  // Load connections and queries on component mount
  useEffect(() => {
    const fetchConnections = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/database/connections`);
        setConnections(response.data);
      } catch (error) {
        console.error('Error fetching database connections:', error);
        enqueueSnackbar('Failed to load database connections', { variant: 'error' });
      }
    };
    
    const fetchQueries = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/database/queries`);
        setQueries(response.data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching database queries:', error);
        enqueueSnackbar('Failed to load database queries', { variant: 'error' });
        setLoading(false);
      }
    };
    
    fetchConnections();
    fetchQueries();
  }, [projectId, api, enqueueSnackbar]);
  
  const validateConnectionForm = () => {
    const errors = {};
    
    if (!connectionForm.name.trim()) {
      errors.name = 'Connection name is required';
    }
    
    if (!connectionForm.type) {
      errors.type = 'Connection type is required';
    }
    
    if (!connectionForm.host.trim() && !connectionForm.connectionString.trim()) {
      errors.host = 'Host or connection string is required';
    }
    
    if (!connectionForm.port && !connectionForm.connectionString.trim()) {
      errors.port = 'Port or connection string is required';
    }
    
    if (!connectionForm.database.trim() && !connectionForm.connectionString.trim()) {
      errors.database = 'Database name or connection string is required';
    }
    
    if (!connectionForm.username.trim()) {
      errors.username = 'Username is required';
    }
    
    setConnectionFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const validateQueryForm = () => {
    const errors = {};
    
    if (!queryForm.name.trim()) {
      errors.name = 'Query name is required';
    }
    
    if (!queryForm.connectionId) {
      errors.connectionId = 'Database connection is required';
    }
    
    if (!queryForm.queryType) {
      errors.queryType = 'Query type is required';
    }
    
    if (!queryForm.queryText.trim()) {
      errors.queryText = 'Query text is required';
    }
    
    setQueryFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const handleConnectionSubmit = async () => {
    if (!validateConnectionForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentConnection) {
        // Update existing connection
        response = await api.put(
          `/projects/${projectId}/database/connections/${currentConnection.id}`,
          connectionForm
        );
        
        // Update the connections list
        setConnections(connections.map(conn => 
          conn.id === currentConnection.id ? response.data : conn
        ));
        
        enqueueSnackbar('Connection updated successfully', { variant: 'success' });
      } else {
        // Create new connection
        response = await api.post(
          `/projects/${projectId}/database/connections`,
          connectionForm
        );
        
        // Add the new connection to the list
        setConnections([...connections, response.data]);
        
        enqueueSnackbar('Connection created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setConnectionDialogOpen(false);
      setConnectionForm(initialConnectionState);
      setCurrentConnection(null);
    } catch (error) {
      console.error('Error saving database connection:', error);
      enqueueSnackbar('Failed to save database connection', { variant: 'error' });
    }
  };
  
  const handleQuerySubmit = async () => {
    if (!validateQueryForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentQuery) {
        // Update existing query
        response = await api.put(
          `/projects/${projectId}/database/queries/${currentQuery.id}`,
          queryForm
        );
        
        // Update the queries list
        setQueries(queries.map(query => 
          query.id === currentQuery.id ? response.data : query
        ));
        
        enqueueSnackbar('Query updated successfully', { variant: 'success' });
      } else {
        // Create new query
        response = await api.post(
          `/projects/${projectId}/database/queries`,
          queryForm
        );
        
        // Add the new query to the list
        setQueries([...queries, response.data]);
        
        enqueueSnackbar('Query created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setQueryDialogOpen(false);
      setQueryForm(initialQueryState);
      setCurrentQuery(null);
    } catch (error) {
      console.error('Error saving database query:', error);
      enqueueSnackbar('Failed to save database query', { variant: 'error' });
    }
  };
  
  const handleDeleteConnection = async (connectionId) => {
    if (window.confirm('Are you sure you want to delete this connection? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/database/connections/${connectionId}`);
        
        // Remove the deleted connection from the list
        setConnections(connections.filter(conn => conn.id !== connectionId));
        
        enqueueSnackbar('Connection deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting database connection:', error);
        enqueueSnackbar('Failed to delete database connection', { variant: 'error' });
      }
    }
  };
  
  const handleDeleteQuery = async (queryId) => {
    if (window.confirm('Are you sure you want to delete this query? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/database/queries/${queryId}`);
        
        // Remove the deleted query from the list
        setQueries(queries.filter(query => query.id !== queryId));
        
        enqueueSnackbar('Query deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting database query:', error);
        enqueueSnackbar('Failed to delete database query', { variant: 'error' });
      }
    }
  };
  
  const handleEditConnection = (connection) => {
    setCurrentConnection(connection);
    setConnectionForm({
      name: connection.name,
      type: connection.type,
      host: connection.host,
      port: connection.port,
      database: connection.database,
      username: connection.username,
      password: connection.password,
      connectionString: connection.connectionString,
      properties: connection.properties || {}
    });
    setConnectionDialogOpen(true);
  };
  
  const handleEditQuery = (query) => {
    setCurrentQuery(query);
    setQueryForm({
      name: query.name,
      description: query.description,
      connectionId: query.connectionId,
      queryType: query.queryType,
      queryText: query.queryText,
      parameters: query.parameters || [],
      assertions: query.assertions || []
    });
    setQueryDialogOpen(true);
  };
  
  const handleExecuteQuery = async (query) => {
    setExecutingQuery(true);
    setExecutionResults(null);
    
    try {
      const response = await api.post(
        `/projects/${projectId}/database/queries/${query.id}/execute`,
        { parameters: query.parameters }
      );
      
      setExecutionResults(response.data);
      enqueueSnackbar('Query executed successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error executing database query:', error);
      enqueueSnackbar('Failed to execute database query', { variant: 'error' });
      setExecutionResults({
        success: false,
        error: error.response?.data?.message || 'An error occurred during query execution',
        timestamp: new Date().toISOString()
      });
    } finally {
      setExecutingQuery(false);
    }
  };
  
  const handleDuplicateQuery = async (query) => {
    const duplicatedQuery = {
      ...query,
      name: `${query.name} (Copy)`,
      id: undefined
    };
    
    try {
      const response = await api.post(
        `/projects/${projectId}/database/queries`,
        duplicatedQuery
      );
      
      // Add the duplicated query to the list
      setQueries([...queries, response.data]);
      
      enqueueSnackbar('Query duplicated successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error duplicating database query:', error);
      enqueueSnackbar('Failed to duplicate database query', { variant: 'error' });
    }
  };
  
  const handleConnectionInputChange = (e) => {
    const { name, value } = e.target;
    setConnectionForm({
      ...connectionForm,
      [name]: value
    });
  };
  
  const handleQueryInputChange = (e) => {
    const { name, value } = e.target;
    setQueryForm({
      ...queryForm,
      [name]: value
    });
  };
  
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  const renderExecutionResults = () => {
    if (!executionResults) {
      return null;
    }
    
    if (!executionResults.success) {
      return (
        <Paper sx={{ p: 2, mt: 2, backgroundColor: '#fff8f8', border: '1px solid #ffcdd2' }}>
          <Typography variant="h6" color="error">Execution Failed</Typography>
          <Typography variant="body1">{executionResults.error}</Typography>
          <Typography variant="caption">
            Time: {new Date(executionResults.timestamp).toLocaleString()}
          </Typography>
        </Paper>
      );
    }
    
    return (
      <Paper sx={{ p: 2, mt: 2 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="h6">Execution Results</Typography>
          <Typography variant="caption">
            Time: {new Date(executionResults.timestamp).toLocaleString()} | 
            Duration: {executionResults.duration}ms | 
            Rows: {executionResults.data?.length || 0}
          </Typography>
        </Box>
        
        {executionResults.data && executionResults.data.length > 0 ? (
          <TableContainer>
            <Table size="small">
              <TableHead>
                <TableRow>
                  {Object.keys(executionResults.data[0]).map((key) => (
                    <TableCell key={key}>{key}</TableCell>
                  ))}
                </TableRow>
              </TableHead>
              <TableBody>
                {executionResults.data.map((row, rowIndex) => (
                  <TableRow key={rowIndex}>
                    {Object.values(row).map((value, colIndex) => (
                      <TableCell key={colIndex}>
                        {value === null ? 'NULL' : 
                         typeof value === 'object' ? JSON.stringify(value) : String(value)}
                      </TableCell>
                    ))}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        ) : (
          <Typography variant="body2">
            {executionResults.affectedRows !== undefined 
              ? `Query executed successfully. ${executionResults.affectedRows} rows affected.` 
              : 'Query executed successfully. No results to display.'}
          </Typography>
        )}
      </Paper>
    );
  };
  
  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Database Testing
        </Typography>
        <Box>
          <Button
            variant="contained"
            startIcon={<StorageIcon />}
            onClick={() => {
              setCurrentConnection(null);
              setConnectionForm(initialConnectionState);
              setConnectionFormErrors({});
              setConnectionDialogOpen(true);
            }}
            sx={{ mr: 2 }}
          >
            New Connection
          </Button>
          <Button
            variant="contained"
            startIcon={<CodeIcon />}
            onClick={() => {
              setCurrentQuery(null);
              setQueryForm(initialQueryState);
              setQueryFormErrors({});
              setQueryDialogOpen(true);
            }}
          >
            New Query
          </Button>
        </Box>
      </Box>
      
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab label="Queries" />
          <Tab label="Connections" />
        </Tabs>
      </Paper>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <>
          {currentTab === 0 && (
            <>
              {queries.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1" sx={{ mb: 2 }}>
                    No database queries created yet.
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => {
                      setCurrentQuery(null);
                      setQueryForm(initialQueryState);
                      setQueryFormErrors({});
                      setQueryDialogOpen(true);
                    }}
                  >
                    Create First Query
                  </Button>
                </Paper>
              ) : (
                <Grid container spacing={3}>
                  {queries.map((query) => (
                    <Grid item xs={12} md={6} lg={4} key={query.id}>
                      <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <CardContent sx={{ flexGrow: 1 }}>
                          <Typography variant="h6" gutterBottom>
                            {query.name}
                          </Typography>
                          <Typography variant="body2" color="text.secondary" gutterBottom>
                            {query.description || 'No description'}
                          </Typography>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Connection:</Typography>
                            <Typography variant="body2">
                              {connections.find(c => c.id === query.connectionId)?.name || 'Unknown'}
                            </Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Type:</Typography>
                            <Typography variant="body2">{query.queryType}</Typography>
                          </Box>
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="caption">Query:</Typography>
                            <Paper 
                              sx={{ 
                                p: 1, 
                                backgroundColor: '#f8f9fa', 
                                maxHeight: '100px', 
                                overflow: 'auto',
                                fontSize: '0.8rem',
                                fontFamily: 'monospace' 
                              }}
                            >
                              {query.queryText}
                            </Paper>
                          </Box>
                        </CardContent>
                        <Divider />
                        <CardActions>
                          <IconButton 
                            size="small" 
                            onClick={() => handleExecuteQuery(query)}
                            disabled={executingQuery}
                          >
                            {executingQuery ? <CircularProgress size={24} /> : <PlayArrowIcon />}
                          </IconButton>
                          <IconButton size="small" onClick={() => handleEditQuery(query)}>
                            <EditIcon />
                          </IconButton>
                          <IconButton size="small" onClick={() => handleDuplicateQuery(query)}>
                            <ContentCopyIcon />
                          </IconButton>
                          <IconButton size="small" onClick={() => handleDeleteQuery(query.id)}>
                            <DeleteIcon />
                          </IconButton>
                        </CardActions>
                      </Card>
                    </Grid>
                  ))}
                </Grid>
              )}
              
              {renderExecutionResults()}
            </>
          )}
          
          {currentTab === 1 && (
            <>
              {connections.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1" sx={{ mb: 2 }}>
                    No database connections created yet.
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => {
                      setCurrentConnection(null);
                      setConnectionForm(initialConnectionState);
                      setConnectionFormErrors({});
                      setConnectionDialogOpen(true);
                    }}
                  >
                    Create First Connection
                  </Button>
                </Paper>
              ) : (
                <Grid container spacing={3}>
                  {connections.map((connection) => (
                    <Grid item xs={12} md={6} lg={4} key={connection.id}>
                      <Card>
                        <CardContent>
                          <Typography variant="h6" gutterBottom>
                            {connection.name}
                          </Typography>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Type:</Typography>
                            <Typography variant="body2">{connection.type}</Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Database:</Typography>
                            <Typography variant="body2">{connection.database}</Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Host:</Typography>
                            <Typography variant="body2">
                              {connection.host}:{connection.port}
                            </Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Username:</Typography>
                            <Typography variant="body2">{connection.username}</Typography>
                          </Box>
                        </CardContent>
                        <CardActions>
                          <IconButton size="small" onClick={() => handleEditConnection(connection)}>
                            <EditIcon />
                          </IconButton>
                          <IconButton 
                            size="small" 
                            onClick={() => handleDeleteConnection(connection.id)}
                          >
                            <DeleteIcon />
                          </IconButton>
                        </CardActions>
                      </Card>
                    </Grid>
                  ))}
                </Grid>
              )}
            </>
          )}
        </>
      )}
      
      {/* Connection Dialog */}
      <Dialog
        open={connectionDialogOpen}
        onClose={() => setConnectionDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentConnection ? 'Edit Connection' : 'New Connection'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Connection Name"
                name="name"
                value={connectionForm.name}
                onChange={handleConnectionInputChange}
                error={!!connectionFormErrors.name}
                helperText={connectionFormErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required error={!!connectionFormErrors.type}>
                <InputLabel>Database Type</InputLabel>
                <Select
                  name="type"
                  value={connectionForm.type}
                  onChange={handleConnectionInputChange}
                  label="Database Type"
                >
                  <MenuItem value="MYSQL">MySQL</MenuItem>
                  <MenuItem value="POSTGRESQL">PostgreSQL</MenuItem>
                  <MenuItem value="ORACLE">Oracle</MenuItem>
                  <MenuItem value="SQLSERVER">SQL Server</MenuItem>
                  <MenuItem value="MONGODB">MongoDB</MenuItem>
                  <MenuItem value="SQLITE">SQLite</MenuItem>
                </Select>
                {connectionFormErrors.type && (
                  <FormHelperText>{connectionFormErrors.type}</FormHelperText>
                )}
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Connection Details
              </Typography>
              <Divider />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Connection String (Optional)"
                name="connectionString"
                value={connectionForm.connectionString}
                onChange={handleConnectionInputChange}
                helperText="If provided, this will override individual connection properties"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Host"
                name="host"
                value={connectionForm.host}
                onChange={handleConnectionInputChange}
                error={!!connectionFormErrors.host}
                helperText={connectionFormErrors.host}
                required={!connectionForm.connectionString}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Port"
                name="port"
                type="number"
                value={connectionForm.port}
                onChange={handleConnectionInputChange}
                error={!!connectionFormErrors.port}
                helperText={connectionFormErrors.port}
                required={!connectionForm.connectionString}
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Database Name"
                name="database"
                value={connectionForm.database}
                onChange={handleConnectionInputChange}
                error={!!connectionFormErrors.database}
                helperText={connectionFormErrors.database}
                required={!connectionForm.connectionString}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Username"
                name="username"
                value={connectionForm.username}
                onChange={handleConnectionInputChange}
                error={!!connectionFormErrors.username}
                helperText={connectionFormErrors.username}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Password"
                name="password"
                type="password"
                value={connectionForm.password}
                onChange={handleConnectionInputChange}
                required
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setConnectionDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleConnectionSubmit} 
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Query Dialog */}
      <Dialog
        open={queryDialogOpen}
        onClose={() => setQueryDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentQuery ? 'Edit Query' : 'New Query'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Query Name"
                name="name"
                value={queryForm.name}
                onChange={handleQueryInputChange}
                error={!!queryFormErrors.name}
                helperText={queryFormErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required error={!!queryFormErrors.connectionId}>
                <InputLabel>Database Connection</InputLabel>
                <Select
                  name="connectionId"
                  value={queryForm.connectionId}
                  onChange={handleQueryInputChange}
                  label="Database Connection"
                >
                  {connections.map((connection) => (
                    <MenuItem key={connection.id} value={connection.id}>
                      {connection.name} ({connection.type})
                    </MenuItem>
                  ))}
                </Select>
                {queryFormErrors.connectionId && (
                  <FormHelperText>{queryFormErrors.connectionId}</FormHelperText>
                )}
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={queryForm.description}
                onChange={handleQueryInputChange}
                multiline
                rows={2}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required error={!!queryFormErrors.queryType}>
                <InputLabel>Query Type</InputLabel>
                <Select
                  name="queryType"
                  value={queryForm.queryType}
                  onChange={handleQueryInputChange}
                  label="Query Type"
                >
                  <MenuItem value="SELECT">SELECT</MenuItem>
                  <MenuItem value="INSERT">INSERT</MenuItem>
                  <MenuItem value="UPDATE">UPDATE</MenuItem>
                  <MenuItem value="DELETE">DELETE</MenuItem>
                  <MenuItem value="CALL">CALL (Stored Procedure)</MenuItem>
                  <MenuItem value="CREATE">CREATE</MenuItem>
                  <MenuItem value="ALTER">ALTER</MenuItem>
                  <MenuItem value="DROP">DROP</MenuItem>
                  <MenuItem value="TRUNCATE">TRUNCATE</MenuItem>
                </Select>
                {queryFormErrors.queryType && (
                  <FormHelperText>{queryFormErrors.queryType}</FormHelperText>
                )}
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Query Text
              </Typography>
              <CodeEditor
                value={queryForm.queryText}
                onChange={(value) => setQueryForm({ ...queryForm, queryText: value })}
                language="sql"
                height="200px"
                error={!!queryFormErrors.queryText}
                helperText={queryFormErrors.queryText}
              />
            </Grid>
            
            {/* Parameter handling would go here in a production app */}
            
            {/* Assertions handling would go here in a production app */}
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setQueryDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleQuerySubmit} 
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default DatabaseTesting;


// src/pages/BDDTesting.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  IconButton,
  Grid,
  Card,
  CardContent,
  CardActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tab,
  Tabs,
  Divider,
  CircularProgress,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Chip
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import DescriptionIcon from '@mui/icons-material/Description';
import AssignmentIcon from '@mui/icons-material/Assignment';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';
import CodeEditor from '../components/CodeEditor';

const BDDTesting = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { project } = useProject();
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(true);
  const [currentTab, setCurrentTab] = useState(0);
  const [features, setFeatures] = useState([]);
  const [stepDefinitions, setStepDefinitions] = useState([]);
  const [featureDialogOpen, setFeatureDialogOpen] = useState(false);
  const [stepDefDialogOpen, setStepDefDialogOpen] = useState(false);
  const [currentFeature, setCurrentFeature] = useState(null);
  const [currentStepDef, setCurrentStepDef] = useState(null);
  const [executingFeature, setExecutingFeature] = useState(false);
  const [executionResults, setExecutionResults] = useState(null);
  
  const initialFeatureState = {
    name: '',
    description: '',
    tags: [],
    content: `Feature: 
    
  Scenario: 
    Given 
    When 
    Then `
  };
  
  const initialStepDefState = {
    name: '',
    pattern: '',
    stepType: 'GIVEN', // GIVEN, WHEN, THEN
    implementationType: 'JS', // JS, JAVA
    implementation: ''
  };
  
  const [featureForm, setFeatureForm] = useState(initialFeatureState);
  const [stepDefForm, setStepDefForm] = useState(initialStepDefState);
  const [featureFormErrors, setFeatureFormErrors] = useState({});
  const [stepDefFormErrors, setStepDefFormErrors] = useState({});
  
  // Load features and step definitions on component mount
  useEffect(() => {
    const fetchFeatures = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/bdd/features`);
        setFeatures(response.data);
      } catch (error) {
        console.error('Error fetching BDD features:', error);
        enqueueSnackbar('Failed to load BDD features', { variant: 'error' });
      }
    };
    
    const fetchStepDefinitions = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/bdd/step-definitions`);
        setStepDefinitions(response.data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching BDD step definitions:', error);
        enqueueSnackbar('Failed to load BDD step definitions', { variant: 'error' });
        setLoading(false);
      }
    };
    
    fetchFeatures();
    fetchStepDefinitions();
  }, [projectId, api, enqueueSnackbar]);
  
  const validateFeatureForm = () => {
    const errors = {};
    
    if (!featureForm.name.trim()) {
      errors.name = 'Feature name is required';
    }
    
    if (!featureForm.content.trim()) {
      errors.content = 'Feature content is required';
    }
    
    // Basic validation for Gherkin syntax
    const contentLines = featureForm.content.trim().split('\n');
    let hasFeature = false;
    let hasScenario = false;
    
    for (const line of contentLines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('Feature:')) {
        hasFeature = true;
      } else if (trimmedLine.startsWith('Scenario:')) {
        hasScenario = true;
      }
    }
    
    if (!hasFeature) {
      errors.content = 'Feature content must include a Feature: declaration';
    } else if (!hasScenario) {
      errors.content = 'Feature content must include at least one Scenario: declaration';
    }
    
    setFeatureFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const validateStepDefForm = () => {
    const errors = {};
    
    if (!stepDefForm.name.trim()) {
      errors.name = 'Step definition name is required';
    }
    
    if (!stepDefForm.pattern.trim()) {
      errors.pattern = 'Step pattern is required';
    }
    
    if (!stepDefForm.implementation.trim()) {
      errors.implementation = 'Implementation is required';
    }
    
    setStepDefFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const handleFeatureSubmit = async () => {
    if (!validateFeatureForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentFeature) {
        // Update existing feature
        response = await api.put(
          `/projects/${projectId}/bdd/features/${currentFeature.id}`,
          featureForm
        );
        
        // Update the features list
        setFeatures(features.map(feature => 
          feature.id === currentFeature.id ? response.data : feature
        ));
        
        enqueueSnackbar('Feature updated successfully', { variant: 'success' });
      } else {
        // Create new feature
        response = await api.post(
          `/projects/${projectId}/bdd/features`,
          featureForm
        );
        
        // Add the new feature to the list
        setFeatures([...features, response.data]);
        
        enqueueSnackbar('Feature created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setFeatureDialogOpen(false);
      setFeatureForm(initialFeatureState);
      setCurrentFeature(null);
    } catch (error) {
      console.error('Error saving BDD feature:', error);
      enqueueSnackbar('Failed to save BDD feature', { variant: 'error' });
    }
  };
  
  const handleStepDefSubmit = async () => {
    if (!validateStepDefForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentStepDef) {
        // Update existing step definition
        response = await api.put(
          `/projects/${projectId}/bdd/step-definitions/${currentStepDef.id}`,
          stepDefForm
        );
        
        // Update the step definitions list
        setStepDefinitions(stepDefinitions.map(stepDef => 
          stepDef.id === currentStepDef.id ? response.data : stepDef
        ));
        
        enqueueSnackbar('Step definition updated successfully', { variant: 'success' });
      } else {
        // Create new step definition
        response = await api.post(
          `/projects/${projectId}/bdd/step-definitions`,
          stepDefForm
        );
        
        // Add the new step definition to the list
        setStepDefinitions([...stepDefinitions, response.data]);
        
        enqueueSnackbar('Step definition created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setStepDefDialogOpen(false);
      setStepDefForm(initialStepDefState);
      setCurrentStepDef(null);
    } catch (error) {
      console.error('Error saving BDD step definition:', error);
      enqueueSnackbar('Failed to save BDD step definition', { variant: 'error' });
    }
  };
  
  const handleDeleteFeature = async (featureId) => {
    if (window.confirm('Are you sure you want to delete this feature? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/bdd/features/${featureId}`);
        
        // Remove the deleted feature from the list
        setFeatures(features.filter(feature => feature.id !== featureId));
        
        enqueueSnackbar('Feature deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting BDD feature:', error);
        enqueueSnackbar('Failed to delete BDD feature', { variant: 'error' });
      }
    }
  };
  
  const handleDeleteStepDef = async (stepDefId) => {
    if (window.confirm('Are you sure you want to delete this step definition? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/bdd/step-definitions/${stepDefId}`);
        
        // Remove the deleted step definition from the list
        setStepDefinitions(stepDefinitions.filter(stepDef => stepDef.id !== stepDefId));
        
        enqueueSnackbar('Step definition deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting BDD step definition:', error);
        enqueueSnackbar('Failed to delete BDD step definition', { variant: 'error' });
      }
    }
  };
  
  const handleEditFeature = (feature) => {
    setCurrentFeature(feature);
    setFeatureForm({
      name: feature.name,
      description: feature.description || '',
      tags: feature.tags || [],
      content: feature.content
    });
    setFeatureDialogOpen(true);
  };
  
  const handleEditStepDef = (stepDef) => {
    setCurrentStepDef(stepDef);
    setStepDefForm({
      name: stepDef.name,
      pattern: stepDef.pattern,
      stepType: stepDef.stepType,
      implementationType: stepDef.implementationType,
      implementation: stepDef.implementation
    });
    setStepDefDialogOpen(true);
  };
  
  const handleExecuteFeature = async (feature) => {
    setExecutingFeature(true);
    setExecutionResults(null);
    
    try {
      const response = await api.post(
        `/projects/${projectId}/bdd/features/${feature.id}/execute`
      );
      
      setExecutionResults(response.data);
      enqueueSnackbar('Feature executed successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error executing BDD feature:', error);
      enqueueSnackbar('Failed to execute BDD feature', { variant: 'error' });
      setExecutionResults({
        success: false,
        error: error.response?.data?.message || 'An error occurred during execution',
        timestamp: new Date().toISOString()
      });
    } finally {
      setExecutingFeature(false);
    }
  };
  
  const handleDuplicateFeature = async (feature) => {
    const duplicatedFeature = {
      ...feature,
      name: `${feature.name} (Copy)`,
      id: undefined
    };
    
    try {
      const response = await api.post(
        `/projects/${projectId}/bdd/features`,
        duplicatedFeature
      );
      
      // Add the duplicated feature to the list
      setFeatures([...features, response.data]);
      
      enqueueSnackbar('Feature duplicated successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error duplicating BDD feature:', error);
      enqueueSnackbar('Failed to duplicate BDD feature', { variant: 'error' });
    }
  };
  
  const handleFeatureInputChange = (e) => {
    const { name, value } = e.target;
    setFeatureForm({
      ...featureForm,
      [name]: value
    });
  };
  
  const handleStepDefInputChange = (e) => {
    const { name, value } = e.target;
    setStepDefForm({
      ...stepDefForm,
      [name]: value
    });
  };
  
  const handleTagsChange = (e) => {
    const value = e.target.value;
    // Split the comma-separated tags and trim whitespace
    const tags = value.split(',').map(tag => tag.trim()).filter(tag => tag);
    setFeatureForm({
      ...featureForm,
      tags
    });
  };
  
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  const renderExecutionResults = () => {
    if (!executionResults) {
      return null;
    }
    
    if (!executionResults.success) {
      return (
        <Paper sx={{ p: 2, mt: 2, backgroundColor: '#fff8f8', border: '1px solid #ffcdd2' }}>
          <Typography variant="h6" color="error">Execution Failed</Typography>
          <Typography variant="body1">{executionResults.error}</Typography>
          <Typography variant="caption">
            Time: {new Date(executionResults.timestamp).toLocaleString()}
          </Typography>
        </Paper>
      );
    }
    
    return (
      <Paper sx={{ p: 2, mt: 2 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="h6">Execution Results</Typography>
          <Typography variant="caption">
            Time: {new Date(executionResults.timestamp).toLocaleString()} | 
            Duration: {executionResults.duration}ms
          </Typography>
        </Box>
        
        <List>
          {executionResults.scenarios.map((scenario, index) => (
            <React.Fragment key={index}>
              <ListItem 
                sx={{ 
                  backgroundColor: scenario.passed ? '#e8f5e9' : '#ffebee',
                  borderRadius: 1,
                  mb: 1
                }}
              >
                <ListItemText
                  primary={`Scenario: ${scenario.name}`}
                  secondary={`${scenario.passed ? 'Passed' : 'Failed'} - Duration: ${scenario.duration}ms`}
                />
              </ListItem>
              
              {scenario.steps.map((step, stepIndex) => (
                <ListItem 
                  key={stepIndex}
                  sx={{ pl: 4, py: 0.5 }}
                >
                  <ListItemIcon sx={{ minWidth: '40px' }}>
                    {step.status === 'PASSED' && (
                      <Chip 
                        label="" 
                        size="small" 
                        color="success" 
                        sx={{ minWidth: '32px' }}
                      />
                    )}
                    {step.status === 'FAILED' && (
                      <Chip 
                        label="" 
                        size="small" 
                        color="error"
                        sx={{ minWidth: '32px' }}
                      />
                    )}
                    {step.status === 'SKIPPED' && (
                      <Chip 
                        label="-" 
                        size="small" 
                        color="default"
                        sx={{ minWidth: '32px' }}
                      />
                    )}
                  </ListItemIcon>
                  <ListItemText
                    primary={`${step.keyword} ${step.text}`}
                    secondary={step.status !== 'SKIPPED' ? `Duration: ${step.duration}ms` : 'Skipped'}
                  />
                </ListItem>
              ))}
              
              {scenario.error && (
                <ListItem sx={{ pl: 4, color: 'error.main' }}>
                  <ListItemText
                    primary="Error:"
                    secondary={scenario.error}
                  />
                </ListItem>
              )}
              
              {index < executionResults.scenarios.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))}
        </List>
      </Paper>
    );
  };
  
  // Extract scenarios from feature content
  const extractScenarios = (content) => {
    const lines = content.split('\n');
    const scenarios = [];
    let currentScenario = null;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      if (trimmedLine.startsWith('Scenario:')) {
        if (currentScenario) {
          scenarios.push(currentScenario);
        }
        currentScenario = {
          name: trimmedLine.substring('Scenario:'.length).trim(),
          steps: []
        };
      } else if (currentScenario && (
        trimmedLine.startsWith('Given ') ||
        trimmedLine.startsWith('When ') ||
        trimmedLine.startsWith('Then ') ||
        trimmedLine.startsWith('And ') ||
        trimmedLine.startsWith('But ')
      )) {
        // Extract the keyword (Given, When, Then, And, But)
        const keyword = trimmedLine.split(' ')[0];
        const text = trimmedLine.substring(keyword.length).trim();
        
        currentScenario.steps.push({
          keyword,
          text
        });
      }
    }
    
    if (currentScenario) {
      scenarios.push(currentScenario);
    }
    
    return scenarios;
  };
  
  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          BDD Testing
        </Typography>
        <Box>
          <Button
            variant="contained"
            startIcon={<DescriptionIcon />}
            onClick={() => {
              setCurrentFeature(null);
              setFeatureForm(initialFeatureState);
              setFeatureFormErrors({});
              setFeatureDialogOpen(true);
            }}
            sx={{ mr: 2 }}
          >
            New Feature
          </Button>
          <Button
            variant="contained"
            startIcon={<AssignmentIcon />}
            onClick={() => {
              setCurrentStepDef(null);
              setStepDefForm(initialStepDefState);
              setStepDefFormErrors({});
              setStepDefDialogOpen(true);
            }}
          >
            New Step Definition
          </Button>
        </Box>
      </Box>
      
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab label="Features" />
          <Tab label="Step Definitions" />
        </Tabs>
      </Paper>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <>
          {currentTab === 0 && (
            <>
              {features.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1" sx={{ mb: 2 }}>
                    No BDD features created yet.
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => {
                      setCurrentFeature(null);
                      setFeatureForm(initialFeatureState);
                      setFeatureFormErrors({});
                      setFeatureDialogOpen(true);
                    }}
                  >
                    Create First Feature
                  </Button>
                </Paper>
              ) : (
                <Grid container spacing={3}>
                  {features.map((feature) => {
                    const scenarios = extractScenarios(feature.content);
                    
                    return (
                      <Grid item xs={12} md={6} lg={4} key={feature.id}>
                        <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                          <CardContent sx={{ flexGrow: 1 }}>
                            <Typography variant="h6" gutterBottom>
                              {feature.name}
                            </Typography>
                            
                            {feature.tags && feature.tags.length > 0 && (
                              <Box sx={{ mb: 2 }}>
                                {feature.tags.map((tag, index) => (
                                  <Chip 
                                    key={index} 
                                    label={tag} 
                                    size="small" 
                                    sx={{ mr: 0.5, mb: 0.5 }}
                                  />
                                ))}
                              </Box>
                            )}
                            
                            {feature.description && (
                              <Typography 
                                variant="body2" 
                                color="text.secondary" 
                                gutterBottom
                                sx={{ mb: 2 }}
                              >
                                {feature.description}
                              </Typography>
                            )}
                            
                            <Typography variant="subtitle2" gutterBottom>
                              Scenarios ({scenarios.length})
                            </Typography>
                            
                            <List dense disablePadding>
                              {scenarios.map((scenario, index) => (
                                <ListItem key={index} disableGutters>
                                  <ListItemText
                                    primary={scenario.name}
                                    secondary={`${scenario.steps.length} steps`}
                                  />
                                </ListItem>
                              ))}
                            </List>
                          </CardContent>
                          <Divider />
                          <CardActions>
                            <IconButton 
                              size="small" 
                              onClick={() => handleExecuteFeature(feature)}
                              disabled={executingFeature}
                            >
                              {executingFeature ? <CircularProgress size={24} /> : <PlayArrowIcon />}
                            </IconButton>
                            <IconButton size="small" onClick={() => handleEditFeature(feature)}>
                              <EditIcon />
                            </IconButton>
                            <IconButton size="small" onClick={() => handleDuplicateFeature(feature)}>
                              <ContentCopyIcon />
                            </IconButton>
                            <IconButton size="small" onClick={() => handleDeleteFeature(feature.id)}>
                              <DeleteIcon />
                            </IconButton>
                          </CardActions>
                        </Card>
                      </Grid>
                    );
                  })}
                </Grid>
              )}
              
              {renderExecutionResults()}
            </>
          )}
          
          {currentTab === 1 && (
            <>
              {stepDefinitions.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1" sx={{ mb: 2 }}>
                    No BDD step definitions created yet.
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => {
                      setCurrentStepDef(null);
                      setStepDefForm(initialStepDefState);
                      setStepDefFormErrors({});
                      setStepDefDialogOpen(true);
                    }}
                  >
                    Create First Step Definition
                  </Button>
                </Paper>
              ) : (
                <Grid container spacing={3}>
                  {stepDefinitions.map((stepDef) => (
                    <Grid item xs={12} md={6} lg={4} key={stepDef.id}>
                      <Card>
                        <CardContent>
                          <Typography variant="h6" gutterBottom>
                            {stepDef.name}
                          </Typography>
                          
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Type:</Typography>
                            <Chip 
                              label={stepDef.stepType} 
                              size="small"
                              color={
                                stepDef.stepType === 'GIVEN' ? 'primary' :
                                stepDef.stepType === 'WHEN' ? 'secondary' : 'default'
                              }
                            />
                          </Box>
                          
                          <Box sx={{ mb: 2 }}>
                            <Typography variant="caption">Pattern:</Typography>
                            <Paper 
                              sx={{ 
                                p: 1, 
                                backgroundColor: '#f8f9fa', 
                                fontFamily: 'monospace',
                                fontSize: '0.9rem'
                              }}
                            >
                              {stepDef.pattern}
                            </Paper>
                          </Box>
                          
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                            <Typography variant="caption" sx={{ mr: 1 }}>Implementation Type:</Typography>
                            <Typography variant="body2">{stepDef.implementationType}</Typography>
                          </Box>
                          
                          <Box>
                            <Typography variant="caption">Implementation:</Typography>
                            <Paper 
                              sx={{ 
                                p: 1, 
                                backgroundColor: '#f8f9fa', 
                                maxHeight: '100px', 
                                overflow: 'auto',
                                fontFamily: 'monospace',
                                fontSize: '0.8rem' 
                              }}
                            >
                              {stepDef.implementation}
                            </Paper>
                          </Box>
                        </CardContent>
                        <CardActions>
                          <IconButton size="small" onClick={() => handleEditStepDef(stepDef)}>
                            <EditIcon />
                          </IconButton>
                          <IconButton size="small" onClick={() => handleDeleteStepDef(stepDef.id)}>
                            <DeleteIcon />
                          </IconButton>
                        </CardActions>
                      </Card>
                    </Grid>
                  ))}
                </Grid>
              )}
            </>
          )}
        </>
      )}
      
      {/* Feature Dialog */}
      <Dialog
        open={featureDialogOpen}
        onClose={() => setFeatureDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentFeature ? 'Edit Feature' : 'New Feature'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Feature Name"
                name="name"
                value={featureForm.name}
                onChange={handleFeatureInputChange}
                error={!!featureFormErrors.name}
                helperText={featureFormErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Tags (comma-separated)"
                name="tags"
                value={featureForm.tags.join(', ')}
                onChange={handleTagsChange}
                placeholder="@ui, @regression, @smoke"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={featureForm.description}
                onChange={handleFeatureInputChange}
                multiline
                rows={2}
              />
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Feature File Content (Gherkin Syntax)
              </Typography>
              <CodeEditor
                value={featureForm.content}
                onChange={(value) => setFeatureForm({ ...featureForm, content: value })}
                language="gherkin"
                height="300px"
                error={!!featureFormErrors.content}
                helperText={featureFormErrors.content}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setFeatureDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleFeatureSubmit} 
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Step Definition Dialog */}
      <Dialog
        open={stepDefDialogOpen}
        onClose={() => setStepDefDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentStepDef ? 'Edit Step Definition' : 'New Step Definition'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Step Definition Name"
                name="name"
                value={stepDefForm.name}
                onChange={handleStepDefInputChange}
                error={!!stepDefFormErrors.name}
                helperText={stepDefFormErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Step Type</InputLabel>
                <Select
                  name="stepType"
                  value={stepDefForm.stepType}
                  onChange={handleStepDefInputChange}
                  label="Step Type"
                >
                  <MenuItem value="GIVEN">Given</MenuItem>
                  <MenuItem value="WHEN">When</MenuItem>
                  <MenuItem value="THEN">Then</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Step Pattern (Regular Expression)"
                name="pattern"
                value={stepDefForm.pattern}
                onChange={handleStepDefInputChange}
                error={!!stepDefFormErrors.pattern}
                helperText={stepDefFormErrors.pattern || "e.g. ^I login with username \"([^\"]*)\" and password \"([^\"]*)\"$"}
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Implementation Type</InputLabel>
                <Select
                  name="implementationType"
                  value={stepDefForm.implementationType}
                  onChange={handleStepDefInputChange}
                  label="Implementation Type"
                >
                  <MenuItem value="JS">JavaScript</MenuItem>
                  <MenuItem value="JAVA">Java</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Implementation
              </Typography>
              <CodeEditor
                value={stepDefForm.implementation}
                onChange={(value) => setStepDefForm({ ...stepDefForm, implementation: value })}
                language={stepDefForm.implementationType === 'JS' ? 'javascript' : 'java'}
                height="200px"
                error={!!stepDefFormErrors.implementation}
                helperText={stepDefFormErrors.implementation}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setStepDefDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleStepDefSubmit} 
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default BDDTesting;


// src/pages/Integrations.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  IconButton,
  Grid,
  Card,
  CardContent,
  CardActions,
  CardHeader,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Divider,
  CircularProgress,
  Switch,
  FormControlLabel,
  Alert,
  Collapse,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Chip
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import SyncIcon from '@mui/icons-material/Sync';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import LinkIcon from '@mui/icons-material/Link';
import DoneIcon from '@mui/icons-material/Done';
import ErrorIcon from '@mui/icons-material/Error';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';
import CodeEditor from '../components/CodeEditor';

const Integrations = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { project } = useProject();
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(true);
  const [integrations, setIntegrations] = useState([]);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentIntegration, setCurrentIntegration] = useState(null);
  const [testingIntegration, setTestingIntegration] = useState(false);
  const [testResults, setTestResults] = useState(null);
  const [expandedIntegration, setExpandedIntegration] = useState(null);

  // Define available integration types
  const integrationTypes = [
    { 
      type: 'JIRA', 
      name: 'Jira',
      description: 'Integrate with Jira for issue tracking and test case management',
      icon: '',
      fields: [
        { name: 'url', label: 'Jira URL', type: 'text', required: true },
        { name: 'username', label: 'Username', type: 'text', required: true },
        { name: 'apiToken', label: 'API Token', type: 'password', required: true },
        { name: 'project', label: 'Jira Project Key', type: 'text', required: true }
      ]
    },
    { 
      type: 'GITHUB', 
      name: 'GitHub',
      description: 'Integrate with GitHub for version control and CI/CD',
      icon: '',
      fields: [
        { name: 'url', label: 'GitHub URL', type: 'text', required: true, defaultValue: 'https://api.github.com' },
        { name: 'accessToken', label: 'Access Token', type: 'password', required: true },
        { name: 'repository', label: 'Repository', type: 'text', required: true, placeholder: 'owner/repo' }
      ]
    },
    { 
      type: 'JENKINS', 
      name: 'Jenkins',
      description: 'Integrate with Jenkins for CI/CD pipelines',
      icon: '',
      fields: [
        { name: 'url', label: 'Jenkins URL', type: 'text', required: true },
        { name: 'username', label: 'Username', type: 'text', required: true },
        { name: 'apiToken', label: 'API Token', type: 'password', required: true },
        { name: 'jobName', label: 'Job Name', type: 'text', required: true }
      ]
    },
    { 
      type: 'SLACK', 
      name: 'Slack',
      description: 'Integrate with Slack for notifications',
      icon: '',
      fields: [
        { name: 'webhookUrl', label: 'Webhook URL', type: 'text', required: true },
        { name: 'channel', label: 'Channel', type: 'text', required: true, placeholder: '#channel' }
      ]
    },
    { 
      type: 'SELENIUM_GRID', 
      name: 'Selenium Grid',
      description: 'Integrate with Selenium Grid for distributed test execution',
      icon: '',
      fields: [
        { name: 'url', label: 'Grid URL', type: 'text', required: true },
        { name: 'maxSessions', label: 'Max Sessions', type: 'number', required: true, defaultValue: 5 }
      ]
    },
    { 
      type: 'CUSTOM_API', 
      name: 'Custom API',
      description: 'Integrate with a custom API',
      icon: '',
      fields: [
        { name: 'url', label: 'API URL', type: 'text', required: true },
        { name: 'method', label: 'HTTP Method', type: 'select', required: true, options: [
          { value: 'GET', label: 'GET' },
          { value: 'POST', label: 'POST' },
          { value: 'PUT', label: 'PUT' },
          { value: 'DELETE', label: 'DELETE' }
        ]},
        { name: 'headers', label: 'Headers (JSON)', type: 'json', required: false },
        { name: 'body', label: 'Body Template (JSON)', type: 'json', required: false }
      ]
    }
  ];
  
  const initialIntegrationState = {
    name: '',
    type: '',
    enabled: true,
    configuration: {}
  };
  
  const [integrationForm, setIntegrationForm] = useState(initialIntegrationState);
  const [formErrors, setFormErrors] = useState({});
  
  // Load integrations on component mount
  useEffect(() => {
    const fetchIntegrations = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/integrations`);
        setIntegrations(response.data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching integrations:', error);
        enqueueSnackbar('Failed to load integrations', { variant: 'error' });
        setLoading(false);
      }
    };
    
    fetchIntegrations();
  }, [projectId, api, enqueueSnackbar]);
  
  const validateForm = () => {
    const errors = {};
    
    if (!integrationForm.name.trim()) {
      errors.name = 'Integration name is required';
    }
    
    if (!integrationForm.type) {
      errors.type = 'Integration type is required';
    }
    
    // Find the selected integration type
    const selectedType = integrationTypes.find(
      type => type.type === integrationForm.type
    );
    
    if (selectedType) {
      // Validate required fields for the selected type
      selectedType.fields.forEach(field => {
        if (field.required && !integrationForm.configuration[field.name]) {
          errors[`configuration.${field.name}`] = `${field.label} is required`;
        }
        
        // Validate JSON fields
        if (field.type === 'json' && integrationForm.configuration[field.name]) {
          try {
            JSON.parse(integrationForm.configuration[field.name]);
          } catch (e) {
            errors[`configuration.${field.name}`] = 'Invalid JSON format';
          }
        }
      });
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const handleSubmit = async () => {
    if (!validateForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentIntegration) {
        // Update existing integration
        response = await api.put(
          `/projects/${projectId}/integrations/${currentIntegration.id}`,
          integrationForm
        );
        
        // Update the integrations list
        setIntegrations(integrations.map(integration => 
          integration.id === currentIntegration.id ? response.data : integration
        ));
        
        enqueueSnackbar('Integration updated successfully', { variant: 'success' });
      } else {
        // Create new integration
        response = await api.post(
          `/projects/${projectId}/integrations`,
          integrationForm
        );
        
        // Add the new integration to the list
        setIntegrations([...integrations, response.data]);
        
        enqueueSnackbar('Integration created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setDialogOpen(false);
      setIntegrationForm(initialIntegrationState);
      setCurrentIntegration(null);
    } catch (error) {
      console.error('Error saving integration:', error);
      enqueueSnackbar('Failed to save integration', { variant: 'error' });
    }
  };
  
  const handleDelete = async (integrationId) => {
    if (window.confirm('Are you sure you want to delete this integration? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/integrations/${integrationId}`);
        
        // Remove the deleted integration from the list
        setIntegrations(integrations.filter(integration => integration.id !== integrationId));
        
        enqueueSnackbar('Integration deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting integration:', error);
        enqueueSnackbar('Failed to delete integration', { variant: 'error' });
      }
    }
  };
  
  const handleEdit = (integration) => {
    setCurrentIntegration(integration);
    setIntegrationForm({
      name: integration.name,
      type: integration.type,
      enabled: integration.enabled,
      configuration: { ...integration.configuration }
    });
    setDialogOpen(true);
  };
  
  const handleTestIntegration = async (integration) => {
    setTestingIntegration(true);
    setTestResults(null);
    
    try {
      const response = await api.post(
        `/projects/${projectId}/integrations/${integration.id}/test`
      );
      
      setTestResults({
        success: response.data.success,
        message: response.data.message,
        details: response.data.details,
        timestamp: new Date().toISOString()
      });
      
      if (response.data.success) {
        enqueueSnackbar('Integration test successful', { variant: 'success' });
      } else {
        enqueueSnackbar('Integration test failed', { variant: 'error' });
      }
    } catch (error) {
      console.error('Error testing integration:', error);
      enqueueSnackbar('Failed to test integration', { variant: 'error' });
      setTestResults({
        success: false,
        message: error.response?.data?.message || 'An error occurred during testing',
        details: error.response?.data?.details || 'No additional details available',
        timestamp: new Date().toISOString()
      });
    } finally {
      setTestingIntegration(false);
    }
  };
  
  const handleToggleEnabled = async (integration) => {
    try {
      const updatedIntegration = {
        ...integration,
        enabled: !integration.enabled
      };
      
      const response = await api.put(
        `/projects/${projectId}/integrations/${integration.id}`,
        updatedIntegration
      );
      
      // Update the integrations list
      setIntegrations(integrations.map(item => 
        item.id === integration.id ? response.data : item
      ));
      
      enqueueSnackbar(`Integration ${response.data.enabled ? 'enabled' : 'disabled'} successfully`, { variant: 'success' });
    } catch (error) {
      console.error('Error updating integration:', error);
      enqueueSnackbar('Failed to update integration', { variant: 'error' });
    }
  };
  
  const handleInputChange = (e) => {
    const { name, value, checked, type } = e.target;
    
    if (name === 'type') {
      // Reset configuration when integration type changes
      const selectedType = integrationTypes.find(type => type.type === value);
      const newConfiguration = {};
      
      if (selectedType) {
        // Set default values for configuration fields
        selectedType.fields.forEach(field => {
          if (field.defaultValue !== undefined) {
            newConfiguration[field.name] = field.defaultValue;
          }
        });
      }
      
      setIntegrationForm({
        ...integrationForm,
        type: value,
        configuration: newConfiguration
      });
    } else if (name === 'enabled') {
      setIntegrationForm({
        ...integrationForm,
        [name]: checked
      });
    } else if (name.startsWith('configuration.')) {
      const fieldName = name.replace('configuration.', '');
      setIntegrationForm({
        ...integrationForm,
        configuration: {
          ...integrationForm.configuration,
          [fieldName]: value
        }
      });
    } else {
      setIntegrationForm({
        ...integrationForm,
        [name]: value
      });
    }
  };

  const handleExpand = (integrationId) => {
    setExpandedIntegration(expandedIntegration === integrationId ? null : integrationId);
    setTestResults(null);
  };
  
  const renderConfigurationFields = () => {
    const selectedType = integrationTypes.find(
      type => type.type === integrationForm.type
    );
    
    if (!selectedType) {
      return null;
    }
    
    return (
      <Grid container spacing={2}>
        {selectedType.fields.map((field) => {
          const fieldName = `configuration.${field.name}`;
          const fieldValue = integrationForm.configuration[field.name] || '';
          const fieldError = formErrors[fieldName];
          
          if (field.type === 'select') {
            return (
              <Grid item xs={12} sm={6} key={field.name}>
                <FormControl 
                  fullWidth 
                  required={field.required}
                  error={!!fieldError}
                >
                  <InputLabel>{field.label}</InputLabel>
                  <Select
                    name={fieldName}
                    value={fieldValue}
                    onChange={handleInputChange}
                    label={field.label}
                  >
                    {field.options.map(option => (
                      <MenuItem key={option.value} value={option.value}>
                        {option.label}
                      </MenuItem>
                    ))}
                  </Select>
                  {fieldError && (
                    <Typography variant="caption" color="error">
                      {fieldError}
                    </Typography>
                  )}
                </FormControl>
              </Grid>
            );
          } else if (field.type === 'json') {
            return (
              <Grid item xs={12} key={field.name}>
                <Typography variant="subtitle2" gutterBottom>
                  {field.label}
                  {field.required && ' *'}
                </Typography>
                <CodeEditor
                  value={fieldValue}
                  onChange={(value) => {
                    handleInputChange({
                      target: {
                        name: fieldName,
                        value
                      }
                    });
                  }}
                  language="json"
                  height="150px"
                  error={!!fieldError}
                  helperText={fieldError}
                />
              </Grid>
            );
          } else {
            return (
              <Grid item xs={12} sm={6} key={field.name}>
                <TextField
                  fullWidth
                  label={field.label}
                  name={fieldName}
                  type={field.type}
                  value={fieldValue}
                  onChange={handleInputChange}
                  required={field.required}
                  error={!!fieldError}
                  helperText={fieldError}
                  placeholder={field.placeholder}
                />
              </Grid>
            );
          }
        })}
      </Grid>
    );
  };
  
  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Integrations
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => {
            setCurrentIntegration(null);
            setIntegrationForm(initialIntegrationState);
            setFormErrors({});
            setDialogOpen(true);
          }}
        >
          New Integration
        </Button>
      </Box>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <>
          {integrations.length === 0 ? (
            <Paper sx={{ p: 3, textAlign: 'center' }}>
              <Typography variant="body1" sx={{ mb: 2 }}>
                No integrations configured yet.
              </Typography>
              <Button
                variant="contained"
                startIcon={<AddIcon />}
                onClick={() => {
                  setCurrentIntegration(null);
                  setIntegrationForm(initialIntegrationState);
                  setFormErrors({});
                  setDialogOpen(true);
                }}
              >
                Configure First Integration
              </Button>
            </Paper>
          ) : (
            <Grid container spacing={3}>
              {integrations.map((integration) => {
                const integrationType = integrationTypes.find(
                  type => type.type === integration.type
                );
                
                return (
                  <Grid item xs={12} md={6} key={integration.id}>
                    <Card>
                      <CardHeader
                        avatar={
                          <Box sx={{ fontSize: '1.5rem' }}>
                            {integrationType?.icon || ''}
                          </Box>
                        }
                        action={
                          <FormControlLabel
                            control={
                              <Switch
                                checked={integration.enabled}
                                onChange={() => handleToggleEnabled(integration)}
                                color="primary"
                              />
                            }
                            label={integration.enabled ? 'Enabled' : 'Disabled'}
                          />
                        }
                        title={
                          <Typography variant="h6">
                            {integration.name}
                            {!integration.enabled && (
                              <Chip
                                label="Disabled"
                                size="small"
                                color="default"
                                sx={{ ml: 1 }}
                              />
                            )}
                          </Typography>
                        }
                        subheader={integrationType?.name || 'Custom Integration'}
                      />
                      <CardContent>
                        <Typography variant="body2" color="text.secondary" gutterBottom>
                          {integrationType?.description || 'Custom integration with external system'}
                        </Typography>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
                          <Button
                            size="small"
                            endIcon={expandedIntegration === integration.id ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                            onClick={() => handleExpand(integration.id)}
                          >
                            {expandedIntegration === integration.id ? 'Hide Details' : 'Show Details'}
                          </Button>
                        </Box>
                        
                        <Collapse in={expandedIntegration === integration.id}>
                          <Box sx={{ mb: 2 }}>
                            <Typography variant="subtitle2" gutterBottom>
                              Configuration Details
                            </Typography>
                            
                            <Paper 
                              variant="outlined" 
                              sx={{ p: 1, backgroundColor: '#f8f9fa' }}
                            >
                              <List dense disablePadding>
                                {Object.entries(integration.configuration).map(([key, value]) => (
                                  <ListItem key={key} disableGutters>
                                    <ListItemText
                                      primary={
                                        <Typography variant="body2">
                                          <strong>{key}:</strong> {
                                            key.toLowerCase().includes('password') ||
                                            key.toLowerCase().includes('token') ||
                                            key.toLowerCase().includes('secret')
                                              ? ''
                                              : value
                                          }
                                        </Typography>
                                      }
                                    />
                                  </ListItem>
                                ))}
                              </List>
                            </Paper>
                          </Box>
                          
                          <Button
                            variant="outlined"
                            startIcon={testingIntegration ? <CircularProgress size={20} /> : <SyncIcon />}
                            onClick={() => handleTestIntegration(integration)}
                            disabled={testingIntegration || !integration.enabled}
                            sx={{ mb: 2 }}
                          >
                            Test Connection
                          </Button>
                          
                          {testResults && expandedIntegration === integration.id && (
                            <Alert 
                              severity={testResults.success ? 'success' : 'error'}
                              sx={{ mb: 2 }}
                            >
                              <Typography variant="body2" gutterBottom>
                                <strong>{testResults.message}</strong>
                              </Typography>
                              {testResults.details && (
                                <Typography variant="caption" component="div">
                                  {testResults.details}
                                </Typography>
                              )}
                              <Typography variant="caption" component="div">
                                {new Date(testResults.timestamp).toLocaleString()}
                              </Typography>
                            </Alert>
                          )}
                          
                        </Collapse>
                      </CardContent>
                      <Divider />
                      <CardActions>
                        <IconButton size="small" onClick={() => handleEdit(integration)}>
                          <EditIcon />
                        </IconButton>
                        <IconButton size="small" onClick={() => handleDelete(integration.id)}>
                          <DeleteIcon />
                        </IconButton>
                      </CardActions>
                    </Card>
                  </Grid>
                );
              })}
            </Grid>
          )}
        </>
      )}
      
      {/* Integration Dialog */}
      <Dialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentIntegration ? 'Edit Integration' : 'New Integration'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Integration Name"
                name="name"
                value={integrationForm.name}
                onChange={handleInputChange}
                error={!!formErrors.name}
                helperText={formErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required error={!!formErrors.type}>
                <InputLabel>Integration Type</InputLabel>
                <Select
                  name="type"
                  value={integrationForm.type}
                  onChange={handleInputChange}
                  label="Integration Type"
                >
                  {integrationTypes.map((type) => (
                    <MenuItem key={type.type} value={type.type}>
                      {type.icon} {type.name}
                    </MenuItem>
                  ))}
                </Select>
                {formErrors.type && (
                  <Typography variant="caption" color="error">
                    {formErrors.type}
                  </Typography>
                )}
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={integrationForm.enabled}
                    onChange={handleInputChange}
                    name="enabled"
                    color="primary"
                  />
                }
                label="Enable Integration"
              />
            </Grid>
            
            {integrationForm.type && (
              <Grid item xs={12}>
                <Typography variant="subtitle1" gutterBottom>
                  Configuration
                </Typography>
                <Divider sx={{ mb: 2 }} />
                {renderConfigurationFields()}
              </Grid>
            )}
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleSubmit} 
            variant="contained"
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default Integrations;


// src/pages/TestSuites.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  IconButton,
  Grid,
  Card,
  CardContent,
  CardActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Divider,
  CircularProgress,
  Checkbox,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemSecondaryAction,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  Tooltip,
  Tab,
  Tabs
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import DragIndicatorIcon from '@mui/icons-material/DragIndicator';
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';

const TestSuites = () => {
  const navigate = useNavigate();
  const { projectId } = useParams();
  const { project } = useProject();
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(true);
  const [testSuites, setTestSuites] = useState([]);
  const [testCases, setTestCases] = useState([]);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [currentTestSuite, setCurrentTestSuite] = useState(null);
  const [executingTestSuite, setExecutingTestSuite] = useState(false);
  const [currentTab, setCurrentTab] = useState(0);
  const [testSuiteResults, setTestSuiteResults] = useState([]);
  
  const initialTestSuiteState = {
    name: '',
    description: '',
    tags: [],
    parallel: false,
    retries: 0,
    timeout: 300000, // 5 minutes in milliseconds
    browser: 'CHROME',
    testCaseIds: []
  };
  
  const [testSuiteForm, setTestSuiteForm] = useState(initialTestSuiteState);
  const [formErrors, setFormErrors] = useState({});
  
  // Load test suites, test cases, and execution results on component mount
  useEffect(() => {
    const fetchTestSuites = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/test-suites`);
        setTestSuites(response.data);
      } catch (error) {
        console.error('Error fetching test suites:', error);
        enqueueSnackbar('Failed to load test suites', { variant: 'error' });
      }
    };
    
    const fetchTestCases = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/test-cases`);
        setTestCases(response.data);
      } catch (error) {
        console.error('Error fetching test cases:', error);
        enqueueSnackbar('Failed to load test cases', { variant: 'error' });
      }
    };
    
    const fetchExecutionResults = async () => {
      try {
        const response = await api.get(`/projects/${projectId}/executions`);
        setTestSuiteResults(response.data);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching execution results:', error);
        enqueueSnackbar('Failed to load execution results', { variant: 'error' });
        setLoading(false);
      }
    };
    
    fetchTestSuites();
    fetchTestCases();
    fetchExecutionResults();
  }, [projectId, api, enqueueSnackbar]);
  
  const validateForm = () => {
    const errors = {};
    
    if (!testSuiteForm.name.trim()) {
      errors.name = 'Test suite name is required';
    }
    
    if (!testSuiteForm.testCaseIds || testSuiteForm.testCaseIds.length === 0) {
      errors.testCaseIds = 'At least one test case must be selected';
    }
    
    if (testSuiteForm.timeout <= 0) {
      errors.timeout = 'Timeout must be greater than 0';
    }
    
    if (testSuiteForm.retries < 0) {
      errors.retries = 'Retries cannot be negative';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const handleSubmit = async () => {
    if (!validateForm()) {
      return;
    }
    
    try {
      let response;
      
      if (currentTestSuite) {
        // Update existing test suite
        response = await api.put(
          `/projects/${projectId}/test-suites/${currentTestSuite.id}`,
          testSuiteForm
        );
        
        // Update the test suites list
        setTestSuites(testSuites.map(suite => 
          suite.id === currentTestSuite.id ? response.data : suite
        ));
        
        enqueueSnackbar('Test suite updated successfully', { variant: 'success' });
      } else {
        // Create new test suite
        response = await api.post(
          `/projects/${projectId}/test-suites`,
          testSuiteForm
        );
        
        // Add the new test suite to the list
        setTestSuites([...testSuites, response.data]);
        
        enqueueSnackbar('Test suite created successfully', { variant: 'success' });
      }
      
      // Close the dialog and reset the form
      setDialogOpen(false);
      setTestSuiteForm(initialTestSuiteState);
      setCurrentTestSuite(null);
    } catch (error) {
      console.error('Error saving test suite:', error);
      enqueueSnackbar('Failed to save test suite', { variant: 'error' });
    }
  };
  
  const handleDelete = async (testSuiteId) => {
    if (window.confirm('Are you sure you want to delete this test suite? This action cannot be undone.')) {
      try {
        await api.delete(`/projects/${projectId}/test-suites/${testSuiteId}`);
        
        // Remove the deleted test suite from the list
        setTestSuites(testSuites.filter(suite => suite.id !== testSuiteId));
        
        enqueueSnackbar('Test suite deleted successfully', { variant: 'success' });
      } catch (error) {
        console.error('Error deleting test suite:', error);
        enqueueSnackbar('Failed to delete test suite', { variant: 'error' });
      }
    }
  };
  
  const handleEdit = (testSuite) => {
    setCurrentTestSuite(testSuite);
    setTestSuiteForm({
      name: testSuite.name,
      description: testSuite.description || '',
      tags: testSuite.tags || [],
      parallel: testSuite.parallel || false,
      retries: testSuite.retries || 0,
      timeout: testSuite.timeout || 300000,
      browser: testSuite.browser || 'CHROME',
      testCaseIds: testSuite.testCaseIds || []
    });
    setDialogOpen(true);
  };
  
  const handleExecuteTestSuite = async (testSuite) => {
    setExecutingTestSuite(true);
    
    try {
      const response = await api.post(
        `/projects/${projectId}/test-suites/${testSuite.id}/execute`
      );
      
      // Add the new execution result to the list
      setTestSuiteResults([response.data, ...testSuiteResults]);
      
      enqueueSnackbar('Test suite execution started', { variant: 'success' });
      
      // Switch to the Results tab
      setCurrentTab(1);
    } catch (error) {
      console.error('Error executing test suite:', error);
      enqueueSnackbar('Failed to execute test suite', { variant: 'error' });
    } finally {
      setExecutingTestSuite(false);
    }
  };
  
  const handleDuplicateTestSuite = async (testSuite) => {
    const duplicatedTestSuite = {
      ...testSuite,
      name: `${testSuite.name} (Copy)`,
      id: undefined
    };
    
    try {
      const response = await api.post(
        `/projects/${projectId}/test-suites`,
        duplicatedTestSuite
      );
      
      // Add the duplicated test suite to the list
      setTestSuites([...testSuites, response.data]);
      
      enqueueSnackbar('Test suite duplicated successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error duplicating test suite:', error);
      enqueueSnackbar('Failed to duplicate test suite', { variant: 'error' });
    }
  };
  
  const handleInputChange = (e) => {
    const { name, value, checked, type } = e.target;
    
    if (type === 'checkbox') {
      setTestSuiteForm({
        ...testSuiteForm,
        [name]: checked
      });
    } else {
      setTestSuiteForm({
        ...testSuiteForm,
        [name]: value
      });
    }
  };
  
  const handleTagsChange = (e) => {
    const value = e.target.value;
    // Split the comma-separated tags and trim whitespace
    const tags = value.split(',').map(tag => tag.trim()).filter(tag => tag);
    setTestSuiteForm({
      ...testSuiteForm,
      tags
    });
  };
  
  const handleTestCaseToggle = (testCaseId) => {
    const currentTestCaseIds = [...testSuiteForm.testCaseIds];
    const index = currentTestCaseIds.indexOf(testCaseId);
    
    if (index === -1) {
      // Add test case to the list
      currentTestCaseIds.push(testCaseId);
    } else {
      // Remove test case from the list
      currentTestCaseIds.splice(index, 1);
    }
    
    setTestSuiteForm({
      ...testSuiteForm,
      testCaseIds: currentTestCaseIds
    });
  };
  
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };

  const getLatestResult = (testSuiteId) => {
    return testSuiteResults.find(result => result.testSuiteId === testSuiteId);
  };
  
  const formatDuration = (durationMs) => {
    if (durationMs < 1000) {
      return `${durationMs}ms`;
    } else if (durationMs < 60000) {
      return `${(durationMs / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(durationMs / 60000);
      const seconds = ((durationMs % 60000) / 1000).toFixed(0);
      return `${minutes}m ${seconds}s`;
    }
  };
  
  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Test Suites
        </Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => {
            setCurrentTestSuite(null);
            setTestSuiteForm(initialTestSuiteState);
            setFormErrors({});
            setDialogOpen(true);
          }}
        >
          New Test Suite
        </Button>
      </Box>
      
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab label="Test Suites" />
          <Tab label="Execution Results" />
        </Tabs>
      </Paper>
      
      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <>
          {currentTab === 0 && (
            <>
              {testSuites.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1" sx={{ mb: 2 }}>
                    No test suites created yet.
                  </Typography>
                  <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => {
                      setCurrentTestSuite(null);
                      setTestSuiteForm(initialTestSuiteState);
                      setFormErrors({});
                      setDialogOpen(true);
                    }}
                  >
                    Create First Test Suite
                  </Button>
                </Paper>
              ) : (
                <Grid container spacing={3}>
                  {testSuites.map((testSuite) => {
                    const latestResult = getLatestResult(testSuite.id);
                    const testCasesInSuite = testCases.filter(
                      tc => testSuite.testCaseIds.includes(tc.id)
                    );
                    
                    return (
                      <Grid item xs={12} md={6} lg={4} key={testSuite.id}>
                        <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                          <CardContent sx={{ flexGrow: 1 }}>
                            <Box 
                              sx={{ 
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'flex-start',
                                mb: 1
                              }}
                            >
                              <Typography variant="h6" gutterBottom>
                                {testSuite.name}
                              </Typography>
                              
                              {latestResult && (
                                <Tooltip 
                                  title={`Last run: ${new Date(latestResult.timestamp).toLocaleString()}`}
                                >
                                  <Chip
                                    icon={
                                      latestResult.status === 'PASSED' ? <CheckCircleOutlineIcon /> :
                                      latestResult.status === 'FAILED' ? <ErrorOutlineIcon /> :
                                      <AccessTimeIcon />
                                    }
                                    label={latestResult.status}
                                    color={
                                      latestResult.status === 'PASSED' ? 'success' :
                                      latestResult.status === 'FAILED' ? 'error' :
                                      'warning'
                                    }
                                    size="small"
                                  />
                                </Tooltip>
                              )}
                            </Box>
                            
                            {testSuite.tags && testSuite.tags.length > 0 && (
                              <Box sx={{ mb: 2 }}>
                                {testSuite.tags.map((tag, index) => (
                                  <Chip 
                                    key={index} 
                                    label={tag} 
                                    size="small" 
                                    sx={{ mr: 0.5, mb: 0.5 }}
                                  />
                                ))}
                              </Box>
                            )}
                            
                            {testSuite.description && (
                              <Typography 
                                variant="body2" 
                                color="text.secondary" 
                                gutterBottom
                                sx={{ mb: 2 }}
                              >
                                {testSuite.description}
                              </Typography>
                            )}
                            
                            <Box sx={{ mt: 2 }}>
                              <Typography variant="subtitle2" gutterBottom>
                                Configuration
                              </Typography>
                              <Grid container spacing={1}>
                                <Grid item xs={6}>
                                  <Typography variant="caption" display="block">
                                    Browser: {testSuite.browser || 'CHROME'}
                                  </Typography>
                                </Grid>
                                <Grid item xs={6}>
                                  <Typography variant="caption" display="block">
                                    Parallel: {testSuite.parallel ? 'Yes' : 'No'}
                                  </Typography>
                                </Grid>
                                <Grid item xs={6}>
                                  <Typography variant="caption" display="block">
                                    Retries: {testSuite.retries || 0}
                                  </Typography>
                                </Grid>
                                <Grid item xs={6}>
                                  <Typography variant="caption" display="block">
                                    Timeout: {formatDuration(testSuite.timeout || 300000)}
                                  </Typography>
                                </Grid>
                              </Grid>
                            </Box>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            <Typography variant="subtitle2" gutterBottom>
                              Test Cases ({testCasesInSuite.length})
                            </Typography>
                            
                            <List dense disablePadding sx={{ maxHeight: '150px', overflow: 'auto' }}>
                              {testCasesInSuite.map((testCase) => (
                                <ListItem key={testCase.id} disableGutters>
                                  <ListItemIcon sx={{ minWidth: 24 }}>
                                    <DragIndicatorIcon fontSize="small" />
                                  </ListItemIcon>
                                  <ListItemText
                                    primary={testCase.name}
                                  />
                                </ListItem>
                              ))}
                              {testCasesInSuite.length === 0 && (
                                <ListItem disableGutters>
                                  <ListItemText
                                    primary="No test cases selected"
                                    primaryTypographyProps={{ color: 'text.secondary', fontStyle: 'italic' }}
                                  />
                                </ListItem>
                              )}
                            </List>
                          </CardContent>
                          <Divider />
                          <CardActions>
                            <IconButton 
                              size="small" 
                              onClick={() => handleExecuteTestSuite(testSuite)}
                              disabled={executingTestSuite || testCasesInSuite.length === 0}
                            >
                              {executingTestSuite ? <CircularProgress size={24} /> : <PlayArrowIcon />}
                            </IconButton>
                            <IconButton size="small" onClick={() => handleEdit(testSuite)}>
                              <EditIcon />
                            </IconButton>
                            <IconButton size="small" onClick={() => handleDuplicateTestSuite(testSuite)}>
                              <ContentCopyIcon />
                            </IconButton>
                            <IconButton size="small" onClick={() => handleDelete(testSuite.id)}>
                              <DeleteIcon />
                            </IconButton>
                          </CardActions>
                        </Card>
                      </Grid>
                    );
                  })}
                </Grid>
              )}
            </>
          )}
          
          {currentTab === 1 && (
            <>
              {testSuiteResults.length === 0 ? (
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                  <Typography variant="body1">
                    No test suite executions found.
                  </Typography>
                </Paper>
              ) : (
                <Box>
                  {testSuiteResults.map((result) => {
                    const testSuite = testSuites.find(suite => suite.id === result.testSuiteId);
                    
                    return (
                      <Accordion key={result.id} sx={{ mb: 2 }}>
                        <AccordionSummary
                          expandIcon={<ExpandMoreIcon />}
                        >
                          <Grid container alignItems="center" spacing={2}>
                            <Grid item>
                              {result.status === 'PASSED' && (
                                <CheckCircleOutlineIcon color="success" />
                              )}
                              {result.status === 'FAILED' && (
                                <ErrorOutlineIcon color="error" />
                              )}
                              {result.status === 'RUNNING' && (
                                <CircularProgress size={24} />
                              )}
                            </Grid>
                            <Grid item xs>
                              <Typography variant="subtitle1">
                                {testSuite ? testSuite.name : 'Unknown Test Suite'}
                              </Typography>
                              <Typography variant="caption" color="text.secondary">
                                {new Date(result.timestamp).toLocaleString()} - 
                                Duration: {formatDuration(result.duration || 0)}
                              </Typography>
                            </Grid>
                            <Grid item>
                              <Chip
                                label={`${result.passedCount || 0}/${result.totalCount || 0} Passed`}
                                color={result.status === 'PASSED' ? 'success' : 'default'}
                                size="small"
                              />
                            </Grid>
                          </Grid>
                        </AccordionSummary>
                        <AccordionDetails>
                          <List>
                            {result.testCaseResults && result.testCaseResults.map((tcResult) => {
                              const testCase = testCases.find(tc => tc.id === tcResult.testCaseId);
                              
                              return (
                                <Paper key={tcResult.id} variant="outlined" sx={{ mb: 2, p: 1 }}>
                                  <Box 
                                    sx={{ 
                                      display: 'flex', 
                                      justifyContent: 'space-between',
                                      alignItems: 'center',
                                      mb: 1
                                    }}
                                  >
                                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                      {tcResult.status === 'PASSED' && (
                                        <CheckCircleOutlineIcon color="success" sx={{ mr: 1 }} />
                                      )}
                                      {tcResult.status === 'FAILED' && (
                                        <ErrorOutlineIcon color="error" sx={{ mr: 1 }} />
                                      )}
                                      {tcResult.status === 'RUNNING' && (
                                        <CircularProgress size={20} sx={{ mr: 1 }} />
                                      )}
                                      <Typography variant="subtitle2">
                                        {testCase ? testCase.name : 'Unknown Test Case'}
                                      </Typography>
                                    </Box>
                                    <Typography variant="caption" color="text.secondary">
                                      Duration: {formatDuration(tcResult.duration || 0)}
                                    </Typography>
                                  </Box>
                                  
                                  {tcResult.errorMessage && (
                                    <Paper 
                                      sx={{ 
                                        p: 1, 
                                        backgroundColor: '#fff8f8', 
                                        border: '1px solid #ffcdd2',
                                        mb: 1
                                      }}
                                    >
                                      <Typography variant="caption" component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                                        {tcResult.errorMessage}
                                      </Typography>
                                    </Paper>
                                  )}
                                  
                                  {tcResult.stepResults && (
                                    <List dense disablePadding>
                                      {tcResult.stepResults.map((stepResult, index) => (
                                        <ListItem 
                                          key={index}
                                          disablePadding
                                          sx={{ 
                                            pl: 1,
                                            py: 0.5,
                                            borderLeft: stepResult.status === 'PASSED' 
                                              ? '3px solid #4caf50' 
                                              : stepResult.status === 'FAILED'
                                                ? '3px solid #f44336'
                                                : 'none'
                                          }}
                                        >
                                          <ListItemText
                                            primary={stepResult.description || `Step ${index + 1}`}
                                            secondary={
                                              <>
                                                {stepResult.status} - {formatDuration(stepResult.duration || 0)}
                                                {stepResult.error && (
                                                  <Typography 
                                                    variant="caption" 
                                                    component="div"
                                                    color="error"
                                                    sx={{ mt: 0.5 }}
                                                  >
                                                    {stepResult.error}
                                                  </Typography>
                                                )}
                                              </>
                                            }
                                          />
                                        </ListItem>
                                      ))}
                                    </List>
                                  )}
                                </Paper>
                              );
                            })}
                          </List>
                        </AccordionDetails>
                      </Accordion>
                    );
                  })}
                </Box>
              )}
            </>
          )}
        </>
      )}
      
      {/* Test Suite Dialog */}
      <Dialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {currentTestSuite ? 'Edit Test Suite' : 'New Test Suite'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Test Suite Name"
                name="name"
                value={testSuiteForm.name}
                onChange={handleInputChange}
                error={!!formErrors.name}
                helperText={formErrors.name}
                required
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Tags (comma-separated)"
                name="tags"
                value={testSuiteForm.tags.join(', ')}
                onChange={handleTagsChange}
                placeholder="regression, smoke, ui"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={testSuiteForm.description}
                onChange={handleInputChange}
                multiline
                rows={2}
              />
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle1" gutterBottom>
                Configuration
              </Typography>
              <Divider sx={{ mb: 2 }} />
              
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <FormControl fullWidth>
                    <InputLabel>Browser</InputLabel>
                    <Select
                      name="browser"
                      value={testSuiteForm.browser}
                      onChange={handleInputChange}
                      label="Browser"
                    >
                      <MenuItem value="CHROME">Chrome</MenuItem>
                      <MenuItem value="FIREFOX">Firefox</MenuItem>
                      <MenuItem value="EDGE">Edge</MenuItem>
                      <MenuItem value="SAFARI">Safari</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={testSuiteForm.parallel}
                        onChange={handleInputChange}
                        name="parallel"
                        color="primary"
                      />
                    }
                    label="Run Tests in Parallel"
                  />
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Retries"
                    name="retries"
                    type="number"
                    value={testSuiteForm.retries}
                    onChange={handleInputChange}
                    InputProps={{ inputProps: { min: 0 } }}
                    error={!!formErrors.retries}
                    helperText={formErrors.retries}
                  />
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Timeout (ms)"
                    name="timeout"
                    type="number"
                    value={testSuiteForm.timeout}
                    onChange={handleInputChange}
                    InputProps={{ inputProps: { min: 1000 } }}
                    error={!!formErrors.timeout}
                    helperText={formErrors.timeout}
                  />
                </Grid>
              </Grid>
            </Grid>
            
            <Grid item xs={12}>
              <Typography variant="subtitle1" gutterBottom>
                Test Cases
              </Typography>
              <Divider sx={{ mb: 2 }} />
              
              {testCases.length === 0 ? (
                <Typography variant="body2" color="text.secondary">
                  No test cases available. Please create test cases first.
                </Typography>
              ) : (
                <>
                  {formErrors.testCaseIds && (
                    <Typography variant="caption" color="error" sx={{ mb: 2, display: 'block' }}>
                      {formErrors.testCaseIds}
                    </Typography>
                  )}
                  
                  <Paper variant="outlined" sx={{ maxHeight: '300px', overflow: 'auto' }}>
                    <List dense disablePadding>
                      {testCases.map((testCase) => (
                        <ListItem key={testCase.id} divider>
                          <ListItemIcon>
                            <Checkbox
                              edge="start"
                              checked={testSuiteForm.testCaseIds.includes(testCase.id)}
                              onChange={() => handleTestCaseToggle(testCase.id)}
                              tabIndex={-1}
                              disableRipple
                            />
                          </ListItemIcon>
                          <ListItemText
                            primary={testCase.name}
                            secondary={
                              <>
                                {testCase.description && (
                                  <Typography variant="caption" component="span" display="block">
                                    {testCase.description}
                                  </Typography>
                                )}
                                <Box sx={{ mt: 0.5 }}>
                                  {testCase.tags?.map((tag, index) => (
                                    <Chip 
                                      key={index} 
                                      label={tag} 
                                      size="small" 
                                      sx={{ mr: 0.5, mb: 0.5 }}
                                    />
                                  ))}
                                </Box>
                              </>
                            }
                          />
                        </ListItem>
                      ))}
                    </List>
                  </Paper>
                </>
              )}
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setDialogOpen(false)}
          >
            Cancel
          </Button>
          <Button 
            onClick={handleSubmit} 
            variant="contained"
            disabled={testCases.length === 0}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default TestSuites;


// src/pages/Login.jsx
import React, { useState } from 'react';
import { useNavigate, useLocation, Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  Link,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress
} from '@mui/material';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import LockOutlinedIcon from '@mui/icons-material/LockOutlined';
import { useAuth } from '../contexts/AuthContext';
import logo from '../assets/logo.png';

const Login = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { login } = useAuth();
  
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  });
  
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  // Check if user was redirected from another page
  const from = location.state?.from?.pathname || '/';
  
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };
  
  const handleTogglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Simple validation
    if (!formData.username.trim() || !formData.password) {
      setError('Username and password are required');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      await login(formData.username, formData.password);
      
      // Redirect user to the page they were trying to access or to the dashboard
      navigate(from, { replace: true });
    } catch (err) {
      console.error('Login error:', err);
      setError(err.response?.data?.message || 'Invalid username or password');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        padding: 3,
        backgroundColor: '#f5f5f5'
      }}
    >
      <Paper
        elevation={3}
        sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          p: 4,
          maxWidth: 400,
          width: '100%'
        }}
      >
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            mb: 3
          }}
        >
          <img src={logo} alt="CSTestForge Logo" height="60" />
          <Typography component="h1" variant="h5" sx={{ mt: 2 }}>
            CSTestForge
          </Typography>
          <Typography variant="subtitle1" color="text.secondary">
            Test Automation Platform
          </Typography>
        </Box>
        
        {error && (
          <Alert severity="error" sx={{ width: '100%', mb: 2 }}>
            {error}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="username"
            label="Username"
            name="username"
            autoComplete="username"
            autoFocus
            value={formData.username}
            onChange={handleInputChange}
            disabled={loading}
          />
          
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type={showPassword ? 'text' : 'password'}
            id="password"
            autoComplete="current-password"
            value={formData.password}
            onChange={handleInputChange}
            disabled={loading}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    aria-label="toggle password visibility"
                    onClick={handleTogglePasswordVisibility}
                    edge="end"
                  >
                    {showPassword ? <VisibilityOff /> : <Visibility />}
                  </IconButton>
                </InputAdornment>
              )
            }}
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
            disabled={loading}
          >
            {loading ? <CircularProgress size={24} /> : 'Sign In'}
          </Button>
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
            <Link component={RouterLink} to="/forgot-password" variant="body2">
              Forgot password?
            </Link>
            <Link component={RouterLink} to="/register" variant="body2">
              {"Don't have an account? Sign Up"}
            </Link>
          </Box>
        </Box>
      </Paper>
      
      <Typography variant="body2" color="text.secondary" sx={{ mt: 4 }}>
         {new Date().getFullYear()} CSTestForge. All rights reserved.
      </Typography>
    </Box>
  );
};

export default Login;


// src/pages/Register.jsx
import React, { useState } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  Link,
  InputAdornment,
  IconButton,
  Alert,
  CircularProgress,
  Stepper,
  Step,
  StepLabel,
  FormControlLabel,
  Checkbox
} from '@mui/material';
import Visibility from '@mui/icons-material/Visibility';
import VisibilityOff from '@mui/icons-material/VisibilityOff';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import { useAuth } from '../contexts/AuthContext';
import { useApi } from '../contexts/ApiContext';
import logo from '../assets/logo.png';

const Register = () => {
  const navigate = useNavigate();
  const { register } = useAuth();
  const { api } = useApi();
  
  const [activeStep, setActiveStep] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    username: '',
    password: '',
    confirmPassword: '',
    company: '',
    jobTitle: '',
    agreeToTerms: false
  });
  
  const [formErrors, setFormErrors] = useState({});
  
  const steps = [
    'Account Information',
    'Personal Details',
    'Terms and Conditions'
  ];
  
  const handleInputChange = (e) => {
    const { name, value, checked, type } = e.target;
    
    setFormData({
      ...formData,
      [name]: type === 'checkbox' ? checked : value
    });
    
    // Clear error for the field when user types
    if (formErrors[name]) {
      setFormErrors({
        ...formErrors,
        [name]: ''
      });
    }
  };
  
  const handleTogglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };
  
  const handleToggleConfirmPasswordVisibility = () => {
    setShowConfirmPassword(!showConfirmPassword);
  };
  
  const validateStep = (step) => {
    const errors = {};
    
    if (step === 0) {
      // Validate account information
      if (!formData.username.trim()) {
        errors.username = 'Username is required';
      } else if (formData.username.length < 3) {
        errors.username = 'Username must be at least 3 characters long';
      }
      
      if (!formData.email.trim()) {
        errors.email = 'Email is required';
      } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
        errors.email = 'Email is invalid';
      }
      
      if (!formData.password) {
        errors.password = 'Password is required';
      } else if (formData.password.length < 8) {
        errors.password = 'Password must be at least 8 characters long';
      }
      
      if (!formData.confirmPassword) {
        errors.confirmPassword = 'Please confirm your password';
      } else if (formData.password !== formData.confirmPassword) {
        errors.confirmPassword = 'Passwords do not match';
      }
    } else if (step === 1) {
      // Validate personal details
      if (!formData.firstName.trim()) {
        errors.firstName = 'First name is required';
      }
      
      if (!formData.lastName.trim()) {
        errors.lastName = 'Last name is required';
      }
    } else if (step === 2) {
      // Validate terms and conditions
      if (!formData.agreeToTerms) {
        errors.agreeToTerms = 'You must agree to the terms and conditions';
      }
    }
    
    return errors;
  };
  
  const handleNext = () => {
    const errors = validateStep(activeStep);
    
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    setActiveStep((prevStep) => prevStep + 1);
  };
  
  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const errors = validateStep(activeStep);
    
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // Register the user
      await register({
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        username: formData.username,
        password: formData.password,
        company: formData.company,
        jobTitle: formData.jobTitle
      });
      
      // Navigate to login page after successful registration
      navigate('/login', { 
        state: { 
          registrationSuccess: true,
          message: 'Registration successful! Please log in with your credentials.'
        } 
      });
    } catch (err) {
      console.error('Registration error:', err);
      setError(err.response?.data?.message || 'Registration failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  // Render the current step content
  const renderStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="Username"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleInputChange}
              error={!!formErrors.username}
              helperText={formErrors.username}
              disabled={loading}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleInputChange}
              error={!!formErrors.email}
              helperText={formErrors.email}
              disabled={loading}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleInputChange}
              error={!!formErrors.password}
              helperText={formErrors.password}
              disabled={loading}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={handleTogglePasswordVisibility}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                )
              }}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type={showConfirmPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleInputChange}
              error={!!formErrors.confirmPassword}
              helperText={formErrors.confirmPassword}
              disabled={loading}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={handleToggleConfirmPasswordVisibility}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                )
              }}
            />
          </>
        );
        
      case 1:
        return (
          <>
            <TextField
              margin="normal"
              required
              fullWidth
              id="firstName"
              label="First Name"
              name="firstName"
              autoComplete="given-name"
              value={formData.firstName}
              onChange={handleInputChange}
              error={!!formErrors.firstName}
              helperText={formErrors.firstName}
              disabled={loading}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              id="lastName"
              label="Last Name"
              name="lastName"
              autoComplete="family-name"
              value={formData.lastName}
              onChange={handleInputChange}
              error={!!formErrors.lastName}
              helperText={formErrors.lastName}
              disabled={loading}
            />
            
            <TextField
              margin="normal"
              fullWidth
              id="company"
              label="Company"
              name="company"
              autoComplete="organization"
              value={formData.company}
              onChange={handleInputChange}
              disabled={loading}
            />
            
            <TextField
              margin="normal"
              fullWidth
              id="jobTitle"
              label="Job Title"
              name="jobTitle"
              autoComplete="organization-title"
              value={formData.jobTitle}
              onChange={handleInputChange}
              disabled={loading}
            />
          </>
        );
        
      case 2:
        return (
          <>
            <Typography variant="body1" gutterBottom>
              Terms and Conditions
            </Typography>
            
            <Paper
              variant="outlined"
              sx={{
                p: 2,
                maxHeight: 200,
                overflow: 'auto',
                my: 2,
                bgcolor: '#f5f5f5'
              }}
            >
              <Typography variant="body2">
                By creating an account on CSTestForge, you agree to our Terms of Service and Privacy Policy.
                
                CSTestForge is provided "as is", without warranty of any kind. In no event shall the
                authors or copyright holders be liable for any claim, damages or other liability,
                whether in an action of contract, tort or otherwise, arising from, out of or in
                connection with the software or the use or other dealings in the software.
                
                You are responsible for safeguarding your password and for all activities that occur under your account.
                
                We reserve the right to modify, suspend or terminate the service at any time without prior notice.
              </Typography>
            </Paper>
            
            <FormControlLabel
              control={
                <Checkbox
                  name="agreeToTerms"
                  checked={formData.agreeToTerms}
                  onChange={handleInputChange}
                  color="primary"
                  disabled={loading}
                />
              }
              label="I agree to the Terms and Conditions"
            />
            
            {formErrors.agreeToTerms && (
              <Typography variant="caption" color="error">
                {formErrors.agreeToTerms}
              </Typography>
            )}
          </>
        );
        
      default:
        return null;
    }
  };
  
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minHeight: '100vh',
        padding: 3,
        backgroundColor: '#f5f5f5'
      }}
    >
      <Paper
        elevation={3}
        sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          p: 4,
          maxWidth: 500,
          width: '100%'
        }}
      >
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            mb: 3
          }}
        >
          <img src={logo} alt="CSTestForge Logo" height="60" />
          <Typography component="h1" variant="h5" sx={{ mt: 2 }}>
            Create an Account
          </Typography>
        </Box>
        
        {error && (
          <Alert severity="error" sx={{ width: '100%', mb: 2 }}>
            {error}
          </Alert>
        )}
        
        <Stepper activeStep={activeStep} sx={{ width: '100%', mb: 4 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
          {renderStepContent(activeStep)}
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
            <Button
              onClick={handleBack}
              disabled={activeStep === 0 || loading}
              startIcon={<ArrowBackIcon />}
            >
              Back
            </Button>
            
            {activeStep === steps.length - 1 ? (
              <Button
                type="submit"
                variant="contained"
                disabled={loading}
              >
                {loading ? <CircularProgress size={24} /> : 'Register'}
              </Button>
            ) : (
              <Button
                variant="contained"
                onClick={handleNext}
                disabled={loading}
              >
                Next
              </Button>
            )}
          </Box>
        </Box>
        
        <Box sx={{ mt: 3 }}>
          <Link component={RouterLink} to="/login" variant="body2">
            Already have an account? Sign in
          </Link>
        </Box>
      </Paper>
      
      <Typography variant="body2" color="text.secondary" sx={{ mt: 4 }}>
         {new Date().getFullYear()} CSTestForge. All rights reserved.
      </Typography>
    </Box>
  );
};

export default Register;


// src/components/CodeEditor.jsx
import React, { useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Box, Typography, Paper } from '@mui/material';

// Import CodeMirror and its dependencies
import { EditorView, basicSetup } from 'codemirror';
import { EditorState } from '@codemirror/state';
import { javascript } from '@codemirror/lang-javascript';
import { java } from '@codemirror/lang-java';
import { sql } from '@codemirror/lang-sql';
import { json } from '@codemirror/lang-json';
import { html } from '@codemirror/lang-html';
import { xml } from '@codemirror/lang-xml';
import { markdown } from '@codemirror/lang-markdown';
import { StreamLanguage } from '@codemirror/language';
import { gherkin } from '@codemirror/legacy-modes/mode/gherkin';

const CodeEditor = ({
  value,
  onChange,
  language = 'javascript',
  height = '300px',
  error = false,
  helperText = '',
  readOnly = false
}) => {
  const editorRef = useRef(null);
  const editorViewRef = useRef(null);
  
  // Get the language extension based on the language prop
  const getLanguageExtension = () => {
    switch (language.toLowerCase()) {
      case 'javascript':
      case 'js':
        return javascript();
      case 'java':
        return java();
      case 'sql':
        return sql();
      case 'json':
        return json();
      case 'html':
        return html();
      case 'xml':
        return xml();
      case 'markdown':
      case 'md':
        return markdown();
      case 'gherkin':
        return StreamLanguage.define(gherkin);
      default:
        return javascript();
    }
  };
  
  useEffect(() => {
    // Initialize the editor when the component mounts
    if (editorRef.current && !editorViewRef.current) {
      const startState = EditorState.create({
        doc: value || '',
        extensions: [
          basicSetup,
          getLanguageExtension(),
          EditorView.updateListener.of(update => {
            if (update.docChanged && onChange) {
              onChange(update.state.doc.toString());
            }
          }),
          EditorView.theme({
            "&": {
              fontSize: "14px",
              fontFamily: "monospace",
              height: height
            }
          }),
          EditorState.readOnly.of(readOnly)
        ]
      });
      
      editorViewRef.current = new EditorView({
        state: startState,
        parent: editorRef.current
      });
    }
    
    // Clean up the editor when the component unmounts
    return () => {
      if (editorViewRef.current) {
        editorViewRef.current.destroy();
        editorViewRef.current = null;
      }
    };
  }, [language, readOnly]); // Only reinitialize when language or readOnly changes
  
  // Update the editor content when the value prop changes
  useEffect(() => {
    if (editorViewRef.current && value !== editorViewRef.current.state.doc.toString()) {
      editorViewRef.current.dispatch({
        changes: {
          from: 0,
          to: editorViewRef.current.state.doc.length,
          insert: value || ''
        }
      });
    }
  }, [value]);
  
  return (
    <Box sx={{ width: '100%' }}>
      <Paper 
        variant="outlined"
        sx={{
          width: '100%',
          border: error ? '1px solid #f44336' : '1px solid #ccc',
          borderRadius: 1,
          overflow: 'hidden'
        }}
      >
        <div ref={editorRef} style={{ width: '100%', height }} />
      </Paper>
      
      {helperText && (
        <Typography
          variant="caption"
          color={error ? 'error' : 'text.secondary'}
          sx={{ mt: 0.5, ml: 1.5 }}
        >
          {helperText}
        </Typography>
      )}
    </Box>
  );
};

CodeEditor.propTypes = {
  value: PropTypes.string,
  onChange: PropTypes.func,
  language: PropTypes.string,
  height: PropTypes.string,
  error: PropTypes.bool,
  helperText: PropTypes.string,
  readOnly: PropTypes.bool
};

export default CodeEditor;


// src/pages/UserProfile.jsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  Grid,
  TextField,
  Button,
  Avatar,
  IconButton,
  Divider,
  Tab,
  Tabs,
  Alert,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  InputAdornment,
  Tooltip,
  Card,
  CardContent
} from '@mui/material';
import { styled } from '@mui/material/styles';
import SaveIcon from '@mui/icons-material/Save';
import EditIcon from '@mui/icons-material/Edit';
import LockIcon from '@mui/icons-material/Lock';
import SecurityIcon from '@mui/icons-material/Security';
import SettingsIcon from '@mui/icons-material/Settings';
import PersonIcon from '@mui/icons-material/Person';
import UploadIcon from '@mui/icons-material/Upload';
import VisibilityIcon from '@mui/icons-material/Visibility';
import VisibilityOffIcon from '@mui/icons-material/VisibilityOff';
import { useAuth } from '../contexts/AuthContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';

const UserProfile = () => {
  const { user, updateUser } = useAuth();
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [loading, setLoading] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [currentTab, setCurrentTab] = useState(0);
  const [editMode, setEditMode] = useState(false);
  const [changePasswordDialog, setChangePasswordDialog] = useState(false);
  const [showCurrentPassword, setShowCurrentPassword] = useState(false);
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  
  // User profile form
  const [profileForm, setProfileForm] = useState({
    firstName: '',
    lastName: '',
    email: '',
    username: '',
    company: '',
    jobTitle: '',
    profilePicture: null
  });
  
  // Settings form
  const [settingsForm, setSettingsForm] = useState({
    theme: 'light',
    notificationsEnabled: true,
    defaultBrowser: 'CHROME',
    timezone: 'UTC',
    dateFormat: 'MM/DD/YYYY'
  });
  
  // Change password form
  const [passwordForm, setPasswordForm] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  });
  
  // Form errors
  const [profileErrors, setProfileErrors] = useState({});
  const [settingsErrors, setSettingsErrors] = useState({});
  const [passwordErrors, setPasswordErrors] = useState({});
  
  // Load user data
  useEffect(() => {
    if (user) {
      setProfileForm({
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        email: user.email || '',
        username: user.username || '',
        company: user.company || '',
        jobTitle: user.jobTitle || '',
        profilePicture: user.profilePicture || null
      });
      
      // Load user settings
      loadUserSettings();
    }
  }, [user]);
  
  const loadUserSettings = async () => {
    try {
      const response = await api.get('/user/settings');
      setSettingsForm(response.data);
    } catch (error) {
      console.error('Error loading user settings:', error);
      enqueueSnackbar('Failed to load user settings', { variant: 'error' });
    }
  };
  
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  const handleProfileInputChange = (e) => {
    const { name, value } = e.target;
    setProfileForm({
      ...profileForm,
      [name]: value
    });
    
    // Clear error for the field when user types
    if (profileErrors[name]) {
      setProfileErrors({
        ...profileErrors,
        [name]: ''
      });
    }
  };
  
  const handleSettingsInputChange = (e) => {
    const { name, value, checked, type } = e.target;
    setSettingsForm({
      ...settingsForm,
      [name]: type === 'checkbox' ? checked : value
    });
    
    // Clear error for the field when user types
    if (settingsErrors[name]) {
      setSettingsErrors({
        ...settingsErrors,
        [name]: ''
      });
    }
  };
  
  const handlePasswordInputChange = (e) => {
    const { name, value } = e.target;
    setPasswordForm({
      ...passwordForm,
      [name]: value
    });
    
    // Clear error for the field when user types
    if (passwordErrors[name]) {
      setPasswordErrors({
        ...passwordErrors,
        [name]: ''
      });
    }
  };
  
  const validateProfileForm = () => {
    const errors = {};
    
    if (!profileForm.firstName.trim()) {
      errors.firstName = 'First name is required';
    }
    
    if (!profileForm.lastName.trim()) {
      errors.lastName = 'Last name is required';
    }
    
    if (!profileForm.email.trim()) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(profileForm.email)) {
      errors.email = 'Email is invalid';
    }
    
    if (!profileForm.username.trim()) {
      errors.username = 'Username is required';
    }
    
    setProfileErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const validatePasswordForm = () => {
    const errors = {};
    
    if (!passwordForm.currentPassword) {
      errors.currentPassword = 'Current password is required';
    }
    
    if (!passwordForm.newPassword) {
      errors.newPassword = 'New password is required';
    } else if (passwordForm.newPassword.length < 8) {
      errors.newPassword = 'New password must be at least 8 characters long';
    }
    
    if (!passwordForm.confirmPassword) {
      errors.confirmPassword = 'Please confirm your new password';
    } else if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      errors.confirmPassword = 'Passwords do not match';
    }
    
    setPasswordErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  const handleProfileSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateProfileForm()) {
      return;
    }
    
    setLoading(true);
    setSaveSuccess(false);
    
    try {
      const response = await updateUser(profileForm);
      
      // Update the user context with the new data
      enqueueSnackbar('Profile updated successfully', { variant: 'success' });
      setSaveSuccess(true);
      setEditMode(false);
    } catch (error) {
      console.error('Error updating profile:', error);
      enqueueSnackbar('Failed to update profile', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  const handleSettingsSubmit = async (e) => {
    e.preventDefault();
    
    setLoading(true);
    setSaveSuccess(false);
    
    try {
      await api.put('/user/settings', settingsForm);
      
      enqueueSnackbar('Settings updated successfully', { variant: 'success' });
      setSaveSuccess(true);
    } catch (error) {
      console.error('Error updating settings:', error);
      enqueueSnackbar('Failed to update settings', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  const handleChangePassword = async (e) => {
    e.preventDefault();
    
    if (!validatePasswordForm()) {
      return;
    }
    
    setLoading(true);
    
    try {
      await api.put('/user/change-password', {
        currentPassword: passwordForm.currentPassword,
        newPassword: passwordForm.newPassword
      });
      
      enqueueSnackbar('Password changed successfully', { variant: 'success' });
      setChangePasswordDialog(false);
      
      // Reset the password form
      setPasswordForm({
        currentPassword: '',
        newPassword: '',
        confirmPassword: ''
      });
    } catch (error) {
      console.error('Error changing password:', error);
      
      if (error.response?.status === 401) {
        setPasswordErrors({
          ...passwordErrors,
          currentPassword: 'Current password is incorrect'
        });
      } else {
        enqueueSnackbar('Failed to change password', { variant: 'error' });
      }
    } finally {
      setLoading(false);
    }
  };
  
  const handleProfilePictureUpload = (e) => {
    const file = e.target.files[0];
    
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        setProfileForm({
          ...profileForm,
          profilePicture: reader.result
        });
      };
      reader.readAsDataURL(file);
    }
  };
  
  const Input = styled('input')({
    display: 'none',
  });
  
  // Get user initials for avatar
  const getUserInitials = () => {
    const firstName = profileForm.firstName || '';
    const lastName = profileForm.lastName || '';
    
    return `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase();
  };
  
  const renderProfileTab = () => {
    return (
      <Box component="form" onSubmit={handleProfileSubmit}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6">Personal Information</Typography>
          
          {!editMode ? (
            <Button 
              startIcon={<EditIcon />} 
              onClick={() => setEditMode(true)}
            >
              Edit Profile
            </Button>
          ) : (
            <Button 
              variant="contained" 
              color="primary" 
              startIcon={<SaveIcon />}
              type="submit"
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : 'Save Changes'}
            </Button>
          )}
        </Box>
        
        {saveSuccess && (
          <Alert severity="success" sx={{ mb: 3 }}>
            Profile updated successfully!
          </Alert>
        )}
        
        <Grid container spacing={3}>
          <Grid item xs={12} sm={4} sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
            <Avatar
              src={profileForm.profilePicture}
              sx={{ width: 120, height: 120, mb: 2, fontSize: 48 }}
            >
              {getUserInitials()}
            </Avatar>
            
            <label htmlFor="profile-picture-upload">
              <Input
                accept="image/*"
                id="profile-picture-upload"
                type="file"
                onChange={handleProfilePictureUpload}
                disabled={!editMode}
              />
              <Button
                variant="outlined"
                component="span"
                startIcon={<UploadIcon />}
                disabled={!editMode}
              >
                Upload Photo
              </Button>
            </label>
          </Grid>
          
          <Grid item xs={12} sm={8}>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="First Name"
                  name="firstName"
                  value={profileForm.firstName}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                  error={!!profileErrors.firstName}
                  helperText={profileErrors.firstName}
                  required
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="Last Name"
                  name="lastName"
                  value={profileForm.lastName}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                  error={!!profileErrors.lastName}
                  helperText={profileErrors.lastName}
                  required
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Email"
                  name="email"
                  type="email"
                  value={profileForm.email}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                  error={!!profileErrors.email}
                  helperText={profileErrors.email}
                  required
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Username"
                  name="username"
                  value={profileForm.username}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                  error={!!profileErrors.username}
                  helperText={profileErrors.username}
                  required
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="Company"
                  name="company"
                  value={profileForm.company}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                />
              </Grid>
              
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="Job Title"
                  name="jobTitle"
                  value={profileForm.jobTitle}
                  onChange={handleProfileInputChange}
                  disabled={!editMode || loading}
                />
              </Grid>
            </Grid>
          </Grid>
        </Grid>
        
        <Box sx={{ mt: 3 }}>
          <Typography variant="h6" gutterBottom>
            Account Security
          </Typography>
          
          <Button
            variant="outlined"
            color="primary"
            startIcon={<LockIcon />}
            onClick={() => setChangePasswordDialog(true)}
            sx={{ mr: 2 }}
          >
            Change Password
          </Button>
        </Box>
      </Box>
    );
  };
  
  const renderSettingsTab = () => {
    return (
      <Box component="form" onSubmit={handleSettingsSubmit}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6">Application Settings</Typography>
          
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<SaveIcon />}
            type="submit"
            disabled={loading}
          >
            {loading ? <CircularProgress size={24} /> : 'Save Settings'}
          </Button>
        </Box>
        
        {saveSuccess && (
          <Alert severity="success" sx={{ mb: 3 }}>
            Settings updated successfully!
          </Alert>
        )}
        
        <Grid container spacing={3}>
          <Grid item xs={12} sm={6}>
            <Card>
              <CardContent>
                <Typography variant="subtitle1" gutterBottom>
                  Display Settings
                </Typography>
                
                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <TextField
                      select
                      fullWidth
                      label="Theme"
                      name="theme"
                      value={settingsForm.theme}
                      onChange={handleSettingsInputChange}
                      disabled={loading}
                      SelectProps={{
                        native: true
                      }}
                    >
                      <option value="light">Light</option>
                      <option value="dark">Dark</option>
                      <option value="system">System Default</option>
                    </TextField>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <TextField
                      select
                      fullWidth
                      label="Date Format"
                      name="dateFormat"
                      value={settingsForm.dateFormat}
                      onChange={handleSettingsInputChange}
                      disabled={loading}
                      SelectProps={{
                        native: true
                      }}
                    >
                      <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                      <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                      <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                    </TextField>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <TextField
                      select
                      fullWidth
                      label="Timezone"
                      name="timezone"
                      value={settingsForm.timezone}
                      onChange={handleSettingsInputChange}
                      disabled={loading}
                      SelectProps={{
                        native: true
                      }}
                    >
                      <option value="UTC">UTC</option>
                      <option value="America/New_York">Eastern Time (ET)</option>
                      <option value="America/Chicago">Central Time (CT)</option>
                      <option value="America/Denver">Mountain Time (MT)</option>
                      <option value="America/Los_Angeles">Pacific Time (PT)</option>
                      <option value="Europe/London">London (GMT)</option>
                      <option value="Europe/Paris">Paris (CET)</option>
                      <option value="Asia/Tokyo">Tokyo (JST)</option>
                    </TextField>
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <Card>
              <CardContent>
                <Typography variant="subtitle1" gutterBottom>
                  Testing Defaults
                </Typography>
                
                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <TextField
                      select
                      fullWidth
                      label="Default Browser"
                      name="defaultBrowser"
                      value={settingsForm.defaultBrowser}
                      onChange={handleSettingsInputChange}
                      disabled={loading}
                      SelectProps={{
                        native: true
                      }}
                    >
                      <option value="CHROME">Chrome</option>
                      <option value="FIREFOX">Firefox</option>
                      <option value="EDGE">Edge</option>
                      <option value="SAFARI">Safari</option>
                    </TextField>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="Notifications"
                      name="notificationsEnabled"
                      select
                      value={settingsForm.notificationsEnabled ? 'true' : 'false'}
                      onChange={(e) => {
                        handleSettingsInputChange({
                          target: {
                            name: 'notificationsEnabled',
                            value: e.target.value === 'true',
                            type: 'checkbox',
                            checked: e.target.value === 'true'
                          }
                        });
                      }}
                      disabled={loading}
                      SelectProps={{
                        native: true
                      }}
                    >
                      <option value="true">Enabled</option>
                      <option value="false">Disabled</option>
                    </TextField>
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Box>
    );
  };
  
  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        My Account
      </Typography>
      
      <Paper sx={{ mb: 3 }}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab icon={<PersonIcon />} label="Profile" />
          <Tab icon={<SettingsIcon />} label="Settings" />
        </Tabs>
      </Paper>
      
      <Paper sx={{ p: 3 }}>
        {currentTab === 0 && renderProfileTab()}
        {currentTab === 1 && renderSettingsTab()}
      </Paper>
      
      {/* Change Password Dialog */}
      <Dialog
        open={changePasswordDialog}
        onClose={() => setChangePasswordDialog(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Change Password</DialogTitle>
        <DialogContent>
          <DialogContentText sx={{ mb: 2 }}>
            To change your password, please enter your current password and then your new password.
          </DialogContentText>
          
          <form onSubmit={handleChangePassword}>
            <TextField
              margin="normal"
              required
              fullWidth
              name="currentPassword"
              label="Current Password"
              type={showCurrentPassword ? 'text' : 'password'}
              value={passwordForm.currentPassword}
              onChange={handlePasswordInputChange}
              error={!!passwordErrors.currentPassword}
              helperText={passwordErrors.currentPassword}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowCurrentPassword(!showCurrentPassword)}
                      edge="end"
                    >
                      {showCurrentPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                )
              }}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="newPassword"
              label="New Password"
              type={showNewPassword ? 'text' : 'password'}
              value={passwordForm.newPassword}
              onChange={handlePasswordInputChange}
              error={!!passwordErrors.newPassword}
              helperText={passwordErrors.newPassword}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowNewPassword(!showNewPassword)}
                      edge="end"
                    >
                      {showNewPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                )
              }}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm New Password"
              type={showConfirmPassword ? 'text' : 'password'}
              value={passwordForm.confirmPassword}
              onChange={handlePasswordInputChange}
              error={!!passwordErrors.confirmPassword}
              helperText={passwordErrors.confirmPassword}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                )
              }}
            />
          </form>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setChangePasswordDialog(false)}>
            Cancel
          </Button>
          <Button 
            onClick={handleChangePassword} 
            variant="contained"
            disabled={loading}
          >
            {loading ? <CircularProgress size={24} /> : 'Change Password'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default UserProfile;


// src/main/java/com/cstestforge/service/impl/browser/BrowserService.java
package com.cstestforge.service.impl.browser;

import com.cstestforge.exception.BrowserException;
import com.cstestforge.model.execution.BrowserContext;
import com.cstestforge.model.execution.BrowserOptions;
import com.cstestforge.model.execution.ElementInfo;
import com.cstestforge.model.recorder.RecordingSession;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.service.browser.BrowserService;
import com.microsoft.playwright.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PreDestroy;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Implementation of Browser Service using Playwright
 * Provides methods for browser automation and test recording
 */
@Service
public class BrowserServiceImpl implements BrowserService {
    private static final Logger logger = LoggerFactory.getLogger(BrowserServiceImpl.class);
    private final Map<String, BrowserContext> browserContexts = new ConcurrentHashMap<>();
    private final Map<String, RecordingSession> recordingSessions = new ConcurrentHashMap<>();
    private final ReentrantLock browserLock = new ReentrantLock();
    private Playwright playwright;

    /**
     * Initialize Playwright instance lazily
     */
    private synchronized Playwright getPlaywright() {
        if (playwright == null) {
            logger.info("Initializing Playwright instance");
            playwright = Playwright.create();
        }
        return playwright;
    }

    @PreDestroy
    public void cleanupResources() {
        logger.info("Cleaning up browser resources");
        browserContexts.forEach((id, context) -> {
            try {
                closeContext(id);
            } catch (Exception e) {
                logger.error("Error closing browser context: {}", id, e);
            }
        });
        
        if (playwright != null) {
            try {
                playwright.close();
                playwright = null;
            } catch (Exception e) {
                logger.error("Error closing Playwright instance", e);
            }
        }
    }

    @Override
    public BrowserContext createBrowserContext(BrowserOptions options) {
        logger.info("Creating browser context with options: {}", options);
        try {
            browserLock.lock();
            
            // Generate a unique ID for this browser context
            String contextId = UUID.randomUUID().toString();
            
            // Create Playwright browser based on options
            Playwright playwrightInstance = getPlaywright();
            BrowserType browserType = getBrowserType(playwrightInstance, options.getBrowserType());
            
            Browser.LaunchOptions launchOptions = new Browser.LaunchOptions()
                    .setHeadless(options.isHeadless())
                    .setSlowMo(options.getSlowMotion())
                    .setTimeout(options.getTimeout());
            
            // Set additional options if specified
            if (options.getExecutablePath() != null) {
                launchOptions.setExecutablePath(Paths.get(options.getExecutablePath()));
            }
            
            // Launch browser
            Browser browser = browserType.launch(launchOptions);
            
            // Create browser context
            Browser.NewContextOptions contextOptions = new Browser.NewContextOptions()
                    .setViewportSize(options.getViewportWidth(), options.getViewportHeight())
                    .setIgnoreHTTPSErrors(options.isIgnoreHttpsErrors())
                    .setJavaScriptEnabled(options.isJavaScriptEnabled());
            
            // Set user agent if specified
            if (options.getUserAgent() != null) {
                contextOptions.setUserAgent(options.getUserAgent());
            }
            
            // Set locale if specified
            if (options.getLocale() != null) {
                contextOptions.setLocale(options.getLocale());
            }
            
            // Set timezone if specified
            if (options.getTimezone() != null) {
                contextOptions.setTimezone(options.getTimezone());
            }
            
            // Set geolocation if specified
            if (options.getLatitude() != null && options.getLongitude() != null) {
                contextOptions.setGeolocation(options.getLatitude(), options.getLongitude());
            }
            
            // Create context
            com.microsoft.playwright.BrowserContext pwContext = browser.newContext(contextOptions);
            
            // Create page
            Page page = pwContext.newPage();
            
            // Create and store our custom BrowserContext wrapper
            BrowserContext context = new BrowserContext();
            context.setId(contextId);
            context.setBrowser(browser);
            context.setPlaywrightContext(pwContext);
            context.setPage(page);
            context.setOptions(options);
            context.setCreatedAt(new Date());
            
            // Store in context map
            browserContexts.put(contextId, context);
            
            logger.info("Browser context created successfully: {}", contextId);
            return context;
            
        } catch (Exception e) {
            logger.error("Error creating browser context", e);
            throw new BrowserException("Failed to create browser context", e);
        } finally {
            browserLock.unlock();
        }
    }

    @Override
    public void closeContext(String contextId) {
        logger.info("Closing browser context: {}", contextId);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            // Close page if open
            if (context.getPage() != null) {
                context.getPage().close();
            }
            
            // Close Playwright context
            if (context.getPlaywrightContext() != null) {
                context.getPlaywrightContext().close();
            }
            
            // Close browser
            if (context.getBrowser() != null) {
                context.getBrowser().close();
            }
            
            // Remove from context map
            browserContexts.remove(contextId);
            logger.info("Browser context closed successfully: {}", contextId);
        } catch (Exception e) {
            logger.error("Error closing browser context: {}", contextId, e);
            throw new BrowserException("Failed to close browser context", e);
        }
    }

    @Override
    public void navigateTo(String contextId, String url) {
        logger.info("Navigating to URL in context {}: {}", contextId, url);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            // Navigate to URL
            context.getPage().navigate(url);
            
            // Wait for page to load
            context.getPage().waitForLoadState();
            
            logger.info("Navigation successful: {}", url);
        } catch (Exception e) {
            logger.error("Error navigating to URL: {}", url, e);
            throw new BrowserException("Failed to navigate to URL: " + url, e);
        }
    }

    @Override
    public void executeAction(String contextId, TestStep step) {
        logger.info("Executing action in context {}: {}", contextId, step.getAction());
        BrowserContext context = getBrowserContext(contextId);
        Page page = context.getPage();
        
        try {
            switch (step.getAction().toUpperCase()) {
                case "NAVIGATE":
                    page.navigate(step.getTarget());
                    page.waitForLoadState();
                    break;
                    
                case "CLICK":
                    page.click(step.getSelector());
                    break;
                    
                case "DOUBLE_CLICK":
                    page.dblclick(step.getSelector());
                    break;
                    
                case "TYPE":
                    page.fill(step.getSelector(), step.getValue());
                    break;
                    
                case "SELECT":
                    page.selectOption(step.getSelector(), step.getValue());
                    break;
                    
                case "CHECK":
                    page.check(step.getSelector());
                    break;
                    
                case "UNCHECK":
                    page.uncheck(step.getSelector());
                    break;
                    
                case "HOVER":
                    page.hover(step.getSelector());
                    break;
                    
                case "PRESS_KEY":
                    page.press(step.getSelector(), step.getValue());
                    break;
                    
                case "WAIT_FOR_ELEMENT":
                    page.waitForSelector(step.getSelector(), 
                            new Page.WaitForSelectorOptions().setTimeout(step.getTimeout()));
                    break;
                    
                case "WAIT_FOR_NAVIGATION":
                    page.waitForNavigation();
                    break;
                    
                case "WAIT_FOR_TIMEOUT":
                    page.waitForTimeout(step.getTimeout());
                    break;
                    
                case "ASSERT_VISIBLE":
                    page.waitForSelector(step.getSelector(), 
                            new Page.WaitForSelectorOptions().setState(Page.WaitForSelectorState.VISIBLE));
                    break;
                    
                case "ASSERT_TEXT":
                    page.waitForSelector(step.getSelector() + ":has-text('" + step.getValue() + "')");
                    break;
                    
                case "ASSERT_VALUE":
                    String actualValue = page.inputValue(step.getSelector());
                    if (!step.getValue().equals(actualValue)) {
                        throw new AssertionError(
                                "Expected value '" + step.getValue() + "' but got '" + actualValue + "'");
                    }
                    break;
                    
                case "EXECUTE_JAVASCRIPT":
                    page.evaluate(step.getValue());
                    break;
                    
                default:
                    throw new IllegalArgumentException("Unsupported action: " + step.getAction());
            }
            
            logger.info("Action executed successfully: {}", step.getAction());
        } catch (Exception e) {
            logger.error("Error executing action: {}", step.getAction(), e);
            throw new BrowserException("Failed to execute action: " + step.getAction(), e);
        }
    }

    @Override
    public byte[] takeScreenshot(String contextId, String selector) {
        logger.info("Taking screenshot in context {}", contextId);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            if (selector != null && !selector.isEmpty()) {
                // Take screenshot of specific element
                ElementHandle element = context.getPage().querySelector(selector);
                if (element == null) {
                    throw new IllegalArgumentException("Element not found: " + selector);
                }
                return element.screenshot();
            } else {
                // Take screenshot of entire page
                return context.getPage().screenshot();
            }
        } catch (Exception e) {
            logger.error("Error taking screenshot", e);
            throw new BrowserException("Failed to take screenshot", e);
        }
    }

    @Override
    public byte[] captureVideo(String contextId) {
        logger.info("Capturing video for context {}", contextId);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            // Videos are stored in a temporary directory by Playwright
            Path videoPath = context.getPage().video().path();
            
            // Stop recording to ensure video is saved
            context.getPlaywrightContext().close();
            
            // Read the video file
            byte[] videoBytes = Files.readAllBytes(videoPath);
            
            // Delete the temporary file
            Files.delete(videoPath);
            
            return videoBytes;
        } catch (Exception e) {
            logger.error("Error capturing video", e);
            throw new BrowserException("Failed to capture video", e);
        }
    }

    @Override
    public String getPageHtml(String contextId) {
        logger.info("Getting page HTML for context {}", contextId);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            return (String) context.getPage().evaluate("() => document.documentElement.outerHTML");
        } catch (Exception e) {
            logger.error("Error getting page HTML", e);
            throw new BrowserException("Failed to get page HTML", e);
        }
    }

    @Override
    public ElementInfo getElementInfo(String contextId, String selector) {
        logger.info("Getting element info for selector in context {}: {}", contextId, selector);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            JSHandle jsHandle = context.getPage().evaluateHandle("selector => {" +
                    "const element = document.querySelector(selector);" +
                    "if (!element) return null;" +
                    "const rect = element.getBoundingClientRect();" +
                    "return {" +
                    "  tagName: element.tagName.toLowerCase()," +
                    "  attributes: Array.from(element.attributes).reduce((obj, attr) => {" +
                    "    obj[attr.name] = attr.value; return obj;" +
                    "  }, {})," +
                    "  textContent: element.textContent," +
                    "  boundingBox: {" +
                    "    x: rect.x," +
                    "    y: rect.y," +
                    "    width: rect.width," +
                    "    height: rect.height" +
                    "  }," +
                    "  xpath: getXPath(element)," +
                    "  cssPath: getCssPath(element)," +
                    "  isVisible: isVisible(element)," +
                    "  zIndex: parseInt(window.getComputedStyle(element).zIndex) || 0" +
                    "};" +
                    "function getXPath(element) {" +
                    "  if (element.id) return `//*[@id=\"${element.id}\"]`;" +
                    "  if (element === document.body) return '/html/body';" +
                    "  let ix = 0;" +
                    "  const siblings = element.parentNode.childNodes;" +
                    "  for (let i = 0; i < siblings.length; i++) {" +
                    "    const sibling = siblings[i];" +
                    "    if (sibling === element) return `${getXPath(element.parentNode)}/${element.tagName.toLowerCase()}[${ix + 1}]`;" +
                    "    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;" +
                    "  }" +
                    "}" +
                    "function getCssPath(element) {" +
                    "  if (element.id) return `#${element.id}`;" +
                    "  if (element === document.body) return 'body';" +
                    "  let path = element.tagName.toLowerCase();" +
                    "  if (element.className) {" +
                    "    const classes = element.className.split(/\\s+/).filter(c => c);" +
                    "    if (classes.length > 0) path += `.${classes.join('.')}`;" +
                    "  }" +
                    "  return `${getCssPath(element.parentNode)} > ${path}`;" +
                    "}" +
                    "function isVisible(element) {" +
                    "  const style = window.getComputedStyle(element);" +
                    "  return style.display !== 'none' && style.visibility !== 'hidden' && element.offsetWidth > 0 && element.offsetHeight > 0;" +
                    "}" +
                    "}", selector);
            
            Map<String, Object> elementData = (Map<String, Object>) jsHandle.jsonValue();
            jsHandle.dispose();
            
            if (elementData == null) {
                throw new IllegalArgumentException("Element not found: " + selector);
            }
            
            // Create ElementInfo from the JavaScript data
            ElementInfo elementInfo = new ElementInfo();
            elementInfo.setTagName((String) elementData.get("tagName"));
            elementInfo.setAttributes((Map<String, String>) elementData.get("attributes"));
            elementInfo.setTextContent((String) elementData.get("textContent"));
            elementInfo.setBoundingBox((Map<String, Object>) elementData.get("boundingBox"));
            elementInfo.setXpath((String) elementData.get("xpath"));
            elementInfo.setCssPath((String) elementData.get("cssPath"));
            elementInfo.setVisible((Boolean) elementData.get("isVisible"));
            elementInfo.setZIndex(((Number) elementData.get("zIndex")).intValue());
            
            return elementInfo;
        } catch (Exception e) {
            logger.error("Error getting element info for selector: {}", selector, e);
            throw new BrowserException("Failed to get element info for selector: " + selector, e);
        }
    }

    @Override
    public Map<String, String> generateSelectors(String contextId, String existingSelector) {
        logger.info("Generating selectors for existing selector in context {}: {}", contextId, existingSelector);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            JSHandle jsHandle = context.getPage().evaluateHandle("selector => {" +
                    "const element = document.querySelector(selector);" +
                    "if (!element) return null;" +
                    "return {" +
                    "  id: element.id ? `#${element.id}` : null," +
                    "  class: element.className ? `.${element.className.trim().replace(/\\s+/g, '.')}` : null," +
                    "  tag: element.tagName.toLowerCase()," +
                    "  xpath: getXPath(element)," +
                    "  css: getCssPath(element)," +
                    "  text: element.textContent.trim() ? `${element.tagName.toLowerCase()}:has-text(\"${element.textContent.trim().substring(0, 50)}\")` : null," +
                    "  attribute: getAttributeSelector(element)" +
                    "};" +
                    "function getXPath(element) {" +
                    "  if (element.id) return `//*[@id=\"${element.id}\"]`;" +
                    "  if (element === document.body) return '/html/body';" +
                    "  let ix = 0;" +
                    "  const siblings = element.parentNode.childNodes;" +
                    "  for (let i = 0; i < siblings.length; i++) {" +
                    "    const sibling = siblings[i];" +
                    "    if (sibling === element) return `${getXPath(element.parentNode)}/${element.tagName.toLowerCase()}[${ix + 1}]`;" +
                    "    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;" +
                    "  }" +
                    "}" +
                    "function getCssPath(element) {" +
                    "  if (element.id) return `#${element.id}`;" +
                    "  if (element === document.body) return 'body';" +
                    "  let path = element.tagName.toLowerCase();" +
                    "  if (element.className) {" +
                    "    const classes = element.className.split(/\\s+/).filter(c => c);" +
                    "    if (classes.length > 0) path += `.${classes.join('.')}`;" +
                    "  }" +
                    "  return `${getCssPath(element.parentNode)} > ${path}`;" +
                    "}" +
                    "function getAttributeSelector(element) {" +
                    "  for (const attr of ['name', 'placeholder', 'title', 'alt', 'data-testid', 'data-test', 'data-cy']) {" +
                    "    if (element.hasAttribute(attr)) {" +
                    "      return `[${attr}=\"${element.getAttribute(attr)}\"]`;" +
                    "    }" +
                    "  }" +
                    "  return null;" +
                    "}" +
                    "}", existingSelector);
            
            Map<String, Object> selectorsData = (Map<String, Object>) jsHandle.jsonValue();
            jsHandle.dispose();
            
            if (selectorsData == null) {
                throw new IllegalArgumentException("Element not found: " + existingSelector);
            }
            
            // Convert to Map<String, String>, filtering out null values
            Map<String, String> selectors = new HashMap<>();
            for (Map.Entry<String, Object> entry : selectorsData.entrySet()) {
                if (entry.getValue() != null) {
                    selectors.put(entry.getKey(), (String) entry.getValue());
                }
            }
            
            return selectors;
        } catch (Exception e) {
            logger.error("Error generating selectors for existing selector: {}", existingSelector, e);
            throw new BrowserException("Failed to generate selectors for existing selector: " + existingSelector, e);
        }
    }

    @Override
    public String startRecording(String contextId) {
        logger.info("Starting recording for context {}", contextId);
        BrowserContext context = getBrowserContext(contextId);
        
        try {
            // Generate recording session ID
            String recordingId = UUID.randomUUID().toString();
            
            // Create recording session
            RecordingSession session = new RecordingSession();
            session.setId(recordingId);
            session.setContextId(contextId);
            session.setStartTime(new Date());
            session.setStatus("RECORDING");
            session.setUrl(context.getPage().url());
            session.setRecordedSteps(new ArrayList<>());
            
            // Store session
            recordingSessions.put(recordingId, session);
            
            // Add event listeners to the page for recording
            addRecordingEventListeners(contextId, recordingId);
            
            logger.info("Recording started successfully: {}", recordingId);
            return recordingId;
        } catch (Exception e) {
            logger.error("Error starting recording", e);
            throw new BrowserException("Failed to start recording", e);
        }
    }

    @Override
    public void stopRecording(String recordingId) {
        logger.info("Stopping recording: {}", recordingId);
        RecordingSession session = getRecordingSession(recordingId);
        
        try {
            // Remove event listeners
            removeRecordingEventListeners(session.getContextId());
            
            // Update session
            session.setEndTime(new Date());
            session.setStatus("COMPLETED");
            
            logger.info("Recording stopped successfully: {}", recordingId);
        } catch (Exception e) {
            logger.error("Error stopping recording: {}", recordingId, e);
            throw new BrowserException("Failed to stop recording", e);
        }
    }

    @Override
    public RecordingSession getRecordingSession(String recordingId) {
        RecordingSession session = recordingSessions.get(recordingId);
        if (session == null) {
            throw new IllegalArgumentException("Recording session not found: " + recordingId);
        }
        return session;
    }

    // Private helper methods

    private BrowserType getBrowserType(Playwright playwright, String browserType) {
        switch (browserType.toUpperCase()) {
            case "CHROMIUM":
                return playwright.chromium();
            case "FIREFOX":
                return playwright.firefox();
            case "WEBKIT":
                return playwright.webkit();
            default:
                return playwright.chromium(); // Default to Chromium
        }
    }

    private BrowserContext getBrowserContext(String contextId) {
        BrowserContext context = browserContexts.get(contextId);
        if (context == null) {
            throw new IllegalArgumentException("Browser context not found: " + contextId);
        }
        return context;
    }

    private void addRecordingEventListeners(String contextId, String recordingId) {
        BrowserContext context = getBrowserContext(contextId);
        Page page = context.getPage();
        
        // Add JavaScript to intercept user interactions
        page.evaluate("() => {" +
                "window.__recordingId = '" + recordingId + "';" +
                "window.__recordedEvents = [];" +
                "window.__recordEvent = function(event) {" +
                "  window.__recordedEvents.push(event);" +
                "  fetch('/api/recorder/sessions/' + window.__recordingId + '/events', {" +
                "    method: 'POST'," +
                "    headers: {'Content-Type': 'application/json'}," +
                "    body: JSON.stringify(event)" +
                "  }).catch(console.error);" +
                "};" +
                "document.addEventListener('click', function(e) {" +
                "  const target = e.target;" +
                "  window.__recordEvent({" +
                "    type: 'click'," +
                "    timestamp: new Date().toISOString()," +
                "    element: {" +
                "      tagName: target.tagName.toLowerCase()," +
                "      id: target.id," +
                "      className: target.className," +
                "      textContent: target.textContent.trim()," +
                "      attributes: Array.from(target.attributes).reduce((obj, attr) => {" +
                "        obj[attr.name] = attr.value; return obj;" +
                "      }, {})" +
                "    }," +
                "    position: {x: e.clientX, y: e.clientY}" +
                "  });" +
                "});" +
                "document.addEventListener('input', function(e) {" +
                "  const target = e.target;" +
                "  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {" +
                "    window.__recordEvent({" +
                "      type: 'input'," +
                "      timestamp: new Date().toISOString()," +
                "      element: {" +
                "        tagName: target.tagName.toLowerCase()," +
                "        id: target.id," +
                "        className: target.className," +
                "        attributes: Array.from(target.attributes).reduce((obj, attr) => {" +
                "          obj[attr.name] = attr.value; return obj;" +
                "        }, {})" +
                "      }," +
                "      value: target.value || target.innerHTML" +
                "    });" +
                "  }" +
                "});" +
                "document.addEventListener('change', function(e) {" +
                "  const target = e.target;" +
                "  if (target.tagName === 'SELECT') {" +
                "    window.__recordEvent({" +
                "      type: 'select'," +
                "      timestamp: new Date().toISOString()," +
                "      element: {" +
                "        tagName: target.tagName.toLowerCase()," +
                "        id: target.id," +
                "        className: target.className," +
                "        attributes: Array.from(target.attributes).reduce((obj, attr) => {" +
                "          obj[attr.name] = attr.value; return obj;" +
                "        }, {})" +
                "      }," +
                "      value: target.value," +
                "      selectedIndex: target.selectedIndex," +
                "      selectedText: target.options[target.selectedIndex].text" +
                "    });" +
                "  }" +
                "});" +
                // Record navigation events
                "const originalPushState = history.pushState;" +
                "history.pushState = function() {" +
                "  originalPushState.apply(this, arguments);" +
                "  window.__recordEvent({" +
                "    type: 'navigation'," +
                "    timestamp: new Date().toISOString()," +
                "    url: window.location.href" +
                "  });" +
                "};" +
                "window.addEventListener('popstate', function() {" +
                "  window.__recordEvent({" +
                "    type: 'navigation'," +
                "    timestamp: new Date().toISOString()," +
                "    url: window.location.href" +
                "  });" +
                "});" +
                "}");
        
        // Set up poll to retrieve recorded events
        startEventPolling(contextId, recordingId);
    }

    private void startEventPolling(String contextId, String recordingId) {
        Thread pollingThread = new Thread(() -> {
            BrowserContext context = getBrowserContext(contextId);
            RecordingSession session = getRecordingSession(recordingId);
            
            try {
                while ("RECORDING".equals(session.getStatus())) {
                    // Retrieve recorded events
                    Object events = context.getPage().evaluate("() => {" +
                            "const events = window.__recordedEvents || [];" +
                            "window.__recordedEvents = [];" +
                            "return events;" +
                            "}");
                    
                    // Process events
                    if (events instanceof List) {
                        processRecordedEvents(recordingId, (List<Map<String, Object>>) events);
                    }
                    
                    // Sleep before next poll
                    TimeUnit.MILLISECONDS.sleep(500);
                }
            } catch (Exception e) {
                logger.error("Error polling recording events", e);
            }
        });
        
        pollingThread.setDaemon(true);
        pollingThread.start();
    }

    private void processRecordedEvents(String recordingId, List<Map<String, Object>> events) {
        RecordingSession session = getRecordingSession(recordingId);
        
        for (Map<String, Object> event : events) {
            String type = (String) event.get("type");
            String timestamp = (String) event.get("timestamp");
            
            // Create test step from event
            TestStep step = createTestStepFromEvent(event);
            
            // Add step to session
            if (step != null) {
                session.getRecordedSteps().add(step);
            }
        }
    }

    private TestStep createTestStepFromEvent(Map<String, Object> event) {
        String type = (String) event.get("type");
        
        TestStep step = new TestStep();
        step.setId(UUID.randomUUID().toString());
        
        switch (type) {
            case "click":
                step.setAction("CLICK");
                Map<String, Object> element = (Map<String, Object>) event.get("element");
                step.setTarget(generateSelector(element));
                break;
                
            case "input":
                step.setAction("TYPE");
                element = (Map<String, Object>) event.get("element");
                step.setTarget(generateSelector(element));
                step.setValue((String) event.get("value"));
                break;
                
            case "select":
                step.setAction("SELECT");
                element = (Map<String, Object>) event.get("element");
                step.setTarget(generateSelector(element));
                step.setValue((String) event.get("value"));
                break;
                
            case "navigation":
                step.setAction("NAVIGATE");
                step.setTarget((String) event.get("url"));
                break;
                
            default:
                return null; // Unsupported event type
        }
        
        return step;
    }

    private String generateSelector(Map<String, Object> element) {
        // Try ID first
        String id = (String) element.get("id");
        if (id != null && !id.isEmpty()) {
            return "#" + id;
        }
        
        // Try attributes
        Map<String, Object> attributes = (Map<String, Object>) element.get("attributes");
        if (attributes != null) {
            // Try data attributes first
            for (String attr : new String[]{"data-testid", "data-test", "data-cy", "name"}) {
                String value = (String) attributes.get(attr);
                if (value != null && !value.isEmpty()) {
                    return "[" + attr + "=\"" + value + "\"]";
                }
            }
        }
        
        // Try class
        String className = (String) element.get("className");
        if (className != null && !className.isEmpty()) {
            String tagName = (String) element.get("tagName");
            return tagName + "." + className.trim().replace(" ", ".");
        }
        
        // Fall back to text content
        String textContent = (String) element.get("textContent");
        if (textContent != null && !textContent.isEmpty()) {
            String tagName = (String) element.get("tagName");
            if (textContent.length() > 50) {
                textContent = textContent.substring(0, 50);
            }
            return tagName + ":has-text(\"" + textContent + "\")";
        }
        
        // Last resort: tag name
        return (String) element.get("tagName");
    }

    private void removeRecordingEventListeners(String contextId) {
        BrowserContext context = getBrowserContext(contextId);
        
        // Remove JavaScript event listeners
        context.getPage().evaluate("() => {" +
                "window.__recordingId = null;" +
                "window.__recordedEvents = null;" +
                "}");
    }
}


package com.cstestforge.service.browser;

import com.microsoft.playwright.Browser;
import com.microsoft.playwright.Page;

import java.util.Map;

/**
 * Service interface for browser automation using Playwright
 */
public interface BrowserService {
    
    /**
     * Launches a browser with the specified settings
     * 
     * @param browserType Browser type (chromium, firefox, webkit)
     * @param headless Whether to run in headless mode
     * @param sessionId Session ID for tracking
     * @return The launched Browser instance
     */
    Browser launchBrowser(String browserType, boolean headless, String sessionId);
    
    /**
     * Launches a browser with default settings (chromium, non-headless)
     * 
     * @param sessionId Session ID for tracking
     * @return The launched Browser instance
     */
    Browser launchBrowser(String sessionId);
    
    /**
     * Gets a page from a browser session
     * 
     * @param sessionId Session ID
     * @return The Page instance or null if not found
     */
    Page getPage(String sessionId);
    
    /**
     * Closes a browser session
     * 
     * @param sessionId Session ID to close
     */
    void closeBrowser(String sessionId);
    
    /**
     * Takes a screenshot of the current page
     * 
     * @param sessionId Session ID
     * @param path Path to save the screenshot
     * @return The path where the screenshot was saved
     */
    String takeScreenshot(String sessionId, String path);
    
    /**
     * Starts recording a video
     * 
     * @param sessionId Session ID
     * @param path Path to save the video
     */
    void startVideoRecording(String sessionId, String path);
    
    /**
     * Stops recording a video
     * 
     * @param sessionId Session ID
     * @return The path where the video was saved
     */
    String stopVideoRecording(String sessionId);
    
    /**
     * Navigates to a URL
     * 
     * @param sessionId Session ID
     * @param url URL to navigate to
     */
    void navigateTo(String sessionId, String url);
    
    /**
     * Clicks on an element
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     */
    void click(String sessionId, String selector);
    
    /**
     * Types text into an element
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @param text Text to type
     */
    void type(String sessionId, String selector, String text);
    
    /**
     * Selects an option from a dropdown
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @param value Option value to select
     */
    void select(String sessionId, String selector, String value);
    
    /**
     * Performs a hover action on an element
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     */
    void hover(String sessionId, String selector);
    
    /**
     * Executes JavaScript in the browser
     * 
     * @param sessionId Session ID
     * @param script JavaScript code to execute
     * @return Result of the script execution
     */
    Object executeScript(String sessionId, String script);
    
    /**
     * Waits for an element to be visible
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @param timeout Timeout in milliseconds
     */
    void waitForElementVisible(String sessionId, String selector, int timeout);
    
    /**
     * Waits for navigation to complete
     * 
     * @param sessionId Session ID
     * @param timeout Timeout in milliseconds
     */
    void waitForNavigation(String sessionId, int timeout);
    
    /**
     * Gets the text content of an element
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @return Text content of the element
     */
    String getElementText(String sessionId, String selector);
    
    /**
     * Checks if an element is visible
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @return true if the element is visible, false otherwise
     */
    boolean isElementVisible(String sessionId, String selector);
    
    /**
     * Gets all browser cookies
     * 
     * @param sessionId Session ID
     * @return Map of cookie name to value
     */
    Map<String, String> getCookies(String sessionId);
    
    /**
     * Sets a browser cookie
     * 
     * @param sessionId Session ID
     * @param name Cookie name
     * @param value Cookie value
     */
    void setCookie(String sessionId, String name, String value);
    
    /**
     * Clears all browser cookies
     * 
     * @param sessionId Session ID
     */
    void clearCookies(String sessionId);
    
    /**
     * Gets element information by selector
     * 
     * @param sessionId Session ID
     * @param selector Element selector
     * @return Map of element properties
     */
    Map<String, Object> getElementInfo(String sessionId, String selector);
    
    /**
     * Gets the current URL
     * 
     * @param sessionId Session ID
     * @return Current URL
     */
    String getCurrentUrl(String sessionId);
    
    /**
     * Gets the page title
     * 
     * @param sessionId Session ID
     * @return Page title
     */
    String getPageTitle(String sessionId);
    
    /**
     * Refreshes the page
     * 
     * @param sessionId Session ID
     */
    void refreshPage(String sessionId);
    
    /**
     * Goes back in browser history
     * 
     * @param sessionId Session ID
     */
    void goBack(String sessionId);
    
    /**
     * Goes forward in browser history
     * 
     * @param sessionId Session ID
     */
    void goForward(String sessionId);
}

package com.cstestforge.service.selfhealing;

import com.microsoft.playwright.Page;

import java.util.List;
import java.util.Map;

/**
 * Service interface for selector self-healing functionality
 */
public interface SelfHealingService {
    
    /**
     * Attempts to heal a broken selector
     * 
     * @param page Playwright Page instance
     * @param originalSelector Original selector that failed
     * @param actionType Type of action being performed (click, type, etc.)
     * @return Healed selector or null if healing failed
     */
    String healSelector(Page page, String originalSelector, String actionType);
    
    /**
     * Generates alternative selectors for an element
     * 
     * @param page Playwright Page instance
     * @param originalSelector Original selector
     * @return List of alternative selectors
     */
    List<String> generateAlternativeSelectors(Page page, String originalSelector);
    
    /**
     * Evaluates a selector against a page
     * 
     * @param page Playwright Page instance
     * @param selector Selector to evaluate
     * @return Score from 0 to 1 indicating selector quality
     */
    double evaluateSelector(Page page, String selector);
    
    /**
     * Records a healing event for future analysis
     * 
     * @param executionId Execution ID
     * @param stepId Step ID
     * @param originalSelector Original selector
     * @param healedSelector Healed selector
     */
    void recordHealingEvent(String executionId, String stepId, String originalSelector, String healedSelector);
    
    /**
     * Gets healing history for a project
     * 
     * @param projectId Project ID
     * @return List of healing events
     */
    List<Map<String, Object>> getHealingHistory(String projectId);
    
    /**
     * Gets healing statistics for a project
     * 
     * @param projectId Project ID
     * @return Map of healing statistics
     */
    Map<String, Object> getHealingStats(String projectId);
    
    /**
     * Optimizes a selector for robustness
     * 
     * @param page Playwright Page instance
     * @param selector Selector to optimize
     * @return Optimized selector
     */
    String optimizeSelector(Page page, String selector);
    
    /**
     * Saves a healing rule for future use
     * 
     * @param projectId Project ID
     * @param originalPattern Original selector pattern
     * @param healedPattern Healed selector pattern
     * @param description Rule description
     */
    void saveHealingRule(String projectId, String originalPattern, String healedPattern, String description);
    
    /**
     * Gets healing rules for a project
     * 
     * @param projectId Project ID
     * @return List of healing rules
     */
    List<Map<String, Object>> getHealingRules(String projectId);
    
    /**
     * Updates element selectors in a test case
     * 
     * @param projectId Project ID
     * @param testCaseId Test case ID
     * @param selectorUpdates Map of original selectors to updated selectors
     * @return Number of selectors updated
     */
    int updateTestCaseSelectors(String projectId, String testCaseId, Map<String, String> selectorUpdates);
    
    /**
     * Analyzes a selector for potential weaknesses
     * 
     * @param selector Selector to analyze
     * @return List of potential issues with the selector
     */
    List<String> analyzeSelectorWeaknesses(String selector);
    
    /**
     * Suggests healing rules based on healing history
     * 
     * @param projectId Project ID
     * @return List of suggested healing rules
     */
    List<Map<String, Object>> suggestHealingRules(String projectId);
}


// src/components/recorder/RecorderClient.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Typography,
  Paper,
  Button,
  IconButton,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  CircularProgress,
  Grid,
  Tabs,
  Tab,
  AppBar,
  Card,
  CardContent,
  Badge,
  Chip
} from '@mui/material';
import {
  PlayArrow as PlayIcon,
  Stop as StopIcon,
  Pause as PauseIcon,
  Save as SaveIcon,
  AddCircle as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Visibility as VisibilityIcon,
  Code as CodeIcon,
  CheckCircle as CheckIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Screenshot as ScreenshotIcon,
  VideoCameraBack as VideoIcon,
  Refresh as RefreshIcon
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Real-time Test Recorder Client Component
 * Provides UI for recording user interactions and converting them to test steps
 */
const RecorderClient = ({ onStepsRecorded }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  const navigate = useNavigate();
  const { projectId } = useParams();
  
  const [loading, setLoading] = useState(false);
  const [currentTab, setCurrentTab] = useState(0);
  const [recording, setRecording] = useState(false);
  const [recordingSession, setRecordingSession] = useState(null);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [targetUrl, setTargetUrl] = useState('');
  const [selectedBrowser, setSelectedBrowser] = useState('CHROMIUM');
  const [headless, setHeadless] = useState(false);
  const [viewport, setViewport] = useState({ width: 1280, height: 720 });
  const [previewStepIndex, setPreviewStepIndex] = useState(-1);
  const [previewImage, setPreviewImage] = useState(null);
  const [previewDialog, setPreviewDialog] = useState(false);
  const [editStepDialog, setEditStepDialog] = useState(false);
  const [currentStep, setCurrentStep] = useState(null);
  const [saveTestDialog, setSaveTestDialog] = useState(false);
  const [testName, setTestName] = useState('');
  const [testDescription, setTestDescription] = useState('');
  
  const pollingInterval = useRef(null);
  
  // Browser options
  const browserOptions = [
    { value: 'CHROMIUM', label: 'Chromium' },
    { value: 'FIREFOX', label: 'Firefox' },
    { value: 'WEBKIT', label: 'WebKit' }
  ];
  
  // Clean up resources on unmount
  useEffect(() => {
    return () => {
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
      }
      
      // If recording is still active, stop it
      if (recording && recordingSession) {
        stopRecording();
      }
    };
  }, [recording, recordingSession]);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Start recording
  const startRecording = async () => {
    if (!targetUrl) {
      enqueueSnackbar('Please enter a URL to record', { variant: 'error' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Create browser options
      const options = {
        browserType: selectedBrowser,
        headless: headless,
        viewportWidth: viewport.width,
        viewportHeight: viewport.height
      };
      
      // Start recording session
      const response = await api.post(`/projects/${projectId}/recorder/sessions`, {
        url: targetUrl,
        browserOptions: options
      });
      
      const sessionId = response.data.id;
      
      // Start the recording
      await api.post(`/recorder/sessions/${sessionId}/start`);
      
      setRecordingSession(response.data);
      setRecording(true);
      setRecordedSteps([]);
      
      // Start polling for recorded steps
      startPolling(sessionId);
      
      enqueueSnackbar('Recording started', { variant: 'success' });
    } catch (error) {
      console.error('Error starting recording:', error);
      enqueueSnackbar('Failed to start recording', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Stop recording
  const stopRecording = async () => {
    if (!recordingSession) return;
    
    try {
      setLoading(true);
      
      // Stop polling
      if (pollingInterval.current) {
        clearInterval(pollingInterval.current);
        pollingInterval.current = null;
      }
      
      // Stop the recording
      await api.post(`/recorder/sessions/${recordingSession.id}/stop`);
      
      // Get final session data
      const response = await api.get(`/recorder/sessions/${recordingSession.id}`);
      
      setRecordingSession(response.data);
      setRecording(false);
      setRecordedSteps(response.data.recordedSteps || []);
      
      enqueueSnackbar('Recording stopped', { variant: 'success' });
    } catch (error) {
      console.error('Error stopping recording:', error);
      enqueueSnackbar('Failed to stop recording', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Start polling for updates
  const startPolling = (sessionId) => {
    // Clear any existing intervals
    if (pollingInterval.current) {
      clearInterval(pollingInterval.current);
    }
    
    // Set up polling
    pollingInterval.current = setInterval(async () => {
      try {
        // Get session data
        const response = await api.get(`/recorder/sessions/${sessionId}`);
        
        // Update state
        setRecordingSession(response.data);
        setRecordedSteps(response.data.recordedSteps || []);
        
        // If session is no longer recording, stop polling
        if (response.data.status !== 'RECORDING') {
          clearInterval(pollingInterval.current);
          pollingInterval.current = null;
          setRecording(false);
        }
      } catch (error) {
        console.error('Error polling recording session:', error);
        
        // If there's an error, stop polling
        clearInterval(pollingInterval.current);
        pollingInterval.current = null;
      }
    }, 1000); // Poll every second
  };
  
  // Save as test
  const saveAsTest = async () => {
    if (!testName.trim()) {
      enqueueSnackbar('Please enter a test name', { variant: 'error' });
      return;
    }
    
    try {
      setLoading(true);
      
      // Create test case from recording
      const response = await api.post(`/recorder/sessions/${recordingSession.id}/save`, {
        name: testName,
        description: testDescription
      });
      
      // Close dialog
      setSaveTestDialog(false);
      
      // Notify parent component
      if (onStepsRecorded) {
        onStepsRecorded(recordedSteps);
      }
      
      enqueueSnackbar('Test case created successfully', { variant: 'success' });
      
      // Navigate to the test case
      navigate(`/projects/${projectId}/test-cases/${response.data.id}`);
    } catch (error) {
      console.error('Error saving test:', error);
      enqueueSnackbar('Failed to save test', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Show step preview
  const showStepPreview = async (index) => {
    if (!recordingSession || index < 0 || index >= recordedSteps.length) return;
    
    try {
      setPreviewStepIndex(index);
      setLoading(true);
      
      // Get step screenshot
      const response = await api.get(
        `/recorder/sessions/${recordingSession.id}/steps/${recordedSteps[index].id}/screenshot`,
        { responseType: 'blob' }
      );
      
      // Create URL from blob
      const url = URL.createObjectURL(response.data);
      setPreviewImage(url);
      setPreviewDialog(true);
    } catch (error) {
      console.error('Error getting step preview:', error);
      enqueueSnackbar('Failed to load preview', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Handle preview dialog close
  const handlePreviewClose = () => {
    setPreviewDialog(false);
    if (previewImage) {
      URL.revokeObjectURL(previewImage);
      setPreviewImage(null);
    }
  };
  
  // Edit step
  const editStep = (step) => {
    setCurrentStep({ ...step });
    setEditStepDialog(true);
  };
  
  // Update step
  const updateStep = async () => {
    if (!currentStep) return;
    
    try {
      setLoading(true);
      
      // Update step
      await api.put(
        `/recorder/sessions/${recordingSession.id}/steps/${currentStep.id}`,
        currentStep
      );
      
      // Get updated session
      const response = await api.get(`/recorder/sessions/${recordingSession.id}`);
      
      // Update state
      setRecordingSession(response.data);
      setRecordedSteps(response.data.recordedSteps || []);
      
      // Close dialog
      setEditStepDialog(false);
      setCurrentStep(null);
      
      enqueueSnackbar('Step updated successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error updating step:', error);
      enqueueSnackbar('Failed to update step', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Delete step
  const deleteStep = async (stepId) => {
    if (!window.confirm('Are you sure you want to delete this step?')) return;
    
    try {
      setLoading(true);
      
      // Delete step
      await api.delete(`/recorder/sessions/${recordingSession.id}/steps/${stepId}`);
      
      // Get updated session
      const response = await api.get(`/recorder/sessions/${recordingSession.id}`);
      
      // Update state
      setRecordingSession(response.data);
      setRecordedSteps(response.data.recordedSteps || []);
      
      enqueueSnackbar('Step deleted successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error deleting step:', error);
      enqueueSnackbar('Failed to delete step', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Add assertion
  const addAssertion = async (type, selector, value) => {
    try {
      setLoading(true);
      
      // Create assertion step
      const assertion = {
        action: `ASSERT_${type.toUpperCase()}`,
        selector: selector,
        value: value
      };
      
      // Add assertion
      await api.post(
        `/recorder/sessions/${recordingSession.id}/assertions`,
        assertion
      );
      
      // Get updated session
      const response = await api.get(`/recorder/sessions/${recordingSession.id}`);
      
      // Update state
      setRecordingSession(response.data);
      setRecordedSteps(response.data.recordedSteps || []);
      
      enqueueSnackbar('Assertion added successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error adding assertion:', error);
      enqueueSnackbar('Failed to add assertion', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Add wait condition
  const addWaitCondition = async (type, selector, timeout) => {
    try {
      setLoading(true);
      
      // Create wait step
      const waitStep = {
        action: `WAIT_FOR_${type.toUpperCase()}`,
        selector: selector,
        timeout: timeout
      };
      
      // Add wait condition
      await api.post(
        `/recorder/sessions/${recordingSession.id}/wait-conditions`,
        waitStep
      );
      
      // Get updated session
      const response = await api.get(`/recorder/sessions/${recordingSession.id}`);
      
      // Update state
      setRecordingSession(response.data);
      setRecordedSteps(response.data.recordedSteps || []);
      
      enqueueSnackbar('Wait condition added successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error adding wait condition:', error);
      enqueueSnackbar('Failed to add wait condition', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Render step icon based on action
  const renderStepIcon = (action) => {
    if (!action) return <WarningIcon color="warning" />;
    
    const actionType = action.toUpperCase();
    
    if (actionType.startsWith('CLICK')) {
      return <TouchAppIcon color="primary" />;
    } else if (actionType.startsWith('TYPE')) {
      return <KeyboardIcon color="primary" />;
    } else if (actionType.startsWith('NAVIGATE')) {
      return <NavigateNextIcon color="primary" />;
    } else if (actionType.startsWith('SELECT')) {
      return <MenuIcon color="primary" />;
    } else if (actionType.startsWith('ASSERT')) {
      return <CheckIcon color="success" />;
    } else if (actionType.startsWith('WAIT')) {
      return <TimerIcon color="secondary" />;
    } else {
      return <CodeIcon color="default" />;
    }
  };
  
  // Render settings tab
  const renderSettingsTab = () => {
    return (
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>Recording Settings</Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Target URL"
              value={targetUrl}
              onChange={(e) => setTargetUrl(e.target.value)}
              placeholder="https://example.com"
              disabled={recording}
              required
            />
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <TextField
              select
              fullWidth
              label="Browser"
              value={selectedBrowser}
              onChange={(e) => setSelectedBrowser(e.target.value)}
              disabled={recording}
              SelectProps={{
                native: true
              }}
            >
              {browserOptions.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </TextField>
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <FormControlLabel
              control={
                <Switch
                  checked={headless}
                  onChange={(e) => setHeadless(e.target.checked)}
                  disabled={recording}
                />
              }
              label="Headless Mode"
            />
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              type="number"
              label="Viewport Width"
              value={viewport.width}
              onChange={(e) => setViewport({ ...viewport, width: parseInt(e.target.value) })}
              disabled={recording}
              InputProps={{
                inputProps: { min: 320, max: 3840 }
              }}
            />
          </Grid>
          
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              type="number"
              label="Viewport Height"
              value={viewport.height}
              onChange={(e) => setViewport({ ...viewport, height: parseInt(e.target.value) })}
              disabled={recording}
              InputProps={{
                inputProps: { min: 240, max: 2160 }
              }}
            />
          </Grid>
        </Grid>
        
        <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
          {!recording ? (
            <Button
              variant="contained"
              color="primary"
              startIcon={<PlayIcon />}
              onClick={startRecording}
              disabled={loading || !targetUrl}
              sx={{ minWidth: 150 }}
            >
              {loading ? <CircularProgress size={24} /> : 'Start Recording'}
            </Button>
          ) : (
            <Button
              variant="contained"
              color="error"
              startIcon={<StopIcon />}
              onClick={stopRecording}
              disabled={loading}
              sx={{ minWidth: 150 }}
            >
              {loading ? <CircularProgress size={24} /> : 'Stop Recording'}
            </Button>
          )}
        </Box>
      </Paper>
    );
  };
  
  // Render steps tab
  const renderStepsTab = () => {
    return (
      <Paper sx={{ p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6">
            Recorded Steps
            <Chip
              label={recordedSteps.length}
              color="primary"
              size="small"
              sx={{ ml: 1 }}
            />
          </Typography>
          
          <Box>
            {!recording && recordedSteps.length > 0 && (
              <Button
                variant="contained"
                color="primary"
                startIcon={<SaveIcon />}
                onClick={() => setSaveTestDialog(true)}
                disabled={loading}
              >
                Save as Test
              </Button>
            )}
          </Box>
        </Box>
        
        {recordedSteps.length === 0 ? (
          <Paper variant="outlined" sx={{ p: 3, textAlign: 'center' }}>
            <Typography variant="body1" color="textSecondary">
              {recording ? 'Interact with the page to record steps...' : 'No steps recorded yet'}
            </Typography>
          </Paper>
        ) : (
          <List>
            {recordedSteps.map((step, index) => (
              <ListItem
                key={step.id || index}
                divider={index < recordedSteps.length - 1}
                sx={{
                  bgcolor: step.action?.startsWith('ASSERT') ? 'rgba(76, 175, 80, 0.1)' : 
                          step.action?.startsWith('WAIT') ? 'rgba(63, 81, 181, 0.1)' : 
                          'transparent'
                }}
              >
                <ListItemIcon>
                  {renderStepIcon(step.action)}
                </ListItemIcon>
                <ListItemText
                  primary={
                    <Typography variant="subtitle2">
                      {step.action || 'Unknown Action'}
                    </Typography>
                  }
                  secondary={
                    <>
                      {step.selector && (
                        <Typography variant="body2" component="span" display="block">
                          Selector: <code>{step.selector}</code>
                        </Typography>
                      )}
                      {step.target && (
                        <Typography variant="body2" component="span" display="block">
                          Target: <code>{step.target}</code>
                        </Typography>
                      )}
                      {step.value && (
                        <Typography variant="body2" component="span" display="block">
                          Value: <code>{step.value}</code>
                        </Typography>
                      )}
                    </>
                  }
                />
                <Box>
                  <Tooltip title="View Screenshot">
                    <IconButton
                      size="small"
                      onClick={() => showStepPreview(index)}
                      disabled={loading}
                    >
                      <VisibilityIcon />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Edit">
                    <IconButton
                      size="small"
                      onClick={() => editStep(step)}
                      disabled={loading || recording}
                    >
                      <EditIcon />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Delete">
                    <IconButton
                      size="small"
                      onClick={() => deleteStep(step.id)}
                      disabled={loading || recording}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </Tooltip>
                </Box>
              </ListItem>
            ))}
          </List>
        )}
      </Paper>
    );
  };
  
  return (
    <Box>
      <AppBar position="static" color="default" elevation={0}>
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          indicatorColor="primary"
          textColor="primary"
          variant="fullWidth"
        >
          <Tab label="Settings" />
          <Tab 
            label={
              <Badge color="primary" badgeContent={recordedSteps.length} showZero>
                Steps
              </Badge>
            } 
          />
        </Tabs>
      </AppBar>
      
      <Box sx={{ p: 2 }}>
        {currentTab === 0 && renderSettingsTab()}
        {currentTab === 1 && renderStepsTab()}
      </Box>
      
      {/* Preview Dialog */}
      <Dialog open={previewDialog} onClose={handlePreviewClose} maxWidth="lg" fullWidth>
        <DialogTitle>
          Step Preview
          {recordedSteps[previewStepIndex] && (
            <Typography variant="subtitle1" component="span">
              {recordedSteps[previewStepIndex].action}
            </Typography>
          )}
        </DialogTitle>
        <DialogContent>
          {previewImage && (
            <Box sx={{ textAlign: 'center' }}>
              <img 
                src={previewImage} 
                alt="Step Preview" 
                style={{ maxWidth: '100%', maxHeight: '70vh' }} 
              />
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handlePreviewClose}>Close</Button>
        </DialogActions>
      </Dialog>
      
      {/* Edit Step Dialog */}
      <Dialog open={editStepDialog} onClose={() => setEditStepDialog(false)} maxWidth="md" fullWidth>
        <DialogTitle>Edit Step</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                select
                label="Action"
                value={currentStep?.action || ''}
                onChange={(e) => setCurrentStep({ ...currentStep, action: e.target.value })}
                SelectProps={{
                  native: true
                }}
              >
                <option value="CLICK">Click</option>
                <option value="DOUBLE_CLICK">Double Click</option>
                <option value="TYPE">Type</option>
                <option value="SELECT">Select</option>
                <option value="CHECK">Check</option>
                <option value="UNCHECK">Uncheck</option>
                <option value="HOVER">Hover</option>
                <option value="NAVIGATE">Navigate</option>
                <option value="WAIT_FOR_ELEMENT">Wait for Element</option>
                <option value="WAIT_FOR_NAVIGATION">Wait for Navigation</option>
                <option value="WAIT_FOR_TIMEOUT">Wait for Timeout</option>
                <option value="ASSERT_VISIBLE">Assert Visible</option>
                <option value="ASSERT_TEXT">Assert Text</option>
                <option value="ASSERT_VALUE">Assert Value</option>
                <option value="EXECUTE_JAVASCRIPT">Execute JavaScript</option>
              </TextField>
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Selector"
                value={currentStep?.selector || ''}
                onChange={(e) => setCurrentStep({ ...currentStep, selector: e.target.value })}
                disabled={currentStep?.action === 'NAVIGATE' || currentStep?.action === 'WAIT_FOR_TIMEOUT'}
                helperText="CSS selector or XPath"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label={currentStep?.action === 'NAVIGATE' ? 'URL' : 'Value'}
                value={currentStep?.value || ''}
                onChange={(e) => setCurrentStep({ ...currentStep, value: e.target.value })}
                disabled={
                  ['CLICK', 'DOUBLE_CLICK', 'HOVER', 'CHECK', 'UNCHECK', 'WAIT_FOR_ELEMENT', 'WAIT_FOR_NAVIGATION', 'ASSERT_VISIBLE'].includes(currentStep?.action)
                }
              />
            </Grid>
            
            {['WAIT_FOR_ELEMENT', 'WAIT_FOR_TIMEOUT'].includes(currentStep?.action) && (
              <Grid item xs={12} sm={6}>
                <TextField
                  fullWidth
                  label="Timeout (ms)"
                  type="number"
                  value={currentStep?.timeout || 30000}
                  onChange={(e) => setCurrentStep({ ...currentStep, timeout: parseInt(e.target.value) })}
                  InputProps={{
                    inputProps: { min: 0 }
                  }}
                />
              </Grid>
            )}
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditStepDialog(false)}>Cancel</Button>
          <Button onClick={updateStep} variant="contained" color="primary" disabled={loading}>
            {loading ? <CircularProgress size={24} /> : 'Update'}
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Save Test Dialog */}
      <Dialog open={saveTestDialog} onClose={() => setSaveTestDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Save as Test Case</DialogTitle>
        <DialogContent>
          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Test Name"
                value={testName}
                onChange={(e) => setTestName(e.target.value)}
                required
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                value={testDescription}
                onChange={(e) => setTestDescription(e.target.value)}
                multiline
                rows={3}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveTestDialog(false)}>Cancel</Button>
          <Button onClick={saveAsTest} variant="contained" color="primary" disabled={loading || !testName.trim()}>
            {loading ? <CircularProgress size={24} /> : 'Save'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default RecorderClient;



// src/utils/browserUtils.js

/**
 * Browser utilities for working with selectors, elements, and browser automation
 */

/**
 * Optimizes a CSS selector to make it more robust and reliable
 * @param {string} selector - Original CSS selector
 * @param {object} elementInfo - Element information (optional)
 * @returns {string} Optimized selector
 */
export const optimizeSelector = (selector, elementInfo = null) => {
  if (!selector) return null;
  
  // Remove unnecessary whitespace
  let optimized = selector.trim();
  
  // If it's an ID selector, just use that (most reliable)
  if (optimized.startsWith('#') && !optimized.includes(' ') && !optimized.includes('>')) {
    return optimized;
  }
  
  // If we have element info, try to create a better selector
  if (elementInfo) {
    // If element has an ID, use that
    if (elementInfo.attributes && elementInfo.attributes.id) {
      return `#${elementInfo.attributes.id}`;
    }
    
    // If element has a unique data attribute, use that
    const dataAttributes = ['data-testid', 'data-test', 'data-cy', 'data-automation-id'];
    for (const attr of dataAttributes) {
      if (elementInfo.attributes && elementInfo.attributes[attr]) {
        return `[${attr}="${elementInfo.attributes[attr]}"]`;
      }
    }
    
    // If element has a name attribute (form elements), use that
    if (elementInfo.attributes && elementInfo.attributes.name) {
      return `${elementInfo.tagName}[name="${elementInfo.attributes.name}"]`;
    }
  }
  
  // If it's a complex selector, try to simplify it
  if (optimized.includes('>') || optimized.includes(' ') || optimized.length > 100) {
    // If it has classes, try to simplify to just tag + class
    if (optimized.includes('.') && !optimized.startsWith('.')) {
      const tagWithClass = optimized.match(/(\w+)(\.\w+(-\w+)*)+/);
      if (tagWithClass && tagWithClass[0]) {
        return tagWithClass[0];
      }
    }
  }
  
  return optimized;
};

/**
 * Generates multiple alternative selectors for an element
 * @param {object} elementInfo - Element information
 * @returns {object} Map of selector types to selectors
 */
export const generateAlternativeSelectors = (elementInfo) => {
  if (!elementInfo) return {};
  
  const selectors = {};
  
  // ID selector
  if (elementInfo.attributes && elementInfo.attributes.id) {
    selectors.id = `#${elementInfo.attributes.id}`;
  }
  
  // Tag selector
  if (elementInfo.tagName) {
    selectors.tag = elementInfo.tagName;
  }
  
  // Class selector
  if (elementInfo.attributes && elementInfo.attributes.class) {
    const classes = elementInfo.attributes.class.split(/\s+/).filter(Boolean);
    if (classes.length > 0) {
      selectors.class = `${elementInfo.tagName}.${classes.join('.')}`;
    }
  }
  
  // Data attribute selectors
  const dataAttributes = ['data-testid', 'data-test', 'data-cy', 'data-automation-id'];
  for (const attr of dataAttributes) {
    if (elementInfo.attributes && elementInfo.attributes[attr]) {
      selectors[attr] = `[${attr}="${elementInfo.attributes[attr]}"]`;
    }
  }
  
  // Name attribute (for form elements)
  if (elementInfo.attributes && elementInfo.attributes.name) {
    selectors.name = `${elementInfo.tagName}[name="${elementInfo.attributes.name}"]`;
  }
  
  // Text content selector
  if (elementInfo.textContent && elementInfo.textContent.trim()) {
    const text = elementInfo.textContent.trim();
    if (text.length <= 50) {
      selectors.text = `${elementInfo.tagName}:has-text("${text}")`;
    }
  }
  
  // XPath
  if (elementInfo.xpath) {
    selectors.xpath = elementInfo.xpath;
  }
  
  // CSS Path
  if (elementInfo.cssPath) {
    selectors.cssPath = elementInfo.cssPath;
  }
  
  return selectors;
};

/**
 * Checks if a selector is unique in the current document
 * @param {string} selector - CSS selector
 * @returns {boolean} True if selector is unique
 */
export const isSelectorUnique = (selector) => {
  try {
    const elements = document.querySelectorAll(selector);
    return elements.length === 1;
  } catch (error) {
    console.error('Error checking selector uniqueness:', error);
    return false;
  }
};

/**
 * Scores selectors based on reliability and robustness
 * Higher score is better
 * @param {object} selectors - Map of selector types to selectors
 * @returns {Array} Sorted array of [selector, score] pairs
 */
export const rankSelectors = (selectors) => {
  if (!selectors || Object.keys(selectors).length === 0) return [];
  
  const scores = {};
  
  // Scoring criteria:
  // 1. ID selectors are most reliable
  // 2. Data attributes are next best
  // 3. Unique class or tag+class selectors are good
  // 4. XPath is less reliable
  // 5. Text content selectors can be brittle
  
  for (const [type, selector] of Object.entries(selectors)) {
    let score = 0;
    
    // Base score by type
    switch (type) {
      case 'id':
        score += 100;
        break;
      case 'data-testid':
      case 'data-test':
      case 'data-cy':
      case 'data-automation-id':
        score += 90;
        break;
      case 'name':
        score += 80;
        break;
      case 'class':
        score += 70;
        break;
      case 'tag':
        score += 30;
        break;
      case 'text':
        score += 40;
        break;
      case 'xpath':
        score += 20;
        break;
      case 'cssPath':
        score += 10;
        break;
      default:
        score += 5;
    }
    
    // Penalize overly complex selectors
    const complexity = (selector.match(/[>\s+~]/g) || []).length;
    score -= complexity * 5;
    
    // Penalize very long selectors
    if (selector.length > 100) {
      score -= 20;
    } else if (selector.length > 50) {
      score -= 10;
    }
    
    // Check uniqueness if possible
    try {
      if (typeof document !== 'undefined' && isSelectorUnique(selector)) {
        score += 15;
      }
    } catch (e) {
      // Ignore errors when checking uniqueness
    }
    
    scores[selector] = score;
  }
  
  // Sort by score (descending)
  return Object.entries(scores).sort((a, b) => b[1] - a[1]);
};

/**
 * Extracts element information from a DOM element
 * @param {Element} element - DOM element
 * @returns {object} Element information
 */
export const getElementInfo = (element) => {
  if (!element || typeof element !== 'object') return null;
  
  // Get bounding box
  const rect = element.getBoundingClientRect();
  
  // Get attributes
  const attributes = {};
  for (const attr of element.attributes) {
    attributes[attr.name] = attr.value;
  }
  
  // Get text content with whitespace normalized
  const textContent = element.textContent.replace(/\s+/g, ' ').trim();
  
  // Get computed style
  const style = window.getComputedStyle(element);
  
  return {
    tagName: element.tagName.toLowerCase(),
    attributes,
    textContent,
    boundingBox: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    xpath: getXPath(element),
    cssPath: getCssPath(element),
    visible: isElementVisible(element),
    zIndex: parseInt(style.zIndex) || 0
  };
};

/**
 * Generates an XPath for a DOM element
 * @param {Element} element - DOM element
 * @returns {string} XPath
 */
export const getXPath = (element) => {
  if (!element) return null;
  
  // If element has an ID, use a simple XPath with the ID
  if (element.id) {
    return `//*[@id="${element.id}"]`;
  }
  
  // If we reach the body, return the path
  if (element === document.body) {
    return '/html/body';
  }
  
  // Count the element's position among siblings of the same type
  let position = 1;
  let sibling = element.previousSibling;
  
  while (sibling) {
    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
      position++;
    }
    sibling = sibling.previousSibling;
  }
  
  // Recursively build the path
  return `${getXPath(element.parentNode)}/${element.tagName.toLowerCase()}[${position}]`;
};

/**
 * Generates a CSS path for a DOM element
 * @param {Element} element - DOM element
 * @returns {string} CSS path
 */
export const getCssPath = (element) => {
  if (!element) return null;
  
  // If element has an ID, use that
  if (element.id) {
    return `#${element.id}`;
  }
  
  // If we reach the body, return the body selector
  if (element === document.body) {
    return 'body';
  }
  
  // Build the selector for this element
  let selector = element.tagName.toLowerCase();
  
  // Add classes
  if (element.className) {
    const classes = element.className.split(/\s+/).filter(Boolean);
    if (classes.length > 0) {
      selector += `.${classes.join('.')}`;
    }
  }
  
  // Recursively build the path
  return `${getCssPath(element.parentNode)} > ${selector}`;
};

/**
 * Checks if an element is visible
 * @param {Element} element - DOM element
 * @returns {boolean} True if element is visible
 */
export const isElementVisible = (element) => {
  if (!element) return false;
  
  const style = window.getComputedStyle(element);
  
  return style.display !== 'none' && 
         style.visibility !== 'hidden' && 
         style.opacity !== '0' &&
         element.offsetWidth > 0 && 
         element.offsetHeight > 0;
};

/**
 * Calculates the similarity between two element info objects
 * Higher score (0-1) means more similar
 * @param {object} element1 - First element info
 * @param {object} element2 - Second element info
 * @returns {number} Similarity score (0-1)
 */
export const calculateElementSimilarity = (element1, element2) => {
  if (!element1 || !element2) return 0;
  
  let score = 0;
  let totalWeight = 0;
  
  // Check tag name (high weight)
  if (element1.tagName === element2.tagName) {
    score += 3;
  }
  totalWeight += 3;
  
  // Check attributes (moderate weight)
  const attributes1 = element1.attributes || {};
  const attributes2 = element2.attributes || {};
  
  // Important attributes
  const keyAttributes = ['id', 'name', 'class', 'type', 'role', 'aria-label'];
  
  for (const attr of keyAttributes) {
    if (attributes1[attr] && attributes2[attr]) {
      if (attributes1[attr] === attributes2[attr]) {
        score += 2;
      } else if (attr === 'class') {
        // For class, check common classes
        const classes1 = attributes1[attr].split(/\s+/).filter(Boolean);
        const classes2 = attributes2[attr].split(/\s+/).filter(Boolean);
        const commonClasses = classes1.filter(cls => classes2.includes(cls));
        
        if (commonClasses.length > 0) {
          score += (1 * commonClasses.length / Math.max(classes1.length, classes2.length));
        }
      }
    }
    totalWeight += 2;
  }
  
  // Check text content (moderate weight)
  if (element1.textContent && element2.textContent) {
    if (element1.textContent === element2.textContent) {
      score += 2;
    } else {
      // Calculate text similarity
      const textSimilarity = calculateStringSimilarity(element1.textContent, element2.textContent);
      score += 2 * textSimilarity;
    }
  }
  totalWeight += 2;
  
  // Check position (low weight)
  if (element1.boundingBox && element2.boundingBox) {
    const box1 = element1.boundingBox;
    const box2 = element2.boundingBox;
    
    // Position similarity based on proximity
    const centerX1 = box1.x + box1.width / 2;
    const centerY1 = box1.y + box1.height / 2;
    const centerX2 = box2.x + box2.width / 2;
    const centerY2 = box2.y + box2.height / 2;
    
    // Max distance for normalization
    const maxDistance = Math.sqrt(
      Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)
    );
    
    const distance = Math.sqrt(
      Math.pow(centerX1 - centerX2, 2) + Math.pow(centerY1 - centerY2, 2)
    );
    
    // Normalize to 0-1 (1 is closest)
    const positionSimilarity = 1 - Math.min(distance / maxDistance, 1);
    score += positionSimilarity;
  }
  totalWeight += 1;
  
  // Normalize score to 0-1
  return score / totalWeight;
};

/**
 * Calculates string similarity using Levenshtein distance
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} Similarity score (0-1)
 */
export const calculateStringSimilarity = (str1, str2) => {
  if (typeof str1 !== 'string' || typeof str2 !== 'string') return 0;
  if (str1 === str2) return 1;
  
  // Normalize strings
  const s1 = str1.toLowerCase().trim();
  const s2 = str2.toLowerCase().trim();
  
  if (s1 === s2) return 1;
  if (s1.length === 0 || s2.length === 0) return 0;
  
  // Calculate Levenshtein distance
  const track = Array(s2.length + 1).fill(null).map(() => 
    Array(s1.length + 1).fill(null));
  
  for (let i = 0; i <= s1.length; i += 1) {
    track[0][i] = i;
  }
  
  for (let j = 0; j <= s2.length; j += 1) {
    track[j][0] = j;
  }
  
  for (let j = 1; j <= s2.length; j += 1) {
    for (let i = 1; i <= s1.length; i += 1) {
      const indicator = s1[i - 1] === s2[j - 1] ? 0 : 1;
      track[j][i] = Math.min(
        track[j][i - 1] + 1, // deletion
        track[j - 1][i] + 1, // insertion
        track[j - 1][i - 1] + indicator, // substitution
      );
    }
  }
  
  // Calculate similarity as 1 - normalized distance
  return 1 - (track[s2.length][s1.length] / Math.max(s1.length, s2.length));
};

// Export all utilities
export default {
  optimizeSelector,
  generateAlternativeSelectors,
  isSelectorUnique,
  rankSelectors,
  getElementInfo,
  getXPath,
  getCssPath,
  isElementVisible,
  calculateElementSimilarity,
  calculateStringSimilarity
};


// src/utils/webSocketUtils.js

import SockJS from 'sockjs-client';
import { Stomp } from '@stomp/stompjs';

/**
 * WebSocket client for real-time communication with the server
 * Provides connections to STOMP over SockJS
 */
class WebSocketClient {
  constructor(serverUrl) {
    this.serverUrl = serverUrl || '/api/websocket';
    this.stompClient = null;
    this.connected = false;
    this.subscriptions = new Map();
    this.reconnectDelay = 5000;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 10;
    this.connectionCallback = null;
    this.errorCallback = null;
    this.automaticReconnect = true;
  }

  /**
   * Connects to the WebSocket server
   * @param {Function} onConnected - Callback when connection is established
   * @param {Function} onError - Callback when an error occurs
   * @returns {Promise} Promise that resolves when connected
   */
  connect(onConnected, onError) {
    if (this.connected && this.stompClient) {
      if (onConnected) onConnected();
      return Promise.resolve();
    }
    
    this.connectionCallback = onConnected;
    this.errorCallback = onError;
    
    return new Promise((resolve, reject) => {
      try {
        // Create SockJS connection
        const socket = new SockJS(this.serverUrl);
        
        // Create STOMP client
        this.stompClient = Stomp.over(socket);
        
        // Disable debug logging
        this.stompClient.debug = () => {};
        
        // Connect to server
        this.stompClient.connect(
          {}, // Headers
          frame => {
            this.connected = true;
            this.reconnectAttempts = 0;
            
            console.log('WebSocket connected');
            
            // Resubscribe to previous topics
            this.resubscribe();
            
            if (this.connectionCallback) {
              this.connectionCallback(frame);
            }
            
            resolve(frame);
          },
          error => {
            this.connected = false;
            console.error('WebSocket connection error:', error);
            
            if (this.errorCallback) {
              this.errorCallback(error);
            }
            
            // Attempt to reconnect
            if (this.automaticReconnect) {
              this.scheduleReconnect();
            }
            
            reject(error);
          }
        );
      } catch (error) {
        console.error('WebSocket initialization error:', error);
        
        if (this.errorCallback) {
          this.errorCallback(error);
        }
        
        reject(error);
      }
    });
  }

  /**
   * Disconnects from the WebSocket server
   * @returns {Promise} Promise that resolves when disconnected
   */
  disconnect() {
    return new Promise((resolve) => {
      if (!this.connected || !this.stompClient) {
        this.connected = false;
        resolve();
        return;
      }
      
      try {
        this.stompClient.disconnect(() => {
          this.connected = false;
          console.log('WebSocket disconnected');
          resolve();
        });
      } catch (error) {
        console.error('WebSocket disconnection error:', error);
        this.connected = false;
        resolve();
      }
    });
  }

  /**
   * Schedules a reconnection attempt
   */
  scheduleReconnect() {
    this.reconnectAttempts++;
    
    if (this.reconnectAttempts > this.maxReconnectAttempts) {
      console.warn(`Maximum reconnect attempts (${this.maxReconnectAttempts}) reached. Giving up.`);
      return;
    }
    
    const delay = this.reconnectDelay * Math.min(this.reconnectAttempts, 5);
    
    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    setTimeout(() => {
      if (!this.connected) {
        console.log(`Attempting to reconnect (${this.reconnectAttempts})...`);
        this.connect(this.connectionCallback, this.errorCallback)
          .catch(() => {
            // Error is already handled in connect method
          });
      }
    }, delay);
  }

  /**
   * Subscribes to a topic
   * @param {string} topic - Topic to subscribe to
   * @param {Function} callback - Callback when a message is received
   * @returns {string} Subscription ID
   */
  subscribe(topic, callback) {
    if (!this.connected || !this.stompClient) {
      throw new Error('Not connected to WebSocket server');
    }
    
    try {
      const subscription = this.stompClient.subscribe(topic, message => {
        let parsedBody;
        
        // Try to parse message body as JSON
        try {
          parsedBody = JSON.parse(message.body);
        } catch (e) {
          parsedBody = message.body;
        }
        
        callback(parsedBody, message);
      });
      
      // Store subscription
      this.subscriptions.set(topic, {
        id: subscription.id,
        callback
      });
      
      return subscription.id;
    } catch (error) {
      console.error(`Error subscribing to ${topic}:`, error);
      throw error;
    }
  }

  /**
   * Unsubscribes from a topic
   * @param {string} topic - Topic to unsubscribe from
   */
  unsubscribe(topic) {
    if (!this.connected || !this.stompClient) {
      return;
    }
    
    const subscription = this.subscriptions.get(topic);
    
    if (subscription) {
      try {
        this.stompClient.unsubscribe(subscription.id);
        this.subscriptions.delete(topic);
      } catch (error) {
        console.error(`Error unsubscribing from ${topic}:`, error);
      }
    }
  }

  /**
   * Resubscribes to all previously subscribed topics
   */
  resubscribe() {
    if (!this.connected || !this.stompClient) {
      return;
    }
    
    // Store subscriptions in a temporary array
    const topics = Array.from(this.subscriptions.entries());
    
    // Clear subscriptions
    this.subscriptions.clear();
    
    // Resubscribe to each topic
    topics.forEach(([topic, { callback }]) => {
      try {
        this.subscribe(topic, callback);
      } catch (error) {
        console.error(`Error resubscribing to ${topic}:`, error);
      }
    });
  }

  /**
   * Sends a message to a destination
   * @param {string} destination - Destination to send to
   * @param {object|string} body - Message body
   * @param {object} headers - Optional message headers
   */
  send(destination, body, headers = {}) {
    if (!this.connected || !this.stompClient) {
      throw new Error('Not connected to WebSocket server');
    }
    
    try {
      const payload = typeof body === 'string' ? body : JSON.stringify(body);
      
      this.stompClient.send(destination, headers, payload);
    } catch (error) {
      console.error(`Error sending message to ${destination}:`, error);
      throw error;
    }
  }
}

// Create a singleton instance
const wsClient = new WebSocketClient();

/**
 * Hook for using WebSocket in React components
 * @param {string} serverUrl - WebSocket server URL (optional)
 * @returns {object} WebSocket hook state and methods
 */
export const useWebSocket = (serverUrl) => {
  const [connected, setConnected] = React.useState(wsClient.connected);
  const [error, setError] = React.useState(null);
  
  // Set server URL if provided
  if (serverUrl) {
    wsClient.serverUrl = serverUrl;
  }
  
  // Connect to WebSocket server
  React.useEffect(() => {
    const onConnected = () => {
      setConnected(true);
      setError(null);
    };
    
    const onError = (err) => {
      setConnected(false);
      setError(err);
    };
    
    // Connect if not already connected
    if (!wsClient.connected) {
      wsClient.connect(onConnected, onError)
        .catch(() => {
          // Error is already handled in connect method
        });
    } else {
      setConnected(true);
    }
    
    // Disconnect when component unmounts
    return () => {
      // We don't disconnect on unmount to maintain ongoing connections
      // If needed, call disconnect manually
    };
  }, [serverUrl]);
  
  /**
   * Subscribes to a topic
   * @param {string} topic - Topic to subscribe to
   * @param {Function} callback - Callback when a message is received
   */
  const subscribe = React.useCallback((topic, callback) => {
    if (!wsClient.connected) {
      // Connect first if not connected
      return wsClient.connect(() => {
        wsClient.subscribe(topic, callback);
      })
        .catch((err) => {
          setError(err);
          throw err;
        });
    }
    
    return wsClient.subscribe(topic, callback);
  }, []);
  
  /**
   * Unsubscribes from a topic
   * @param {string} topic - Topic to unsubscribe from
   */
  const unsubscribe = React.useCallback((topic) => {
    wsClient.unsubscribe(topic);
  }, []);
  
  /**
   * Sends a message to a destination
   * @param {string} destination - Destination to send to
   * @param {object|string} body - Message body
   * @param {object} headers - Optional message headers
   */
  const send = React.useCallback((destination, body, headers = {}) => {
    if (!wsClient.connected) {
      // Connect first if not connected
      return wsClient.connect(() => {
        wsClient.send(destination, body, headers);
      })
        .catch((err) => {
          setError(err);
          throw err;
        });
    }
    
    wsClient.send(destination, body, headers);
  }, []);
  
  /**
   * Disconnects from the WebSocket server
   */
  const disconnect = React.useCallback(() => {
    wsClient.disconnect()
      .then(() => {
        setConnected(false);
      });
  }, []);
  
  return {
    connected,
    error,
    subscribe,
    unsubscribe,
    send,
    disconnect
  };
};

// Export the client for direct usage
export default wsClient;



// src/components/execution/ExecutionMonitor.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box,
  Typography,
  Paper,
  CircularProgress,
  LinearProgress,
  Stepper,
  Step,
  StepLabel,
  StepContent,
  Button,
  IconButton,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Tooltip,
  Grid,
  Card,
  CardContent,
  CardHeader,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  CheckCircle as CheckCircleIcon,
  Cancel as CancelIcon,
  Warning as WarningIcon,
  PlayArrow as PlayIcon,
  Pause as PauseIcon,
  Stop as StopIcon,
  Refresh as RefreshIcon,
  Visibility as VisibilityIcon,
  Code as CodeIcon,
  BugReport as BugReportIcon,
  Timer as TimerIcon,
  Screenshot as ScreenshotIcon
} from '@mui/icons-material';
import { useParams } from 'react-router-dom';
import { useApi } from '../../contexts/ApiContext';
import { useWebSocket } from '../../utils/webSocketUtils';
import { useSnackbar } from 'notistack';

/**
 * Real-time Execution Monitor Component
 * Shows real-time status and progress of test execution
 */
const ExecutionMonitor = ({ executionId, onComplete }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  const { projectId } = useParams();
  
  const [loading, setLoading] = useState(true);
  const [execution, setExecution] = useState(null);
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState('PENDING');
  const [testCaseResults, setTestCaseResults] = useState([]);
  const [currentTestCase, setCurrentTestCase] = useState(null);
  const [currentStep, setCurrentStep] = useState(null);
  const [screenshotDialog, setScreenshotDialog] = useState(false);
  const [screenshotUrl, setScreenshotUrl] = useState(null);
  const [overallDuration, setOverallDuration] = useState(0);
  const [refreshInterval, setRefreshInterval] = useState(null);
  
  // WebSocket for real-time updates
  const { connected, subscribe, unsubscribe } = useWebSocket();
  
  // References to track mount state
  const isMounted = useRef(true);
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      isMounted.current = false;
      
      // Stop the refresh interval
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
      
      // Unsubscribe from WebSocket topics
      unsubscribe(`/topic/executions/${executionId}`);
    };
  }, [executionId, unsubscribe, refreshInterval]);
  
  // Load initial execution data
  useEffect(() => {
    const fetchExecution = async () => {
      if (!executionId) return;
      
      try {
        setLoading(true);
        
        const response = await api.get(`/executions/results/${executionId}`);
        
        if (isMounted.current) {
          setExecution(response.data);
          setStatus(response.data.status);
          setTestCaseResults(response.data.testCaseResults || []);
          
          // Calculate progress
          calculateProgress(response.data);
          
          // Calculate duration
          calculateDuration(response.data);
          
          setLoading(false);
          
          // If execution is completed, notify the parent component
          if (['COMPLETED', 'FAILED', 'ABORTED'].includes(response.data.status) && onComplete) {
            onComplete(response.data);
          }
        }
      } catch (error) {
        console.error('Error fetching execution:', error);
        
        if (isMounted.current) {
          enqueueSnackbar('Failed to fetch execution details', { variant: 'error' });
          setLoading(false);
        }
      }
    };
    
    fetchExecution();
  }, [executionId, api, enqueueSnackbar, onComplete]);
  
  // Subscribe to WebSocket for real-time updates
  useEffect(() => {
    if (!executionId || !connected) return;
    
    const handleExecutionUpdate = (data) => {
      if (!isMounted.current) return;
      
      setStatus(data.status);
      
      // Update test case results if provided
      if (data.testCaseResults) {
        setTestCaseResults(data.testCaseResults);
      }
      
      // Update current test case if provided
      if (data.currentTestCase) {
        setCurrentTestCase(data.currentTestCase);
      }
      
      // Update current step if provided
      if (data.currentStep) {
        setCurrentStep(data.currentStep);
      }
      
      // Update progress
      setProgress(data.progress || 0);
      
      // Update duration
      if (data.duration) {
        setOverallDuration(data.duration);
      }
      
      // If execution is completed, notify the parent component
      if (['COMPLETED', 'FAILED', 'ABORTED'].includes(data.status) && onComplete) {
        onComplete(data);
      }
    };
    
    // Subscribe to execution updates
    subscribe(`/topic/executions/${executionId}`, handleExecutionUpdate);
    
    // If WebSocket is not connected, set up a polling interval as fallback
    if (!connected && !refreshInterval) {
      const interval = setInterval(async () => {
        if (!isMounted.current) {
          clearInterval(interval);
          return;
        }
        
        try {
          const response = await api.get(`/executions/results/${executionId}`);
          
          if (isMounted.current) {
            setExecution(response.data);
            setStatus(response.data.status);
            setTestCaseResults(response.data.testCaseResults || []);
            
            // Calculate progress
            calculateProgress(response.data);
            
            // Calculate duration
            calculateDuration(response.data);
            
            // If execution is completed, notify the parent component
            if (['COMPLETED', 'FAILED', 'ABORTED'].includes(response.data.status) && onComplete) {
              onComplete(response.data);
              
              // Clear interval when completed
              clearInterval(interval);
              setRefreshInterval(null);
            }
          }
        } catch (error) {
          console.error('Error polling execution:', error);
        }
      }, 2000); // Poll every 2 seconds
      
      setRefreshInterval(interval);
    }
    
    // Cleanup: unsubscribe from topics and clear interval
    return () => {
      unsubscribe(`/topic/executions/${executionId}`);
      
      if (refreshInterval) {
        clearInterval(refreshInterval);
        setRefreshInterval(null);
      }
    };
  }, [executionId, connected, subscribe, unsubscribe, api, onComplete, refreshInterval, enqueueSnackbar]);
  
  // Helper function to calculate progress
  const calculateProgress = (executionData) => {
    if (!executionData) return;
    
    // If execution has explicit progress field, use that
    if (executionData.progress !== undefined) {
      setProgress(executionData.progress);
      return;
    }
    
    // Otherwise calculate based on test case results
    const testCaseResults = executionData.testCaseResults || [];
    const totalTestCases = executionData.totalTests || testCaseResults.length;
    
    if (totalTestCases === 0) {
      setProgress(0);
      return;
    }
    
    const completedTestCases = testCaseResults.filter(
      result => ['PASSED', 'FAILED', 'SKIPPED'].includes(result.status)
    ).length;
    
    // Calculate progress percentage
    const percentage = Math.floor((completedTestCases / totalTestCases) * 100);
    
    setProgress(percentage);
  };
  
  // Helper function to calculate duration
  const calculateDuration = (executionData) => {
    if (!executionData) return;
    
    // If execution has explicit duration field, use that
    if (executionData.duration !== undefined) {
      setOverallDuration(executionData.duration);
      return;
    }
    
    // Calculate based on start and end times
    if (executionData.startTime) {
      const startTime = new Date(executionData.startTime).getTime();
      const endTime = executionData.endTime 
        ? new Date(executionData.endTime).getTime() 
        : Date.now();
      
      const duration = endTime - startTime;
      setOverallDuration(duration);
    }
  };
  
  // Stop execution
  const stopExecution = async () => {
    if (!executionId) return;
    
    if (!window.confirm('Are you sure you want to stop this execution?')) {
      return;
    }
    
    try {
      await api.post(`/executions/${executionId}/stop`);
      
      enqueueSnackbar('Execution stopped successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error stopping execution:', error);
      enqueueSnackbar('Failed to stop execution', { variant: 'error' });
    }
  };
  
  // View screenshot
  const viewScreenshot = async (screenshotPath) => {
    if (!screenshotPath) return;
    
    try {
      const response = await api.get(
        `/executions/${executionId}/screenshots/${screenshotPath}`,
        { responseType: 'blob' }
      );
      
      const url = URL.createObjectURL(response.data);
      setScreenshotUrl(url);
      setScreenshotDialog(true);
    } catch (error) {
      console.error('Error fetching screenshot:', error);
      enqueueSnackbar('Failed to load screenshot', { variant: 'error' });
    }
  };
  
  // Close screenshot dialog
  const closeScreenshotDialog = () => {
    setScreenshotDialog(false);
    
    // Clean up the object URL
    if (screenshotUrl) {
      URL.revokeObjectURL(screenshotUrl);
      setScreenshotUrl(null);
    }
  };
  
  // Format duration in a human-readable way
  const formatDuration = (durationMs) => {
    if (durationMs < 1000) {
      return `${durationMs}ms`;
    } else if (durationMs < 60000) {
      return `${(durationMs / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(durationMs / 60000);
      const seconds = ((durationMs % 60000) / 1000).toFixed(0);
      return `${minutes}m ${seconds}s`;
    }
  };
  
  // Get status chip color
  const getStatusColor = (status) => {
    switch (status?.toUpperCase()) {
      case 'PASSED':
      case 'COMPLETED':
        return 'success';
      case 'FAILED':
        return 'error';
      case 'RUNNING':
      case 'PENDING':
        return 'primary';
      case 'SKIPPED':
        return 'default';
      case 'ABORTED':
        return 'warning';
      default:
        return 'default';
    }
  };
  
  // Get status icon
  const getStatusIcon = (status) => {
    switch (status?.toUpperCase()) {
      case 'PASSED':
      case 'COMPLETED':
        return <CheckCircleIcon color="success" />;
      case 'FAILED':
        return <CancelIcon color="error" />;
      case 'RUNNING':
      case 'PENDING':
        return <CircularProgress size={24} />;
      case 'SKIPPED':
        return <WarningIcon color="disabled" />;
      case 'ABORTED':
        return <StopIcon color="warning" />;
      default:
        return <HelpIcon />;
    }
  };
  
  // Render loading state
  if (loading) {
    return (
      <Box 
        sx={{ 
          display: 'flex', 
          flexDirection: 'column',
          alignItems: 'center', 
          justifyContent: 'center',
          p: 3 
        }}
      >
        <CircularProgress size={40} sx={{ mb: 2 }} />
        <Typography>Loading execution details...</Typography>
      </Box>
    );
  }
  
  // Render execution summary
  return (
    <Box>
      {/* Execution Summary Card */}
      <Card sx={{ mb: 3 }}>
        <CardHeader
          title="Execution Status"
          subheader={`ID: ${executionId}`}
          action={
            <Box>
              <Chip
                label={status}
                color={getStatusColor(status)}
                sx={{ fontWeight: 'bold', mr: 1 }}
              />
              {['RUNNING', 'PENDING'].includes(status) && (
                <Tooltip title="Stop Execution">
                  <IconButton color="error" onClick={stopExecution}>
                    <StopIcon />
                  </IconButton>
                </Tooltip>
              )}
            </Box>
          }
        />
        <Divider />
        <CardContent>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12}>
              <LinearProgress 
                variant="determinate" 
                value={progress}
                sx={{ height: 10, borderRadius: 5 }}
              />
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Progress: {progress}%
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Duration: {formatDuration(overallDuration)}
                </Typography>
              </Box>
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h6">
                  {testCaseResults.filter(r => r.status === 'PASSED').length}
                </Typography>
                <Typography variant="body2" color="success.main">
                  Passed
                </Typography>
              </Box>
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h6">
                  {testCaseResults.filter(r => r.status === 'FAILED').length}
                </Typography>
                <Typography variant="body2" color="error.main">
                  Failed
                </Typography>
              </Box>
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h6">
                  {testCaseResults.filter(r => r.status === 'SKIPPED').length}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Skipped
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
      
      {/* Current Execution State */}
      {['RUNNING', 'PENDING'].includes(status) && currentTestCase && (
        <Card sx={{ mb: 3 }}>
          <CardHeader
            title="Currently Executing"
            subheader={currentTestCase.name}
          />
          <Divider />
          <CardContent>
            {currentStep && (
              <Box>
                <Typography variant="subtitle2">
                  Current Step:
                </Typography>
                <Paper variant="outlined" sx={{ p: 2, mb: 2 }}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <Typography variant="body2">
                        <strong>Action:</strong> {currentStep.action}
                      </Typography>
                    </Grid>
                    
                    {currentStep.selector && (
                      <Grid item xs={12} sm={6}>
                        <Typography variant="body2" noWrap>
                          <strong>Selector:</strong> <code>{currentStep.selector}</code>
                        </Typography>
                      </Grid>
                    )}
                    
                    {currentStep.value && (
                      <Grid item xs={12} sm={6}>
                        <Typography variant="body2" noWrap>
                          <strong>Value:</strong> <code>{currentStep.value}</code>
                        </Typography>
                      </Grid>
                    )}
                  </Grid>
                </Paper>
              </Box>
            )}
            
            <LinearProgress sx={{ mb: 1 }} />
          </CardContent>
        </Card>
      )}
      
      {/* Test Case Results */}
      <Card>
        <CardHeader
          title="Test Case Results"
          subheader={`${testCaseResults.length} test cases`}
        />
        <Divider />
        <List 
          sx={{ 
            maxHeight: '400px',
            overflow: 'auto',
            p: 0
          }}
        >
          {testCaseResults.length === 0 ? (
            <ListItem>
              <ListItemText primary="No test cases executed yet" />
            </ListItem>
          ) : (
            testCaseResults.map((result, index) => (
              <React.Fragment key={result.id || index}>
                <ListItem 
                  alignItems="flex-start"
                  sx={{
                    backgroundColor: 
                      result.status === 'PASSED' ? 'rgba(76, 175, 80, 0.08)' :
                      result.status === 'FAILED' ? 'rgba(244, 67, 54, 0.08)' :
                      result.status === 'RUNNING' ? 'rgba(33, 150, 243, 0.08)' :
                      'transparent'
                  }}
                >
                  <ListItemIcon>
                    {getStatusIcon(result.status)}
                  </ListItemIcon>
                  
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography variant="subtitle1">
                          {result.testCaseName || `Test Case ${index + 1}`}
                        </Typography>
                        <Chip
                          label={result.status}
                          size="small"
                          color={getStatusColor(result.status)}
                        />
                      </Box>
                    }
                    secondary={
                      <Box sx={{ mt: 1 }}>
                        <Typography variant="body2" component="span" display="block">
                          Duration: {formatDuration(result.duration || 0)}
                        </Typography>
                        
                        {result.error && (
                          <Typography 
                            variant="body2" 
                            component="span" 
                            display="block"
                            color="error"
                            sx={{ mt: 1 }}
                          >
                            Error: {result.error}
                          </Typography>
                        )}
                        
                        {/* Step Results */}
                        {result.stepResults && result.stepResults.length > 0 && (
                          <Box sx={{ mt: 1 }}>
                            <Typography variant="body2" color="text.secondary">
                              Steps: {result.stepResults.length}
                            </Typography>
                            
                            <List dense sx={{ pl: 2 }}>
                              {result.stepResults.slice(0, 3).map((stepResult, stepIndex) => (
                                <ListItem key={stepIndex} disableGutters>
                                  <ListItemIcon sx={{ minWidth: 28 }}>
                                    {stepResult.status === 'PASSED' ? 
                                      <CheckCircleIcon fontSize="small" color="success" /> :
                                      stepResult.status === 'FAILED' ?
                                      <CancelIcon fontSize="small" color="error" /> :
                                      <CircularProgress size={16} />
                                    }
                                  </ListItemIcon>
                                  <ListItemText
                                    primary={
                                      <Typography variant="body2">
                                        {stepResult.description || stepResult.action || `Step ${stepIndex + 1}`}
                                      </Typography>
                                    }
                                  />
                                  {stepResult.screenshotPath && (
                                    <Tooltip title="View Screenshot">
                                      <IconButton 
                                        size="small"
                                        onClick={() => viewScreenshot(stepResult.screenshotPath)}
                                      >
                                        <ScreenshotIcon fontSize="small" />
                                      </IconButton>
                                    </Tooltip>
                                  )}
                                </ListItem>
                              ))}
                              
                              {result.stepResults.length > 3 && (
                                <ListItem disableGutters>
                                  <Typography variant="body2" color="primary">
                                    +{result.stepResults.length - 3} more steps
                                  </Typography>
                                </ListItem>
                              )}
                            </List>
                          </Box>
                        )}
                      </Box>
                    }
                  />
                </ListItem>
                {index < testCaseResults.length - 1 && <Divider />}
              </React.Fragment>
            ))
          )}
        </List>
      </Card>
      
      {/* Screenshot Dialog */}
      <Dialog
        open={screenshotDialog}
        onClose={closeScreenshotDialog}
        maxWidth="lg"
        fullWidth
      >
        <DialogTitle>
          Screenshot
          <IconButton
            onClick={closeScreenshotDialog}
            sx={{ position: 'absolute', right: 8, top: 8 }}
          >
            <CancelIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent>
          {screenshotUrl && (
            <Box sx={{ textAlign: 'center' }}>
              <img 
                src={screenshotUrl} 
                alt="Test Screenshot" 
                style={{ maxWidth: '100%', maxHeight: '70vh' }} 
              />
            </Box>
          )}
        </DialogContent>
      </Dialog>
    </Box>
  );
};

export default ExecutionMonitor;


// src/components/recorder/ElementInspector.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  IconButton,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  Tooltip,
  Chip,
  Card,
  CardContent,
  CardHeader,
  List,
  ListItem,
  ListItemText,
  Grid,
  Tabs,
  Tab,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  ContentCopy as CopyIcon,
  Check as CheckIcon,
  MouseOutlined as MouseIcon,
  CodeOutlined as CodeIcon,
  LabelOutlined as LabelIcon,
  TextFieldsOutlined as TextIcon,
  CropFree as CropIcon,
  Refresh as RefreshIcon,
  ErrorOutline as ErrorIcon
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { useApi } from '../../contexts/ApiContext';

/**
 * Element Inspector Component
 * Allows inspecting elements in the browser and generating selectors
 */
const ElementInspector = ({ sessionId, onElementSelected, onSelectorChosen }) => {
  const { api } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [inspecting, setInspecting] = useState(false);
  const [loading, setLoading] = useState(false);
  const [hoveredElement, setHoveredElement] = useState(null);
  const [selectedElement, setSelectedElement] = useState(null);
  const [selectors, setSelectors] = useState({});
  const [currentTab, setCurrentTab] = useState(0);
  const [previewHtml, setPreviewHtml] = useState(null);
  const [previewVisible, setPreviewVisible] = useState(false);
  
  // Start element inspection
  const startInspection = async () => {
    if (!sessionId) {
      enqueueSnackbar('No active recording session', { variant: 'error' });
      return;
    }
    
    try {
      setLoading(true);
      setInspecting(true);
      
      // Tell the backend to start inspection mode
      await api.post(`/recorder/sessions/${sessionId}/inspect/start`);
      
      setLoading(false);
      
      // Poll for element updates
      pollForElementUpdates();
    } catch (error) {
      console.error('Error starting inspection:', error);
      setLoading(false);
      setInspecting(false);
      enqueueSnackbar('Failed to start element inspection', { variant: 'error' });
    }
  };
  
  // Stop element inspection
  const stopInspection = async () => {
    if (!sessionId) return;
    
    try {
      setLoading(true);
      
      // Tell the backend to stop inspection mode
      await api.post(`/recorder/sessions/${sessionId}/inspect/stop`);
      
      setInspecting(false);
      setLoading(false);
    } catch (error) {
      console.error('Error stopping inspection:', error);
      setInspecting(false);
      setLoading(false);
      enqueueSnackbar('Failed to stop element inspection', { variant: 'error' });
    }
  };
  
  // Poll for element updates
  const pollForElementUpdates = () => {
    if (!sessionId || !inspecting) return;
    
    const intervalId = setInterval(async () => {
      if (!inspecting) {
        clearInterval(intervalId);
        return;
      }
      
      try {
        // Get current hovered element
        const response = await api.get(`/recorder/sessions/${sessionId}/inspect/element`);
        setHoveredElement(response.data);
      } catch (error) {
        console.error('Error polling for element updates:', error);
        // Don't stop inspection on polling errors
      }
    }, 200); // Poll every 200ms
    
    // Cleanup interval on component unmount
    return () => clearInterval(intervalId);
  };
  
  // Handle element selection
  const selectElement = async () => {
    if (!hoveredElement || !sessionId) return;
    
    try {
      setLoading(true);
      
      // Stop inspection
      await api.post(`/recorder/sessions/${sessionId}/inspect/stop`);
      
      // Generate selectors for the element
      const response = await api.post(
        `/recorder/sessions/${sessionId}/inspect/selectors`,
        { elementInfo: hoveredElement }
      );
      
      setSelectors(response.data || {});
      setSelectedElement(hoveredElement);
      setInspecting(false);
      
      // Notify parent component
      if (onElementSelected) {
        onElementSelected(hoveredElement);
      }
      
      setLoading(false);
    } catch (error) {
      console.error('Error selecting element:', error);
      setInspecting(false);
      setLoading(false);
      enqueueSnackbar('Failed to select element', { variant: 'error' });
    }
  };
  
  // Choose a selector
  const chooseSelector = (type, selector) => {
    // Notify parent component
    if (onSelectorChosen) {
      onSelectorChosen(selector, type);
    }
    
    enqueueSnackbar(`Selector "${type}" chosen`, { variant: 'success' });
  };
  
  // Copy selector to clipboard
  const copySelector = (selector) => {
    navigator.clipboard.writeText(selector)
      .then(() => {
        enqueueSnackbar('Selector copied to clipboard', { variant: 'success' });
      })
      .catch((error) => {
        console.error('Error copying selector:', error);
        enqueueSnackbar('Failed to copy selector', { variant: 'error' });
      });
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };
  
  // Preview HTML
  const previewElementHtml = async () => {
    if (!selectedElement || !sessionId) return;
    
    try {
      setLoading(true);
      
      // Get element HTML
      const response = await api.post(
        `/recorder/sessions/${sessionId}/inspect/html`,
        { elementInfo: selectedElement }
      );
      
      setPreviewHtml(response.data.html || '');
      setPreviewVisible(true);
      setLoading(false);
    } catch (error) {
      console.error('Error getting element HTML:', error);
      setLoading(false);
      enqueueSnackbar('Failed to get element HTML', { variant: 'error' });
    }
  };
  
  // Close preview
  const closePreview = () => {
    setPreviewVisible(false);
    setPreviewHtml(null);
  };
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Stop inspection if component unmounts
      if (inspecting && sessionId) {
        api.post(`/recorder/sessions/${sessionId}/inspect/stop`)
          .catch(error => {
            console.error('Error stopping inspection on unmount:', error);
          });
      }
    };
  }, [api, inspecting, sessionId]);
  
  // Check if there's a selected element
  const hasSelectedElement = selectedElement !== null;
  
  // Render inspector UI
  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardHeader 
          title="Element Inspector" 
          subheader={
            inspecting 
              ? "Hover over elements in the browser and click to select" 
              : "Start inspection to select an element"
          }
        />
        <Divider />
        <CardContent>
          <Box sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
            {!inspecting ? (
              <Button
                variant="contained"
                color="primary"
                startIcon={<MouseIcon />}
                onClick={startInspection}
                disabled={loading || !sessionId}
              >
                {loading ? <CircularProgress size={24} /> : 'Start Inspection'}
              </Button>
            ) : (
              <Box sx={{ display: 'flex', gap: 2 }}>
                <Button
                  variant="contained"
                  color="secondary"
                  onClick={selectElement}
                  disabled={loading || !hoveredElement}
                >
                  {loading ? <CircularProgress size={24} /> : 'Select Element'}
                </Button>
                <Button
                  variant="outlined"
                  color="error"
                  onClick={stopInspection}
                  disabled={loading}
                >
                  {loading ? <CircularProgress size={24} /> : 'Cancel'}
                </Button>
              </Box>
            )}
          </Box>
          
          {inspecting && hoveredElement && (
            <Paper variant="outlined" sx={{ p: 2, mb: 2 }}>
              <Typography variant="subtitle2" gutterBottom>
                Hovered Element
              </Typography>
              
              <Grid container spacing={1}>
                <Grid item xs={12} sm={6}>
                  <Typography variant="body2">
                    <strong>Tag:</strong> {hoveredElement.tagName}
                  </Typography>
                </Grid>
                
                {hoveredElement.attributes?.id && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>ID:</strong> {hoveredElement.attributes.id}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.attributes?.class && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>Class:</strong> {hoveredElement.attributes.class}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.attributes?.name && (
                  <Grid item xs={12} sm={6}>
                    <Typography variant="body2">
                      <strong>Name:</strong> {hoveredElement.attributes.name}
                    </Typography>
                  </Grid>
                )}
                
                {hoveredElement.textContent && (
                  <Grid item xs={12}>
                    <Typography variant="body2" noWrap>
                      <strong>Text:</strong> {hoveredElement.textContent}
                    </Typography>
                  </Grid>
                )}
              </Grid>
            </Paper>
          )}
          
          {hasSelectedElement && (
            <Box>
              <Tabs
                value={currentTab}
                onChange={handleTabChange}
                variant="fullWidth"
                sx={{ mb: 2 }}
              >
                <Tab label="Selectors" />
                <Tab label="Attributes" />
                <Tab label="Details" />
              </Tabs>
              
              {currentTab === 0 && (
                <TableContainer component={Paper} variant="outlined">
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Type</TableCell>
                        <TableCell>Selector</TableCell>
                        <TableCell>Actions</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {Object.entries(selectors).length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={3} align="center">
                            <Typography variant="body2" color="text.secondary">
                              No selectors available
                            </Typography>
                          </TableCell>
                        </TableRow>
                      ) : (
                        Object.entries(selectors).map(([type, selector]) => (
                          <TableRow key={type}>
                            <TableCell>
                              <Chip 
                                label={type} 
                                size="small" 
                                color={
                                  type === 'id' ? 'success' :
                                  type === 'data-testid' ? 'primary' :
                                  type === 'xpath' ? 'warning' :
                                  type === 'css' ? 'info' :
                                  'default'
                                }
                              />
                            </TableCell>
                            <TableCell>
                              <Typography 
                                variant="body2" 
                                sx={{ 
                                  fontFamily: 'monospace',
                                  whiteSpace: 'nowrap',
                                  overflow: 'hidden',
                                  textOverflow: 'ellipsis',
                                  maxWidth: '200px'
                                }}
                              >
                                {selector}
                              </Typography>
                            </TableCell>
                            <TableCell>
                              <Tooltip title="Use This Selector">
                                <IconButton 
                                  size="small" 
                                  color="primary"
                                  onClick={() => chooseSelector(type, selector)}
                                >
                                  <CheckIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                              <Tooltip title="Copy to Clipboard">
                                <IconButton 
                                  size="small"
                                  onClick={() => copySelector(selector)}
                                >
                                  <CopyIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
              
              {currentTab === 1 && (
                <TableContainer component={Paper} variant="outlined">
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Attribute</TableCell>
                        <TableCell>Value</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {selectedElement.attributes && Object.entries(selectedElement.attributes).length > 0 ? (
                        Object.entries(selectedElement.attributes).map(([name, value]) => (
                          <TableRow key={name}>
                            <TableCell>{name}</TableCell>
                            <TableCell>{value}</TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={2} align="center">
                            <Typography variant="body2" color="text.secondary">
                              No attributes available
                            </Typography>
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
              
              {currentTab === 2 && (
                <Box>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <Paper variant="outlined" sx={{ p: 2 }}>
                        <Typography variant="subtitle2" gutterBottom>
                          Element Properties
                        </Typography>
                        <List dense disablePadding>
                          <ListItem disableGutters>
                            <ListItemText 
                              primary="Tag Name" 
                              secondary={selectedElement.tagName} 
                            />
                          </ListItem>
                          
                          <ListItem disableGutters>
                            <ListItemText 
                              primary="Visible" 
                              secondary={selectedElement.visible ? 'Yes' : 'No'} 
                            />
                          </ListItem>
                          
                          {selectedElement.boundingBox && (
                            <>
                              <ListItem disableGutters>
                                <ListItemText 
                                  primary="Position" 
                                  secondary={
                                    `X: ${Math.round(selectedElement.boundingBox.x)}, ` +
                                    `Y: ${Math.round(selectedElement.boundingBox.y)}`
                                  } 
                                />
                              </ListItem>
                              
                              <ListItem disableGutters>
                                <ListItemText 
                                  primary="Size" 
                                  secondary={
                                    `Width: ${Math.round(selectedElement.boundingBox.width)}px, ` +
                                    `Height: ${Math.round(selectedElement.boundingBox.height)}px`
                                  } 
                                />
                              </ListItem>
                            </>
                          )}
                          
                          {selectedElement.zIndex !== undefined && (
                            <ListItem disableGutters>
                              <ListItemText 
                                primary="Z-Index" 
                                secondary={selectedElement.zIndex} 
                              />
                            </ListItem>
                          )}
                        </List>
                      </Paper>
                    </Grid>
                    
                    <Grid item xs={12} sm={6}>
                      <Paper variant="outlined" sx={{ p: 2 }}>
                        <Typography variant="subtitle2" gutterBottom>
                          Content
                        </Typography>
                        
                        {selectedElement.textContent ? (
                          <Typography 
                            variant="body2" 
                            sx={{ 
                              wordBreak: 'break-word',
                              maxHeight: '100px',
                              overflow: 'auto'
                            }}
                          >
                            {selectedElement.textContent}
                          </Typography>
                        ) : (
                          <Typography variant="body2" color="text.secondary">
                            No text content
                          </Typography>
                        )}
                        
                        <Box sx={{ mt: 2 }}>
                          <Button
                            size="small"
                            startIcon={<CodeIcon />}
                            onClick={previewElementHtml}
                            disabled={loading}
                          >
                            View HTML
                          </Button>
                        </Box>
                      </Paper>
                    </Grid>
                  </Grid>
                </Box>
              )}
            </Box>
          )}
        </CardContent>
      </Card>
      
      {/* HTML Preview Dialog */}
      <Dialog
        open={previewVisible}
        onClose={closePreview}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Element HTML</DialogTitle>
        <DialogContent>
          <Paper
            sx={{
              p: 2,
              maxHeight: '400px',
              overflow: 'auto',
              backgroundColor: '#f5f5f5',
              fontFamily: 'monospace',
              fontSize: '14px',
              whiteSpace: 'pre-wrap'
            }}
          >
            {previewHtml || 'No HTML available'}
          </Paper>
        </DialogContent>
        <DialogActions>
          <Button onClick={closePreview}>Close</Button>
          <Button 
            onClick={() => {
              if (previewHtml) {
                navigator.clipboard.writeText(previewHtml);
                enqueueSnackbar('HTML copied to clipboard', { variant: 'success' });
              }
            }}
            disabled={!previewHtml}
          >
            Copy HTML
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ElementInspector;

