import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box, Button, TextField, Typography, Paper, Grid, FormControl,
  InputLabel, Select, MenuItem, FormControlLabel, Switch,
  Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle,
  Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  IconButton, Snackbar, Alert, Card, CardContent, CardActions,
  Tabs, Tab, Breadcrumbs, Link, Chip, Tooltip, CircularProgress
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  FileCopy as FileCopyIcon,
  ArrowUpward as ArrowUpwardIcon,
  ArrowDownward as ArrowDownwardIcon,
  Save as SaveIcon,
  Cancel as CancelIcon,
  PlayArrow as PlayArrowIcon,
  History as HistoryIcon,
  Visibility as VisibilityIcon,
  MoreVert as MoreVertIcon,
  Settings as SettingsIcon
} from '@mui/icons-material';
import { TestCaseService } from '../services/TestCaseService';
import { useNotification } from '../contexts/NotificationContext';
import TestStepForm from './TestStepForm';
import StepList from './StepList';

const TestCaseForm = () => {
  const { projectId, testCaseId } = useParams();
  const navigate = useNavigate();
  const { showNotification } = useNotification();
  const isNewTestCase = testCaseId === 'new';
  
  // State
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [testCase, setTestCase] = useState({
    id: '',
    projectId: projectId,
    name: '',
    description: '',
    tags: [],
    steps: [],
    enabled: true,
    createdAt: null,
    updatedAt: null
  });
  const [activeTab, setActiveTab] = useState(0);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [showStepForm, setShowStepForm] = useState(false);
  const [editingStep, setEditingStep] = useState(null);
  
  // Load test case data
  useEffect(() => {
    if (!isNewTestCase) {
      setLoading(true);
      TestCaseService.getTestCase(projectId, testCaseId)
        .then(data => {
          setTestCase(data);
          setLoading(false);
        })
        .catch(error => {
          showNotification('Failed to load test case: ' + error.message, 'error');
          setLoading(false);
        });
    }
  }, [projectId, testCaseId, isNewTestCase, showNotification]);
  
  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setTestCase(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Handle enabled toggle
  const handleEnabledChange = (e) => {
    setTestCase(prev => ({
      ...prev,
      enabled: e.target.checked
    }));
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!testCase.name.trim()) {
      showNotification('Test case name is required', 'error');
      return;
    }
    
    setSaving(true);
    
    if (isNewTestCase) {
      // Create new test case
      TestCaseService.createTestCase(projectId, testCase)
        .then(savedTestCase => {
          showNotification('Test case created successfully', 'success');
          navigate(`/projects/${projectId}/testcases/${savedTestCase.id}`);
          setSaving(false);
        })
        .catch(error => {
          showNotification('Failed to create test case: ' + error.message, 'error');
          setSaving(false);
        });
    } else {
      // Update existing test case
      TestCaseService.updateTestCase(projectId, testCaseId, testCase)
        .then(savedTestCase => {
          setTestCase(savedTestCase);
          showNotification('Test case updated successfully', 'success');
          setSaving(false);
        })
        .catch(error => {
          showNotification('Failed to update test case: ' + error.message, 'error');
          setSaving(false);
        });
    }
  };
  
  // Handle delete confirmation
  const handleDeleteConfirm = () => {
    TestCaseService.deleteTestCase(projectId, testCaseId)
      .then(() => {
        showNotification('Test case deleted successfully', 'success');
        navigate(`/projects/${projectId}/testcases`);
      })
      .catch(error => {
        showNotification('Failed to delete test case: ' + error.message, 'error');
        setShowDeleteDialog(false);
      });
  };
  
  // Handle step add/edit
  const handleStepFormOpen = (step = null) => {
    setEditingStep(step);
    setShowStepForm(true);
  };
  
  const handleStepFormClose = () => {
    setEditingStep(null);
    setShowStepForm(false);
  };
  
  const handleStepSave = (step) => {
    let updatedSteps;
    
    if (step.id && testCase.steps.some(s => s.id === step.id)) {
      // Update existing step
      updatedSteps = testCase.steps.map(s => s.id === step.id ? step : s);
    } else {
      // Add new step
      // Generate ID if not present
      if (!step.id) {
        step.id = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();
      }
      updatedSteps = [...testCase.steps, step];
    }
    
    setTestCase(prev => ({
      ...prev,
      steps: updatedSteps
    }));
    
    handleStepFormClose();
  };
  
  // Handle step delete
  const handleDeleteStep = (stepId) => {
    const updatedSteps = testCase.steps.filter(step => step.id !== stepId);
    setTestCase(prev => ({
      ...prev,
      steps: updatedSteps
    }));
  };
  
  // Handle step reorder
  const handleMoveStep = (stepId, direction) => {
    const currentIndex = testCase.steps.findIndex(step => step.id === stepId);
    if (currentIndex < 0) return;
    
    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    if (newIndex < 0 || newIndex >= testCase.steps.length) return;
    
    const updatedSteps = [...testCase.steps];
    const step = updatedSteps[currentIndex];
    updatedSteps.splice(currentIndex, 1);
    updatedSteps.splice(newIndex, 0, step);
    
    setTestCase(prev => ({
      ...prev,
      steps: updatedSteps
    }));
  };
  
  // Handle tag changes
  const handleTagAdd = () => {
    const newTag = prompt('Enter a new tag:');
    if (newTag && newTag.trim() && !testCase.tags.includes(newTag.trim())) {
      setTestCase(prev => ({
        ...prev,
        tags: [...(prev.tags || []), newTag.trim()]
      }));
    }
  };
  
  const handleTagDelete = (tagToDelete) => {
    setTestCase(prev => ({
      ...prev,
      tags: (prev.tags || []).filter(tag => tag !== tagToDelete)
    }));
  };
  
  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="300px">
        <CircularProgress />
      </Box>
    );
  }
  
  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs sx={{ mb: 2 }}>
        <Link color="inherit" href="/projects">Projects</Link>
        <Link color="inherit" href={`/projects/${projectId}`}>Project Details</Link>
        <Link color="inherit" href={`/projects/${projectId}/testcases`}>Test Cases</Link>
        <Typography color="text.primary">
          {isNewTestCase ? 'New Test Case' : testCase.name}
        </Typography>
      </Breadcrumbs>
      
      {/* Title */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">
          {isNewTestCase ? 'Create New Test Case' : 'Edit Test Case'}
        </Typography>
        <Box>
          {!isNewTestCase && (
            <>
              <Tooltip title="Run Test Case">
                <IconButton 
                  color="primary" 
                  onClick={() => navigate(`/projects/${projectId}/execute/testcase/${testCaseId}`)}
                >
                  <PlayArrowIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="View History">
                <IconButton 
                  color="primary" 
                  onClick={() => navigate(`/projects/${projectId}/testcases/${testCaseId}/history`)}
                >
                  <HistoryIcon />
                </IconButton>
              </Tooltip>
              <Tooltip title="Delete Test Case">
                <IconButton 
                  color="error" 
                  onClick={() => setShowDeleteDialog(true)}
                >
                  <DeleteIcon />
                </IconButton>
              </Tooltip>
            </>
          )}
        </Box>
      </Box>
      
      {/* Main form */}
      <Paper elevation={2} sx={{ p: 3, mb: 3 }}>
        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={8}>
              <TextField
                name="name"
                label="Test Case Name"
                fullWidth
                required
                value={testCase.name}
                onChange={handleInputChange}
              />
            </Grid>
            <Grid item xs={12} md={4}>
              <FormControlLabel
                control={
                  <Switch
                    checked={testCase.enabled}
                    onChange={handleEnabledChange}
                    color="primary"
                  />
                }
                label="Enabled"
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                name="description"
                label="Description"
                fullWidth
                multiline
                rows={3}
                value={testCase.description || ''}
                onChange={handleInputChange}
              />
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" alignItems="center">
                <Typography variant="subtitle1" mr={2}>Tags:</Typography>
                <Box display="flex" flexWrap="wrap" gap={1}>
                  {(testCase.tags || []).map((tag) => (
                    <Chip
                      key={tag}
                      label={tag}
                      onDelete={() => handleTagDelete(tag)}
                    />
                  ))}
                  <Chip
                    icon={<AddIcon />}
                    label="Add Tag"
                    onClick={handleTagAdd}
                    variant="outlined"
                  />
                </Box>
              </Box>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end" gap={2}>
                <Button
                  variant="outlined"
                  onClick={() => navigate(`/projects/${projectId}/testcases`)}
                  startIcon={<CancelIcon />}
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={saving}
                  startIcon={saving ? <CircularProgress size={20} /> : <SaveIcon />}
                >
                  {isNewTestCase ? 'Create Test Case' : 'Save Changes'}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </form>
      </Paper>
      
      {/* Test Steps Section */}
      <Paper elevation={2} sx={{ p: 3 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h5">Test Steps</Typography>
          <Button
            variant="contained"
            color="secondary"
            startIcon={<AddIcon />}
            onClick={() => handleStepFormOpen()}
          >
            Add Step
          </Button>
        </Box>
        
        {testCase.steps.length === 0 ? (
          <Box textAlign="center" py={4}>
            <Typography variant="body1" color="textSecondary">
              No steps added yet. Click "Add Step" to start building your test case.
            </Typography>
          </Box>
        ) : (
          <StepList
            steps={testCase.steps}
            onEdit={handleStepFormOpen}
            onDelete={handleDeleteStep}
            onMove={handleMoveStep}
          />
        )}
      </Paper>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteDialog} onClose={() => setShowDeleteDialog(false)}>
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Are you sure you want to delete this test case? This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setShowDeleteDialog(false)}>Cancel</Button>
          <Button onClick={handleDeleteConfirm} color="error">Delete</Button>
        </DialogActions>
      </Dialog>
      
      {/* Step Form Dialog */}
      <Dialog 
        open={showStepForm} 
        onClose={handleStepFormClose}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          {editingStep ? 'Edit Step' : 'Add Step'}
        </DialogTitle>
        <DialogContent>
          <TestStepForm
            step={editingStep}
            onSave={handleStepSave}
            onCancel={handleStepFormClose}
          />
        </DialogContent>
      </Dialog>
    </Box>
  );
};

export default TestCaseForm;


Step List Component
---------------------

import React from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  IconButton,
  Grid,
  Paper,
  Tooltip,
  Divider,
  Chip,
  Badge,
  List,
  ListItem,
  ListItemText,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow
} from '@mui/material';
import {
  Edit as EditIcon,
  Delete as DeleteIcon,
  ArrowUpward as ArrowUpwardIcon,
  ArrowDownward as ArrowDownwardIcon,
  MouseOutlined as MouseIcon,
  KeyboardOutlined as KeyboardIcon,
  VisibilityOutlined as VisibilityIcon,
  TouchAppOutlined as TouchIcon,
  CodeOutlined as CodeIcon,
  NavigateNext as NavigateIcon,
  CheckCircleOutlined as CheckIcon,
  Timer as TimerIcon,
  PhotoCamera as CameraIcon
} from '@mui/icons-material';

/**
 * StepList Component
 * Displays a list of test steps with actions for editing, deleting, and reordering
 */
const StepList = ({ steps, onEdit, onDelete, onMove }) => {
  // Map action types to icons
  const getActionIcon = (action) => {
    switch (action.toLowerCase()) {
      case 'click':
        return <MouseIcon />;
      case 'type':
        return <KeyboardIcon />;
      case 'navigate':
        return <NavigateIcon />;
      case 'wait':
        return <TimerIcon />;
      case 'assert':
        return <CheckIcon />;
      case 'screenshot':
        return <CameraIcon />;
      case 'hover':
        return <TouchIcon />;
      case 'js':
        return <CodeIcon />;
      default:
        return <VisibilityIcon />;
    }
  };
  
  // Format action for display
  const formatAction = (step) => {
    switch (step.action.toLowerCase()) {
      case 'click':
        return `Click on ${step.selector || 'element'}`;
      case 'type':
        return `Type "${step.parameters?.text || ''}" in ${step.selector || 'element'}`;
      case 'navigate':
        return `Navigate to ${step.parameters?.url || 'URL'}`;
      case 'wait':
        if (step.parameters?.waitType === 'timeout') {
          const duration = step.parameters?.duration || 0;
          return `Wait for ${duration / 1000} seconds`;
        } else {
          return `Wait for ${step.selector || 'element'} to be ${step.parameters?.state || 'visible'}`;
        }
      case 'assert':
        if (step.parameters?.assertType === 'visible') {
          return `Assert ${step.selector || 'element'} is ${step.parameters?.expected === 'true' ? 'visible' : 'not visible'}`;
        } else if (step.parameters?.assertType === 'text') {
          return `Assert ${step.selector || 'element'} ${step.parameters?.matchType === 'contains' ? 'contains' : 'equals'} "${step.parameters?.expected || ''}"`;
        } else {
          return `Assert ${step.parameters?.assertType || 'condition'} for ${step.selector || 'element'}`;
        }
      case 'screenshot':
        return `Take screenshot${step.parameters?.fullPage ? ' of full page' : ''}`;
      default:
        return `${step.action} ${step.selector || ''}`;
    }
  };
  
  return (
    <TableContainer component={Paper} variant="outlined">
      <Table>
        <TableHead>
          <TableRow>
            <TableCell width="50">#</TableCell>
            <TableCell width="60">Action</TableCell>
            <TableCell>Description</TableCell>
            <TableCell width="80">Selector</TableCell>
            <TableCell width="150" align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {steps.map((step, index) => (
            <TableRow key={step.id} hover>
              <TableCell>{index + 1}</TableCell>
              <TableCell>
                <Tooltip title={step.action}>
                  <Box sx={{ color: 'primary.main' }}>
                    {getActionIcon(step.action)}
                  </Box>
                </Tooltip>
              </TableCell>
              <TableCell>
                <Typography variant="body2">
                  {formatAction(step)}
                </Typography>
                {step.parameters && Object.keys(step.parameters).length > 0 && (
                  <Box mt={1} display="flex" flexWrap="wrap" gap={0.5}>
                    {Object.entries(step.parameters)
                      .filter(([key]) => !['waitType', 'state', 'assertType', 'matchType'].includes(key))
                      .map(([key, value]) => (
                        <Chip
                          key={key}
                          label={`${key}: ${typeof value === 'object' ? JSON.stringify(value) : value}`}
                          size="small"
                          variant="outlined"
                          sx={{ fontSize: '0.7rem' }}
                        />
                      ))}
                  </Box>
                )}
              </TableCell>
              <TableCell>
                {step.selector && (
                  <Tooltip title={step.selector}>
                    <Chip
                      label={step.selector.length > 15 ? `${step.selector.substring(0, 15)}...` : step.selector}
                      size="small"
                      color="secondary"
                      variant="outlined"
                    />
                  </Tooltip>
                )}
                {step.selectorType && (
                  <Typography variant="caption" display="block">
                    {step.selectorType}
                  </Typography>
                )}
              </TableCell>
              <TableCell align="right">
                <Box display="flex" justifyContent="flex-end">
                  <Tooltip title="Move Up">
                    <span>
                      <IconButton
                        size="small"
                        disabled={index === 0}
                        onClick={() => onMove(step.id, 'up')}
                      >
                        <ArrowUpwardIcon fontSize="small" />
                      </IconButton>
                    </span>
                  </Tooltip>
                  <Tooltip title="Move Down">
                    <span>
                      <IconButton
                        size="small"
                        disabled={index === steps.length - 1}
                        onClick={() => onMove(step.id, 'down')}
                      >
                        <ArrowDownwardIcon fontSize="small" />
                      </IconButton>
                    </span>
                  </Tooltip>
                  <Tooltip title="Edit Step">
                    <IconButton
                      size="small"
                      color="primary"
                      onClick={() => onEdit(step)}
                    >
                      <EditIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  <Tooltip title="Delete Step">
                    <IconButton
                      size="small"
                      color="error"
                      onClick={() => onDelete(step.id)}
                    >
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Box>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default StepList;


Test Step Form Component:
--------------------------


import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
  Grid,
  Typography,
  Divider,
  Paper,
  Tabs,
  Tab,
  Switch,
  FormControlLabel,
  InputAdornment,
  IconButton,
  Tooltip,
  Chip,
  Autocomplete
} from '@mui/material';
import {
  Save as SaveIcon,
  Cancel as CancelIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  Help as HelpIcon,
  Code as CodeIcon,
  SearchOutlined as SearchIcon,
  SettingsOutlined as SettingsIcon
} from '@mui/icons-material';

// Action types and their configurations
const actionTypes = [
  { value: 'navigate', label: 'Navigate', description: 'Navigate to a URL' },
  { value: 'click', label: 'Click', description: 'Click on an element' },
  { value: 'type', label: 'Type', description: 'Type text into an element' },
  { value: 'wait', label: 'Wait', description: 'Wait for an element or timeout' },
  { value: 'assert', label: 'Assert', description: 'Assert conditions about elements' },
  { value: 'check', label: 'Check', description: 'Check a checkbox or radio button' },
  { value: 'uncheck', label: 'Uncheck', description: 'Uncheck a checkbox' },
  { value: 'select', label: 'Select', description: 'Select option from dropdown' },
  { value: 'hover', label: 'Hover', description: 'Hover over an element' },
  { value: 'screenshot', label: 'Screenshot', description: 'Take a screenshot' },
  { value: 'js', label: 'JavaScript', description: 'Execute JavaScript code' }
];

// Selector type options
const selectorTypes = [
  { value: 'css', label: 'CSS', description: 'CSS selector (default)' },
  { value: 'xpath', label: 'XPath', description: 'XPath selector' },
  { value: 'text', label: 'Text', description: 'Element containing text' },
  { value: 'id', label: 'ID', description: 'Element with specified ID' },
  { value: 'name', label: 'Name', description: 'Element with specified name attribute' },
  { value: 'class', label: 'Class', description: 'Element with specified class' }
];

// TabPanel component for managing tab content
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`step-tabpanel-${index}`}
      aria-labelledby={`step-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

/**
 * TestStepForm Component
 * Form for creating and editing test steps
 */
const TestStepForm = ({ step, onSave, onCancel }) => {
  const isEditMode = !!step?.id;
  
  // Set initial state for the form
  const [formValues, setFormValues] = useState({
    id: '',
    action: 'click',
    selector: '',
    selectorType: 'css',
    parameters: {}
  });
  
  const [activeTab, setActiveTab] = useState(0);
  const [paramErrors, setParamErrors] = useState({});
  
  // Load step data if in edit mode
  useEffect(() => {
    if (step) {
      setFormValues({
        id: step.id || '',
        action: step.action || 'click',
        selector: step.selector || '',
        selectorType: step.selectorType || 'css',
        parameters: step.parameters || {}
      });
    }
  }, [step]);
  
  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormValues(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Handle parameter changes
  const handleParameterChange = (name, value) => {
    setFormValues(prev => ({
      ...prev,
      parameters: {
        ...prev.parameters,
        [name]: value
      }
    }));
    
    // Clear error for this parameter
    if (paramErrors[name]) {
      setParamErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };
  
  // Handle boolean parameter change (checkboxes/switches)
  const handleBooleanParameterChange = (name, checked) => {
    handleParameterChange(name, checked);
  };
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // Get parameter fields based on the selected action
  const getParameterFields = () => {
    switch (formValues.action) {
      case 'navigate':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="URL"
                fullWidth
                required
                value={formValues.parameters.url || ''}
                onChange={(e) => handleParameterChange('url', e.target.value)}
                error={!!paramErrors.url}
                helperText={paramErrors.url}
                placeholder="https://example.com"
              />
            </Grid>
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Wait Until</InputLabel>
                <Select
                  name="waitUntil"
                  value={formValues.parameters.waitUntil || 'load'}
                  onChange={(e) => handleParameterChange('waitUntil', e.target.value)}
                >
                  <MenuItem value="load">Load (document and resources)</MenuItem>
                  <MenuItem value="domcontentloaded">DOM Content Loaded</MenuItem>
                  <MenuItem value="networkidle">Network Idle</MenuItem>
                </Select>
                <FormHelperText>
                  When to consider navigation complete
                </FormHelperText>
              </FormControl>
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Timeout (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.timeout || 30000}
                onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
          </Grid>
        );
        
      case 'click':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Mouse Button</InputLabel>
                <Select
                  name="button"
                  value={formValues.parameters.button || 'left'}
                  onChange={(e) => handleParameterChange('button', e.target.value)}
                >
                  <MenuItem value="left">Left Click</MenuItem>
                  <MenuItem value="middle">Middle Click</MenuItem>
                  <MenuItem value="right">Right Click</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Timeout (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.timeout || 30000}
                onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.force}
                    onChange={(e) => handleBooleanParameterChange('force', e.target.checked)}
                  />
                }
                label="Force click (bypass checks)"
              />
            </Grid>
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.noWaitAfter}
                    onChange={(e) => handleBooleanParameterChange('noWaitAfter', e.target.checked)}
                  />
                }
                label="Don't wait for navigation after click"
              />
            </Grid>
          </Grid>
        );
        
      case 'type':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="Text to Type"
                fullWidth
                required
                value={formValues.parameters.text || ''}
                onChange={(e) => handleParameterChange('text', e.target.value)}
                error={!!paramErrors.text}
                helperText={paramErrors.text}
                multiline
                rows={2}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Delay between keypresses (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.delay || 0}
                onChange={(e) => handleParameterChange('delay', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Timeout (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.timeout || 30000}
                onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={formValues.parameters.clear !== false}
                    onChange={(e) => handleBooleanParameterChange('clear', e.target.checked)}
                  />
                }
                label="Clear field before typing"
              />
            </Grid>
          </Grid>
        );
        
      case 'wait':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Wait Type</InputLabel>
                <Select
                  name="waitType"
                  value={formValues.parameters.waitType || 'selector'}
                  onChange={(e) => handleParameterChange('waitType', e.target.value)}
                >
                  <MenuItem value="selector">Wait for Element</MenuItem>
                  <MenuItem value="navigation">Wait for Navigation</MenuItem>
                  <MenuItem value="loadstate">Wait for Page Load State</MenuItem>
                  <MenuItem value="timeout">Wait for Timeout</MenuItem>
                  <MenuItem value="function">Wait for JavaScript Condition</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            {formValues.parameters.waitType === 'selector' && (
              <>
                <Grid item xs={12}>
                  <FormControl fullWidth>
                    <InputLabel>State</InputLabel>
                    <Select
                      name="state"
                      value={formValues.parameters.state || 'visible'}
                      onChange={(e) => handleParameterChange('state', e.target.value)}
                    >
                      <MenuItem value="visible">Visible</MenuItem>
                      <MenuItem value="hidden">Hidden</MenuItem>
                      <MenuItem value="attached">Attached to DOM</MenuItem>
                      <MenuItem value="detached">Detached from DOM</MenuItem>
                    </Select>
                    <FormHelperText>
                      Element state to wait for
                    </FormHelperText>
                  </FormControl>
                </Grid>
              </>
            )}
            
            {formValues.parameters.waitType === 'loadstate' && (
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Load State</InputLabel>
                  <Select
                    name="state"
                    value={formValues.parameters.state || 'load'}
                    onChange={(e) => handleParameterChange('state', e.target.value)}
                  >
                    <MenuItem value="load">Load</MenuItem>
                    <MenuItem value="domcontentloaded">DOM Content Loaded</MenuItem>
                    <MenuItem value="networkidle">Network Idle</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            )}
            
            {formValues.parameters.waitType === 'timeout' && (
              <Grid item xs={12}>
                <TextField
                  label="Duration (ms)"
                  type="number"
                  fullWidth
                  required
                  value={formValues.parameters.duration || 1000}
                  onChange={(e) => handleParameterChange('duration', parseInt(e.target.value))}
                  inputProps={{ min: 0 }}
                />
              </Grid>
            )}
            
            {formValues.parameters.waitType === 'function' && (
              <Grid item xs={12}>
                <TextField
                  label="JavaScript Function"
                  fullWidth
                  required
                  multiline
                  rows={4}
                  value={formValues.parameters.function || ''}
                  onChange={(e) => handleParameterChange('function', e.target.value)}
                  placeholder="() => document.querySelector('.ready') !== null"
                  error={!!paramErrors.function}
                  helperText={paramErrors.function}
                />
              </Grid>
            )}
            
            {formValues.parameters.waitType !== 'timeout' && (
              <Grid item xs={12}>
                <TextField
                  label="Timeout (ms)"
                  type="number"
                  fullWidth
                  value={formValues.parameters.timeout || 30000}
                  onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                  inputProps={{ min: 0 }}
                />
              </Grid>
            )}
          </Grid>
        );
        
      case 'assert':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <FormControl fullWidth>
                <InputLabel>Assertion Type</InputLabel>
                <Select
                  name="assertType"
                  value={formValues.parameters.assertType || 'visible'}
                  onChange={(e) => handleParameterChange('assertType', e.target.value)}
                >
                  <MenuItem value="visible">Visibility</MenuItem>
                  <MenuItem value="enabled">Enabled State</MenuItem>
                  <MenuItem value="text">Text Content</MenuItem>
                  <MenuItem value="attribute">Attribute Value</MenuItem>
                  <MenuItem value="count">Element Count</MenuItem>
                  <MenuItem value="url">Page URL</MenuItem>
                  <MenuItem value="title">Page Title</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            {(formValues.parameters.assertType === 'visible' || 
              formValues.parameters.assertType === 'enabled') && (
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel>Expected</InputLabel>
                  <Select
                    name="expected"
                    value={formValues.parameters.expected || 'true'}
                    onChange={(e) => handleParameterChange('expected', e.target.value)}
                  >
                    <MenuItem value="true">
                      {formValues.parameters.assertType === 'visible' ? 'Visible' : 'Enabled'}
                    </MenuItem>
                    <MenuItem value="false">
                      {formValues.parameters.assertType === 'visible' ? 'Not Visible' : 'Not Enabled'}
                    </MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            )}
            
            {formValues.parameters.assertType === 'text' && (
              <>
                <Grid item xs={12}>
                  <TextField
                    label="Expected Text"
                    fullWidth
                    required
                    value={formValues.parameters.expected || ''}
                    onChange={(e) => handleParameterChange('expected', e.target.value)}
                    error={!!paramErrors.expected}
                    helperText={paramErrors.expected}
                  />
                </Grid>
                <Grid item xs={12}>
                  <FormControl fullWidth>
                    <InputLabel>Match Type</InputLabel>
                    <Select
                      name="matchType"
                      value={formValues.parameters.matchType || 'exact'}
                      onChange={(e) => handleParameterChange('matchType', e.target.value)}
                    >
                      <MenuItem value="exact">Exact Match</MenuItem>
                      <MenuItem value="contains">Contains</MenuItem>
                      <MenuItem value="regex">Regular Expression</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              </>
            )}
            
            {formValues.parameters.assertType === 'attribute' && (
              <>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="Attribute Name"
                    fullWidth
                    required
                    value={formValues.parameters.attribute || ''}
                    onChange={(e) => handleParameterChange('attribute', e.target.value)}
                    error={!!paramErrors.attribute}
                    helperText={paramErrors.attribute}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="Expected Value"
                    fullWidth
                    required
                    value={formValues.parameters.expected || ''}
                    onChange={(e) => handleParameterChange('expected', e.target.value)}
                    error={!!paramErrors.expected}
                    helperText={paramErrors.expected}
                  />
                </Grid>
              </>
            )}
            
            {formValues.parameters.assertType === 'count' && (
              <Grid item xs={12}>
                <TextField
                  label="Expected Count"
                  type="number"
                  fullWidth
                  required
                  value={formValues.parameters.expected || ''}
                  onChange={(e) => handleParameterChange('expected', e.target.value)}
                  error={!!paramErrors.expected}
                  helperText={paramErrors.expected}
                  inputProps={{ min: 0 }}
                />
              </Grid>
            )}
            
            {(formValues.parameters.assertType === 'url' || 
              formValues.parameters.assertType === 'title') && (
              <>
                <Grid item xs={12}>
                  <TextField
                    label={`Expected ${formValues.parameters.assertType === 'url' ? 'URL' : 'Title'}`}
                    fullWidth
                    required
                    value={formValues.parameters.expected || ''}
                    onChange={(e) => handleParameterChange('expected', e.target.value)}
                    error={!!paramErrors.expected}
                    helperText={paramErrors.expected}
                  />
                </Grid>
                <Grid item xs={12}>
                  <FormControl fullWidth>
                    <InputLabel>Match Type</InputLabel>
                    <Select
                      name="matchType"
                      value={formValues.parameters.matchType || 'exact'}
                      onChange={(e) => handleParameterChange('matchType', e.target.value)}
                    >
                      <MenuItem value="exact">Exact Match</MenuItem>
                      <MenuItem value="contains">Contains</MenuItem>
                      <MenuItem value="regex">Regular Expression</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              </>
            )}
            
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.screenshotOnFailure}
                    onChange={(e) => handleBooleanParameterChange('screenshotOnFailure', e.target.checked)}
                  />
                }
                label="Take screenshot on failure"
              />
            </Grid>
          </Grid>
        );
        
      case 'check':
      case 'uncheck':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="Timeout (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.timeout || 30000}
                onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.force}
                    onChange={(e) => handleBooleanParameterChange('force', e.target.checked)}
                  />
                }
                label="Force action (bypass checks)"
              />
            </Grid>
          </Grid>
        );
        
      case 'select':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="Option Value"
                fullWidth
                required
                value={formValues.parameters.value || ''}
                onChange={(e) => handleParameterChange('value', e.target.value)}
                error={!!paramErrors.value}
                helperText={paramErrors.value || 'Value of the option to select'}
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Timeout (ms)"
                type="number"
                fullWidth
                value={formValues.parameters.timeout || 30000}
                onChange={(e) => handleParameterChange('timeout', parseInt(e.target.value))}
                inputProps={{ min: 0 }}
              />
            </Grid>
          </Grid>
        );
        
      case 'screenshot':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="File Path"
                fullWidth
                value={formValues.parameters.path || ''}
                onChange={(e) => handleParameterChange('path', e.target.value)}
                placeholder="screenshots/screenshot.png"
                helperText="Leave empty for auto-generated filename"
              />
            </Grid>
            <Grid item xs={12}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.fullPage}
                    onChange={(e) => handleBooleanParameterChange('fullPage', e.target.checked)}
                  />
                }
                label="Full page screenshot"
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                label="Quality (0-100)"
                type="number"
                fullWidth
                value={formValues.parameters.quality || 90}
                onChange={(e) => handleParameterChange('quality', parseInt(e.target.value))}
                inputProps={{ min: 0, max: 100 }}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControlLabel
                control={
                  <Switch
                    checked={!!formValues.parameters.omitBackground}
                    onChange={(e) => handleBooleanParameterChange('omitBackground', e.target.checked)}
                  />
                }
                label="Transparent background"
              />
            </Grid>
          </Grid>
        );
        
      case 'js':
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                label="JavaScript Code"
                fullWidth
                required
                multiline
                rows={6}
                value={formValues.parameters.script || ''}
                onChange={(e) => handleParameterChange('script', e.target.value)}
                error={!!paramErrors.script}
                helperText={paramErrors.script}
                placeholder="return document.title;"
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                label="Result Variable Name"
                fullWidth
                value={formValues.parameters.resultVariable || ''}
                onChange={(e) => handleParameterChange('resultVariable', e.target.value)}
                placeholder="pageTitle"
                helperText="Store result in this variable (optional)"
              />
            </Grid>
          </Grid>
        );
        
      default:
        return (
          <Typography variant="body1" color="text.secondary">
            No parameters needed for this action.
          </Typography>
        );
    }
  };
  
  // Validate form before submitting
  const validateForm = () => {
    const errors = {};
    
    // Check required fields based on action type
    switch (formValues.action) {
      case 'navigate':
        if (!formValues.parameters.url) {
          errors.url = 'URL is required';
        }
        break;
        
      case 'type':
        if (!formValues.parameters.text) {
          errors.text = 'Text is required';
        }
        break;
        
      case 'wait':
        if (formValues.parameters.waitType === 'function' && !formValues.parameters.function) {
          errors.function = 'JavaScript function is required';
        }
        break;
        
      case 'assert':
        if (['text', 'attribute', 'count', 'url', 'title'].includes(formValues.parameters.assertType) && 
            !formValues.parameters.expected) {
          errors.expected = 'Expected value is required';
        }
        if (formValues.parameters.assertType === 'attribute' && !formValues.parameters.attribute) {
          errors.attribute = 'Attribute name is required';
        }
        break;
        
      case 'select':
        if (!formValues.parameters.value) {
          errors.value = 'Value is required';
        }
        break;
        
      case 'js':
        if (!formValues.parameters.script) {
          errors.script = 'JavaScript code is required';
        }
        break;
    }
    
    // Validate selector for actions that require it
    if (['click', 'type', 'check', 'uncheck', 'select'].includes(formValues.action) && !formValues.selector) {
      errors.selector = 'Selector is required';
    }
    
    setParamErrors(errors);
    return Object.keys(errors).length === 0;
  };
  
  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    // Generate ID if not present (new step)
    const stepToSave = {
      ...formValues,
      id: formValues.id || crypto.randomUUID ? crypto.randomUUID() : Date.now().toString()
    };
    
    onSave(stepToSave);
  };
  
  // Get description for the current action type
  const getActionDescription = () => {
    const action = actionTypes.find(a => a.value === formValues.action);
    return action ? action.description : '';
  };
  
  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ mt: 2 }}>
      <Grid container spacing={3}>
        {/* Basic Step Information */}
        <Grid item xs={12} md={6}>
          <FormControl fullWidth>
            <InputLabel>Action</InputLabel>
            <Select
              name="action"
              value={formValues.action}
              onChange={handleInputChange}
            >
              {actionTypes.map(action => (
                <MenuItem key={action.value} value={action.value}>
                  {action.label}
                </MenuItem>
              ))}
            </Select>
            <FormHelperText>{getActionDescription()}</FormHelperText>
          </FormControl>
        </Grid>
        
        {/* Only show selector input for actions that need it */}
        {['click', 'type', 'check', 'uncheck', 'select', 'wait', 'assert', 'hover'].includes(formValues.action) && (
          <>
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel>Selector Type</InputLabel>
                <Select
                  name="selectorType"
                  value={formValues.selectorType}
                  onChange={handleInputChange}
                >
                  {selectorTypes.map(type => (
                    <MenuItem key={type.value} value={type.value}>
                      {type.label}
                    </MenuItem>
                  ))}
                </Select>
                <FormHelperText>
                  {selectorTypes.find(t => t.value === formValues.selectorType)?.description}
                </FormHelperText>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                name="selector"
                label="Selector"
                fullWidth
                required={['click', 'type', 'check', 'uncheck', 'select'].includes(formValues.action)}
                value={formValues.selector}
                onChange={handleInputChange}
                error={paramErrors.selector}
                helperText={paramErrors.selector || `Element selector using ${formValues.selectorType} format`}
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <Tooltip title="Record Selector">
                        <IconButton edge="end">
                          <SearchIcon />
                        </IconButton>
                      </Tooltip>
                    </InputAdornment>
                  ),
                }}
              />
            </Grid>
          </>
        )}
        
        {/* Divider before parameter section */}
        <Grid item xs={12}>
          <Divider />
        </Grid>
        
        {/* Parameters section */}
        <Grid item xs={12}>
          <Typography variant="h6" sx={{ mb: 2 }}>
            {formValues.action.charAt(0).toUpperCase() + formValues.action.slice(1)} Parameters
          </Typography>
          {getParameterFields()}
        </Grid>
        
        {/* Form Actions */}
        <Grid item xs={12}>
          <Box display="flex" justifyContent="flex-end" gap={2} mt={2}>
            <Button
              variant="outlined"
              onClick={onCancel}
              startIcon={<CancelIcon />}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              variant="contained"
              color="primary"
              startIcon={<SaveIcon />}
            >
              {isEditMode ? 'Update Step' : 'Add Step'}
            </Button>
          </Box>
        </Grid>
      </Grid>
    </Box>
  );
};

export default TestStepForm;

/**
 * Main Application Controller
 * Provides the primary REST API endpoints for the CSTestForge application
 */
package com.cstestforge.controller;

import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.project.Project;
import com.cstestforge.service.project.ProjectService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1")
@CrossOrigin(origins = "*", maxAge = 3600)
public class MainController {
    private static final Logger logger = LoggerFactory.getLogger(MainController.class);
    
    @Autowired
    private ProjectService projectService;
    
    /**
     * Health check endpoint
     * @return Status and version information
     */
    @GetMapping("/health")
    public ResponseEntity<ApiResponse> getHealthStatus() {
        logger.info("Health check request received");
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("CSTestForge API is running")
            .setData(Map.of(
                "version", "1.0.0",
                "status", "operational",
                "timestamp", System.currentTimeMillis()
            ));
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get system configuration and capabilities
     * @return System configuration information
     */
    @GetMapping("/system/config")
    public ResponseEntity<ApiResponse> getSystemConfig() {
        logger.info("System configuration request received");
        
        Map<String, Object> config = Map.of(
            "maxParallelExecutions", Runtime.getRuntime().availableProcessors(),
            "supportedBrowsers", List.of("chrome", "firefox", "edge", "safari"),
            "features", Map.of(
                "selfHealing", true,
                "nlpProcessing", true,
                "apiTesting", true,
                "databaseTesting", true,
                "bddTesting", true
            ),
            "storage", Map.of(
                "type", "filesystem",
                "backupEnabled", true
            )
        );
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("System configuration retrieved successfully")
            .setData(config);
        
        return ResponseEntity.ok(response);
    }
}


/**
 * Project Controller
 * Handles REST endpoints for project management
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.project.Project;
import com.cstestforge.model.project.ProjectConfig;
import com.cstestforge.service.project.ProjectService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/projects")
@CrossOrigin(origins = "*", maxAge = 3600)
public class ProjectController {
    private static final Logger logger = LoggerFactory.getLogger(ProjectController.class);
    
    @Autowired
    private ProjectService projectService;
    
    /**
     * Get all projects
     * @return List of all projects
     */
    @GetMapping
    public ResponseEntity<ApiResponse> getAllProjects() {
        logger.info("Request to get all projects");
        
        List<Project> projects = projectService.getAllProjects();
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("Projects retrieved successfully")
            .setData(projects);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get project by ID
     * @param projectId The project ID
     * @return Project details
     */
    @GetMapping("/{projectId}")
    public ResponseEntity<ApiResponse> getProjectById(@PathVariable String projectId) {
        logger.info("Request to get project: {}", projectId);
        
        try {
            Project project = projectService.getProjectById(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Project retrieved successfully")
                .setData(project);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new project
     * @param project The project to create
     * @return Created project details
     */
    @PostMapping
    public ResponseEntity<ApiResponse> createProject(@Valid @RequestBody Project project) {
        logger.info("Request to create project: {}", project.getName());
        
        Project createdProject = projectService.createProject(project);
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("Project created successfully")
            .setData(createdProject);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    /**
     * Update a project
     * @param projectId The project ID
     * @param projectDetails The updated project details
     * @return Updated project details
     */
    @PutMapping("/{projectId}")
    public ResponseEntity<ApiResponse> updateProject(
            @PathVariable String projectId,
            @Valid @RequestBody Project projectDetails) {
        logger.info("Request to update project: {}", projectId);
        
        try {
            Project updatedProject = projectService.updateProject(projectId, projectDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Project updated successfully")
                .setData(updatedProject);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a project
     * @param projectId The project ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{projectId}")
    public ResponseEntity<ApiResponse> deleteProject(@PathVariable String projectId) {
        logger.info("Request to delete project: {}", projectId);
        
        try {
            boolean deleted = projectService.deleteProject(projectId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Project deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete project");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get project configuration
     * @param projectId The project ID
     * @return Project configuration
     */
    @GetMapping("/{projectId}/config")
    public ResponseEntity<ApiResponse> getProjectConfig(@PathVariable String projectId) {
        logger.info("Request to get project config: {}", projectId);
        
        try {
            ProjectConfig config = projectService.getProjectConfig(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Project configuration retrieved successfully")
                .setData(config);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update project configuration
     * @param projectId The project ID
     * @param config The updated project configuration
     * @return Updated project configuration
     */
    @PutMapping("/{projectId}/config")
    public ResponseEntity<ApiResponse> updateProjectConfig(
            @PathVariable String projectId,
            @Valid @RequestBody ProjectConfig config) {
        logger.info("Request to update project config: {}", projectId);
        
        try {
            ProjectConfig updatedConfig = projectService.updateProjectConfig(projectId, config);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Project configuration updated successfully")
                .setData(updatedConfig);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
}


/**
 * Test Case Controller
 * Handles REST endpoints for test case management
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.testcase.TestCase;
import com.cstestforge.model.testcase.TestStep;
import com.cstestforge.service.testcase.TestCaseService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/testcases")
@CrossOrigin(origins = "*", maxAge = 3600)
public class TestCaseController {
    private static final Logger logger = LoggerFactory.getLogger(TestCaseController.class);
    
    @Autowired
    private TestCaseService testCaseService;
    
    /**
     * Get all test cases for a project
     * @param projectId The project ID
     * @return List of test cases
     */
    @GetMapping
    public ResponseEntity<ApiResponse> getAllTestCases(@PathVariable String projectId) {
        logger.info("Request to get all test cases for project: {}", projectId);
        
        try {
            List<TestCase> testCases = testCaseService.getAllTestCases(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test cases retrieved successfully")
                .setData(testCases);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get test case by ID
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @return Test case details
     */
    @GetMapping("/{testCaseId}")
    public ResponseEntity<ApiResponse> getTestCaseById(
            @PathVariable String projectId,
            @PathVariable String testCaseId) {
        logger.info("Request to get test case: {} in project: {}", testCaseId, projectId);
        
        try {
            TestCase testCase = testCaseService.getTestCaseById(projectId, testCaseId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test case retrieved successfully")
                .setData(testCase);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new test case
     * @param projectId The project ID
     * @param testCase The test case to create
     * @return Created test case details
     */
    @PostMapping
    public ResponseEntity<ApiResponse> createTestCase(
            @PathVariable String projectId,
            @Valid @RequestBody TestCase testCase) {
        logger.info("Request to create test case in project: {}", projectId);
        
        try {
            TestCase createdTestCase = testCaseService.createTestCase(projectId, testCase);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test case created successfully")
                .setData(createdTestCase);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a test case
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @param testCaseDetails The updated test case details
     * @return Updated test case details
     */
    @PutMapping("/{testCaseId}")
    public ResponseEntity<ApiResponse> updateTestCase(
            @PathVariable String projectId,
            @PathVariable String testCaseId,
            @Valid @RequestBody TestCase testCaseDetails) {
        logger.info("Request to update test case: {} in project: {}", testCaseId, projectId);
        
        try {
            TestCase updatedTestCase = testCaseService.updateTestCase(projectId, testCaseId, testCaseDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test case updated successfully")
                .setData(updatedTestCase);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a test case
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{testCaseId}")
    public ResponseEntity<ApiResponse> deleteTestCase(
            @PathVariable String projectId,
            @PathVariable String testCaseId) {
        logger.info("Request to delete test case: {} in project: {}", testCaseId, projectId);
        
        try {
            boolean deleted = testCaseService.deleteTestCase(projectId, testCaseId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Test case deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete test case");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get all test steps for a test case
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @return List of test steps
     */
    @GetMapping("/{testCaseId}/steps")
    public ResponseEntity<ApiResponse> getAllTestSteps(
            @PathVariable String projectId,
            @PathVariable String testCaseId) {
        logger.info("Request to get all test steps for test case: {} in project: {}", testCaseId, projectId);
        
        try {
            List<TestStep> testSteps = testCaseService.getAllTestSteps(projectId, testCaseId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test steps retrieved successfully")
                .setData(testSteps);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Add a test step to a test case
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @param testStep The test step to add
     * @return Added test step details
     */
    @PostMapping("/{testCaseId}/steps")
    public ResponseEntity<ApiResponse> addTestStep(
            @PathVariable String projectId,
            @PathVariable String testCaseId,
            @Valid @RequestBody TestStep testStep) {
        logger.info("Request to add test step to test case: {} in project: {}", testCaseId, projectId);
        
        try {
            TestStep addedTestStep = testCaseService.addTestStep(projectId, testCaseId, testStep);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test step added successfully")
                .setData(addedTestStep);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a test step
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @param stepId The step ID
     * @param testStepDetails The updated test step details
     * @return Updated test step details
     */
    @PutMapping("/{testCaseId}/steps/{stepId}")
    public ResponseEntity<ApiResponse> updateTestStep(
            @PathVariable String projectId,
            @PathVariable String testCaseId,
            @PathVariable String stepId,
            @Valid @RequestBody TestStep testStepDetails) {
        logger.info("Request to update test step: {} in test case: {} in project: {}", 
                stepId, testCaseId, projectId);
        
        try {
            TestStep updatedTestStep = testCaseService.updateTestStep(
                    projectId, testCaseId, stepId, testStepDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test step updated successfully")
                .setData(updatedTestStep);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a test step
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @param stepId The step ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{testCaseId}/steps/{stepId}")
    public ResponseEntity<ApiResponse> deleteTestStep(
            @PathVariable String projectId,
            @PathVariable String testCaseId,
            @PathVariable String stepId) {
        logger.info("Request to delete test step: {} in test case: {} in project: {}", 
                stepId, testCaseId, projectId);
        
        try {
            boolean deleted = testCaseService.deleteTestStep(projectId, testCaseId, stepId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Test step deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete test step");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Reorder test steps in a test case
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @param stepIds List of step IDs in their new order
     * @return Updated test case with reordered steps
     */
    @PutMapping("/{testCaseId}/steps/reorder")
    public ResponseEntity<ApiResponse> reorderTestSteps(
            @PathVariable String projectId,
            @PathVariable String testCaseId,
            @RequestBody List<String> stepIds) {
        logger.info("Request to reorder test steps in test case: {} in project: {}", testCaseId, projectId);
        
        try {
            TestCase updatedTestCase = testCaseService.reorderTestSteps(projectId, testCaseId, stepIds);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test steps reordered successfully")
                .setData(updatedTestCase);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (IllegalArgumentException e) {
            logger.error("Invalid step order: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
    }
}


/**
 * Test Execution Controller
 * Handles REST endpoints for test execution
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.execution.ExecutionConfig;
import com.cstestforge.model.execution.ExecutionRequest;
import com.cstestforge.model.execution.ExecutionResult;
import com.cstestforge.model.execution.ExecutionStatus;
import com.cstestforge.service.execution.ExecutionService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.validation.Valid;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@RestController
@RequestMapping("/api/v1/execution")
@CrossOrigin(origins = "*", maxAge = 3600)
public class ExecutionController {
    private static final Logger logger = LoggerFactory.getLogger(ExecutionController.class);
    
    @Autowired
    private ExecutionService executionService;
    
    // Map to store SSE emitters for real-time execution updates
    private final Map<String, SseEmitter> executionEmitters = new ConcurrentHashMap<>();
    
    /**
     * Execute a test case
     * @param executionRequest Contains project ID, test case IDs, and execution config
     * @return Execution result
     */
    @PostMapping("/testcase")
    public ResponseEntity<ApiResponse> executeTestCase(
            @Valid @RequestBody ExecutionRequest executionRequest) {
        logger.info("Request to execute test case(s) in project: {}", executionRequest.getProjectId());
        
        try {
            String executionId = executionService.scheduleTestCaseExecution(
                    executionRequest.getProjectId(),
                    executionRequest.getTestCaseIds(),
                    executionRequest.getConfig());
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test case execution scheduled successfully")
                .setData(Map.of("executionId", executionId));
            
            return ResponseEntity.accepted().body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to schedule test case execution", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to schedule test case execution: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Execute a test suite
     * @param executionRequest Contains project ID, test suite IDs, and execution config
     * @return Execution result
     */
    @PostMapping("/testsuite")
    public ResponseEntity<ApiResponse> executeTestSuite(
            @Valid @RequestBody ExecutionRequest executionRequest) {
        logger.info("Request to execute test suite(s) in project: {}", executionRequest.getProjectId());
        
        try {
            String executionId = executionService.scheduleTestSuiteExecution(
                    executionRequest.getProjectId(),
                    executionRequest.getTestSuiteIds(),
                    executionRequest.getConfig());
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test suite execution scheduled successfully")
                .setData(Map.of("executionId", executionId));
            
            return ResponseEntity.accepted().body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to schedule test suite execution", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to schedule test suite execution: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get execution result
     * @param executionId The execution ID
     * @return Execution result
     */
    @GetMapping("/{executionId}")
    public ResponseEntity<ApiResponse> getExecutionResult(@PathVariable String executionId) {
        logger.info("Request to get execution result: {}", executionId);
        
        try {
            ExecutionResult result = executionService.getExecutionResult(executionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Execution result retrieved successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Execution not found: {}", executionId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get execution status
     * @param executionId The execution ID
     * @return Execution status
     */
    @GetMapping("/{executionId}/status")
    public ResponseEntity<ApiResponse> getExecutionStatus(@PathVariable String executionId) {
        logger.info("Request to get execution status: {}", executionId);
        
        try {
            ExecutionStatus status = executionService.getExecutionStatus(executionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Execution status retrieved successfully")
                .setData(status);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Execution not found: {}", executionId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Cancel execution
     * @param executionId The execution ID
     * @return Cancellation confirmation
     */
    @PostMapping("/{executionId}/cancel")
    public ResponseEntity<ApiResponse> cancelExecution(@PathVariable String executionId) {
        logger.info("Request to cancel execution: {}", executionId);
        
        try {
            boolean canceled = executionService.cancelExecution(executionId);
            
            if (canceled) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Execution canceled successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to cancel execution");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Execution not found: {}", executionId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get recent executions
     * @param limit Maximum number of executions to retrieve
     * @return List of recent executions
     */
    @GetMapping("/recent")
    public ResponseEntity<ApiResponse> getRecentExecutions(
            @RequestParam(defaultValue = "10") int limit) {
        logger.info("Request to get recent executions (limit: {})", limit);
        
        List<ExecutionResult> recentExecutions = executionService.getRecentExecutions(limit);
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("Recent executions retrieved successfully")
            .setData(recentExecutions);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get project executions
     * @param projectId The project ID
     * @param limit Maximum number of executions to retrieve
     * @return List of project executions
     */
    @GetMapping("/project/{projectId}")
    public ResponseEntity<ApiResponse> getProjectExecutions(
            @PathVariable String projectId,
            @RequestParam(defaultValue = "10") int limit) {
        logger.info("Request to get executions for project: {} (limit: {})", projectId, limit);
        
        try {
            List<ExecutionResult> projectExecutions = executionService.getProjectExecutions(projectId, limit);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Project executions retrieved successfully")
                .setData(projectExecutions);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Subscribe to real-time execution updates
     * @param executionId The execution ID
     * @return SSE emitter for streaming updates
     */
    @GetMapping("/events/{executionId}")
    public SseEmitter subscribeToExecutionEvents(@PathVariable String executionId) {
        logger.info("Request to subscribe to execution events: {}", executionId);
        
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        executionEmitters.put(executionId, emitter);
        
        // Set completion handler to remove the emitter when the connection is closed
        emitter.onCompletion(() -> {
            logger.info("SSE connection completed for execution: {}", executionId);
            executionEmitters.remove(executionId);
        });
        
        // Set timeout handler
        emitter.onTimeout(() -> {
            logger.info("SSE connection timed out for execution: {}", executionId);
            emitter.complete();
            executionEmitters.remove(executionId);
        });
        
        // Set error handler
        emitter.onError(e -> {
            logger.error("SSE error for execution: {}", executionId, e);
            executionEmitters.remove(executionId);
        });
        
        try {
            // Send initial connection established event
            emitter.send(SseEmitter.event()
                .name("connected")
                .data("Execution event stream established"));
            
            // Register this emitter with the execution service for updates
            executionService.registerExecutionListener(executionId, event -> {
                try {
                    emitter.send(SseEmitter.event()
                        .name(event.getType())
                        .data(event.getData()));
                    
                    // If execution is complete, close the emitter
                    if (event.getType().equals("completed") || event.getType().equals("failed")) {
                        emitter.complete();
                        executionEmitters.remove(executionId);
                    }
                } catch (IOException e) {
                    logger.error("Failed to send execution event", e);
                    emitter.completeWithError(e);
                    executionEmitters.remove(executionId);
                }
            });
        } catch (IOException e) {
            logger.error("Failed to send initial SSE event", e);
            emitter.completeWithError(e);
            executionEmitters.remove(executionId);
        } catch (ResourceNotFoundException e) {
            logger.error("Execution not found: {}", executionId, e);
            try {
                emitter.send(SseEmitter.event()
                    .name("error")
                    .data("Execution not found: " + executionId));
                emitter.complete();
            } catch (IOException ioException) {
                logger.error("Failed to send error SSE event", ioException);
                emitter.completeWithError(ioException);
            }
            executionEmitters.remove(executionId);
        }
        
        return emitter;
    }
}


/**
 * API Testing Controller
 * Handles REST endpoints for API testing functionality
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.api.*;
import com.cstestforge.service.api.ApiTestingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/api-testing")
@CrossOrigin(origins = "*", maxAge = 3600)
public class ApiTestingController {
    private static final Logger logger = LoggerFactory.getLogger(ApiTestingController.class);
    
    @Autowired
    private ApiTestingService apiTestingService;
    
    /**
     * Get all API tests for a project
     * @param projectId The project ID
     * @return List of API tests
     */
    @GetMapping
    public ResponseEntity<ApiResponse> getAllApiTests(@PathVariable String projectId) {
        logger.info("Request to get all API tests for project: {}", projectId);
        
        try {
            List<ApiTest> apiTests = apiTestingService.getAllApiTests(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API tests retrieved successfully")
                .setData(apiTests);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get API test by ID
     * @param projectId The project ID
     * @param apiTestId The API test ID
     * @return API test details
     */
    @GetMapping("/{apiTestId}")
    public ResponseEntity<ApiResponse> getApiTestById(
            @PathVariable String projectId,
            @PathVariable String apiTestId) {
        logger.info("Request to get API test: {} in project: {}", apiTestId, projectId);
        
        try {
            ApiTest apiTest = apiTestingService.getApiTestById(projectId, apiTestId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API test retrieved successfully")
                .setData(apiTest);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new API test
     * @param projectId The project ID
     * @param apiTest The API test to create
     * @return Created API test details
     */
    @PostMapping
    public ResponseEntity<ApiResponse> createApiTest(
            @PathVariable String projectId,
            @Valid @RequestBody ApiTest apiTest) {
        logger.info("Request to create API test in project: {}", projectId);
        
        try {
            ApiTest createdApiTest = apiTestingService.createApiTest(projectId, apiTest);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API test created successfully")
                .setData(createdApiTest);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update an API test
     * @param projectId The project ID
     * @param apiTestId The API test ID
     * @param apiTestDetails The updated API test details
     * @return Updated API test details
     */
    @PutMapping("/{apiTestId}")
    public ResponseEntity<ApiResponse> updateApiTest(
            @PathVariable String projectId,
            @PathVariable String apiTestId,
            @Valid @RequestBody ApiTest apiTestDetails) {
        logger.info("Request to update API test: {} in project: {}", apiTestId, projectId);
        
        try {
            ApiTest updatedApiTest = apiTestingService.updateApiTest(projectId, apiTestId, apiTestDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API test updated successfully")
                .setData(updatedApiTest);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete an API test
     * @param projectId The project ID
     * @param apiTestId The API test ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{apiTestId}")
    public ResponseEntity<ApiResponse> deleteApiTest(
            @PathVariable String projectId,
            @PathVariable String apiTestId) {
        logger.info("Request to delete API test: {} in project: {}", apiTestId, projectId);
        
        try {
            boolean deleted = apiTestingService.deleteApiTest(projectId, apiTestId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("API test deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete API test");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Execute an API test
     * @param projectId The project ID
     * @param apiTestId The API test ID
     * @return Execution result
     */
    @PostMapping("/{apiTestId}/execute")
    public ResponseEntity<ApiResponse> executeApiTest(
            @PathVariable String projectId,
            @PathVariable String apiTestId,
            @RequestBody(required = false) ApiTestExecutionConfig config) {
        logger.info("Request to execute API test: {} in project: {}", apiTestId, projectId);
        
        try {
            // If config is null, use default configuration
            if (config == null) {
                config = new ApiTestExecutionConfig();
            }
            
            ApiTestResult result = apiTestingService.executeApiTest(projectId, apiTestId, config);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API test executed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("API test execution failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("API test execution failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get API testing environment variables
     * @param projectId The project ID
     * @return List of environment variables
     */
    @GetMapping("/environments")
    public ResponseEntity<ApiResponse> getApiTestingEnvironments(@PathVariable String projectId) {
        logger.info("Request to get API testing environments for project: {}", projectId);
        
        try {
            List<ApiTestingEnvironment> environments = apiTestingService.getEnvironments(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API testing environments retrieved successfully")
                .setData(environments);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create or update an API testing environment
     * @param projectId The project ID
     * @param environment The environment to create or update
     * @return Created or updated environment
     */
    @PostMapping("/environments")
    public ResponseEntity<ApiResponse> createOrUpdateEnvironment(
            @PathVariable String projectId,
            @Valid @RequestBody ApiTestingEnvironment environment) {
        logger.info("Request to create or update API testing environment in project: {}", projectId);
        
        try {
            ApiTestingEnvironment savedEnvironment = apiTestingService.saveEnvironment(projectId, environment);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("API testing environment saved successfully")
                .setData(savedEnvironment);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete an API testing environment
     * @param projectId The project ID
     * @param environmentId The environment ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/environments/{environmentId}")
    public ResponseEntity<ApiResponse> deleteEnvironment(
            @PathVariable String projectId,
            @PathVariable String environmentId) {
        logger.info("Request to delete API testing environment: {} in project: {}", environmentId, projectId);
        
        try {
            boolean deleted = apiTestingService.deleteEnvironment(projectId, environmentId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("API testing environment deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete API testing environment");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
}


/**
 * Database Testing Controller
 * Handles REST endpoints for database testing functionality
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.database.*;
import com.cstestforge.service.database.DatabaseTestingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/db-testing")
@CrossOrigin(origins = "*", maxAge = 3600)
public class DatabaseTestingController {
    private static final Logger logger = LoggerFactory.getLogger(DatabaseTestingController.class);
    
    @Autowired
    private DatabaseTestingService dbTestingService;
    
    /**
     * Get all database connections for a project
     * @param projectId The project ID
     * @return List of database connections
     */
    @GetMapping("/connections")
    public ResponseEntity<ApiResponse> getAllConnections(@PathVariable String projectId) {
        logger.info("Request to get all database connections for project: {}", projectId);
        
        try {
            List<DatabaseConnection> connections = dbTestingService.getAllConnections(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database connections retrieved successfully")
                .setData(connections);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get database connection by ID
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @return Database connection details
     */
    @GetMapping("/connections/{connectionId}")
    public ResponseEntity<ApiResponse> getConnectionById(
            @PathVariable String projectId,
            @PathVariable String connectionId) {
        logger.info("Request to get database connection: {} in project: {}", connectionId, projectId);
        
        try {
            DatabaseConnection connection = dbTestingService.getConnectionById(projectId, connectionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database connection retrieved successfully")
                .setData(connection);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new database connection
     * @param projectId The project ID
     * @param connection The database connection to create
     * @return Created database connection details
     */
    @PostMapping("/connections")
    public ResponseEntity<ApiResponse> createConnection(
            @PathVariable String projectId,
            @Valid @RequestBody DatabaseConnection connection) {
        logger.info("Request to create database connection in project: {}", projectId);
        
        try {
            DatabaseConnection createdConnection = dbTestingService.createConnection(projectId, connection);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database connection created successfully")
                .setData(createdConnection);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a database connection
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @param connectionDetails The updated connection details
     * @return Updated database connection details
     */
    @PutMapping("/connections/{connectionId}")
    public ResponseEntity<ApiResponse> updateConnection(
            @PathVariable String projectId,
            @PathVariable String connectionId,
            @Valid @RequestBody DatabaseConnection connectionDetails) {
        logger.info("Request to update database connection: {} in project: {}", connectionId, projectId);
        
        try {
            DatabaseConnection updatedConnection = dbTestingService.updateConnection(
                    projectId, connectionId, connectionDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database connection updated successfully")
                .setData(updatedConnection);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a database connection
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/connections/{connectionId}")
    public ResponseEntity<ApiResponse> deleteConnection(
            @PathVariable String projectId,
            @PathVariable String connectionId) {
        logger.info("Request to delete database connection: {} in project: {}", connectionId, projectId);
        
        try {
            boolean deleted = dbTestingService.deleteConnection(projectId, connectionId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Database connection deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete database connection");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Test a database connection
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @return Connection test result
     */
    @PostMapping("/connections/{connectionId}/test")
    public ResponseEntity<ApiResponse> testConnection(
            @PathVariable String projectId,
            @PathVariable String connectionId) {
        logger.info("Request to test database connection: {} in project: {}", connectionId, projectId);
        
        try {
            DatabaseConnectionTestResult result = dbTestingService.testConnection(projectId, connectionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database connection test completed")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Database connection test failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Database connection test failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get all database queries for a project
     * @param projectId The project ID
     * @return List of database queries
     */
    @GetMapping("/queries")
    public ResponseEntity<ApiResponse> getAllQueries(@PathVariable String projectId) {
        logger.info("Request to get all database queries for project: {}", projectId);
        
        try {
            List<DatabaseQuery> queries = dbTestingService.getAllQueries(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database queries retrieved successfully")
                .setData(queries);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get database query by ID
     * @param projectId The project ID
     * @param queryId The query ID
     * @return Database query details
     */
    @GetMapping("/queries/{queryId}")
    public ResponseEntity<ApiResponse> getQueryById(
            @PathVariable String projectId,
            @PathVariable String queryId) {
        logger.info("Request to get database query: {} in project: {}", queryId, projectId);
        
        try {
            DatabaseQuery query = dbTestingService.getQueryById(projectId, queryId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database query retrieved successfully")
                .setData(query);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new database query
     * @param projectId The project ID
     * @param query The database query to create
     * @return Created database query details
     */
    @PostMapping("/queries")
    public ResponseEntity<ApiResponse> createQuery(
            @PathVariable String projectId,
            @Valid @RequestBody DatabaseQuery query) {
        logger.info("Request to create database query in project: {}", projectId);
        
        try {
            DatabaseQuery createdQuery = dbTestingService.createQuery(projectId, query);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database query created successfully")
                .setData(createdQuery);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a database query
     * @param projectId The project ID
     * @param queryId The query ID
     * @param queryDetails The updated query details
     * @return Updated database query details
     */
    @PutMapping("/queries/{queryId}")
    public ResponseEntity<ApiResponse> updateQuery(
            @PathVariable String projectId,
            @PathVariable String queryId,
            @Valid @RequestBody DatabaseQuery queryDetails) {
        logger.info("Request to update database query: {} in project: {}", queryId, projectId);
        
        try {
            DatabaseQuery updatedQuery = dbTestingService.updateQuery(projectId, queryId, queryDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database query updated successfully")
                .setData(updatedQuery);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a database query
     * @param projectId The project ID
     * @param queryId The query ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/queries/{queryId}")
    public ResponseEntity<ApiResponse> deleteQuery(
            @PathVariable String projectId,
            @PathVariable String queryId) {
        logger.info("Request to delete database query: {} in project: {}", queryId, projectId);
        
        try {
            boolean deleted = dbTestingService.deleteQuery(projectId, queryId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Database query deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete database query");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Execute a database query
     * @param projectId The project ID
     * @param queryId The query ID
     * @param parameters Optional parameters for the query
     * @return Query execution result
     */
    @PostMapping("/queries/{queryId}/execute")
    public ResponseEntity<ApiResponse> executeQuery(
            @PathVariable String projectId,
            @PathVariable String queryId,
            @RequestBody(required = false) Map<String, Object> parameters) {
        logger.info("Request to execute database query: {} in project: {}", queryId, projectId);
        
        try {
            // If parameters is null, use empty map
            if (parameters == null) {
                parameters = Map.of();
            }
            
            DatabaseQueryResult result = dbTestingService.executeQuery(projectId, queryId, parameters);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database query executed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Database query execution failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Database query execution failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get database tables for a connection
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @return List of database tables
     */
    @GetMapping("/connections/{connectionId}/tables")
    public ResponseEntity<ApiResponse> getDatabaseTables(
            @PathVariable String projectId,
            @PathVariable String connectionId) {
        logger.info("Request to get database tables for connection: {} in project: {}", connectionId, projectId);
        
        try {
            List<DatabaseTable> tables = dbTestingService.getTables(projectId, connectionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Database tables retrieved successfully")
                .setData(tables);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to retrieve database tables", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to retrieve database tables: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get database table schema
     * @param projectId The project ID
     * @param connectionId The connection ID
     * @param tableName The table name
     * @return Table schema
     */
    @GetMapping("/connections/{connectionId}/tables/{tableName}")
    public ResponseEntity<ApiResponse> getTableSchema(
            @PathVariable String projectId,
            @PathVariable String connectionId,
            @PathVariable String tableName) {
        logger.info("Request to get schema for table: {} in connection: {} in project: {}", 
                tableName, connectionId, projectId);
        
        try {
            DatabaseTableSchema schema = dbTestingService.getTableSchema(projectId, connectionId, tableName);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Table schema retrieved successfully")
                .setData(schema);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to retrieve table schema", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to retrieve table schema: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


/**
 * BDD Testing Controller
 * Handles REST endpoints for BDD testing functionality
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.bdd.*;
import com.cstestforge.service.bdd.BDDTestingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/bdd-testing")
@CrossOrigin(origins = "*", maxAge = 3600)
public class BDDTestingController {
    private static final Logger logger = LoggerFactory.getLogger(BDDTestingController.class);
    
    @Autowired
    private BDDTestingService bddTestingService;
    
    /**
     * Get all feature files for a project
     * @param projectId The project ID
     * @return List of feature files
     */
    @GetMapping("/features")
    public ResponseEntity<ApiResponse> getAllFeatures(@PathVariable String projectId) {
        logger.info("Request to get all feature files for project: {}", projectId);
        
        try {
            List<FeatureFile> features = bddTestingService.getAllFeatures(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature files retrieved successfully")
                .setData(features);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get feature file by ID
     * @param projectId The project ID
     * @param featureId The feature ID
     * @return Feature file details
     */
    @GetMapping("/features/{featureId}")
    public ResponseEntity<ApiResponse> getFeatureById(
            @PathVariable String projectId,
            @PathVariable String featureId) {
        logger.info("Request to get feature file: {} in project: {}", featureId, projectId);
        
        try {
            FeatureFile feature = bddTestingService.getFeatureById(projectId, featureId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature file retrieved successfully")
                .setData(feature);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new feature file
     * @param projectId The project ID
     * @param feature The feature file to create
     * @return Created feature file details
     */
    @PostMapping("/features")
    public ResponseEntity<ApiResponse> createFeature(
            @PathVariable String projectId,
            @Valid @RequestBody FeatureFile feature) {
        logger.info("Request to create feature file in project: {}", projectId);
        
        try {
            FeatureFile createdFeature = bddTestingService.createFeature(projectId, feature);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature file created successfully")
                .setData(createdFeature);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a feature file
     * @param projectId The project ID
     * @param featureId The feature ID
     * @param featureDetails The updated feature file details
     * @return Updated feature file details
     */
    @PutMapping("/features/{featureId}")
    public ResponseEntity<ApiResponse> updateFeature(
            @PathVariable String projectId,
            @PathVariable String featureId,
            @Valid @RequestBody FeatureFile featureDetails) {
        logger.info("Request to update feature file: {} in project: {}", featureId, projectId);
        
        try {
            FeatureFile updatedFeature = bddTestingService.updateFeature(projectId, featureId, featureDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature file updated successfully")
                .setData(updatedFeature);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a feature file
     * @param projectId The project ID
     * @param featureId The feature ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/features/{featureId}")
    public ResponseEntity<ApiResponse> deleteFeature(
            @PathVariable String projectId,
            @PathVariable String featureId) {
        logger.info("Request to delete feature file: {} in project: {}", featureId, projectId);
        
        try {
            boolean deleted = bddTestingService.deleteFeature(projectId, featureId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Feature file deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete feature file");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Import feature files from files
     * @param projectId The project ID
     * @param files The feature files to import
     * @return Import result with imported feature files
     */
    @PostMapping("/features/import")
    public ResponseEntity<ApiResponse> importFeatureFiles(
            @PathVariable String projectId,
            @RequestParam("files") MultipartFile[] files) {
        logger.info("Request to import feature files in project: {}", projectId);
        
        try {
            BDDImportResult result = bddTestingService.importFeatureFiles(projectId, files);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature files imported successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to import feature files", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to import feature files: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get all step definitions for a project
     * @param projectId The project ID
     * @return List of step definitions
     */
    @GetMapping("/step-definitions")
    public ResponseEntity<ApiResponse> getAllStepDefinitions(@PathVariable String projectId) {
        logger.info("Request to get all step definitions for project: {}", projectId);
        
        try {
            List<StepDefinition> stepDefinitions = bddTestingService.getAllStepDefinitions(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Step definitions retrieved successfully")
                .setData(stepDefinitions);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get step definition by ID
     * @param projectId The project ID
     * @param stepDefId The step definition ID
     * @return Step definition details
     */
    @GetMapping("/step-definitions/{stepDefId}")
    public ResponseEntity<ApiResponse> getStepDefinitionById(
            @PathVariable String projectId,
            @PathVariable String stepDefId) {
        logger.info("Request to get step definition: {} in project: {}", stepDefId, projectId);
        
        try {
            StepDefinition stepDefinition = bddTestingService.getStepDefinitionById(projectId, stepDefId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Step definition retrieved successfully")
                .setData(stepDefinition);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new step definition
     * @param projectId The project ID
     * @param stepDefinition The step definition to create
     * @return Created step definition details
     */
    @PostMapping("/step-definitions")
    public ResponseEntity<ApiResponse> createStepDefinition(
            @PathVariable String projectId,
            @Valid @RequestBody StepDefinition stepDefinition) {
        logger.info("Request to create step definition in project: {}", projectId);
        
        try {
            StepDefinition createdStepDef = bddTestingService.createStepDefinition(projectId, stepDefinition);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Step definition created successfully")
                .setData(createdStepDef);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Update a step definition
     * @param projectId The project ID
     * @param stepDefId The step definition ID
     * @param stepDefDetails The updated step definition details
     * @return Updated step definition details
     */
    @PutMapping("/step-definitions/{stepDefId}")
    public ResponseEntity<ApiResponse> updateStepDefinition(
            @PathVariable String projectId,
            @PathVariable String stepDefId,
            @Valid @RequestBody StepDefinition stepDefDetails) {
        logger.info("Request to update step definition: {} in project: {}", stepDefId, projectId);
        
        try {
            StepDefinition updatedStepDef = bddTestingService.updateStepDefinition(
                    projectId, stepDefId, stepDefDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Step definition updated successfully")
                .setData(updatedStepDef);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Delete a step definition
     * @param projectId The project ID
     * @param stepDefId The step definition ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/step-definitions/{stepDefId}")
    public ResponseEntity<ApiResponse> deleteStepDefinition(
            @PathVariable String projectId,
            @PathVariable String stepDefId) {
        logger.info("Request to delete step definition: {} in project: {}", stepDefId, projectId);
        
        try {
            boolean deleted = bddTestingService.deleteStepDefinition(projectId, stepDefId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Step definition deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete step definition");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Execute feature file
     * @param projectId The project ID
     * @param featureId The feature ID
     * @param config Execution configuration
     * @return Execution result
     */
    @PostMapping("/features/{featureId}/execute")
    public ResponseEntity<ApiResponse> executeFeature(
            @PathVariable String projectId,
            @PathVariable String featureId,
            @RequestBody(required = false) BDDExecutionConfig config) {
        logger.info("Request to execute feature: {} in project: {}", featureId, projectId);
        
        try {
            // If config is null, use default configuration
            if (config == null) {
                config = new BDDExecutionConfig();
            }
            
            String executionId = bddTestingService.executeFeature(projectId, featureId, config);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Feature execution scheduled successfully")
                .setData(Map.of("executionId", executionId));
            
            return ResponseEntity.accepted().body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to execute feature", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to execute feature: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Generate step definitions from feature file
     * @param projectId The project ID
     * @param featureId The feature ID
     * @return Generated step definitions
     */
    @PostMapping("/features/{featureId}/generate-steps")
    public ResponseEntity<ApiResponse> generateStepDefinitions(
            @PathVariable String projectId,
            @PathVariable String featureId) {
        logger.info("Request to generate step definitions for feature: {} in project: {}", featureId, projectId);
        
        try {
            List<StepDefinition> generatedSteps = bddTestingService.generateStepDefinitions(projectId, featureId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Step definitions generated successfully")
                .setData(generatedSteps);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to generate step definitions", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to generate step definitions: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


/**
 * Test Recorder Controller
 * Handles REST endpoints for test recording functionality
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.recorder.*;
import com.cstestforge.model.testcase.TestCase;
import com.cstestforge.service.recorder.RecorderService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.validation.Valid;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/recorder")
@CrossOrigin(origins = "*", maxAge = 3600)
public class RecorderController {
    private static final Logger logger = LoggerFactory.getLogger(RecorderController.class);
    
    @Autowired
    private RecorderService recorderService;
    
    // Map to store SSE emitters for real-time recording updates
    private final Map<String, SseEmitter> recordingEmitters = new ConcurrentHashMap<>();
    
    /**
     * Start a new recording session
     * @param projectId The project ID
     * @param recordingConfig The recording configuration
     * @return Session ID for the recording
     */
    @PostMapping("/start")
    public ResponseEntity<ApiResponse> startRecording(
            @PathVariable String projectId,
            @Valid @RequestBody RecordingConfig recordingConfig) {
        logger.info("Request to start recording in project: {}", projectId);
        
        try {
            RecordingSession session = recorderService.startRecording(projectId, recordingConfig);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Recording started successfully")
                .setData(session);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to start recording", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to start recording: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Stop a recording session
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return List of recorded actions
     */
    @PostMapping("/{sessionId}/stop")
    public ResponseEntity<ApiResponse> stopRecording(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to stop recording: {} in project: {}", sessionId, projectId);
        
        try {
            RecordingResult result = recorderService.stopRecording(projectId, sessionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Recording stopped successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to stop recording", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to stop recording: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Pause a recording session
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return Status of the paused recording
     */
    @PostMapping("/{sessionId}/pause")
    public ResponseEntity<ApiResponse> pauseRecording(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to pause recording: {} in project: {}", sessionId, projectId);
        
        try {
            boolean paused = recorderService.pauseRecording(projectId, sessionId);
            
            if (paused) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Recording paused successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to pause recording");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Resume a paused recording session
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return Status of the resumed recording
     */
    @PostMapping("/{sessionId}/resume")
    public ResponseEntity<ApiResponse> resumeRecording(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to resume recording: {} in project: {}", sessionId, projectId);
        
        try {
            boolean resumed = recorderService.resumeRecording(projectId, sessionId);
            
            if (resumed) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Recording resumed successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to resume recording");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get the status of a recording session
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return Recording session status
     */
    @GetMapping("/{sessionId}/status")
    public ResponseEntity<ApiResponse> getRecordingStatus(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to get recording status: {} in project: {}", sessionId, projectId);
        
        try {
            RecordingStatus status = recorderService.getRecordingStatus(projectId, sessionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Recording status retrieved successfully")
                .setData(status);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get recorded actions for a session
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return List of recorded actions
     */
    @GetMapping("/{sessionId}/actions")
    public ResponseEntity<ApiResponse> getRecordedActions(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to get recorded actions for session: {} in project: {}", sessionId, projectId);
        
        try {
            List<RecordedAction> actions = recorderService.getRecordedActions(projectId, sessionId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Recorded actions retrieved successfully")
                .setData(actions);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Generate a test case from recorded actions
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @param testCaseConfig The test case configuration
     * @return Generated test case
     */
    @PostMapping("/{sessionId}/generate-test")
    public ResponseEntity<ApiResponse> generateTestCase(
            @PathVariable String projectId,
            @PathVariable String sessionId,
            @Valid @RequestBody TestCaseGenerationConfig testCaseConfig) {
        logger.info("Request to generate test case from recording: {} in project: {}", sessionId, projectId);
        
        try {
            TestCase testCase = recorderService.generateTestCase(projectId, sessionId, testCaseConfig);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Test case generated successfully")
                .setData(testCase);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to generate test case", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to generate test case: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Subscribe to real-time recording events
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @return SSE emitter for streaming updates
     */
    @GetMapping("/{sessionId}/events")
    public SseEmitter subscribeToRecordingEvents(
            @PathVariable String projectId,
            @PathVariable String sessionId) {
        logger.info("Request to subscribe to recording events: {} in project: {}", sessionId, projectId);
        
        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        recordingEmitters.put(sessionId, emitter);
        
        // Set completion handler to remove the emitter when the connection is closed
        emitter.onCompletion(() -> {
            logger.info("SSE connection completed for recording: {}", sessionId);
            recordingEmitters.remove(sessionId);
        });
        
        // Set timeout handler
        emitter.onTimeout(() -> {
            logger.info("SSE connection timed out for recording: {}", sessionId);
            emitter.complete();
            recordingEmitters.remove(sessionId);
        });
        
        // Set error handler
        emitter.onError(e -> {
            logger.error("SSE error for recording: {}", sessionId, e);
            recordingEmitters.remove(sessionId);
        });
        
        try {
            // Send initial connection established event
            emitter.send(SseEmitter.event()
                .name("connected")
                .data("Recording event stream established"));
            
            // Register this emitter with the recorder service for updates
            recorderService.registerRecordingListener(projectId, sessionId, event -> {
                try {
                    emitter.send(SseEmitter.event()
                        .name(event.getType())
                        .data(event.getData()));
                    
                    // If recording is complete, close the emitter
                    if (event.getType().equals("stopped") || event.getType().equals("failed")) {
                        emitter.complete();
                        recordingEmitters.remove(sessionId);
                    }
                } catch (IOException e) {
                    logger.error("Failed to send recording event", e);
                    emitter.completeWithError(e);
                    recordingEmitters.remove(sessionId);
                }
            });
        } catch (IOException e) {
            logger.error("Failed to send initial SSE event", e);
            emitter.completeWithError(e);
            recordingEmitters.remove(sessionId);
        } catch (ResourceNotFoundException e) {
            logger.error("Recording session not found: {}", sessionId, e);
            try {
                emitter.send(SseEmitter.event()
                    .name("error")
                    .data("Recording session not found: " + sessionId));
                emitter.complete();
            } catch (IOException ioException) {
                logger.error("Failed to send error SSE event", ioException);
                emitter.completeWithError(ioException);
            }
            recordingEmitters.remove(sessionId);
        }
        
        return emitter;
    }
    
    /**
     * Edit recorded actions
     * @param projectId The project ID
     * @param sessionId The recording session ID
     * @param actions The updated list of actions
     * @return Updated list of actions
     */
    @PutMapping("/{sessionId}/actions")
    public ResponseEntity<ApiResponse> updateRecordedActions(
            @PathVariable String projectId,
            @PathVariable String sessionId,
            @Valid @RequestBody List<RecordedAction> actions) {
        logger.info("Request to update recorded actions for session: {} in project: {}", sessionId, projectId);
        
        try {
            List<RecordedAction> updatedActions = recorderService.updateRecordedActions(projectId, sessionId, actions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Recorded actions updated successfully")
                .setData(updatedActions);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
}



/**
 * Integration Controller
 * Handles REST endpoints for external system integrations
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.integration.*;
import com.cstestforge.service.integration.IntegrationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/integrations")
@CrossOrigin(origins = "*", maxAge = 3600)
public class IntegrationController {
    private static final Logger logger = LoggerFactory.getLogger(IntegrationController.class);
    
    @Autowired
    private IntegrationService integrationService;
    
    /**
     * Get all integrations for a project
     * @param projectId The project ID
     * @return List of integrations
     */
    @GetMapping
    public ResponseEntity<ApiResponse> getAllIntegrations(@PathVariable String projectId) {
        logger.info("Request to get all integrations for project: {}", projectId);
        
        try {
            List<Integration> integrations = integrationService.getAllIntegrations(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integrations retrieved successfully")
                .setData(integrations);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get integration by ID
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Integration details
     */
    @GetMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> getIntegrationById(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to get integration: {} in project: {}", integrationId, projectId);
        
        try {
            Integration integration = integrationService.getIntegrationById(projectId, integrationId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration retrieved successfully")
                .setData(integration);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new integration
     * @param projectId The project ID
     * @param integration The integration to create
     * @return Created integration details
     */
    @PostMapping
    public ResponseEntity<ApiResponse> createIntegration(
            @PathVariable String projectId,
            @Valid @RequestBody Integration integration) {
        logger.info("Request to create integration in project: {}", projectId);
        
        try {
            Integration createdIntegration = integrationService.createIntegration(projectId, integration);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration created successfully")
                .setData(createdIntegration);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to create integration", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to create integration: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Update an integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param integrationDetails The updated integration details
     * @return Updated integration details
     */
    @PutMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> updateIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @Valid @RequestBody Integration integrationDetails) {
        logger.info("Request to update integration: {} in project: {}", integrationId, projectId);
        
        try {
            Integration updatedIntegration = integrationService.updateIntegration(
                    projectId, integrationId, integrationDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration updated successfully")
                .setData(updatedIntegration);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to update integration", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to update integration: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Delete an integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> deleteIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to delete integration: {} in project: {}", integrationId, projectId);
        
        try {
            boolean deleted = integrationService.deleteIntegration(projectId, integrationId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Integration deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete integration");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Test an integration connection
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Connection test result
     */
    @PostMapping("/{integrationId}/test")
    public ResponseEntity<ApiResponse> testIntegrationConnection(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to test integration connection: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationTestResult result = integrationService.testIntegrationConnection(projectId, integrationId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration connection test completed")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Integration connection test failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Integration connection test failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Sync data with integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param syncOptions Sync options
     * @return Sync result
     */
    @PostMapping("/{integrationId}/sync")
    public ResponseEntity<ApiResponse> syncWithIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody(required = false) IntegrationSyncOptions syncOptions) {
        logger.info("Request to sync with integration: {} in project: {}", integrationId, projectId);
        
        try {
            // If syncOptions is null, use default options
            if (syncOptions == null) {
                syncOptions = new IntegrationSyncOptions();
            }
            
            IntegrationSyncResult result = integrationService.syncWithIntegration(
                    projectId, integrationId, syncOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration sync completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Integration sync failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Integration sync failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get available integration types
     * @return List of available integration types
     */
    @GetMapping("/types")
    public ResponseEntity<ApiResponse> getIntegrationTypes() {
        logger.info("Request to get available integration types");
        
        List<IntegrationType> types = integrationService.getAvailableIntegrationTypes();
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("Integration types retrieved successfully")
            .setData(types);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get integration settings schema for a specific type
     * @param type The integration type
     * @return Settings schema for the integration type
     */
    @GetMapping("/types/{type}/schema")
    public ResponseEntity<ApiResponse> getIntegrationSettingsSchema(@PathVariable String type) {
        logger.info("Request to get settings schema for integration type: {}", type);
        
        try {
            IntegrationSettingsSchema schema = integrationService.getSettingsSchemaForType(type);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration settings schema retrieved successfully")
                .setData(schema);
            
            return ResponseEntity.ok(response);
        } catch (IllegalArgumentException e) {
            logger.error("Invalid integration type: {}", type, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Invalid integration type: " + type);
            
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
    }
    
    /**
     * Import test cases from integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param importOptions Import options
     * @return Import result
     */
    @PostMapping("/{integrationId}/import")
    public ResponseEntity<ApiResponse> importFromIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody IntegrationImportOptions importOptions) {
        logger.info("Request to import from integration: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationImportResult result = integrationService.importFromIntegration(
                    projectId, integrationId, importOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Import from integration completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Import from integration failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Import from integration failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Export test results to integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param exportOptions Export options
     * @return Export result
     */
    @PostMapping("/{integrationId}/export")
    public ResponseEntity<ApiResponse> exportToIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody IntegrationExportOptions exportOptions) {
        logger.info("Request to export to integration: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationExportResult result = integrationService.exportToIntegration(
                    projectId, integrationId, exportOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Export to integration completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Export to integration failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Export to integration failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


Main Application Component:
-------------------------------

import React, { useState, useEffect } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { SnackbarProvider } from 'notistack';
import { ApiProvider } from './contexts/ApiContext';
import { AuthProvider, useAuth } from './contexts/AuthContext';
import { ProjectProvider } from './contexts/ProjectContext';

// Layouts
import MainLayout from './layouts/MainLayout';
import MinimalLayout from './layouts/MinimalLayout';

// Pages
import Dashboard from './pages/Dashboard';
import Projects from './pages/Projects';
import ProjectDetails from './pages/ProjectDetails';
import TestCases from './pages/TestCases';
import TestCase from './pages/TestCase';
import TestSuites from './pages/TestSuites';
import TestSuite from './pages/TestSuite';
import ExecutionResults from './pages/ExecutionResults';
import ExecutionResult from './pages/ExecutionResult';
import TestRecorder from './pages/TestRecorder';
import ApiTesting from './pages/ApiTesting';
import ApiTestDetails from './pages/ApiTestDetails';
import DatabaseTesting from './pages/DatabaseTesting';
import DatabaseTestDetails from './pages/DatabaseTestDetails';
import BDDTesting from './pages/BDDTesting';
import BDDFeature from './pages/BDDFeature';
import Settings from './pages/Settings';
import Integrations from './pages/Integrations';
import IntegrationDetails from './pages/IntegrationDetails';
import Login from './pages/Login';
import Register from './pages/Register';
import ForgotPassword from './pages/ForgotPassword';
import ResetPassword from './pages/ResetPassword';
import NotFound from './pages/NotFound';

// Determine if the user is authenticated
const RequireAuth = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  
  if (isLoading) {
    return <div>Loading...</div>;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  
  return children;
};

const App = () => {
  const [darkMode, setDarkMode] = useState(() => {
    const savedMode = localStorage.getItem('darkMode');
    return savedMode ? JSON.parse(savedMode) : false;
  });
  
  useEffect(() => {
    localStorage.setItem('darkMode', JSON.stringify(darkMode));
  }, [darkMode]);
  
  const theme = createTheme({
    palette: {
      mode: darkMode ? 'dark' : 'light',
      primary: {
        main: '#2196f3',
      },
      secondary: {
        main: '#f50057',
      },
      background: {
        default: darkMode ? '#121212' : '#f5f5f5',
        paper: darkMode ? '#1e1e1e' : '#ffffff',
      },
    },
    typography: {
      fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
      h1: {
        fontWeight: 500,
      },
      h2: {
        fontWeight: 500,
      },
      h3: {
        fontWeight: 500,
      },
      h4: {
        fontWeight: 500,
      },
      h5: {
        fontWeight: 500,
      },
      h6: {
        fontWeight: 500,
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
          },
        },
      },
      MuiTableRow: {
        styleOverrides: {
          root: {
            '&:last-child td': {
              borderBottom: 0,
            },
          },
        },
      },
    },
  });
  
  const toggleDarkMode = () => {
    setDarkMode(!darkMode);
  };
  
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <SnackbarProvider maxSnack={3}>
        <AuthProvider>
          <ApiProvider>
            <BrowserRouter>
              <Routes>
                {/* Auth Routes */}
                <Route path="/login" element={
                  <MinimalLayout>
                    <Login />
                  </MinimalLayout>
                } />
                <Route path="/register" element={
                  <MinimalLayout>
                    <Register />
                  </MinimalLayout>
                } />
                <Route path="/forgot-password" element={
                  <MinimalLayout>
                    <ForgotPassword />
                  </MinimalLayout>
                } />
                <Route path="/reset-password" element={
                  <MinimalLayout>
                    <ResetPassword />
                  </MinimalLayout>
                } />
                
                {/* Protected Routes */}
                <Route path="/" element={
                  <RequireAuth>
                    <MainLayout darkMode={darkMode} toggleDarkMode={toggleDarkMode}>
                      <Dashboard />
                    </MainLayout>
                  </RequireAuth>
                } />
                
                <Route path="/projects" element={
                  <RequireAuth>
                    <MainLayout darkMode={darkMode} toggleDarkMode={toggleDarkMode}>
                      <Projects />
                    </MainLayout>
                  </RequireAuth>
                } />
                
                <Route path="/projects/:projectId/*" element={
                  <RequireAuth>
                    <ProjectProvider>
                      <MainLayout darkMode={darkMode} toggleDarkMode={toggleDarkMode}>
                        <Routes>
                          <Route path="/" element={<ProjectDetails />} />
                          <Route path="/test-cases" element={<TestCases />} />
                          <Route path="/test-cases/:testCaseId" element={<TestCase />} />
                          <Route path="/test-suites" element={<TestSuites />} />
                          <Route path="/test-suites/:testSuiteId" element={<TestSuite />} />
                          <Route path="/executions" element={<ExecutionResults />} />
                          <Route path="/executions/:executionId" element={<ExecutionResult />} />
                          <Route path="/recorder" element={<TestRecorder />} />
                          <Route path="/api-testing" element={<ApiTesting />} />
                          <Route path="/api-testing/:apiTestId" element={<ApiTestDetails />} />
                          <Route path="/db-testing" element={<DatabaseTesting />} />
                          <Route path="/db-testing/:dbTestId" element={<DatabaseTestDetails />} />
                          <Route path="/bdd-testing" element={<BDDTesting />} />
                          <Route path="/bdd-testing/:featureId" element={<BDDFeature />} />
                          <Route path="/settings" element={<Settings />} />
                          <Route path="/integrations" element={<Integrations />} />
                          <Route path="/integrations/:integrationId" element={<IntegrationDetails />} />
                          <Route path="*" element={<NotFound />} />
                        </Routes>
                      </MainLayout>
                    </ProjectProvider>
                  </RequireAuth>
                } />
                
                {/* 404 Page */}
                <Route path="*" element={
                  <MinimalLayout>
                    <NotFound />
                  </MinimalLayout>
                } />
              </Routes>
            </BrowserRouter>
          </ApiProvider>
        </AuthProvider>
      </SnackbarProvider>
    </ThemeProvider>
  );
};

export default App;

Main Layout Component:
-----------------------

import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { styled, useTheme } from '@mui/material/styles';
import {
  AppBar,
  Box,
  Toolbar,
  Typography,
  Drawer,
  IconButton,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Avatar,
  Menu,
  MenuItem,
  Tooltip,
  Badge,
  useMediaQuery,
  Collapse,
  ListItemButton
} from '@mui/material';
import {
  Menu as MenuIcon,
  ChevronLeft as ChevronLeftIcon,
  Dashboard as DashboardIcon,
  FolderOutlined as ProjectsIcon,
  ListAlt as TestCasesIcon,
  PlaylistAddCheck as TestSuitesIcon,
  Assessment as ResultsIcon,
  RadioButtonChecked as RecorderIcon,
  Api as ApiTestingIcon,
  Storage as DatabaseIcon,
  Code as BddTestingIcon,
  Settings as SettingsIcon,
  Link as IntegrationsIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
  ExpandLess,
  ExpandMore,
  Notifications as NotificationsIcon,
  AccountCircle,
  Logout as LogoutIcon,
  Help as HelpIcon
} from '@mui/icons-material';
import { useAuth } from '../contexts/AuthContext';
import { useProject } from '../contexts/ProjectContext';

const drawerWidth = 240;

const Main = styled('main', { shouldForwardProp: (prop) => prop !== 'open' })(
  ({ theme, open }) => ({
    flexGrow: 1,
    padding: theme.spacing(3),
    transition: theme.transitions.create('margin', {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
    marginLeft: `-${drawerWidth}px`,
    ...(open && {
      transition: theme.transitions.create('margin', {
        easing: theme.transitions.easing.easeOut,
        duration: theme.transitions.duration.enteringScreen,
      }),
      marginLeft: 0,
    }),
  }),
);

const AppBarStyled = styled(AppBar, { shouldForwardProp: (prop) => prop !== 'open' })(
  ({ theme, open }) => ({
    transition: theme.transitions.create(['margin', 'width'], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
    ...(open && {
      width: `calc(100% - ${drawerWidth}px)`,
      marginLeft: `${drawerWidth}px`,
      transition: theme.transitions.create(['margin', 'width'], {
        easing: theme.transitions.easing.easeOut,
        duration: theme.transitions.duration.enteringScreen,
      }),
    }),
  }),
);

const DrawerHeader = styled('div')(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  padding: theme.spacing(0, 1),
  ...theme.mixins.toolbar,
  justifyContent: 'flex-end',
}));

const MainLayout = ({ children, darkMode, toggleDarkMode }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const { logout, user } = useAuth();
  const { currentProject } = useProject();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  
  const [open, setOpen] = useState(!isMobile);
  const [userMenuAnchorEl, setUserMenuAnchorEl] = useState(null);
  const [notificationsAnchorEl, setNotificationsAnchorEl] = useState(null);
  const [projectSubmenuOpen, setProjectSubmenuOpen] = useState(false);
  
  const isProjectRoute = location.pathname.includes('/projects/');
  
  const handleDrawerOpen = () => {
    setOpen(true);
  };

  const handleDrawerClose = () => {
    setOpen(false);
  };

  const handleUserMenuOpen = (event) => {
    setUserMenuAnchorEl(event.currentTarget);
  };

  const handleUserMenuClose = () => {
    setUserMenuAnchorEl(null);
  };

  const handleNotificationsOpen = (event) => {
    setNotificationsAnchorEl(event.currentTarget);
  };

  const handleNotificationsClose = () => {
    setNotificationsAnchorEl(null);
  };
  
  const handleLogout = () => {
    handleUserMenuClose();
    logout();
    navigate('/login');
  };
  
  const handleNavigation = (path) => {
    navigate(path);
    if (isMobile) {
      setOpen(false);
    }
  };
  
  const toggleProjectSubmenu = () => {
    setProjectSubmenuOpen(!projectSubmenuOpen);
  };
  
  const isActive = (path) => {
    return location.pathname === path || 
      (path !== '/' && location.pathname.startsWith(path));
  };
  
  const menuItems = [
    { text: 'Dashboard', icon: <DashboardIcon />, path: '/' },
    { text: 'Projects', icon: <ProjectsIcon />, path: '/projects' },
  ];
  
  const projectMenuItems = [
    { text: 'Test Cases', icon: <TestCasesIcon />, path: `/projects/${currentProject?.id}/test-cases` },
    { text: 'Test Suites', icon: <TestSuitesIcon />, path: `/projects/${currentProject?.id}/test-suites` },
    { text: 'Execution Results', icon: <ResultsIcon />, path: `/projects/${currentProject?.id}/executions` },
    { text: 'Test Recorder', icon: <RecorderIcon />, path: `/projects/${currentProject?.id}/recorder` },
    { text: 'API Testing', icon: <ApiTestingIcon />, path: `/projects/${currentProject?.id}/api-testing` },
    { text: 'Database Testing', icon: <DatabaseIcon />, path: `/projects/${currentProject?.id}/db-testing` },
    { text: 'BDD Testing', icon: <BddTestingIcon />, path: `/projects/${currentProject?.id}/bdd-testing` },
    { text: 'Integrations', icon: <IntegrationsIcon />, path: `/projects/${currentProject?.id}/integrations` },
    { text: 'Settings', icon: <SettingsIcon />, path: `/projects/${currentProject?.id}/settings` },
  ];

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBarStyled position="fixed" open={open}>
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            onClick={handleDrawerOpen}
            edge="start"
            sx={{ mr: 2, ...(open && { display: 'none' }) }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            CSTestForge
            {currentProject && (
              <Typography variant="subtitle1" component="span" sx={{ ml: 2, opacity: 0.8 }}>
                / {currentProject.name}
              </Typography>
            )}
          </Typography>
          
          <IconButton color="inherit" onClick={toggleDarkMode}>
            {darkMode ? <LightModeIcon /> : <DarkModeIcon />}
          </IconButton>
          
          <Tooltip title="Notifications">
            <IconButton color="inherit" onClick={handleNotificationsOpen}>
              <Badge badgeContent={3} color="secondary">
                <NotificationsIcon />
              </Badge>
            </IconButton>
          </Tooltip>
          
          <IconButton
            color="inherit"
            onClick={handleUserMenuOpen}
            sx={{ ml: 1 }}
            aria-controls="user-menu"
            aria-haspopup="true"
          >
            {user?.avatar ? (
              <Avatar src={user.avatar} alt={user.name} />
            ) : (
              <AccountCircle />
            )}
          </IconButton>
        </Toolbar>
      </AppBarStyled>
      
      <Drawer
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
          },
        }}
        variant={isMobile ? "temporary" : "persistent"}
        anchor="left"
        open={open}
        onClose={handleDrawerClose}
      >
        <DrawerHeader>
          <Box sx={{ display: 'flex', alignItems: 'center', flexGrow: 1, ml: 1 }}>
            <Typography variant="h6" noWrap>
              CSTestForge
            </Typography>
          </Box>
          <IconButton onClick={handleDrawerClose}>
            <ChevronLeftIcon />
          </IconButton>
        </DrawerHeader>
        
        <Divider />
        
        <List>
          {menuItems.map((item) => (
            <ListItem 
              button 
              key={item.text}
              onClick={() => handleNavigation(item.path)}
              selected={isActive(item.path)}
            >
              <ListItemIcon>
                {item.icon}
              </ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItem>
          ))}
        </List>
        
        {isProjectRoute && currentProject && (
          <>
            <Divider />
            <ListItemButton onClick={toggleProjectSubmenu}>
              <ListItemIcon>
                <ProjectsIcon />
              </ListItemIcon>
              <ListItemText primary={currentProject.name} />
              {projectSubmenuOpen ? <ExpandLess /> : <ExpandMore />}
            </ListItemButton>
            <Collapse in={projectSubmenuOpen} timeout="auto" unmountOnExit>
              <List component="div" disablePadding>
                {projectMenuItems.map((item) => (
                  <ListItem 
                    button 
                    key={item.text}
                    onClick={() => handleNavigation(item.path)}
                    selected={isActive(item.path)}
                    sx={{ pl: 4 }}
                  >
                    <ListItemIcon>
                      {item.icon}
                    </ListItemIcon>
                    <ListItemText primary={item.text} />
                  </ListItem>
                ))}
              </List>
            </Collapse>
          </>
        )}
        
        <Box sx={{ flexGrow: 1 }} />
        
        <List>
          <ListItem button onClick={() => window.open('https://docs.cstestforge.com', '_blank')}>
            <ListItemIcon>
              <HelpIcon />
            </ListItemIcon>
            <ListItemText primary="Help & Documentation" />
          </ListItem>
        </List>
      </Drawer>
      
      <Main open={open}>
        <DrawerHeader />
        {children}
      </Main>
      
      {/* User Menu */}
      <Menu
        id="user-menu"
        anchorEl={userMenuAnchorEl}
        keepMounted
        open={Boolean(userMenuAnchorEl)}
        onClose={handleUserMenuClose}
      >
        <MenuItem onClick={() => { handleUserMenuClose(); navigate('/profile'); }}>
          Profile
        </MenuItem>
        <MenuItem onClick={() => { handleUserMenuClose(); navigate('/settings'); }}>
          Settings
        </MenuItem>
        <Divider />
        <MenuItem onClick={handleLogout}>
          <ListItemIcon>
            <LogoutIcon fontSize="small" />
          </ListItemIcon>
          Logout
        </MenuItem>
      </Menu>
      
      {/* Notifications Menu */}
      <Menu
        id="notifications-menu"
        anchorEl={notificationsAnchorEl}
        keepMounted
        open={Boolean(notificationsAnchorEl)}
        onClose={handleNotificationsClose}
      >
        <MenuItem onClick={handleNotificationsClose}>
          <Typography variant="body2">Test execution completed: Login Test</Typography>
        </MenuItem>
        <MenuItem onClick={handleNotificationsClose}>
          <Typography variant="body2">New integration available: Azure DevOps</Typography>
        </MenuItem>
        <MenuItem onClick={handleNotificationsClose}>
          <Typography variant="body2">Self-healing repaired 3 selectors</Typography>
        </MenuItem>
        <Divider />
        <MenuItem onClick={() => { handleNotificationsClose(); navigate('/notifications'); }}>
          <Typography variant="body2">View all notifications</Typography>
        </MenuItem>
      </Menu>
    </Box>
  );
};

export default MainLayout;

Minimal Layout:
-------------------

import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { Box, Container, Typography, Link, Paper } from '@mui/material';

const MinimalLayout = ({ children }) => {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        minHeight: '100vh',
        backgroundColor: (theme) => theme.palette.background.default
      }}
    >
      <Container component="main" maxWidth="sm" sx={{ mb: 4, pt: 8 }}>
        <Paper
          elevation={3}
          sx={{
            p: 4,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            borderRadius: 2
          }}
        >
          <Typography
            component={RouterLink}
            to="/"
            variant="h4"
            color="primary"
            sx={{ 
              textDecoration: 'none',
              mb: 3,
              fontWeight: 700
            }}
          >
            CSTestForge
          </Typography>
          
          {children}
        </Paper>
      </Container>
      
      <Box
        component="footer"
        sx={{
          py: 3,
          px: 2,
          mt: 'auto',
          backgroundColor: (theme) =>
            theme.palette.mode === 'light' ? theme.palette.grey[200] : theme.palette.grey[800],
        }}
      >
        <Container maxWidth="sm">
          <Typography variant="body2" color="text.secondary" align="center">
            {'© '}
            {new Date().getFullYear()}
            {' '}
            <Link color="inherit" component={RouterLink} to="/">
              CSTestForge
            </Link>
            {' - All rights reserved.'}
          </Typography>
          <Typography variant="body2" color="text.secondary" align="center" sx={{ mt: 1 }}>
            <Link color="inherit" component={RouterLink} to="/privacy-policy" sx={{ mx: 1 }}>
              Privacy Policy
            </Link>
            <Link color="inherit" component={RouterLink} to="/terms-of-service" sx={{ mx: 1 }}>
              Terms of Service
            </Link>
            <Link color="inherit" component={RouterLink} to="/contact" sx={{ mx: 1 }}>
              Contact
            </Link>
          </Typography>
        </Container>
      </Box>
    </Box>
  );
};

export default MinimalLayout;


API Context
--------------

import React, { createContext, useContext, useState, useCallback } from 'react';
import axios from 'axios';
import { useAuth } from './AuthContext';
import { useSnackbar } from 'notistack';

// Create API context
const ApiContext = createContext();

// API base URL from environment variable or default to localhost
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080/api/v1';

// API provider component
export const ApiProvider = ({ children }) => {
  const { token, logout } = useAuth();
  const { enqueueSnackbar } = useSnackbar();
  const [loading, setLoading] = useState({});

  // Create axios instance with authentication token
  const api = axios.create({
    baseURL: API_BASE_URL,
    headers: {
      'Content-Type': 'application/json',
    },
  });

  // Add request interceptor to include auth token
  api.interceptors.request.use(
    (config) => {
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    },
    (error) => Promise.reject(error)
  );

  // Add response interceptor to handle errors
  api.interceptors.response.use(
    (response) => response,
    (error) => {
      // Handle 401 Unauthorized by logging the user out
      if (error.response && error.response.status === 401) {
        enqueueSnackbar('Your session has expired. Please log in again.', { variant: 'error' });
        logout();
      }
      
      // Handle 403 Forbidden
      if (error.response && error.response.status === 403) {
        enqueueSnackbar('You do not have permission to perform this action.', { variant: 'error' });
      }
      
      // Handle 404 Not Found
      if (error.response && error.response.status === 404) {
        enqueueSnackbar('The requested resource was not found.', { variant: 'error' });
      }
      
      // Handle 500 Internal Server Error
      if (error.response && error.response.status === 500) {
        enqueueSnackbar('An error occurred on the server. Please try again later.', { variant: 'error' });
      }
      
      // Handle network errors
      if (error.message === 'Network Error') {
        enqueueSnackbar('Unable to connect to the server. Please check your internet connection.', { variant: 'error' });
      }
      
      return Promise.reject(error);
    }
  );

  // Generic request method with loading state
  const request = useCallback(async (method, url, data = null, options = {}) => {
    const requestId = `${method}-${url}-${Date.now()}`;
    
    try {
      setLoading((prev) => ({ ...prev, [requestId]: true }));
      
      const response = await api({
        method,
        url,
        data,
        ...options,
      });
      
      // Check for success flag in our API response format
      if (response.data && response.data.success === false) {
        enqueueSnackbar(response.data.message || 'Operation failed', { variant: 'error' });
        return Promise.reject(new Error(response.data.message));
      }
      
      return response.data;
    } catch (error) {
      // Error handling is done in the interceptor, but we can add custom handling here
      if (options.showError !== false && error.response && error.response.data) {
        const errorMessage = error.response.data.message || error.message || 'An error occurred';
        enqueueSnackbar(errorMessage, { variant: 'error' });
      }
      throw error;
    } finally {
      setLoading((prev) => {
        const newState = { ...prev };
        delete newState[requestId];
        return newState;
      });
    }
  }, [api, enqueueSnackbar, logout]);

  // Convenience methods for different HTTP verbs
  const get = useCallback((url, options = {}) => request('get', url, null, options), [request]);
  const post = useCallback((url, data, options = {}) => request('post', url, data, options), [request]);
  const put = useCallback((url, data, options = {}) => request('put', url, data, options), [request]);
  const del = useCallback((url, options = {}) => request('delete', url, null, options), [request]);

  // Check if any request is loading
  const isLoading = Object.keys(loading).length > 0;

  // Export the API context value
  const contextValue = {
    api,
    get,
    post,
    put,
    delete: del,
    isLoading,
    loading,
  };

  return <ApiContext.Provider value={contextValue}>{children}</ApiContext.Provider>;
};

// Custom hook to use the API context
export const useApi = () => {
  const context = useContext(ApiContext);
  if (!context) {
    throw new Error('useApi must be used within an ApiProvider');
  }
  return context;
};


Auth Context:
-----------------


import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import { useSnackbar } from 'notistack';

// Create Auth context
const AuthContext = createContext();

// API base URL from environment variable or default to localhost
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080/api/v1';

// Auth provider component
export const AuthProvider = ({ children }) => {
  const { enqueueSnackbar } = useSnackbar();
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('token'));
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  // Initialize auth state from local storage
  useEffect(() => {
    const initAuth = async () => {
      const storedToken = localStorage.getItem('token');
      
      if (storedToken) {
        try {
          // Validate the token by getting user profile
          const response = await axios.get(`${API_BASE_URL}/auth/profile`, {
            headers: {
              Authorization: `Bearer ${storedToken}`,
            },
          });
          
          setUser(response.data.data);
          setToken(storedToken);
          setIsAuthenticated(true);
        } catch (error) {
          console.error('Token validation error:', error);
          localStorage.removeItem('token');
          setToken(null);
          setIsAuthenticated(false);
        }
      }
      
      setIsLoading(false);
    };
    
    initAuth();
  }, []);

  // Login function
  const login = async (email, password) => {
    try {
      setIsLoading(true);
      
      const response = await axios.post(`${API_BASE_URL}/auth/login`, {
        email,
        password,
      });
      
      const { token, user } = response.data.data;
      
      localStorage.setItem('token', token);
      setToken(token);
      setUser(user);
      setIsAuthenticated(true);
      
      enqueueSnackbar('Login successful!', { variant: 'success' });
      
      return user;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Login failed';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Register function
  const register = async (userData) => {
    try {
      setIsLoading(true);
      
      const response = await axios.post(`${API_BASE_URL}/auth/register`, userData);
      
      enqueueSnackbar('Registration successful! Please log in.', { variant: 'success' });
      
      return response.data.data;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Registration failed';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Logout function
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
    setUser(null);
    setIsAuthenticated(false);
  };

  // Update user profile
  const updateProfile = async (userData) => {
    try {
      setIsLoading(true);
      
      const response = await axios.put(`${API_BASE_URL}/auth/profile`, userData, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      
      setUser(response.data.data);
      
      enqueueSnackbar('Profile updated successfully!', { variant: 'success' });
      
      return response.data.data;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Failed to update profile';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Change password
  const changePassword = async (currentPassword, newPassword) => {
    try {
      setIsLoading(true);
      
      await axios.put(
        `${API_BASE_URL}/auth/change-password`,
        {
          currentPassword,
          newPassword,
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );
      
      enqueueSnackbar('Password changed successfully!', { variant: 'success' });
      
      return true;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Failed to change password';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Request password reset
  const requestPasswordReset = async (email) => {
    try {
      setIsLoading(true);
      
      await axios.post(`${API_BASE_URL}/auth/request-reset`, { email });
      
      enqueueSnackbar('Password reset link sent to your email!', { variant: 'success' });
      
      return true;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Failed to request password reset';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Reset password
  const resetPassword = async (token, newPassword) => {
    try {
      setIsLoading(true);
      
      await axios.post(`${API_BASE_URL}/auth/reset-password`, {
        token,
        newPassword,
      });
      
      enqueueSnackbar('Password reset successful! Please log in.', { variant: 'success' });
      
      return true;
    } catch (error) {
      const errorMessage = error.response?.data?.message || 'Failed to reset password';
      enqueueSnackbar(errorMessage, { variant: 'error' });
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Export the auth context value
  const contextValue = {
    user,
    token,
    isAuthenticated,
    isLoading,
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    requestPasswordReset,
    resetPassword,
  };

  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;
};

// Custom hook to use the auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


Project Context:
--------------------

import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useParams } from 'react-router-dom';
import { useApi } from './ApiContext';
import { useSnackbar } from 'notistack';

// Create Project context
const ProjectContext = createContext();

// Project provider component
export const ProjectProvider = ({ children }) => {
  const { projectId } = useParams();
  const { get, post, put, delete: del } = useApi();
  const { enqueueSnackbar } = useSnackbar();
  
  const [currentProject, setCurrentProject] = useState(null);
  const [testCases, setTestCases] = useState([]);
  const [testSuites, setTestSuites] = useState([]);
  const [executionResults, setExecutionResults] = useState([]);
  const [projectSettings, setProjectSettings] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch current project data
  const fetchProject = useCallback(async () => {
    if (!projectId) return;
    
    try {
      setIsLoading(true);
      const response = await get(`/projects/${projectId}`);
      setCurrentProject(response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching project:', error);
    } finally {
      setIsLoading(false);
    }
  }, [projectId, get]);

  // Fetch test cases for the current project
  const fetchTestCases = useCallback(async () => {
    if (!projectId) return;
    
    try {
      const response = await get(`/projects/${projectId}/testcases`);
      setTestCases(response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching test cases:', error);
    }
  }, [projectId, get]);

  // Fetch test suites for the current project
  const fetchTestSuites = useCallback(async () => {
    if (!projectId) return;
    
    try {
      const response = await get(`/projects/${projectId}/testsuites`);
      setTestSuites(response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching test suites:', error);
    }
  }, [projectId, get]);

  // Fetch execution results for the current project
  const fetchExecutionResults = useCallback(async (limit = 10) => {
    if (!projectId) return;
    
    try {
      const response = await get(`/execution/project/${projectId}?limit=${limit}`);
      setExecutionResults(response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching execution results:', error);
    }
  }, [projectId, get]);

  // Fetch project settings
  const fetchProjectSettings = useCallback(async () => {
    if (!projectId) return;
    
    try {
      const response = await get(`/projects/${projectId}/config`);
      setProjectSettings(response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching project settings:', error);
    }
  }, [projectId, get]);

  // Update project settings
  const updateProjectSettings = useCallback(async (settings) => {
    if (!projectId) return;
    
    try {
      const response = await put(`/projects/${projectId}/config`, settings);
      setProjectSettings(response.data);
      enqueueSnackbar('Project settings updated successfully', { variant: 'success' });
      return response.data;
    } catch (error) {
      console.error('Error updating project settings:', error);
      enqueueSnackbar('Failed to update project settings', { variant: 'error' });
    }
  }, [projectId, put, enqueueSnackbar]);

  // Create a new test case
  const createTestCase = useCallback(async (testCase) => {
    if (!projectId) return;
    
    try {
      const response = await post(`/projects/${projectId}/testcases`, testCase);
      setTestCases(prevTestCases => [...prevTestCases, response.data]);
      enqueueSnackbar('Test case created successfully', { variant: 'success' });
      return response.data;
    } catch (error) {
      console.error('Error creating test case:', error);
      enqueueSnackbar('Failed to create test case', { variant: 'error' });
    }
  }, [projectId, post, enqueueSnackbar]);

  // Update a test case
  const updateTestCase = useCallback(async (testCaseId, testCase) => {
    if (!projectId) return;
    
    try {
      const response = await put(`/projects/${projectId}/testcases/${testCaseId}`, testCase);
      setTestCases(prevTestCases => 
        prevTestCases.map(tc => tc.id === testCaseId ? response.data : tc)
      );
      enqueueSnackbar('Test case updated successfully', { variant: 'success' });
      return response.data;
    } catch (error) {
      console.error('Error updating test case:', error);
      enqueueSnackbar('Failed to update test case', { variant: 'error' });
    }
  }, [projectId, put, enqueueSnackbar]);

  // Delete a test case
  const deleteTestCase = useCallback(async (testCaseId) => {
    if (!projectId) return;
    
    try {
      await del(`/projects/${projectId}/testcases/${testCaseId}`);
      setTestCases(prevTestCases => prevTestCases.filter(tc => tc.id !== testCaseId));
      enqueueSnackbar('Test case deleted successfully', { variant: 'success' });
      return true;
    } catch (error) {
      console.error('Error deleting test case:', error);
      enqueueSnackbar('Failed to delete test case', { variant: 'error' });
      return false;
    }
  }, [projectId, del, enqueueSnackbar]);

  // Create a new test suite
  const createTestSuite = useCallback(async (testSuite) => {
    if (!projectId) return;
    
    try {
      const response = await post(`/projects/${projectId}/testsuites`, testSuite);
      setTestSuites(prevTestSuites => [...prevTestSuites, response.data]);
      enqueueSnackbar('Test suite created successfully', { variant: 'success' });
      return response.data;
    } catch (error) {
      console.error('Error creating test suite:', error);
      enqueueSnackbar('Failed to create test suite', { variant: 'error' });
    }
  }, [projectId, post, enqueueSnackbar]);

  // Update a test suite
  const updateTestSuite = useCallback(async (testSuiteId, testSuite) => {
    if (!projectId) return;
    
    try {
      const response = await put(`/projects/${projectId}/testsuites/${testSuiteId}`, testSuite);
      setTestSuites(prevTestSuites => 
        prevTestSuites.map(ts => ts.id === testSuiteId ? response.data : ts)
      );
      enqueueSnackbar('Test suite updated successfully', { variant: 'success' });
      return response.data;
    } catch (error) {
      console.error('Error updating test suite:', error);
      enqueueSnackbar('Failed to update test suite', { variant: 'error' });
    }
  }, [projectId, put, enqueueSnackbar]);

  // Delete a test suite
  const deleteTestSuite = useCallback(async (testSuiteId) => {
    if (!projectId) return;
    
    try {
      await del(`/projects/${projectId}/testsuites/${testSuiteId}`);
      setTestSuites(prevTestSuites => prevTestSuites.filter(ts => ts.id !== testSuiteId));
      enqueueSnackbar('Test suite deleted successfully', { variant: 'success' });
      return true;
    } catch (error) {
      console.error('Error deleting test suite:', error);
      enqueueSnackbar('Failed to delete test suite', { variant: 'error' });
      return false;
    }
  }, [projectId, del, enqueueSnackbar]);

  // Execute a test case
  const executeTestCase = useCallback(async (testCaseIds, config = {}) => {
    if (!projectId) return;
    
    try {
      const response = await post('/execution/testcase', {
        projectId,
        testCaseIds: Array.isArray(testCaseIds) ? testCaseIds : [testCaseIds],
        config
      });
      enqueueSnackbar('Test execution started', { variant: 'success' });
      return response.data.executionId;
    } catch (error) {
      console.error('Error executing test case:', error);
      enqueueSnackbar('Failed to start test execution', { variant: 'error' });
    }
  }, [projectId, post, enqueueSnackbar]);

  // Execute a test suite
  const executeTestSuite = useCallback(async (testSuiteIds, config = {}) => {
    if (!projectId) return;
    
    try {
      const response = await post('/execution/testsuite', {
        projectId,
        testSuiteIds: Array.isArray(testSuiteIds) ? testSuiteIds : [testSuiteIds],
        config
      });
      enqueueSnackbar('Test suite execution started', { variant: 'success' });
      return response.data.executionId;
    } catch (error) {
      console.error('Error executing test suite:', error);
      enqueueSnackbar('Failed to start test suite execution', { variant: 'error' });
    }
  }, [projectId, post, enqueueSnackbar]);

  // Load initial project data
  useEffect(() => {
    if (projectId) {
      fetchProject();
    }
  }, [projectId, fetchProject]);

  // Export the project context value
  const contextValue = {
    currentProject,
    testCases,
    testSuites,
    executionResults,
    projectSettings,
    isLoading,
    fetchProject,
    fetchTestCases,
    fetchTestSuites,
    fetchExecutionResults,
    fetchProjectSettings,
    updateProjectSettings,
    createTestCase,
    updateTestCase,
    deleteTestCase,
    createTestSuite,
    updateTestSuite,
    deleteTestSuite,
    executeTestCase,
    executeTestSuite,
  };

  return <ProjectContext.Provider value={contextValue}>{children}</ProjectContext.Provider>;
};

// Custom hook to use the project context
export const useProject = () => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};


Dashboard:
----------------

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Grid,
  Paper,
  Card,
  CardContent,
  CardActions,
  Button,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Avatar,
  Chip,
  LinearProgress,
  useTheme
} from '@mui/material';
import {
  CheckCircle as SuccessIcon,
  Error as FailureIcon,
  Schedule as PendingIcon,
  Folder as ProjectIcon,
  List as TestCaseIcon,
  PlaylistAddCheck as TestSuiteIcon,
  Assessment as ReportIcon,
  Lightbulb as TipIcon
} from '@mui/icons-material';
import { useApi } from '../contexts/ApiContext';
import { useAuth } from '../contexts/AuthContext';

// Dashboard statistics card component
const StatCard = ({ title, value, icon, color, onClick }) => {
  const theme = useTheme();
  
  return (
    <Card 
      sx={{ 
        height: '100%', 
        cursor: onClick ? 'pointer' : 'default',
        transition: 'transform 0.2s',
        '&:hover': onClick ? { transform: 'translateY(-4px)', boxShadow: 4 } : {}
      }}
      onClick={onClick}
    >
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Avatar sx={{ bgcolor: color, mr: 2 }}>
            {icon}
          </Avatar>
          <Typography variant="h6" component="div">
            {title}
          </Typography>
        </Box>
        <Typography variant="h3" component="div" align="center" sx={{ my: 2, color }}>
          {value}
        </Typography>
      </CardContent>
    </Card>
  );
};

// Recent execution item component
const ExecutionItem = ({ execution, onClick }) => {
  let statusIcon;
  let statusColor;
  
  switch (execution.status) {
    case 'SUCCESS':
      statusIcon = <SuccessIcon sx={{ color: 'success.main' }} />;
      statusColor = 'success';
      break;
    case 'FAILED':
      statusIcon = <FailureIcon sx={{ color: 'error.main' }} />;
      statusColor = 'error';
      break;
    default:
      statusIcon = <PendingIcon sx={{ color: 'warning.main' }} />;
      statusColor = 'warning';
  }
  
  return (
    <ListItem 
      button 
      onClick={onClick}
      sx={{ 
        borderLeft: 3, 
        borderColor: `${statusColor}.main`, 
        mb: 1, 
        borderRadius: 1,
        '&:hover': { backgroundColor: 'action.hover' }
      }}
    >
      <ListItemAvatar>
        {statusIcon}
      </ListItemAvatar>
      <ListItemText
        primary={execution.name}
        secondary={
          <React.Fragment>
            <Typography component="span" variant="body2" color="text.primary">
              {execution.type === 'TEST_CASE' ? 'Test Case' : 'Test Suite'}
            </Typography>
            {` - ${new Date(execution.timestamp).toLocaleString()}`}
          </React.Fragment>
        }
      />
      <Chip 
        label={`${execution.passRate}%`} 
        color={statusColor} 
        size="small" 
        variant="outlined"
      />
    </ListItem>
  );
};

// Recent project card component
const ProjectCard = ({ project, onClick }) => {
  return (
    <Card sx={{ height: '100%' }}>
      <CardContent>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Avatar sx={{ bgcolor: 'primary.main', mr: 2 }}>
            <ProjectIcon />
          </Avatar>
          <Typography variant="h6" component="div" noWrap>
            {project.name}
          </Typography>
        </Box>
        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
          {project.description || 'No description'}
        </Typography>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
          <Typography variant="body2" color="text.secondary">
            Test Cases:
          </Typography>
          <Typography variant="body2" fontWeight="bold">
            {project.testCaseCount || 0}
          </Typography>
        </Box>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
          <Typography variant="body2" color="text.secondary">
            Test Suites:
          </Typography>
          <Typography variant="body2" fontWeight="bold">
            {project.testSuiteCount || 0}
          </Typography>
        </Box>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
          <Typography variant="body2" color="text.secondary">
            Success Rate:
          </Typography>
          <Typography variant="body2" fontWeight="bold">
            {project.successRate || 0}%
          </Typography>
        </Box>
        <LinearProgress 
          variant="determinate" 
          value={project.successRate || 0} 
          sx={{ mb: 1, height: 8, borderRadius: 1 }}
        />
      </CardContent>
      <CardActions>
        <Button size="small" color="primary" onClick={onClick}>
          Open Project
        </Button>
      </CardActions>
    </Card>
  );
};

// Dashboard page component
const Dashboard = () => {
  const navigate = useNavigate();
  const { get } = useApi();
  const { user } = useAuth();
  const theme = useTheme();
  
  const [isLoading, setIsLoading] = useState(true);
  const [dashboardData, setDashboardData] = useState({
    stats: {
      projectCount: 0,
      testCaseCount: 0,
      testSuiteCount: 0,
      executionCount: 0,
      successRate: 0
    },
    recentExecutions: [],
    recentProjects: [],
    tips: []
  });
  
  // Fetch dashboard data
  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setIsLoading(true);
        const response = await get('/dashboard');
        setDashboardData(response.data || {});
      } catch (error) {
        console.error('Error fetching dashboard data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchDashboardData();
  }, [get]);
  
  // Navigation handlers
  const handleNavigateToProjects = () => navigate('/projects');
  const handleNavigateToTestCases = () => navigate('/projects');
  const handleNavigateToTestSuites = () => navigate('/projects');
  const handleNavigateToReports = () => navigate('/reports');
  const handleNavigateToExecution = (executionId) => navigate(`/execution/${executionId}`);
  const handleNavigateToProject = (projectId) => navigate(`/projects/${projectId}`);
  
  return (
    <Box>
      <Typography variant="h4" component="h1" gutterBottom>
        Dashboard
      </Typography>
      <Typography variant="subtitle1" color="textSecondary" gutterBottom>
        Welcome back, {user?.name || 'User'}! Here's your testing overview.
      </Typography>
      
      {isLoading ? (
        <LinearProgress sx={{ my: 4 }} />
      ) : (
        <Box sx={{ mt: 4 }}>
          {/* Statistics Cards */}
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} sm={6} md={3}>
              <StatCard
                title="Projects"
                value={dashboardData.stats.projectCount}
                icon={<ProjectIcon />}
                color={theme.palette.primary.main}
                onClick={handleNavigateToProjects}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <StatCard
                title="Test Cases"
                value={dashboardData.stats.testCaseCount}
                icon={<TestCaseIcon />}
                color={theme.palette.secondary.main}
                onClick={handleNavigateToTestCases}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <StatCard
                title="Test Suites"
                value={dashboardData.stats.testSuiteCount}
                icon={<TestSuiteIcon />}
                color={theme.palette.success.main}
                onClick={handleNavigateToTestSuites}
              />
            </Grid>
            <Grid item xs={12} sm={6} md={3}>
              <StatCard
                title="Success Rate"
                value={`${dashboardData.stats.successRate}%`}
                icon={<ReportIcon />}
                color={theme.palette.warning.main}
                onClick={handleNavigateToReports}
              />
            </Grid>
          </Grid>
          
          <Grid container spacing={3}>
            {/* Recent Projects */}
            <Grid item xs={12} md={6}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" component="h2" gutterBottom>
                  Recent Projects
                </Typography>
                <Divider sx={{ mb: 2 }} />
                
                {dashboardData.recentProjects.length === 0 ? (
                  <Box sx={{ textAlign: 'center', py: 4 }}>
                    <Typography variant="body1" color="textSecondary">
                      No projects found. Create your first project to get started.
                    </Typography>
                    <Button 
                      variant="contained" 
                      color="primary" 
                      sx={{ mt: 2 }}
                      onClick={handleNavigateToProjects}
                    >
                      Create Project
                    </Button>
                  </Box>
                ) : (
                  <Grid container spacing={2}>
                    {dashboardData.recentProjects.map((project) => (
                      <Grid item xs={12} sm={6} key={project.id}>
                        <ProjectCard 
                          project={project} 
                          onClick={() => handleNavigateToProject(project.id)}
                        />
                      </Grid>
                    ))}
                    
                    <Grid item xs={12} sx={{ textAlign: 'center', mt: 2 }}>
                      <Button 
                        color="primary" 
                        onClick={handleNavigateToProjects}
                      >
                        View All Projects
                      </Button>
                    </Grid>
                  </Grid>
                )}
              </Paper>
            </Grid>
            
            {/* Recent Executions */}
            <Grid item xs={12} md={6}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" component="h2" gutterBottom>
                  Recent Executions
                </Typography>
                <Divider sx={{ mb: 2 }} />
                
                {dashboardData.recentExecutions.length === 0 ? (
                  <Box sx={{ textAlign: 'center', py: 4 }}>
                    <Typography variant="body1" color="textSecondary">
                      No test executions found. Execute a test to see results here.
                    </Typography>
                  </Box>
                ) : (
                  <List sx={{ width: '100%' }}>
                    {dashboardData.recentExecutions.map((execution) => (
                      <ExecutionItem 
                        key={execution.id} 
                        execution={execution} 
                        onClick={() => handleNavigateToExecution(execution.id)}
                      />
                    ))}
                    
                    <Box sx={{ textAlign: 'center', mt: 2 }}>
                      <Button 
                        color="primary" 
                        onClick={() => navigate('/executions')}
                      >
                        View All Executions
                      </Button>
                    </Box>
                  </List>
                )}
              </Paper>
            </Grid>
            
            {/* Tips & Recommendations */}
            <Grid item xs={12}>
              <Paper sx={{ p: 2 }}>
                <Typography variant="h6" component="h2" gutterBottom>
                  Tips & Recommendations
                </Typography>
                <Divider sx={{ mb: 2 }} />
                
                <List>
                  {dashboardData.tips.map((tip, index) => (
                    <ListItem key={index}>
                      <ListItemAvatar>
                        <Avatar sx={{ bgcolor: 'info.main' }}>
                          <TipIcon />
                        </Avatar>
                      </ListItemAvatar>
                      <ListItemText
                        primary={tip.title}
                        secondary={tip.description}
                      />
                      {tip.actionPath && (
                        <Button 
                          variant="outlined" 
                          size="small"
                          onClick={() => navigate(tip.actionPath)}
                        >
                          {tip.actionLabel || 'View'}
                        </Button>
                      )}
                    </ListItem>
                  ))}
                  
                  {dashboardData.tips.length === 0 && (
                    <ListItem>
                      <ListItemAvatar>
                        <Avatar sx={{ bgcolor: 'info.main' }}>
                          <TipIcon />
                        </Avatar>
                      </ListItemAvatar>
                      <ListItemText
                        primary="Get Started with CSTestForge"
                        secondary="Create your first project and test case to start automating your testing workflow."
                      />
                      <Button 
                        variant="outlined" 
                        size="small"
                        onClick={handleNavigateToProjects}
                      >
                        Create Project
                      </Button>
                    </ListItem>
                  )}
                </List>
              </Paper>
            </Grid>
          </Grid>
        </Box>
      )}
    </Box>
  );
};

export default Dashboard;


// src/pages/TestCases.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Chip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Menu,
  MenuItem,
  Tooltip,
  InputAdornment,
  CircularProgress,
  Breadcrumbs,
  Link
} from '@mui/material';
import {
  Add as AddIcon,
  Search as SearchIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  PlayArrow as RunIcon,
  ContentCopy as DuplicateIcon,
  FilterList as FilterIcon,
  Refresh as RefreshIcon,
  MoreVert as MoreVertIcon
} from '@mui/icons-material';
import { useProject } from '../contexts/ProjectContext';
import { useSnackbar } from 'notistack';

const TestCases = () => {
  const navigate = useNavigate();
  const { enqueueSnackbar } = useSnackbar();
  const { 
    currentProject, 
    testCases,
    fetchTestCases,
    executeTestCase,
    deleteTestCase
  } = useProject();

  // Local state
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [selectedTestCase, setSelectedTestCase] = useState(null);
  const [actionMenuAnchorEl, setActionMenuAnchorEl] = useState(null);
  const [filteredTestCases, setFilteredTestCases] = useState([]);
  
  // Fetch test cases
  useEffect(() => {
    const loadTestCases = async () => {
      setLoading(true);
      try {
        await fetchTestCases();
      } catch (error) {
        console.error('Error loading test cases:', error);
        enqueueSnackbar('Failed to load test cases', { variant: 'error' });
      } finally {
        setLoading(false);
      }
    };
    
    loadTestCases();
  }, [fetchTestCases, enqueueSnackbar]);
  
  // Filter test cases based on search term
  useEffect(() => {
    if (!testCases) {
      setFilteredTestCases([]);
      return;
    }
    
    if (!searchTerm.trim()) {
      setFilteredTestCases(testCases);
      return;
    }
    
    const filtered = testCases.filter(testCase => 
      testCase.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      testCase.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      testCase.tags?.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    
    setFilteredTestCases(filtered);
  }, [testCases, searchTerm]);
  
  // Handle pagination
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  
  // Handle action menu
  const handleActionMenuOpen = (event, testCase) => {
    setActionMenuAnchorEl(event.currentTarget);
    setSelectedTestCase(testCase);
  };
  
  const handleActionMenuClose = () => {
    setActionMenuAnchorEl(null);
  };
  
  // Handle test case actions
  const handleCreateTestCase = () => {
    navigate(`/projects/${currentProject.id}/test-cases/create`);
  };
  
  const handleEditTestCase = (testCaseId) => {
    navigate(`/projects/${currentProject.id}/test-cases/${testCaseId}`);
    handleActionMenuClose();
  };
  
  const handleRunTestCase = async (testCaseId) => {
    try {
      const executionId = await executeTestCase(testCaseId);
      if (executionId) {
        enqueueSnackbar('Test execution started successfully', { variant: 'success' });
        navigate(`/projects/${currentProject.id}/executions/${executionId}`);
      }
    } catch (error) {
      console.error('Error executing test case:', error);
      enqueueSnackbar('Failed to execute test case', { variant: 'error' });
    }
    handleActionMenuClose();
  };
  
  const handleDuplicateTestCase = (testCaseId) => {
    // This would typically be implemented by the backend
    enqueueSnackbar('Duplication feature is coming soon', { variant: 'info' });
    handleActionMenuClose();
  };
  
  const handleDeleteClick = (testCaseId) => {
    const testCase = testCases.find(tc => tc.id === testCaseId);
    setSelectedTestCase(testCase);
    setDeleteDialogOpen(true);
    handleActionMenuClose();
  };
  
  const handleConfirmDelete = async () => {
    if (!selectedTestCase) return;
    
    try {
      const success = await deleteTestCase(selectedTestCase.id);
      if (success) {
        enqueueSnackbar('Test case deleted successfully', { variant: 'success' });
      }
    } catch (error) {
      console.error('Error deleting test case:', error);
      enqueueSnackbar('Failed to delete test case', { variant: 'error' });
    } finally {
      setDeleteDialogOpen(false);
      setSelectedTestCase(null);
    }
  };
  
  const handleRefresh = async () => {
    setLoading(true);
    try {
      await fetchTestCases();
      enqueueSnackbar('Test cases refreshed', { variant: 'success' });
    } catch (error) {
      console.error('Error refreshing test cases:', error);
      enqueueSnackbar('Failed to refresh test cases', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };
  
  // Status chip component
  const StatusChip = ({ status }) => {
    let color = 'default';
    let label = status || 'Unknown';
    
    switch (status?.toUpperCase()) {
      case 'ACTIVE':
        color = 'success';
        break;
      case 'DRAFT':
        color = 'warning';
        break;
      case 'DEPRECATED':
        color = 'error';
        break;
      case 'MAINTENANCE':
        color = 'info';
        break;
      default:
        color = 'default';
    }
    
    return <Chip size="small" label={label} color={color} />;
  };
  
  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <Link underline="hover" color="inherit" href="/">
          Dashboard
        </Link>
        <Link
          underline="hover"
          color="inherit"
          href={`/projects/${currentProject?.id}`}
        >
          {currentProject?.name}
        </Link>
        <Typography color="text.primary">Test Cases</Typography>
      </Breadcrumbs>
      
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          Test Cases
        </Typography>
        <Box>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<AddIcon />}
            onClick={handleCreateTestCase}
            sx={{ ml: 1 }}
          >
            Create Test Case
          </Button>
        </Box>
      </Box>
      
      {/* Action bar */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <TextField
            placeholder="Search test cases..."
            variant="outlined"
            size="small"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ width: 300 }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
          
          <Box>
            <Tooltip title="Filter">
              <IconButton>
                <FilterIcon />
              </IconButton>
            </Tooltip>
            <Tooltip title="Refresh">
              <IconButton onClick={handleRefresh} disabled={loading}>
                {loading ? <CircularProgress size={24} /> : <RefreshIcon />}
              </IconButton>
            </Tooltip>
          </Box>
        </Box>
      </Paper>
      
      {/* Test Cases Table */}
      <Paper>
        <TableContainer>
          <Table aria-label="test cases table">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Description</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Steps</TableCell>
                <TableCell>Tags</TableCell>
                <TableCell align="right">Actions</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={6} align="center">
                    <CircularProgress size={40} sx={{ my: 3 }} />
                  </TableCell>
                </TableRow>
              ) : filteredTestCases.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={6} align="center">
                    <Typography variant="body1" sx={{ py: 3 }}>
                      {searchTerm ? 'No test cases found matching your search' : 'No test cases found. Create your first test case to get started.'}
                    </Typography>
                    {!searchTerm && (
                      <Button
                        variant="contained"
                        color="primary"
                        startIcon={<AddIcon />}
                        onClick={handleCreateTestCase}
                        sx={{ mt: 1 }}
                      >
                        Create Test Case
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              ) : (
                filteredTestCases
                  .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                  .map((testCase) => (
                    <TableRow key={testCase.id} hover>
                      <TableCell>
                        <Typography
                          variant="body1"
                          sx={{ 
                            cursor: 'pointer',
                            '&:hover': { textDecoration: 'underline' }
                          }}
                          onClick={() => handleEditTestCase(testCase.id)}
                        >
                          {testCase.name}
                        </Typography>
                      </TableCell>
                      <TableCell>{testCase.description || '-'}</TableCell>
                      <TableCell>
                        <StatusChip status={testCase.status} />
                      </TableCell>
                      <TableCell>{testCase.steps?.length || 0}</TableCell>
                      <TableCell>
                        {testCase.tags?.map((tag) => (
                          <Chip
                            key={tag}
                            label={tag}
                            size="small"
                            sx={{ mr: 0.5, mb: 0.5 }}
                          />
                        ))}
                      </TableCell>
                      <TableCell align="right">
                        <Tooltip title="Run">
                          <IconButton 
                            color="primary"
                            onClick={() => handleRunTestCase(testCase.id)}
                          >
                            <RunIcon />
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Edit">
                          <IconButton
                            color="primary"
                            onClick={() => handleEditTestCase(testCase.id)}
                          >
                            <EditIcon />
                          </IconButton>
                        </Tooltip>
                        <IconButton
                          aria-label="more actions"
                          aria-haspopup="true"
                          onClick={(e) => handleActionMenuOpen(e, testCase)}
                        >
                          <MoreVertIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        <TablePagination
          component="div"
          count={filteredTestCases.length}
          page={page}
          onPageChange={handleChangePage}
          rowsPerPage={rowsPerPage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          rowsPerPageOptions={[5, 10, 25, 50]}
        />
      </Paper>
      
      {/* Action Menu */}
      <Menu
        anchorEl={actionMenuAnchorEl}
        open={Boolean(actionMenuAnchorEl)}
        onClose={handleActionMenuClose}
      >
        <MenuItem onClick={() => handleEditTestCase(selectedTestCase?.id)}>
          <EditIcon fontSize="small" sx={{ mr: 1 }} />
          Edit
        </MenuItem>
        <MenuItem onClick={() => handleRunTestCase(selectedTestCase?.id)}>
          <RunIcon fontSize="small" sx={{ mr: 1 }} />
          Run
        </MenuItem>
        <MenuItem onClick={() => handleDuplicateTestCase(selectedTestCase?.id)}>
          <DuplicateIcon fontSize="small" sx={{ mr: 1 }} />
          Duplicate
        </MenuItem>
        <MenuItem onClick={() => handleDeleteClick(selectedTestCase?.id)}>
          <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
          Delete
        </MenuItem>
      </Menu>
      
      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
        aria-labelledby="delete-dialog-title"
        aria-describedby="delete-dialog-description"
      >
        <DialogTitle id="delete-dialog-title">
          Delete Test Case
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="delete-dialog-description">
            Are you sure you want to delete the test case "{selectedTestCase?.name}"? 
            This action cannot be undone.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setDeleteDialogOpen(false)} 
            color="primary"
          >
            Cancel
          </Button>
          <Button 
            onClick={handleConfirmDelete} 
            color="error" 
            variant="contained"
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default TestCases;


// src/pages/TestCase.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Button,
  TextField,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Switch,
  Chip,
  IconButton,
  Divider,
  CircularProgress,
  Breadcrumbs,
  Link,
  Tab,
  Tabs,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tooltip,
  Snackbar,
  Alert
} from '@mui/material';
import {
  Save as SaveIcon,
  PlayArrow as RunIcon,
  Add as AddIcon,
  ArrowBack as BackIcon,
  ContentCopy as DuplicateIcon,
  Delete as DeleteIcon,
  Code as CodeIcon,
  History as HistoryIcon,
  HelpOutline as HelpIcon
} from '@mui/icons-material';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';
import { useSnackbar } from 'notistack';
import StepList from '../components/StepList';
import StepForm from '../components/StepForm';

// Tab Panel Component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`test-case-tabpanel-${index}`}
      aria-labelledby={`test-case-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

const TestCase = () => {
  const navigate = useNavigate();
  const { projectId, testCaseId } = useParams();
  const { enqueueSnackbar } = useSnackbar();
  const { get, post, put } = useApi();
  const { 
    currentProject, 
    executeTestCase,
    createTestCase,
    updateTestCase,
    deleteTestCase
  } = useProject();
  
  // Tab state
  const [tabValue, setTabValue] = useState(0);
  
  // Test case state
  const [isNew, setIsNew] = useState(!testCaseId || testCaseId === 'create');
  const [loading, setLoading] = useState(!isNew);
  const [saving, setSaving] = useState(false);
  const [testCase, setTestCase] = useState({
    name: '',
    description: '',
    status: 'DRAFT',
    tags: [],
    steps: [],
    timeout: 60000,
    retryCount: 0,
    browserType: 'CHROME',
    headless: false,
    screenshotOnError: true,
    selfHealing: true,
    dataDriven: false,
    dataSource: null
  });
  
  // Dialog states
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [discardDialogOpen, setDiscardDialogOpen] = useState(false);
  const [stepDialogOpen, setStepDialogOpen] = useState(false);
  const [currentStep, setCurrentStep] = useState(null);
  
  // Tag input state
  const [tagInput, setTagInput] = useState('');
  
  // Check if form has unsaved changes
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  // Load test case data if editing
  useEffect(() => {
    const fetchTestCase = async () => {
      if (isNew) return;
      
      setLoading(true);
      try {
        const response = await get(`/projects/${projectId}/testcases/${testCaseId}`);
        setTestCase(response.data);
      } catch (error) {
        console.error('Error loading test case:', error);
        enqueueSnackbar('Failed to load test case', { variant: 'error' });
        navigate(`/projects/${projectId}/test-cases`);
      } finally {
        setLoading(false);
      }
    };
    
    fetchTestCase();
  }, [isNew, projectId, testCaseId, get, navigate, enqueueSnackbar]);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Handle form field changes
  const handleChange = (e) => {
    const { name, value, checked, type } = e.target;
    setTestCase(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    setHasUnsavedChanges(true);
  };
  
  // Handle adding a tag
  const handleAddTag = () => {
    if (!tagInput.trim()) return;
    
    if (!testCase.tags.includes(tagInput.trim())) {
      setTestCase(prev => ({
        ...prev,
        tags: [...prev.tags, tagInput.trim()]
      }));
      setHasUnsavedChanges(true);
    }
    
    setTagInput('');
  };
  
  // Handle removing a tag
  const handleRemoveTag = (tagToRemove) => {
    setTestCase(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove)
    }));
    setHasUnsavedChanges(true);
  };
  
  // Handle tag input keypress
  const handleTagKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };
  
  // Handle opening step dialog
  const handleAddStep = () => {
    setCurrentStep(null);
    setStepDialogOpen(true);
  };
  
  // Handle editing a step
  const handleEditStep = (step) => {
    setCurrentStep(step);
    setStepDialogOpen(true);
  };
  
  // Handle step dialog close
  const handleStepDialogClose = () => {
    setStepDialogOpen(false);
    setCurrentStep(null);
  };
  
  // Handle saving a step
  const handleSaveStep = (step) => {
    let updatedSteps;
    
    if (currentStep) {
      // Editing existing step
      updatedSteps = testCase.steps.map(s => 
        s.id === currentStep.id ? { ...step, id: currentStep.id } : s
      );
    } else {
      // Adding new step
      const newStep = {
        ...step,
        id: `temp-${Date.now()}` // Temporary ID until saved to backend
      };
      updatedSteps = [...testCase.steps, newStep];
    }
    
    setTestCase(prev => ({
      ...prev,
      steps: updatedSteps
    }));
    
    setStepDialogOpen(false);
    setCurrentStep(null);
    setHasUnsavedChanges(true);
  };
  
  // Handle removing a step
  const handleRemoveStep = (stepId) => {
    setTestCase(prev => ({
      ...prev,
      steps: prev.steps.filter(step => step.id !== stepId)
    }));
    setHasUnsavedChanges(true);
  };
  
  // Handle reordering steps
  const handleReorderSteps = (reorderedSteps) => {
    setTestCase(prev => ({
      ...prev,
      steps: reorderedSteps
    }));
    setHasUnsavedChanges(true);
  };
  
  // Handle save test case
  const handleSave = async () => {
    if (!testCase.name.trim()) {
      enqueueSnackbar('Test case name is required', { variant: 'error' });
      return;
    }
    
    setSaving(true);
    try {
      let savedTestCase;
      
      if (isNew) {
        savedTestCase = await createTestCase(testCase);
        setIsNew(false);
        navigate(`/projects/${projectId}/test-cases/${savedTestCase.id}`, { replace: true });
      } else {
        savedTestCase = await updateTestCase(testCaseId, testCase);
      }
      
      setTestCase(savedTestCase);
      setHasUnsavedChanges(false);
      enqueueSnackbar('Test case saved successfully', { variant: 'success' });
    } catch (error) {
      console.error('Error saving test case:', error);
      enqueueSnackbar('Failed to save test case', { variant: 'error' });
    } finally {
      setSaving(false);
    }
  };
  
  // Handle run test case
  const handleRun = async () => {
    if (hasUnsavedChanges) {
      enqueueSnackbar('Please save your changes before running the test', { variant: 'warning' });
      return;
    }
    
    if (isNew) {
      enqueueSnackbar('Please save the test case before running it', { variant: 'warning' });
      return;
    }
    
    try {
      const executionId = await executeTestCase(testCaseId);
      if (executionId) {
        enqueueSnackbar('Test execution started successfully', { variant: 'success' });
        navigate(`/projects/${projectId}/executions/${executionId}`);
      }
    } catch (error) {
      console.error('Error executing test case:', error);
      enqueueSnackbar('Failed to execute test case', { variant: 'error' });
    }
  };
  
  // Handle duplicate test case
  const handleDuplicate = () => {
    enqueueSnackbar('Duplication feature is coming soon', { variant: 'info' });
  };
  
  // Handle delete test case
  const handleDelete = async () => {
    if (isNew) {
      navigate(`/projects/${projectId}/test-cases`);
      return;
    }
    
    setDeleteDialogOpen(true);
  };
  
  // Handle confirm delete
  const handleConfirmDelete = async () => {
    try {
      const success = await deleteTestCase(testCaseId);
      if (success) {
        enqueueSnackbar('Test case deleted successfully', { variant: 'success' });
        navigate(`/projects/${projectId}/test-cases`);
      }
    } catch (error) {
      console.error('Error deleting test case:', error);
      enqueueSnackbar('Failed to delete test case', { variant: 'error' });
    } finally {
      setDeleteDialogOpen(false);
    }
  };
  
  // Handle navigate back
  const handleBack = () => {
    if (hasUnsavedChanges) {
      setDiscardDialogOpen(true);
    } else {
      navigate(`/projects/${projectId}/test-cases`);
    }
  };
  
  // Handle discard changes
  const handleDiscardChanges = () => {
    setDiscardDialogOpen(false);
    navigate(`/projects/${projectId}/test-cases`);
  };
  
  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
        <CircularProgress />
      </Box>
    );
  }
  
  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs aria-label="breadcrumb" sx={{ mb: 2 }}>
        <Link underline="hover" color="inherit" href="/">
          Dashboard
        </Link>
        <Link
          underline="hover"
          color="inherit"
          href={`/projects/${projectId}`}
        >
          {currentProject?.name}
        </Link>
        <Link
          underline="hover"
          color="inherit"
          href={`/projects/${projectId}/test-cases`}
        >
          Test Cases
        </Link>
        <Typography color="text.primary">
          {isNew ? 'New Test Case' : testCase.name}
        </Typography>
      </Breadcrumbs>
      
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <IconButton onClick={handleBack} sx={{ mr: 1 }}>
            <BackIcon />
          </IconButton>
          <Typography variant="h4" component="h1">
            {isNew ? 'Create Test Case' : 'Edit Test Case'}
          </Typography>
        </Box>
        <Box>
          <Button
            variant="outlined"
            startIcon={<RunIcon />}
            onClick={handleRun}
            disabled={isNew || hasUnsavedChanges}
            sx={{ mr: 1 }}
          >
            Run
          </Button>
          <Button
            variant="outlined"
            startIcon={<DuplicateIcon />}
            onClick={handleDuplicate}
            disabled={isNew}
            sx={{ mr: 1 }}
          >
            Duplicate
          </Button>
          <Button
            variant="outlined"
            color="error"
            startIcon={<DeleteIcon />}
            onClick={handleDelete}
            sx={{ mr: 1 }}
          >
            Delete
          </Button>
          <Button
            variant="contained"
            color="primary"
            startIcon={saving ? <CircularProgress size={24} /> : <SaveIcon />}
            onClick={handleSave}
            disabled={saving}
          >
            Save
          </Button>
        </Box>
      </Box>
      
      {/* Tabs */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs value={tabValue} onChange={handleTabChange} aria-label="test case tabs">
          <Tab label="Basic Information" id="test-case-tab-0" />
          <Tab label="Test Steps" id="test-case-tab-1" />
          <Tab label="Advanced Settings" id="test-case-tab-2" />
          <Tab label="History" id="test-case-tab-3" disabled={isNew} />
        </Tabs>
      </Box>
      
      {/* Basic Information Tab */}
      <TabPanel value={tabValue} index={0}>
        <Paper sx={{ p: 3 }}>
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <TextField
                name="name"
                label="Test Case Name"
                value={testCase.name}
                onChange={handleChange}
                fullWidth
                required
                error={!testCase.name.trim()}
                helperText={!testCase.name.trim() ? 'Test case name is required' : ''}
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                name="description"
                label="Description"
                value={testCase.description}
                onChange={handleChange}
                fullWidth
                multiline
                rows={3}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel id="status-label">Status</InputLabel>
                <Select
                  labelId="status-label"
                  name="status"
                  value={testCase.status}
                  onChange={handleChange}
                  label="Status"
                >
                  <MenuItem value="DRAFT">Draft</MenuItem>
                  <MenuItem value="ACTIVE">Active</MenuItem>
                  <MenuItem value="MAINTENANCE">Maintenance</MenuItem>
                  <MenuItem value="DEPRECATED">Deprecated</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControl fullWidth>
                <InputLabel id="browser-label">Browser</InputLabel>
                <Select
                  labelId="browser-label"
                  name="browserType"
                  value={testCase.browserType}
                  onChange={handleChange}
                  label="Browser"
                >
                  <MenuItem value="CHROME">Chrome</MenuItem>
                  <MenuItem value="FIREFOX">Firefox</MenuItem>
                  <MenuItem value="EDGE">Edge</MenuItem>
                  <MenuItem value="SAFARI">Safari</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12}>
              <Typography variant="subtitle1" gutterBottom>
                Tags
              </Typography>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', mb: 1 }}>
                {testCase.tags.map((tag) => (
                  <Chip
                    key={tag}
                    label={tag}
                    onDelete={() => handleRemoveTag(tag)}
                    sx={{ mr: 1, mb: 1 }}
                  />
                ))}
              </Box>
              <Box sx={{ display: 'flex' }}>
                <TextField
                  label="Add Tag"
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyPress={handleTagKeyPress}
                  size="small"
                  sx={{ mr: 1 }}
                />
                <Button variant="outlined" onClick={handleAddTag}>
                  Add
                </Button>
              </Box>
            </Grid>
          </Grid>
        </Paper>
      </TabPanel>
      
      {/* Test Steps Tab */}
      <TabPanel value={tabValue} index={1}>
        <Paper sx={{ p: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
            <Typography variant="h6">Test Steps</Typography>
            <Button
              variant="contained"
              color="primary"
              startIcon={<AddIcon />}
              onClick={handleAddStep}
            >
              Add Step
            </Button>
          </Box>
          
          <StepList
            steps={testCase.steps}
            onEditStep={handleEditStep}
            onRemoveStep={handleRemoveStep}
            onReorderSteps={handleReorderSteps}
          />
        </Paper>
      </TabPanel>
      
      {/* Advanced Settings Tab */}
      <TabPanel value={tabValue} index={2}>
        <Paper sx={{ p: 3 }}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <TextField
                name="timeout"
                label="Timeout (ms)"
                type="number"
                value={testCase.timeout}
                onChange={handleChange}
                fullWidth
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                name="retryCount"
                label="Retry Count"
                type="number"
                value={testCase.retryCount}
                onChange={handleChange}
                fullWidth
                inputProps={{ min: 0 }}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="headless"
                    checked={testCase.headless}
                    onChange={handleChange}
                  />
                }
                label="Run in Headless Mode"
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="screenshotOnError"
                    checked={testCase.screenshotOnError}
                    onChange={handleChange}
                  />
                }
                label="Capture Screenshot on Error"
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="selfHealing"
                    checked={testCase.selfHealing}
                    onChange={handleChange}
                  />
                }
                label="Enable Self-Healing"
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControlLabel
                control={
                  <Switch
                    name="dataDriven"
                    checked={testCase.dataDriven}
                    onChange={handleChange}
                  />
                }
                label="Data-Driven Testing"
              />
            </Grid>
            {testCase.dataDriven && (
              <Grid item xs={12}>
                <FormControl fullWidth>
                  <InputLabel id="data-source-label">Data Source</InputLabel>
                  <Select
                    labelId="data-source-label"
                    name="dataSource"
                    value={testCase.dataSource || ''}
                    onChange={handleChange}
                    label="Data Source"
                  >
                    <MenuItem value="">None</MenuItem>
                    <MenuItem value="csv">CSV File</MenuItem>
                    <MenuItem value="excel">Excel File</MenuItem>
                    <MenuItem value="database">Database Query</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            )}
          </Grid>
        </Paper>
      </TabPanel>
      
      {/* History Tab */}
      <TabPanel value={tabValue} index={3}>
        <Paper sx={{ p: 3 }}>
          <Typography variant="body1" color="textSecondary" align="center">
            History functionality is coming soon
          </Typography>
        </Paper>
      </TabPanel>
      
      {/* Step Form Dialog */}
      <Dialog
        open={stepDialogOpen}
        onClose={handleStepDialogClose}
        fullWidth
        maxWidth="md"
      >
        <DialogTitle>
          {currentStep ? 'Edit Step' : 'Add Step'}
        </DialogTitle>
        <DialogContent dividers>
          <StepForm
            step={currentStep}
            onSave={handleSaveStep}
            onCancel={handleStepDialogClose}
          />
        </DialogContent>
      </Dialog>
      
      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
      >
        <DialogTitle>Delete Test Case</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete this test case? This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleConfirmDelete} color="error" variant="contained">
            Delete
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Discard Changes Dialog */}
      <Dialog
        open={discardDialogOpen}
        onClose={() => setDiscardDialogOpen(false)}
      >
        <DialogTitle>Discard Changes</DialogTitle>
        <DialogContent>
          <Typography>
            You have unsaved changes. Are you sure you want to leave this page?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDiscardDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleDiscardChanges} color="error">
            Discard Changes
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default TestCase;


// src/components/StepList.jsx
import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  IconButton,
  Grid,
  Paper,
  Tooltip,
  Divider,
  Chip,
  Badge,
  List,
  ListItem,
  ListItemText,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Collapse,
  Alert,
  CircularProgress
} from '@mui/material';
import {
  Edit as EditIcon,
  Delete as DeleteIcon,
  DragIndicator as DragIcon,
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  CheckCircle as SuccessIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Visibility as ViewIcon,
  FileCopy as CodeIcon,
  ArrowUpward as MoveUpIcon,
  ArrowDownward as MoveDownIcon
} from '@mui/icons-material';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';

// Step action icon mapping
const getActionIcon = (action) => {
  switch (action?.toUpperCase()) {
    case 'CLICK':
      return '🖱️';
    case 'TYPE':
      return '⌨️';
    case 'SELECT':
      return '📋';
    case 'NAVIGATE':
      return '🌐';
    case 'WAIT':
      return '⏱️';
    case 'ASSERT':
      return '✓';
    case 'HOVER':
      return '👆';
    case 'SCROLL':
      return '📜';
    case 'UPLOAD':
      return '📤';
    case 'DOWNLOAD':
      return '📥';
    case 'SWITCH_TAB':
      return '📑';
    case 'SCREENSHOT':
      return '📸';
    case 'EXECUTE_SCRIPT':
      return '📝';
    case 'API_CALL':
      return '🔄';
    case 'DB_QUERY':
      return '🗃️';
    default:
      return '❓';
  }
};

// Step severity chip component
const SeverityChip = ({ severity }) => {
  const severityMap = {
    'BLOCKER': { color: 'error', label: 'Blocker' },
    'CRITICAL': { color: 'error', label: 'Critical' },
    'MAJOR': { color: 'warning', label: 'Major' },
    'MINOR': { color: 'info', label: 'Minor' },
    'TRIVIAL': { color: 'default', label: 'Trivial' }
  };
  
  const config = severityMap[severity] || { color: 'default', label: severity || 'Normal' };
  
  return (
    <Chip
      label={config.label}
      color={config.color}
      size="small"
      variant="outlined"
    />
  );
};

// Step Item Component
const StepItem = ({ step, index, onEdit, onRemove, onMoveUp, onMoveDown, isFirst, isLast }) => {
  const [expanded, setExpanded] = useState(false);
  
  const toggleExpand = () => {
    setExpanded(!expanded);
  };
  
  return (
    <Draggable draggableId={step.id.toString()} index={index}>
      {(provided) => (
        <Card 
          ref={provided.innerRef}
          {...provided.draggableProps}
          sx={{ 
            mb: 2,
            borderLeft: 4,
            borderColor: step.disabled ? 'grey.400' : 'primary.main',
            opacity: step.disabled ? 0.7 : 1
          }}
        >
          <CardContent sx={{ p: 2, '&:last-child': { pb: 2 } }}>
            <Grid container spacing={1}>
              <Grid item sx={{ display: 'flex', alignItems: 'center' }}>
                <Box {...provided.dragHandleProps} sx={{ cursor: 'grab', mr: 1 }}>
                  <DragIcon color="action" />
                </Box>
                <Typography variant="h6" component="span" sx={{ mr: 1 }}>
                  {index + 1}.
                </Typography>
              </Grid>
              
              <Grid item xs>
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <Typography variant="h6" component="span" sx={{ mr: 1 }}>
                    <Box component="span" sx={{ mr: 1 }}>
                      {getActionIcon(step.action)}
                    </Box>
                    {step.name || step.action}
                  </Typography>
                  
                  {step.severity && (
                    <SeverityChip severity={step.severity} />
                  )}
                  
                  {step.disabled && (
                    <Chip
                      label="Disabled"
                      color="default"
                      size="small"
                      sx={{ ml: 1 }}
                    />
                  )}
                </Box>
                
                {step.description && (
                  <Typography variant="body2" color="textSecondary" sx={{ mt: 0.5 }}>
                    {step.description}
                  </Typography>
                )}
              </Grid>
              
              <Grid item>
                <Box sx={{ display: 'flex' }}>
                  <Tooltip title="Move Up">
                    <span>
                      <IconButton 
                        size="small" 
                        disabled={isFirst}
                        onClick={() => onMoveUp(index)}
                      >
                        <MoveUpIcon fontSize="small" />
                      </IconButton>
                    </span>
                  </Tooltip>
                  
                  <Tooltip title="Move Down">
                    <span>
                      <IconButton 
                        size="small" 
                        disabled={isLast}
                        onClick={() => onMoveDown(index)}
                      >
                        <MoveDownIcon fontSize="small" />
                      </IconButton>
                    </span>
                  </Tooltip>
                  
                  <Tooltip title="Edit">
                    <IconButton 
                      size="small" 
                      onClick={() => onEdit(step)}
                      color="primary"
                    >
                      <EditIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  
                  <Tooltip title="Delete">
                    <IconButton 
                      size="small" 
                      onClick={() => onRemove(step.id)}
                      color="error"
                    >
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  
                  <Tooltip title="View Details">
                    <IconButton 
                      size="small" 
                      onClick={toggleExpand}
                    >
                      {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                    </IconButton>
                  </Tooltip>
                </Box>
              </Grid>
            </Grid>
            
            <Collapse in={expanded} timeout="auto" unmountOnExit>
              <Box sx={{ mt: 2 }}>
                <Divider sx={{ mb: 2 }} />
                
                <Typography variant="subtitle2" gutterBottom>
                  Step Details
                </Typography>
                
                <TableContainer component={Paper} variant="outlined" sx={{ mb: 2 }}>
                  <Table size="small">
                    <TableBody>
                      <TableRow>
                        <TableCell component="th" scope="row" width="30%">
                          Action
                        </TableCell>
                        <TableCell>
                          {step.action || 'N/A'}
                        </TableCell>
                      </TableRow>
                      
                      <TableRow>
                        <TableCell component="th" scope="row">
                          Target
                        </TableCell>
                        <TableCell>
                          {step.target || 'N/A'}
                        </TableCell>
                      </TableRow>
                      
                      {step.selector && (
                        <TableRow>
                          <TableCell component="th" scope="row">
                            Selector
                          </TableCell>
                          <TableCell>
                            <Typography
                              variant="body2"
                              component="code"
                              sx={{
                                fontFamily: 'monospace',
                                bgcolor: 'grey.100',
                                p: 0.5,
                                borderRadius: 1,
                                display: 'inline-block',
                                maxWidth: '100%',
                                overflow: 'auto'
                              }}
                            >
                              {step.selector}
                            </Typography>
                          </TableCell>
                        </TableRow>
                      )}
                      
                      {step.value && (
                        <TableRow>
                          <TableCell component="th" scope="row">
                            Value
                          </TableCell>
                          <TableCell>
                            {step.value}
                          </TableCell>
                        </TableRow>
                      )}
                      
                      {step.timeout && (
                        <TableRow>
                          <TableCell component="th" scope="row">
                            Timeout
                          </TableCell>
                          <TableCell>
                            {step.timeout} ms
                          </TableCell>
                        </TableRow>
                      )}
                      
                      {step.assertion && (
                        <TableRow>
                          <TableCell component="th" scope="row">
                            Assertion
                          </TableCell>
                          <TableCell>
                            {step.assertion.type}: {step.assertion.expected}
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
                
                {step.conditionalLogic && (
                  <Alert severity="info" sx={{ mb: 2 }}>
                    <Typography variant="subtitle2">
                      Conditional Logic
                    </Typography>
                    <Typography variant="body2">
                      {step.conditionalLogic.description || 'This step contains conditional logic.'}
                    </Typography>
                  </Alert>
                )}
                
                {step.screenshot && (
                  <Alert severity="info" icon={<ViewIcon />} sx={{ mb: 2 }}>
                    Screenshot will be captured after this step.
                  </Alert>
                )}
              </Box>
            </Collapse>
          </CardContent>
        </Card>
      )}
    </Draggable>
  );
};

// Main StepList Component
const StepList = ({ steps = [], onEditStep, onRemoveStep, onReorderSteps }) => {
  const handleDragEnd = (result) => {
    if (!result.destination) return;
    
    // Reorder the steps
    const reorderedSteps = Array.from(steps);
    const [removed] = reorderedSteps.splice(result.source.index, 1);
    reorderedSteps.splice(result.destination.index, 0, removed);
    
    onReorderSteps(reorderedSteps);
  };
  
  const handleMoveUp = (index) => {
    if (index === 0) return;
    
    const newSteps = Array.from(steps);
    const temp = newSteps[index];
    newSteps[index] = newSteps[index - 1];
    newSteps[index - 1] = temp;
    
    onReorderSteps(newSteps);
  };
  
  const handleMoveDown = (index) => {
    if (index === steps.length - 1) return;
    
    const newSteps = Array.from(steps);
    const temp = newSteps[index];
    newSteps[index] = newSteps[index + 1];
    newSteps[index + 1] = temp;
    
    onReorderSteps(newSteps);
  };
  
  if (!steps.length) {
    return (
      <Box sx={{ textAlign: 'center', py: 4 }}>
        <Typography variant="body1" color="textSecondary" gutterBottom>
          No steps added yet.
        </Typography>
        <Typography variant="body2" color="textSecondary">
          Add a step to start building your test case.
        </Typography>
      </Box>
    );
  }
  
  return (
    <DragDropContext onDragEnd={handleDragEnd}>
      <Droppable droppableId="test-steps">
        {(provided) => (
          <Box
            ref={provided.innerRef}
            {...provided.droppableProps}
          >
            {steps.map((step, index) => (
              <StepItem
                key={step.id}
                step={step}
                index={index}
                onEdit={onEditStep}
                onRemove={onRemoveStep}
                onMoveUp={handleMoveUp}
                onMoveDown={handleMoveDown}
                isFirst={index === 0}
                isLast={index === steps.length - 1}
              />
            ))}
            {provided.placeholder}
          </Box>
        )}
      </Droppable>
    </DragDropContext>
  );
};

export default StepList;

// src/components/StepForm.jsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
  Grid,
  Typography,
  Divider,
  Paper,
  Tabs,
  Tab,
  Switch,
  FormControlLabel,
  IconButton,
  Tooltip,
  Alert,
  Collapse,
  Autocomplete,
  Chip,
  OutlinedInput
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  HelpOutline as HelpIcon,
  Code as CodeIcon,
  Refresh as RefreshIcon,
  RecordVoiceOver as NlpIcon,
  PlayArrow as TryIcon
} from '@mui/icons-material';
import { useProject } from '../contexts/ProjectContext';
import { useApi } from '../contexts/ApiContext';

// Action types for different test step actions
const ACTION_TYPES = [
  { value: 'CLICK', label: 'Click', description: 'Click on an element' },
  { value: 'DOUBLE_CLICK', label: 'Double Click', description: 'Double click on an element' },
  { value: 'RIGHT_CLICK', label: 'Right Click', description: 'Right click on an element' },
  { value: 'TYPE', label: 'Type', description: 'Type text into an input field' },
  { value: 'CLEAR', label: 'Clear', description: 'Clear an input field' },
  { value: 'SELECT', label: 'Select', description: 'Select an option from a dropdown' },
  { value: 'HOVER', label: 'Hover', description: 'Hover over an element' },
  { value: 'DRAG_AND_DROP', label: 'Drag and Drop', description: 'Drag an element to a target location' },
  { value: 'NAVIGATE', label: 'Navigate', description: 'Navigate to a URL' },
  { value: 'BACK', label: 'Back', description: 'Navigate back in browser history' },
  { value: 'FORWARD', label: 'Forward', description: 'Navigate forward in browser history' },
  { value: 'REFRESH', label: 'Refresh', description: 'Refresh the current page' },
  { value: 'SWITCH_TAB', label: 'Switch Tab', description: 'Switch to another browser tab' },
  { value: 'CLOSE_TAB', label: 'Close Tab', description: 'Close the current browser tab' },
  { value: 'WAIT', label: 'Wait', description: 'Wait for a specified time' },
  { value: 'WAIT_FOR_ELEMENT', label: 'Wait for Element', description: 'Wait for an element to appear' },
  { value: 'WAIT_FOR_NAVIGATION', label: 'Wait for Navigation', description: 'Wait for page navigation to complete' },
  { value: 'SCREENSHOT', label: 'Take Screenshot', description: 'Capture a screenshot' },
  { value: 'SCROLL', label: 'Scroll', description: 'Scroll the page or element' },
  { value: 'ASSERT', label: 'Assert', description: 'Assert that a condition is true' },
  { value: 'UPLOAD', label: 'Upload File', description: 'Upload a file to a form' },
  { value: 'EXECUTE_SCRIPT', label: 'Execute Script', description: 'Execute JavaScript code' },
  { value: 'API_CALL', label: 'API Call', description: 'Make an API request' },
  { value: 'DB_QUERY', label: 'Database Query', description: 'Execute a database query' },
  { value: 'CUSTOM', label: 'Custom Action', description: 'Execute a custom action' }
];

// Selector types
const SELECTOR_TYPES = [
  { value: 'css', label: 'CSS Selector', example: '#login-button' },
  { value: 'xpath', label: 'XPath', example: '//button[@id="login-button"]' },
  { value: 'id', label: 'ID', example: 'login-button' },
  { value: 'name', label: 'Name', example: 'username' },
  { value: 'linkText', label: 'Link Text', example: 'Sign In' },
  { value: 'partialLinkText', label: 'Partial Link Text', example: 'Sign' },
  { value: 'tagName', label: 'Tag Name', example: 'button' },
  { value: 'className', label: 'Class Name', example: 'login-btn' },
  { value: 'custom', label: 'Custom (Advanced)', example: '' }
];

// Assertion types
const ASSERTION_TYPES = [
  { value: 'equals', label: 'Equals', description: 'Check if value equals expected' },
  { value: 'contains', label: 'Contains', description: 'Check if value contains expected' },
  { value: 'matches', label: 'Matches', description: 'Check if value matches regex pattern' },
  { value: 'exists', label: 'Exists', description: 'Check if element exists' },
  { value: 'notExists', label: 'Not Exists', description: 'Check if element does not exist' },
  { value: 'visible', label: 'Visible', description: 'Check if element is visible' },
  { value: 'notVisible', label: 'Not Visible', description: 'Check if element is not visible' },
  { value: 'enabled', label: 'Enabled', description: 'Check if element is enabled' },
  { value: 'disabled', label: 'Disabled', description: 'Check if element is disabled' },
  { value: 'checked', label: 'Checked', description: 'Check if element is checked' },
  { value: 'notChecked', label: 'Not Checked', description: 'Check if element is not checked' },
  { value: 'count', label: 'Count', description: 'Check number of matching elements' },
  { value: 'gtZero', label: 'Greater Than Zero', description: 'Check if value is greater than zero' },
  { value: 'custom', label: 'Custom', description: 'Custom assertion logic' }
];

// Tab Panel Component
function TabPanel(props) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`step-form-tabpanel-${index}`}
      aria-labelledby={`step-form-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 2 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

// StepForm Component
const StepForm = ({ step, onSave, onCancel }) => {
  const { currentProject } = useProject();
  const { post } = useApi();
  
  // Tab state
  const [tabValue, setTabValue] = useState(0);
  
  // NLP processing state
  const [nlpInput, setNlpInput] = useState('');
  const [processingNlp, setProcessingNlp] = useState(false);
  const [nlpError, setNlpError] = useState(null);
  
  // Form state
  const [formValues, setFormValues] = useState({
    name: '',
    description: '',
    action: 'CLICK',
    selectorType: 'css',
    selector: '',
    target: '',
    value: '',
    timeout: 30000,
    screenshot: false,
    disabled: false,
    severity: 'NORMAL',
    assertion: {
      type: 'equals',
      expected: '',
      property: 'textContent'
    },
    conditionalLogic: null,
    waitForNavigation: false
  });
  
  // Initialize form values from existing step
  useEffect(() => {
    if (step) {
      setFormValues({
        name: step.name || '',
        description: step.description || '',
        action: step.action || 'CLICK',
        selectorType: step.selectorType || 'css',
        selector: step.selector || '',
        target: step.target || '',
        value: step.value || '',
        timeout: step.timeout || 30000,
        screenshot: step.screenshot || false,
        disabled: step.disabled || false,
        severity: step.severity || 'NORMAL',
        assertion: step.assertion || {
          type: 'equals',
          expected: '',
          property: 'textContent'
        },
        conditionalLogic: step.conditionalLogic || null,
        waitForNavigation: step.waitForNavigation || false
      });
    }
  }, [step]);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Handle form input changes
  const handleChange = (e) => {
    const { name, value, checked, type } = e.target;
    
    if (name.includes('.')) {
      // Handle nested properties (e.g., assertion.type)
      const [parent, child] = name.split('.');
      setFormValues((prev) => ({
        ...prev,
        [parent]: {
          ...prev[parent],
          [child]: type === 'checkbox' ? checked : value
        }
      }));
    } else {
      // Handle regular properties
      setFormValues((prev) => ({
        ...prev,
        [name]: type === 'checkbox' ? checked : value
      }));
    }
  };
  
  // Handle action type change (show/hide relevant fields)
  const handleActionChange = (e) => {
    const action = e.target.value;
    setFormValues((prev) => ({
      ...prev,
      action
    }));
    
    // Reset certain fields based on the action type
    if (action === 'NAVIGATE') {
      setFormValues((prev) => ({
        ...prev,
        action,
        selector: '',
        selectorType: 'css',
        target: ''
      }));
    } else if (action === 'WAIT') {
      setFormValues((prev) => ({
        ...prev,
        action,
        selector: '',
        selectorType: 'css',
        target: '',
        value: ''
      }));
    } else if (action === 'ASSERT') {
      if (!prev.assertion) {
        setFormValues((prev) => ({
          ...prev,
          action,
          assertion: {
            type: 'equals',
            expected: '',
            property: 'textContent'
          }
        }));
      }
    }
  };
  
  // Process natural language to generate a test step
  const handleNlpProcessing = async () => {
    if (!nlpInput.trim()) return;
    
    setProcessingNlp(true);
    setNlpError(null);
    
    try {
      const response = await post(`/projects/${currentProject.id}/nlp/process-step`, {
        text: nlpInput
      });
      
      // Update the form with the generated step data
      const generatedStep = response.data;
      setFormValues((prev) => ({
        ...prev,
        ...generatedStep
      }));
      
      // Switch to the basic info tab to show the results
      setTabValue(0);
    } catch (error) {
      console.error('Error processing NLP input:', error);
      setNlpError('Failed to process natural language input. Please try a different description or create the step manually.');
    } finally {
      setProcessingNlp(false);
    }
  };
  
  // Check if selector field is required for the current action
  const isSelectorRequired = () => {
    return !['NAVIGATE', 'WAIT', 'BACK', 'FORWARD', 'REFRESH', 'SCREENSHOT', 'EXECUTE_SCRIPT', 'API_CALL', 'DB_QUERY'].includes(formValues.action);
  };
  
  // Check if value field is applicable for the current action
  const isValueApplicable = () => {
    return ['TYPE', 'SELECT', 'ASSERT', 'WAIT', 'NAVIGATE', 'UPLOAD', 'EXECUTE_SCRIPT', 'API_CALL', 'DB_QUERY'].includes(formValues.action);
  };
  
  // Validate the form before saving
  const validateForm = () => {
    // Name is always required
    if (!formValues.name.trim()) {
      return 'Step name is required';
    }
    
    // Validate selector if required
    if (isSelectorRequired() && !formValues.selector.trim()) {
      return 'Selector is required for this action type';
    }
    
    // Validate value if required
    if (formValues.action === 'TYPE' && !formValues.value.trim()) {
      return 'Value is required for the Type action';
    }
    
    if (formValues.action === 'NAVIGATE' && !formValues.value.trim()) {
      return 'URL is required for the Navigate action';
    }
    
    if (formValues.action === 'WAIT' && (!formValues.timeout || formValues.timeout <= 0)) {
      return 'Valid timeout value is required for the Wait action';
    }
    
    if (formValues.action === 'ASSERT') {
      if (!formValues.assertion.type) {
        return 'Assertion type is required';
      }
      
      if (!['exists', 'notExists', 'visible', 'notVisible', 'enabled', 'disabled', 'checked', 'notChecked'].includes(formValues.assertion.type) && 
          !formValues.assertion.expected.trim()) {
        return 'Expected value is required for this assertion type';
      }
    }
    
    return null;
  };
  
  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const validationError = validateForm();
    if (validationError) {
      alert(validationError);
      return;
    }
    
    // If this is an assertion step without a name, use a default name
    let finalValues = { ...formValues };
    if (formValues.action === 'ASSERT' && !formValues.name.trim()) {
      const assertionType = ASSERTION_TYPES.find(type => type.value === formValues.assertion.type);
      finalValues.name = `Assert ${assertionType?.label || formValues.assertion.type}`;
    }
    
    onSave(finalValues);
  };
  
  // Generate a suggestion for step name based on current action and target
  const suggestStepName = () => {
    const action = ACTION_TYPES.find(a => a.value === formValues.action);
    
    if (!action) return '';
    
    let suggestion = action.label;
    
    if (formValues.target) {
      suggestion += ` ${formValues.target}`;
    } else if (formValues.selector && ['id', 'name', 'linkText', 'partialLinkText'].includes(formValues.selectorType)) {
      suggestion += ` ${formValues.selector}`;
    }
    
    if (formValues.action === 'TYPE' && formValues.value) {
      suggestion += `: "${formValues.value.substring(0, 20)}${formValues.value.length > 20 ? '...' : ''}"`;
    }
    
    return suggestion;
  };
  
  // Auto-generate a step name if the name field is empty and we have enough information
  const handleGenerateStepName = () => {
    const suggestion = suggestStepName();
    if (suggestion) {
      setFormValues(prev => ({
        ...prev,
        name: suggestion
      }));
    }
  };
  
  return (
    <Box component="form" onSubmit={handleSubmit} noValidate>
      {/* Tabs */}
      <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
        <Tabs value={tabValue} onChange={handleTabChange} aria-label="step form tabs">
          <Tab label="Basic Info" id="step-form-tab-0" />
          <Tab label="Advanced" id="step-form-tab-1" />
          <Tab label="Natural Language" id="step-form-tab-2" />
        </Tabs>
      </Box>
      
      {/* Basic Info Tab */}
      <TabPanel value={tabValue} index={0}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <Box sx={{ display: 'flex', alignItems: 'flex-start' }}>
              <TextField
                name="name"
                label="Step Name"
                value={formValues.name}
                onChange={handleChange}
                fullWidth
                required
                error={!formValues.name.trim()}
                helperText={!formValues.name.trim() ? 'Step name is required' : ''}
                sx={{ mr: 1 }}
              />
              <Tooltip title="Auto-generate name">
                <IconButton onClick={handleGenerateStepName}>
                  <RefreshIcon />
                </IconButton>
              </Tooltip>
            </Box>
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              name="description"
              label="Description"
              value={formValues.description}
              onChange={handleChange}
              fullWidth
              multiline
              rows={2}
            />
          </Grid>
          
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel id="action-label">Action</InputLabel>
              <Select
                labelId="action-label"
                name="action"
                value={formValues.action}
                onChange={handleActionChange}
                label="Action"
              >
                {ACTION_TYPES.map(action => (
                  <MenuItem key={action.value} value={action.value}>
                    {action.label}
                  </MenuItem>
                ))}
              </Select>
              <FormHelperText>
                {ACTION_TYPES.find(a => a.value === formValues.action)?.description || ''}
              </FormHelperText>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel id="severity-label">Severity</InputLabel>
              <Select
                labelId="severity-label"
                name="severity"
                value={formValues.severity}
                onChange={handleChange}
                label="Severity"
              >
                <MenuItem value="BLOCKER">Blocker</MenuItem>
                <MenuItem value="CRITICAL">Critical</MenuItem>
                <MenuItem value="MAJOR">Major</MenuItem>
                <MenuItem value="NORMAL">Normal</MenuItem>
                <MenuItem value="MINOR">Minor</MenuItem>
                <MenuItem value="TRIVIAL">Trivial</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          
          {isSelectorRequired() && (
            <>
              <Grid item xs={12} md={6}>
                <FormControl fullWidth>
                  <InputLabel id="selector-type-label">Selector Type</InputLabel>
                  <Select
                    labelId="selector-type-label"
                    name="selectorType"
                    value={formValues.selectorType}
                    onChange={handleChange}
                    label="Selector Type"
                  >
                    {SELECTOR_TYPES.map(type => (
                      <MenuItem key={type.value} value={type.value}>
                        {type.label}
                      </MenuItem>
                    ))}
                  </Select>
                  <FormHelperText>
                    Example: {SELECTOR_TYPES.find(type => type.value === formValues.selectorType)?.example || ''}
                  </FormHelperText>
                </FormControl>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <TextField
                  name="selector"
                  label="Selector"
                  value={formValues.selector}
                  onChange={handleChange}
                  fullWidth
                  required={isSelectorRequired()}
                  error={isSelectorRequired() && !formValues.selector.trim()}
                  helperText={isSelectorRequired() && !formValues.selector.trim() ? 'Selector is required' : ''}
                />
              </Grid>
              
              <Grid item xs={12}>
                <TextField
                  name="target"
                  label="Target Description (Optional)"
                  value={formValues.target}
                  onChange={handleChange}
                  fullWidth
                  placeholder="E.g., Login Button, Username Field"
                  helperText="Human-readable description of the target element"
                />
              </Grid>
            </>
          )}
          
          {isValueApplicable() && (
            <Grid item xs={12}>
              {formValues.action === 'NAVIGATE' ? (
                <TextField
                  name="value"
                  label="URL"
                  value={formValues.value}
                  onChange={handleChange}
                  fullWidth
                  required
                  error={!formValues.value.trim()}
                  helperText={!formValues.value.trim() ? 'URL is required' : ''}
                />
              ) : formValues.action === 'WAIT' ? (
                <TextField
                  name="timeout"
                  label="Wait Time (ms)"
                  type="number"
                  value={formValues.timeout}
                  onChange={handleChange}
                  fullWidth
                  required
                  inputProps={{ min: 0 }}
                  error={!formValues.timeout || formValues.timeout <= 0}
                  helperText={!formValues.timeout || formValues.timeout <= 0 ? 'Valid wait time is required' : ''}
                />
              ) : formValues.action === 'EXECUTE_SCRIPT' ? (
                <TextField
                  name="value"
                  label="JavaScript Code"
                  value={formValues.value}
                  onChange={handleChange}
                  fullWidth
                  required
                  multiline
                  rows={4}
                  error={!formValues.value.trim()}
                  helperText={!formValues.value.trim() ? 'JavaScript code is required' : ''}
                />
              ) : formValues.action === 'TYPE' ? (
                <TextField
                  name="value"
                  label="Text to Type"
                  value={formValues.value}
                  onChange={handleChange}
                  fullWidth
                  required
                  error={!formValues.value.trim()}
                  helperText={!formValues.value.trim() ? 'Text is required' : ''}
                />
              ) : (
                <TextField
                  name="value"
                  label="Value"
                  value={formValues.value}
                  onChange={handleChange}
                  fullWidth
                />
              )}
            </Grid>
          )}
          
          {formValues.action === 'ASSERT' && (
            <>
              <Grid item xs={12}>
                <Typography variant="subtitle1" gutterBottom>
                  Assertion Settings
                </Typography>
                <Paper variant="outlined" sx={{ p: 2 }}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} md={6}>
                      <FormControl fullWidth>
                        <InputLabel id="assertion-type-label">Assertion Type</InputLabel>
                        <Select
                          labelId="assertion-type-label"
                          name="assertion.type"
                          value={formValues.assertion.type}
                          onChange={handleChange}
                          label="Assertion Type"
                        >
                          {ASSERTION_TYPES.map(type => (
                            <MenuItem key={type.value} value={type.value}>
                              {type.label}
                            </MenuItem>
                          ))}
                        </Select>
                        <FormHelperText>
                          {ASSERTION_TYPES.find(type => type.value === formValues.assertion.type)?.description || ''}
                        </FormHelperText>
                      </FormControl>
                    </Grid>
                    
                    {!['exists', 'notExists', 'visible', 'notVisible', 'enabled', 'disabled', 'checked', 'notChecked'].includes(formValues.assertion.type) && (
                      <Grid item xs={12} md={6}>
                        <TextField
                          name="assertion.expected"
                          label="Expected Value"
                          value={formValues.assertion.expected}
                          onChange={handleChange}
                          fullWidth
                          required
                          error={!formValues.assertion.expected.trim()}
                          helperText={!formValues.assertion.expected.trim() ? 'Expected value is required' : ''}
                        />
                      </Grid>
                    )}
                    
                    <Grid item xs={12} md={6}>
                      <FormControl fullWidth>
                        <InputLabel id="assertion-property-label">Property</InputLabel>
                        <Select
                          labelId="assertion-property-label"
                          name="assertion.property"
                          value={formValues.assertion.property}
                          onChange={handleChange}
                          label="Property"
                        >
                          <MenuItem value="textContent">Text Content</MenuItem>
                          <MenuItem value="value">Value</MenuItem>
                          <MenuItem value="innerText">Inner Text</MenuItem>
                          <MenuItem value="innerHTML">Inner HTML</MenuItem>
                          <MenuItem value="className">Class Name</MenuItem>
                          <MenuItem value="attribute">Custom Attribute</MenuItem>
                        </Select>
                      </FormControl>
                    </Grid>
                    
                    {formValues.assertion.property === 'attribute' && (
                      <Grid item xs={12} md={6}>
                        <TextField
                          name="assertion.attribute"
                          label="Attribute Name"
                          value={formValues.assertion.attribute || ''}
                          onChange={handleChange}
                          fullWidth
                          required
                        />
                      </Grid>
                    )}
                  </Grid>
                </Paper>
              </Grid>
            </>
          )}
          
          <Grid item xs={12}>
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 2 }}>
              <FormControlLabel
                control={
                  <Switch
                    name="disabled"
                    checked={formValues.disabled}
                    onChange={handleChange}
                  />
                }
                label="Disabled"
              />
              
              <FormControlLabel
                control={
                  <Switch
                    name="screenshot"
                    checked={formValues.screenshot}
                    onChange={handleChange}
                  />
                }
                label="Take Screenshot"
              />
              
              {['CLICK', 'NAVIGATE', 'SUBMIT'].includes(formValues.action) && (
                <FormControlLabel
                  control={
                    <Switch
                      name="waitForNavigation"
                      checked={formValues.waitForNavigation}
                      onChange={handleChange}
                    />
                  }
                  label="Wait for Navigation"
                />
              )}
            </Box>
          </Grid>
        </Grid>
      </TabPanel>
      
      {/* Advanced Tab */}
      <TabPanel value={tabValue} index={1}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              name="timeout"
              label="Element Timeout (ms)"
              type="number"
              value={formValues.timeout}
              onChange={handleChange}
              fullWidth
              inputProps={{ min: 0 }}
              helperText="Maximum time to wait for element to appear (0 = use default timeout)"
            />
          </Grid>
          
          <Grid item xs={12}>
            <Typography variant="subtitle1" gutterBottom>
              Conditional Logic
            </Typography>
            <Alert severity="info" sx={{ mb: 2 }}>
              Conditional logic allows you to execute this step only if certain conditions are met.
              This feature will be implemented in a future update.
            </Alert>
          </Grid>
        </Grid>
      </TabPanel>
      
      {/* Natural Language Tab */}
      <TabPanel value={tabValue} index={2}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <Typography variant="subtitle1" gutterBottom>
              Generate Step from Natural Language
            </Typography>
            <Typography variant="body2" color="textSecondary" paragraph>
              Describe what you want to do in plain English, and we'll try to convert it into a test step.
            </Typography>
            
            <TextField
              label="Natural Language Description"
              value={nlpInput}
              onChange={(e) => setNlpInput(e.target.value)}
              fullWidth
              multiline
              rows={3}
              placeholder="E.g., Click the login button, Type hello@example.com in the email field"
              sx={{ mb: 2 }}
            />
            
            <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
              <Button
                variant="contained"
                startIcon={processingNlp ? null : <NlpIcon />}
                onClick={handleNlpProcessing}
                disabled={!nlpInput.trim() || processingNlp}
              >
                {processingNlp ? 'Processing...' : 'Generate Step'}
              </Button>
            </Box>
            
            {nlpError && (
              <Alert severity="error" sx={{ mt: 2 }}>
                {nlpError}
              </Alert>
            )}
            
            <Box sx={{ mt: 3 }}>
              <Typography variant="subtitle2" gutterBottom>
                Examples:
              </Typography>
              <Grid container spacing={1}>
                {[
                  'Click the "Login" button',
                  'Type "user@example.com" in the email field',
                  'Navigate to https://example.com',
                  'Select "Option 2" from the dropdown',
                  'Wait for the page to load',
                  'Check if the success message appears',
                  'Verify that the page title contains "Dashboard"'
                ].map((example, index) => (
                  <Grid item key={index}>
                    <Chip
                      label={example}
                      onClick={() => setNlpInput(example)}
                      sx={{ mr: 1, mb: 1 }}
                    />
                  </Grid>
                ))}
              </Grid>
            </Box>
          </Grid>
        </Grid>
      </TabPanel>
      
      {/* Form Buttons */}
      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 3 }}>
        <Button onClick={onCancel} sx={{ mr: 1 }}>
          Cancel
        </Button>
        <Button 
          variant="contained" 
          color="primary" 
          type="submit"
        >
          Save
        </Button>
      </Box>
    </Box>
  );
};

export default StepForm;
