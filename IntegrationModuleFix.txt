
## 1. IntegrationSettingsSchema.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Schema definition for integration settings
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSettingsSchema {

    /** Integration type this schema applies to */
    private String integrationType;

    /** Schema version */
    private String version;

    /** List of field definitions */
    private List<SettingsField> fields = new ArrayList<>();

    /** Additional validation rules for this schema */
    private Map<String, Object> validationRules = new HashMap<>();

    /** UI hints for rendering the settings form */
    private Map<String, Object> uiHints = new HashMap<>();

    /**
     * Definition of a settings field
     */
    public static class SettingsField {
        
        /** Field identifier */
        private String id;
        
        /** Field display name */
        private String name;
        
        /** Field description */
        private String description;
        
        /** Field type */
        private String type;
        
        /** Flag indicating if this field is required */
        private boolean required = false;
        
        /** Default value for this field */
        private Object defaultValue;
        
        /** Field validation constraints */
        private Map<String, Object> validation = new HashMap<>();
        
        /** Available options for select type */
        private List<Map<String, Object>> options = new ArrayList<>();
        
        /** UI hints for this field */
        private Map<String, Object> uiHints = new HashMap<>();

        // Getters and Setters
        public String getId() {
            return id;
        }

        public SettingsField setId(String id) {
            this.id = id;
            return this;
        }

        public String getName() {
            return name;
        }

        public SettingsField setName(String name) {
            this.name = name;
            return this;
        }

        public String getDescription() {
            return description;
        }

        public SettingsField setDescription(String description) {
            this.description = description;
            return this;
        }

        public String getType() {
            return type;
        }

        public SettingsField setType(String type) {
            this.type = type;
            return this;
        }

        public boolean isRequired() {
            return required;
        }

        public SettingsField setRequired(boolean required) {
            this.required = required;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public SettingsField setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }

        public Map<String, Object> getValidation() {
            return validation;
        }

        public SettingsField setValidation(Map<String, Object> validation) {
            this.validation = validation;
            return this;
        }

        public List<Map<String, Object>> getOptions() {
            return options;
        }

        public SettingsField setOptions(List<Map<String, Object>> options) {
            this.options = options;
            return this;
        }

        public Map<String, Object> getUiHints() {
            return uiHints;
        }

        public SettingsField setUiHints(Map<String, Object> uiHints) {
            this.uiHints = uiHints;
            return this;
        }
    }

    // Getters and Setters
    public String getIntegrationType() {
        return integrationType;
    }

    public IntegrationSettingsSchema setIntegrationType(String integrationType) {
        this.integrationType = integrationType;
        return this;
    }

    public String getVersion() {
        return version;
    }

    public IntegrationSettingsSchema setVersion(String version) {
        this.version = version;
        return this;
    }

    public List<SettingsField> getFields() {
        return fields;
    }

    public IntegrationSettingsSchema setFields(List<SettingsField> fields) {
        this.fields = fields;
        return this;
    }

    public Map<String, Object> getValidationRules() {
        return validationRules;
    }

    public IntegrationSettingsSchema setValidationRules(Map<String, Object> validationRules) {
        this.validationRules = validationRules;
        return this;
    }

    public Map<String, Object> getUiHints() {
        return uiHints;
    }

    public IntegrationSettingsSchema setUiHints(Map<String, Object> uiHints) {
        this.uiHints = uiHints;
        return this;
    }
}
```

## 2. IntegrationTestResult.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Result of testing an integration connection
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationTestResult {

    /** Integration ID */
    private Long integrationId;

    /** Flag indicating if the test was successful */
    private boolean successful;

    /** Status message */
    private String message;

    /** Error code if the test failed */
    private String errorCode;

    /** Detailed error message if the test failed */
    private String errorDetail;

    /** Timestamp of the test */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime testedAt;

    /** Connection details retrieved from the integration */
    private Map<String, Object> connectionDetails = new HashMap<>();

    /** Test steps and their results */
    private List<TestStep> testSteps = new ArrayList<>();

    /** Response time in milliseconds */
    private Long responseTimeMs;

    /**
     * Individual test step and its result
     */
    public static class TestStep {
        
        /** Step name */
        private String name;
        
        /** Step description */
        private String description;
        
        /** Flag indicating if this step was successful */
        private boolean successful;
        
        /** Status message for this step */
        private String message;
        
        /** Execution time of this step in milliseconds */
        private Long executionTimeMs;

        // Getters and Setters
        public String getName() {
            return name;
        }

        public TestStep setName(String name) {
            this.name = name;
            return this;
        }

        public String getDescription() {
            return description;
        }

        public TestStep setDescription(String description) {
            this.description = description;
            return this;
        }

        public boolean isSuccessful() {
            return successful;
        }

        public TestStep setSuccessful(boolean successful) {
            this.successful = successful;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public TestStep setMessage(String message) {
            this.message = message;
            return this;
        }

        public Long getExecutionTimeMs() {
            return executionTimeMs;
        }

        public TestStep setExecutionTimeMs(Long executionTimeMs) {
            this.executionTimeMs = executionTimeMs;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationTestResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationTestResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationTestResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationTestResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationTestResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getTestedAt() {
        return testedAt;
    }

    public IntegrationTestResult setTestedAt(LocalDateTime testedAt) {
        this.testedAt = testedAt;
        return this;
    }

    public Map<String, Object> getConnectionDetails() {
        return connectionDetails;
    }

    public IntegrationTestResult setConnectionDetails(Map<String, Object> connectionDetails) {
        this.connectionDetails = connectionDetails;
        return this;
    }

    public List<TestStep> getTestSteps() {
        return testSteps;
    }

    public IntegrationTestResult setTestSteps(List<TestStep> testSteps) {
        this.testSteps = testSteps;
        return this;
    }

    public Long getResponseTimeMs() {
        return responseTimeMs;
    }

    public IntegrationTestResult setResponseTimeMs(Long responseTimeMs) {
        this.responseTimeMs = responseTimeMs;
        return this;
    }
}
```

## 3. IntegrationSyncOptions.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Options for synchronizing with an external system
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSyncOptions {

    /** Direction of synchronization */
    private String direction = "PULL";

    /** Content types to synchronize */
    private List<String> contentTypes = new ArrayList<>();

    /** Filters to apply during synchronization */
    private Map<String, Object> filters = new HashMap<>();

    /** Flag to force sync even if no changes detected */
    private boolean forceSync = false;

    /** Flag to only perform a dry run without making changes */
    private boolean dryRun = false;

    /** Maximum items to sync per content type */
    private Integer maxItems;

    /** Conflict resolution strategy */
    private String conflictResolution = "LATEST_WINS";

    /** Additional options specific to the integration type */
    private Map<String, Object> additionalOptions = new HashMap<>();

    /** Azure DevOps project to sync with */
    private String adoProject;

    /** Azure DevOps team to sync with */
    private String adoTeam;

    /** Azure DevOps test plan ID to sync with */
    private Long adoTestPlanId;

    /** Azure DevOps test suite ID to sync with */
    private Long adoTestSuiteId;

    /** Azure DevOps work item query to sync with */
    private String adoWorkItemQuery;

    /** Azure DevOps Git repository ID to sync with */
    private String adoGitRepositoryId;

    /** Azure DevOps Git branch to sync with */
    private String adoGitBranch;

    /** Path pattern for files to sync in Git */
    private String adoGitPathPattern;

    /** Azure DevOps test run title format */
    private String adoTestRunTitleFormat;

    /** Azure DevOps test run status */
    private String adoTestRunStatus;

    /** Flag to include attachments in operations */
    private boolean includeAttachments = true;
    
    /** File extensions to filter by when using Git */
    private List<String> adoGitFileExtensions = new ArrayList<>();
    
    /** Base path for Git operations */
    private String adoGitBasePath;
    
    /** Commit message format for Git operations */
    private String adoGitCommitMessageFormat;
    
    /** Git file format */
    private String adoGitFileFormat;
    
    /** Flag to create Git branch if it doesn't exist */
    private boolean adoGitCreateBranch = false;

    /** Proxy settings to use during synchronization */
    private ProxySettings proxySettings;

    /**
     * Proxy settings for integration connections
     */
    public static class ProxySettings {
        
        /** Proxy host */
        private String host;
        
        /** Proxy port */
        private Integer port;
        
        /** Proxy username if authentication is required */
        private String username;
        
        /** Proxy password if authentication is required */
        private String password;
        
        /** Non-proxy hosts (hosts that shouldn't use the proxy) */
        private String nonProxyHosts;

        // Getters and Setters
        public String getHost() {
            return host;
        }

        public ProxySettings setHost(String host) {
            this.host = host;
            return this;
        }

        public Integer getPort() {
            return port;
        }

        public ProxySettings setPort(Integer port) {
            this.port = port;
            return this;
        }

        public String getUsername() {
            return username;
        }

        public ProxySettings setUsername(String username) {
            this.username = username;
            return this;
        }

        public String getPassword() {
            return password;
        }

        public ProxySettings setPassword(String password) {
            this.password = password;
            return this;
        }

        public String getNonProxyHosts() {
            return nonProxyHosts;
        }

        public ProxySettings setNonProxyHosts(String nonProxyHosts) {
            this.nonProxyHosts = nonProxyHosts;
            return this;
        }
    }

    // Getters and Setters
    public String getDirection() {
        return direction;
    }

    public IntegrationSyncOptions setDirection(String direction) {
        this.direction = direction;
        return this;
    }

    public List<String> getContentTypes() {
        return contentTypes;
    }

    public IntegrationSyncOptions setContentTypes(List<String> contentTypes) {
        this.contentTypes = contentTypes;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationSyncOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isForceSync() {
        return forceSync;
    }

    public IntegrationSyncOptions setForceSync(boolean forceSync) {
        this.forceSync = forceSync;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationSyncOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationSyncOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public String getConflictResolution() {
        return conflictResolution;
    }

    public IntegrationSyncOptions setConflictResolution(String conflictResolution) {
        this.conflictResolution = conflictResolution;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationSyncOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationSyncOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationSyncOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationSyncOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationSyncOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public String getAdoWorkItemQuery() {
        return adoWorkItemQuery;
    }

    public IntegrationSyncOptions setAdoWorkItemQuery(String adoWorkItemQuery) {
        this.adoWorkItemQuery = adoWorkItemQuery;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationSyncOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationSyncOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitPathPattern() {
        return adoGitPathPattern;
    }

    public IntegrationSyncOptions setAdoGitPathPattern(String adoGitPathPattern) {
        this.adoGitPathPattern = adoGitPathPattern;
        return this;
    }

    public ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationSyncOptions setProxySettings(ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
    
    public String getAdoTestRunTitleFormat() {
        return adoTestRunTitleFormat;
    }

    public IntegrationSyncOptions setAdoTestRunTitleFormat(String adoTestRunTitleFormat) {
        this.adoTestRunTitleFormat = adoTestRunTitleFormat;
        return this;
    }

    public String getAdoTestRunStatus() {
        return adoTestRunStatus;
    }

    public IntegrationSyncOptions setAdoTestRunStatus(String adoTestRunStatus) {
        this.adoTestRunStatus = adoTestRunStatus;
        return this;
    }

    public boolean isIncludeAttachments() {
        return includeAttachments;
    }

    public IntegrationSyncOptions setIncludeAttachments(boolean includeAttachments) {
        this.includeAttachments = includeAttachments;
        return this;
    }

    public List<String> getAdoGitFileExtensions() {
        return adoGitFileExtensions;
    }

    public IntegrationSyncOptions setAdoGitFileExtensions(List<String> adoGitFileExtensions) {
        this.adoGitFileExtensions = adoGitFileExtensions;
        return this;
    }

    public String getAdoGitBasePath() {
        return adoGitBasePath;
    }

    public IntegrationSyncOptions setAdoGitBasePath(String adoGitBasePath) {
        this.adoGitBasePath = adoGitBasePath;
        return this;
    }

    public String getAdoGitCommitMessageFormat() {
        return adoGitCommitMessageFormat;
    }

    public IntegrationSyncOptions setAdoGitCommitMessageFormat(String adoGitCommitMessageFormat) {
        this.adoGitCommitMessageFormat = adoGitCommitMessageFormat;
        return this;
    }

    public String getAdoGitFileFormat() {
        return adoGitFileFormat;
    }

    public IntegrationSyncOptions setAdoGitFileFormat(String adoGitFileFormat) {
        this.adoGitFileFormat = adoGitFileFormat;
        return this;
    }

    public boolean isAdoGitCreateBranch() {
        return adoGitCreateBranch;
    }

    public IntegrationSyncOptions setAdoGitCreateBranch(boolean adoGitCreateBranch) {
        this.adoGitCreateBranch = adoGitCreateBranch;
        return this;
    }
}
```

## 4. IntegrationSyncResult.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Result of an integration synchronization operation
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSyncResult {

    /** Integration ID */
    private Long integrationId;

    /** Flag indicating if the sync was successful */
    private boolean successful;

    /** Status message */
    private String message;

    /** Error code if the sync failed */
    private String errorCode;

    /** Detailed error message if the sync failed */
    private String errorDetail;

    /** Start timestamp of the sync operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    /** Completion timestamp of the sync operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    /** Duration of the sync operation in milliseconds */
    private Long durationMs;

    /** Sync statistics per content type */
    private Map<String, SyncStats> stats = new HashMap<>();

    /** List of sync issues encountered */
    private List<SyncIssue> issues = new ArrayList<>();

    /** Sync direction that was performed */
    private String direction;

    /** Flag indicating if this was a dry run */
    private boolean dryRun;

    /** Azure DevOps test run ID created during sync */
    private Long adoTestRunId;

    /** Azure DevOps test run URL */
    private String adoTestRunUrl;

    /** Azure DevOps Git commit ID */
    private String adoGitCommitId;

    /** Azure DevOps Git commit URL */
    private String adoGitCommitUrl;

    /** URLs to exported resources in the external system */
    private Map<String, String> exportedUrls = new HashMap<>();

    /**
     * Synchronization statistics for a content type
     */
    public static class SyncStats {
        
        /** Content type */
        private String contentType;
        
        /** Total items processed */
        private int totalProcessed;
        
        /** New items created */
        private int created;
        
        /** Existing items updated */
        private int updated;
        
        /** Items deleted */
        private int deleted;
        
        /** Items skipped (no changes) */
        private int skipped;
        
        /** Items with errors */
        private int errors;
        
        /** Items with conflicts */
        private int conflicts;
        
        /** Additional statistics specific to content type */
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public String getContentType() {
            return contentType;
        }

        public SyncStats setContentType(String contentType) {
            this.contentType = contentType;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public SyncStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public SyncStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public SyncStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getDeleted() {
            return deleted;
        }

        public SyncStats setDeleted(int deleted) {
            this.deleted = deleted;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public SyncStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public SyncStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getConflicts() {
            return conflicts;
        }

        public SyncStats setConflicts(int conflicts) {
            this.conflicts = conflicts;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public SyncStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    /**
     * Issue encountered during synchronization
     */
    public static class SyncIssue {
        
        /** Issue severity */
        private String severity;
        
        /** Content type */
        private String contentType;
        
        /** Item ID */
        private String itemId;
        
        /** Issue message */
        private String message;
        
        /** Issue code */
        private String code;
        
        /** Additional details about the issue */
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public SyncIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public String getContentType() {
            return contentType;
        }

        public SyncIssue setContentType(String contentType) {
            this.contentType = contentType;
            return this;
        }

        public String getItemId() {
            return itemId;
        }

        public SyncIssue setItemId(String itemId) {
            this.itemId = itemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public SyncIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public SyncIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public SyncIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationSyncResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationSyncResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationSyncResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationSyncResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationSyncResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationSyncResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationSyncResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationSyncResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public Map<String, SyncStats> getStats() {
        return stats;
    }

    public IntegrationSyncResult setStats(Map<String, SyncStats> stats) {
        this.stats = stats;
        return this;
    }

    public List<SyncIssue> getIssues() {
        return issues;
    }

    public IntegrationSyncResult setIssues(List<SyncIssue> issues) {
        this.issues = issues;
        return this;
    }

    public String getDirection() {
        return direction;
    }

    public IntegrationSyncResult setDirection(String direction) {
        this.direction = direction;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationSyncResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Long getAdoTestRunId() {
        return adoTestRunId;
    }

    public IntegrationSyncResult setAdoTestRunId(Long adoTestRunId) {
        this.adoTestRunId = adoTestRunId;
        return this;
    }

    public String getAdoTestRunUrl() {
        return adoTestRunUrl;
    }

    public IntegrationSyncResult setAdoTestRunUrl(String adoTestRunUrl) {
        this.adoTestRunUrl = adoTestRunUrl;
        return this;
    }

    public String getAdoGitCommitId() {
        return adoGitCommitId;
    }

    public IntegrationSyncResult setAdoGitCommitId(String adoGitCommitId) {
        this.adoGitCommitId = adoGitCommitId;
        return this;
    }

    public String getAdoGitCommitUrl() {
        return adoGitCommitUrl;
    }

    public IntegrationSyncResult setAdoGitCommitUrl(String adoGitCommitUrl) {
        this.adoGitCommitUrl = adoGitCommitUrl;
        return this;
    }

    public Map<String, String> getExportedUrls() {
        return exportedUrls;
    }

    public IntegrationSyncResult setExportedUrls(Map<String, String> exportedUrls) {
        this.exportedUrls = exportedUrls;
        return this;
    }
}
```

## 5. IntegrationImportOptions.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Options for importing data from an external system
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationImportOptions {

    /** Content type to import */
    private String contentType;

    /** Target folder ID to import into */
    private Long targetFolderId;

    /** Filters to apply during import */
    private Map<String, Object> filters = new HashMap<>();

    /** Flag to overwrite existing items */
    private boolean overwriteExisting = false;

    /** Flag to only perform a dry run without making changes */
    private boolean dryRun = false;

    /** Maximum items to import */
    private Integer maxItems;

    /** Flag to include child items in the import */
    private boolean includeChildren = true;

    /** Flag to include attachments in the import */
    private boolean includeAttachments = true;

    /** Additional options specific to the integration type */
    private Map<String, Object> additionalOptions = new HashMap<>();

    /** Azure DevOps project to import from */
    private String adoProject;

    /** Azure DevOps team to import from */
    private String adoTeam;

    /** Azure DevOps test plan ID to import from */
    private Long adoTestPlanId;

    /** Azure DevOps test suite ID to import from */
    private Long adoTestSuiteId;

    /** Azure DevOps work item IDs to import */
    private List<Long> adoWorkItemIds = new ArrayList<>();

    /** Azure DevOps work item query to import from */
    private String adoWorkItemQuery;

    /** Azure DevOps area path to import from */
    private String adoAreaPath;

    /** Azure DevOps iteration path to import from */
    private String adoIterationPath;

    /** Azure DevOps Git repository ID to import from */
    private String adoGitRepositoryId;

    /** Azure DevOps Git branch to import from */
    private String adoGitBranch;

    /** Path pattern for files to import from Git */
    private String adoGitPathPattern;

    /** File extensions to filter by when importing from Git */
    private List<String> adoGitFileExtensions = new ArrayList<>();

    /** Flag to only import files changed since last import */
    private boolean adoGitOnlyChangedFiles = false;

    /** Commit ID to import from (if not latest) */
    private String adoGitCommitId;

    /** Field mappings for import */
    private List<FieldMapping> fieldMappings = new ArrayList<>();

    /** Proxy settings to use during import */
    private IntegrationSyncOptions.ProxySettings proxySettings;

    /**
     * Mapping between external system field and local field
     */
    public static class FieldMapping {
        
        /** Source field in external system */
        private String sourceField;
        
        /** Target field in CS Test Forge */
        private String targetField;
        
        /** Transformation to apply during mapping */
        private String transformation;
        
        /** Default value to use if source field is empty */
        private Object defaultValue;

        // Getters and Setters
        public String getSourceField() {
            return sourceField;
        }

        public FieldMapping setSourceField(String sourceField) {
            this.sourceField = sourceField;
            return this;
        }

        public String getTargetField() {
            return targetField;
        }

        public FieldMapping setTargetField(String targetField) {
            this.targetField = targetField;
            return this;
        }

        public String getTransformation() {
            return transformation;
        }

        public FieldMapping setTransformation(String transformation) {
            this.transformation = transformation;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public FieldMapping setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }
    }

    // Getters and Setters
    public String getContentType() {
        return contentType;
    }

    public IntegrationImportOptions setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public Long getTargetFolderId() {
        return targetFolderId;
    }

    public IntegrationImportOptions setTargetFolderId(Long targetFolderId) {
        this.targetFolderId = targetFolderId;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationImportOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isOverwriteExisting() {
        return overwriteExisting;
    }

    public IntegrationImportOptions setOverwriteExisting(boolean overwriteExisting) {
        this.overwriteExisting = overwriteExisting;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationImportOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationImportOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public boolean isIncludeChildren() {
        return includeChildren;
    }

    public IntegrationImportOptions setIncludeChildren(boolean includeChildren) {
        this.includeChildren = includeChildren;
        return this;
    }

    public boolean isIncludeAttachments() {
        return includeAttachments;
    }

    public IntegrationImportOptions setIncludeAttachments(boolean includeAttachments) {
        this.includeAttachments = includeAttachments;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationImportOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationImportOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationImportOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationImportOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationImportOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public List<Long> getAdoWorkItemIds() {
        return adoWorkItemIds;
    }

    public IntegrationImportOptions setAdoWorkItemIds(List<Long> adoWorkItemIds) {
        this.adoWorkItemIds = adoWorkItemIds;
        return this;
    }

    public String getAdoWorkItemQuery() {
        return adoWorkItemQuery;
    }

    public IntegrationImportOptions setAdoWorkItemQuery(String adoWorkItemQuery) {
        this.adoWorkItemQuery = adoWorkItemQuery;
        return this;
    }

    public String getAdoAreaPath() {
        return adoAreaPath;
    }

    public IntegrationImportOptions setAdoAreaPath(String adoAreaPath) {
        this.adoAreaPath = adoAreaPath;
        return this;
    }

    public String getAdoIterationPath() {
        return adoIterationPath;
    }

    public IntegrationImportOptions setAdoIterationPath(String adoIterationPath) {
        this.adoIterationPath = adoIterationPath;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationImportOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationImportOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitPathPattern() {
        return adoGitPathPattern;
    }

    public IntegrationImportOptions setAdoGitPathPattern(String adoGitPathPattern) {
        this.adoGitPathPattern = adoGitPathPattern;
        return this;
    }

    public List<String> getAdoGitFileExtensions() {
        return adoGitFileExtensions;
    }

    public IntegrationImportOptions setAdoGitFileExtensions(List<String> adoGitFileExtensions) {
        this.adoGitFileExtensions = adoGitFileExtensions;
        return this;
    }

    public boolean isAdoGitOnlyChangedFiles() {
        return adoGitOnlyChangedFiles;
    }

    public IntegrationImportOptions setAdoGitOnlyChangedFiles(boolean adoGitOnlyChangedFiles) {
        this.adoGitOnlyChangedFiles = adoGitOnlyChangedFiles;
        return this;
    }

    public String getAdoGitCommitId() {
        return adoGitCommitId;
    }

    public IntegrationImportOptions setAdoGitCommitId(String adoGitCommitId) {
        this.adoGitCommitId = adoGitCommitId;
        return this;
    }

    public List<FieldMapping> getFieldMappings() {
        return fieldMappings;
    }

    public IntegrationImportOptions setFieldMappings(List<FieldMapping> fieldMappings) {
        this.fieldMappings = fieldMappings;
        return this;
    }

    public IntegrationSyncOptions.ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationImportOptions setProxySettings(IntegrationSyncOptions.ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
}
```

## 6. IntegrationImportResult.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Result of importing data from an external system
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationImportResult {

    /** Integration ID */
    private Long integrationId;

    /** Flag indicating if the import was successful */
    private boolean successful;

    /** Status message */
    private String message;

    /** Error code if the import failed */
    private String errorCode;

    /** Detailed error message if the import failed */
    private String errorDetail;

    /** Start timestamp of the import operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    /** Completion timestamp of the import operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    /** Duration of the import operation in milliseconds */
    private Long durationMs;

    /** Content type that was imported */
    private String contentType;

    /** Target folder ID that was imported into */
    private Long targetFolderId;

    /** Import statistics */
    private ImportStats stats = new ImportStats();

    /** List of issues encountered during import */
    private List<ImportIssue> issues = new ArrayList<>();

    /** Flag indicating if this was a dry run */
    private boolean dryRun;

    /** Imported items details */
    private List<ImportedItem> importedItems = new ArrayList<>();

    /**
     * Statistics of the import operation
     */
    public static class ImportStats {
        
        /** Total items found in the external system */
        private int totalFound;
        
        /** Total items processed during import */
        private int totalProcessed;
        
        /** New items created */
        private int created;
        
        /** Existing items updated */
        private int updated;
        
        /** Items skipped (filtered out or errors) */
        private int skipped;
        
        /** Items with errors */
        private int errors;
        
        /** Total attachments imported */
        private int attachmentsImported;
        
        /** Total child items imported */
        private int childItemsImported;
        
        /** Additional statistics specific to content type */
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public int getTotalFound() {
            return totalFound;
        }

        public ImportStats setTotalFound(int totalFound) {
            this.totalFound = totalFound;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public ImportStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public ImportStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public ImportStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public ImportStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public ImportStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getAttachmentsImported() {
            return attachmentsImported;
        }

        public ImportStats setAttachmentsImported(int attachmentsImported) {
            this.attachmentsImported = attachmentsImported;
            return this;
        }

        public int getChildItemsImported() {
            return childItemsImported;
        }

        public ImportStats setChildItemsImported(int childItemsImported) {
            this.childItemsImported = childItemsImported;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public ImportStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    /**
     * Issue encountered during import
     */
    public static class ImportIssue {
        
        /** Issue severity */
        private String severity;
        
        /** External item ID */
        private String externalItemId;
        
        /** Issue message */
        private String message;
        
        /** Issue code */
        private String code;
        
        /** Additional details about the issue */
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public ImportIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public String getExternalItemId() {
            return externalItemId;
        }

        public ImportIssue setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public ImportIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public ImportIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public ImportIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    /**
     * Details of an imported item
     */
    public static class ImportedItem {
        
        /** External item ID */
        private String externalItemId;
        
        /** Local item ID */
        private Long localItemId;
        
        /** Item name or title */
        private String name;
        
        /** Import action performed */
        private String action;
        
        /** Additional properties about the imported item */
        private Map<String, Object> properties = new HashMap<>();

        // Getters and Setters
        public String getExternalItemId() {
            return externalItemId;
        }

        public ImportedItem setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public Long getLocalItemId() {
            return localItemId;
        }

        public ImportedItem setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getName() {
            return name;
        }

        public ImportedItem setName(String name) {
            this.name = name;
            return this;
        }

        public String getAction() {
            return action;
        }

        public ImportedItem setAction(String action) {
            this.action = action;
            return this;
        }

        public Map<String, Object> getProperties() {
            return properties;
        }

        public ImportedItem setProperties(Map<String, Object> properties) {
            this.properties = properties;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationImportResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationImportResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationImportResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationImportResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationImportResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationImportResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationImportResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationImportResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public String getContentType() {
        return contentType;
    }

    public IntegrationImportResult setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public Long getTargetFolderId() {
        return targetFolderId;
    }

    public IntegrationImportResult setTargetFolderId(Long targetFolderId) {
        this.targetFolderId = targetFolderId;
        return this;
    }

    public ImportStats getStats() {
        return stats;
    }

    public IntegrationImportResult setStats(ImportStats stats) {
        this.stats = stats;
        return this;
    }

    public List<ImportIssue> getIssues() {
        return issues;
    }

    public IntegrationImportResult setIssues(List<ImportIssue> issues) {
        this.issues = issues;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationImportResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public List<ImportedItem> getImportedItems() {
        return importedItems;
    }

    public IntegrationImportResult setImportedItems(List<ImportedItem> importedItems) {
        this.importedItems = importedItems;
        return this;
    }
}
```

## 7. IntegrationExportOptions.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Options for exporting data to an external system
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationExportOptions {

    /** Content type to export */
    private String contentType;

    /** List of item IDs to export */
    private List<Long> itemIds = new ArrayList<>();

    /** Folder ID containing items to export */
    private Long folderId;

    /** Filters to apply during export */
    private Map<String, Object> filters = new HashMap<>();

    /** Flag to only perform a dry run without making changes */
    private boolean dryRun = false;

    /** Maximum items to export */
    private Integer maxItems;

    /** Flag to include attachments in the export */
    private boolean includeAttachments = true;

    /** Flag to include screenshots in the export */
    private boolean includeScreenshots = true;

    /** Timestamp format for export */
    private String timestampFormat;

    /** Additional options specific to the integration type */
    private Map<String, Object> additionalOptions = new HashMap<>();

    /** Azure DevOps project to export to */
    private String adoProject;

    /** Azure DevOps team to export to */
    private String adoTeam;

    /** Azure DevOps test plan ID to export to */
    private Long adoTestPlanId;

    /** Azure DevOps test suite ID to export to */
    private Long adoTestSuiteId;

    /** Azure DevOps area path to export to */
    private String adoAreaPath;

    /** Azure DevOps test run title format */
    private String adoTestRunTitleFormat;

    /** Azure DevOps test run status to set */
    private String adoTestRunStatus;

    /** Flag to create new test runs in ADO */
    private boolean adoCreateNewTestRun = true;

    /** Flag to update existing test cases in ADO */
    private boolean adoUpdateExistingTestCases = true;

    /** Azure DevOps Git repository ID to export to */
    private String adoGitRepositoryId;

    /** Azure DevOps Git branch to export to */
    private String adoGitBranch;

    /** Base path for files to export to Git */
    private String adoGitBasePath;

    /** Commit message format */
    private String adoGitCommitMessageFormat;

    /** Azure DevOps Git file format */
    private String adoGitFileFormat;

    /** Flag to create new branch if it doesn't exist */
    private boolean adoGitCreateBranch = false;

    /** Field mappings for export */
    private List<FieldMapping> fieldMappings = new ArrayList<>();

    /** Proxy settings to use during export */
    private IntegrationSyncOptions.ProxySettings proxySettings;

    /**
     * Mapping between local field and external system field
     */
    public static class FieldMapping {
        
        /** Source field in CS Test Forge */
        private String sourceField;
        
        /** Target field in external system */
        private String targetField;
        
        /** Transformation to apply during mapping */
        private String transformation;
        
        /** Default value to use if source field is empty */
        private Object defaultValue;

        // Getters and Setters
        public String getSourceField() {
            return sourceField;
        }

        public FieldMapping setSourceField(String sourceField) {
            this.sourceField = sourceField;
            return this;
        }

        public String getTargetField() {
            return targetField;
        }

        public FieldMapping setTargetField(String targetField) {
            this.targetField = targetField;
            return this;
        }

        public String getTransformation() {
            return transformation;
        }

        public FieldMapping setTransformation(String transformation) {
            this.transformation = transformation;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public FieldMapping setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }
    }

    // Getters and Setters
    public String getContentType() {
        return contentType;
    }

    public IntegrationExportOptions setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public List<Long> getItemIds() {
        return itemIds;
    }

    public IntegrationExportOptions setItemIds(List<Long> itemIds) {
        this.itemIds = itemIds;
        return this;
    }

    public Long getFolderId() {
        return folderId;
    }

    public IntegrationExportOptions setFolderId(Long folderId) {
        this.folderId = folderId;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationExportOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationExportOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationExportOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public boolean isIncludeAttachments() {
        return includeAttachments;
    }

    public IntegrationExportOptions setIncludeAttachments(boolean includeAttachments) {
        this.includeAttachments = includeAttachments;
        return this;
    }

    public boolean isIncludeScreenshots() {
        return includeScreenshots;
    }

    public IntegrationExportOptions setIncludeScreenshots(boolean includeScreenshots) {
        this.includeScreenshots = includeScreenshots;
        return this;
    }

    public String getTimestampFormat() {
        return timestampFormat;
    }

    public IntegrationExportOptions setTimestampFormat(String timestampFormat) {
        this.timestampFormat = timestampFormat;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationExportOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationExportOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationExportOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationExportOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationExportOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public String getAdoAreaPath() {
        return adoAreaPath;
    }

    public IntegrationExportOptions setAdoAreaPath(String adoAreaPath) {
        this.adoAreaPath = adoAreaPath;
        return this;
    }

    public String getAdoTestRunTitleFormat() {
        return adoTestRunTitleFormat;
    }

    public IntegrationExportOptions setAdoTestRunTitleFormat(String adoTestRunTitleFormat) {
        this.adoTestRunTitleFormat = adoTestRunTitleFormat;
        return this;
    }

    public String getAdoTestRunStatus() {
        return adoTestRunStatus;
    }

    public IntegrationExportOptions setAdoTestRunStatus(String adoTestRunStatus) {
        this.adoTestRunStatus = adoTestRunStatus;
        return this;
    }

    public boolean isAdoCreateNewTestRun() {
        return adoCreateNewTestRun;
    }

    public IntegrationExportOptions setAdoCreateNewTestRun(boolean adoCreateNewTestRun) {
        this.adoCreateNewTestRun = adoCreateNewTestRun;
        return this;
    }

    public boolean isAdoUpdateExistingTestCases() {
        return adoUpdateExistingTestCases;
    }

    public IntegrationExportOptions setAdoUpdateExistingTestCases(boolean adoUpdateExistingTestCases) {
        this.adoUpdateExistingTestCases = adoUpdateExistingTestCases;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationExportOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationExportOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitBasePath() {
        return adoGitBasePath;
    }

    public IntegrationExportOptions setAdoGitBasePath(String adoGitBasePath) {
        this.adoGitBasePath = adoGitBasePath;
        return this;
    }

    public String getAdoGitCommitMessageFormat() {
        return adoGitCommitMessageFormat;
    }

    public IntegrationExportOptions setAdoGitCommitMessageFormat(String adoGitCommitMessageFormat) {
        this.adoGitCommitMessageFormat = adoGitCommitMessageFormat;
        return this;
    }

    public String getAdoGitFileFormat() {
        return adoGitFileFormat;
    }

    public IntegrationExportOptions setAdoGitFileFormat(String adoGitFileFormat) {
        this.adoGitFileFormat = adoGitFileFormat;
        return this;
    }

    public boolean isAdoGitCreateBranch() {
        return adoGitCreateBranch;
    }

    public IntegrationExportOptions setAdoGitCreateBranch(boolean adoGitCreateBranch) {
        this.adoGitCreateBranch = adoGitCreateBranch;
        return this;
    }

    public List<FieldMapping> getFieldMappings() {
        return fieldMappings;
    }

    public IntegrationExportOptions setFieldMappings(List<FieldMapping> fieldMappings) {
        this.fieldMappings = fieldMappings;
        return this;
    }

    public IntegrationSyncOptions.ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationExportOptions setProxySettings(IntegrationSyncOptions.ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
}
```

## 8. IntegrationExportResult.java

```java
package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Result of exporting data to an external system
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationExportResult {

    /** Integration ID */
    private Long integrationId;

    /** Flag indicating if the export was successful */
    private boolean successful;

    /** Status message */
    private String message;

    /** Error code if the export failed */
    private String errorCode;

    /** Detailed error message if the export failed */
    private String errorDetail;

    /** Start timestamp of the export operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    /** Completion timestamp of the export operation */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    /** Duration of the export operation in milliseconds */
    private Long durationMs;

    /** Content type that was exported */
    private String contentType;

    /** Export statistics */
    private ExportStats stats = new ExportStats();

    /** List of issues encountered during export */
    private List<ExportIssue> issues = new ArrayList<>();

    /** Flag indicating if this was a dry run */
    private boolean dryRun;

    /** Exported items details */
    private List<ExportedItem> exportedItems = new ArrayList<>();

    /** URLs to exported resources in the external system */
    private Map<String, String> exportedUrls = new HashMap<>();

    /** Azure DevOps test run ID created */
    private Long adoTestRunId;

    /** Azure DevOps test run URL */
    private String adoTestRunUrl;

    /** Azure DevOps Git commit ID */
    private String adoGitCommitId;

    /** Azure DevOps Git commit URL */
    private String adoGitCommitUrl;

    /**
     * Statistics of the export operation
     */
    public static class ExportStats {
        
        /** Total items selected for export */
        private int totalSelected;
        
        /** Total items processed during export */
        private int totalProcessed;
        
        /** New items created in the external system */
        private int created;
        
        /** Existing items updated in the external system */
        private int updated;
        
        /** Items skipped (filtered out or errors) */
        private int skipped;
        
        /** Items with errors */
        private int errors;
        
        /** Total attachments exported */
        private int attachmentsExported;
        
        /** Total screenshots exported */
        private int screenshotsExported;
        
        /** Additional statistics specific to content type */
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public int getTotalSelected() {
            return totalSelected;
        }

        public ExportStats setTotalSelected(int totalSelected) {
            this.totalSelected = totalSelected;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public ExportStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public ExportStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public ExportStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public ExportStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public ExportStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getAttachmentsExported() {
            return attachmentsExported;
        }

        public ExportStats setAttachmentsExported(int attachmentsExported) {
            this.attachmentsExported = attachmentsExported;
            return this;
        }

        public int getScreenshotsExported() {
            return screenshotsExported;
        }

        public ExportStats setScreenshotsExported(int screenshotsExported) {
            this.screenshotsExported = screenshotsExported;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public ExportStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    /**
     * Issue encountered during export
     */
    public static class ExportIssue {
        
        /** Issue severity */
        private String severity;
        
        /** Local item ID */
        private Long localItemId;
        
        /** Issue message */
        private String message;
        
        /** Issue code */
        private String code;
        
        /** Additional details about the issue */
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public ExportIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public Long getLocalItemId() {
            return localItemId;
        }

        public ExportIssue setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public ExportIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public ExportIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public ExportIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    /**
     * Details of an exported item
     */
    public static class ExportedItem {
        
        /** Local item ID */
        private Long localItemId;
        
        /** External item ID */
        private String externalItemId;
        
        /** Item name or title */
        private String name;
        
        /** Export action performed */
        private String action;
        
        /** URL to the item in the external system */
        private String externalUrl;
        
        /** Additional properties about the exported item */
        private Map<String, Object> properties = new HashMap<>();

        // Getters and Setters
        public Long getLocalItemId() {
            return localItemId;
        }

        public ExportedItem setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getExternalItemId() {
            return externalItemId;
        }

        public ExportedItem setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public String getName() {
            return name;
        }

        public ExportedItem setName(String name) {
            this.name = name;
            return this;
        }

        public String getAction() {
            return action;
        }

        public ExportedItem setAction(String action) {
            this.action = action;
            return this;
        }

        public String getExternalUrl() {
            return externalUrl;
        }

        public ExportedItem setExternalUrl(String externalUrl) {
            this.externalUrl = externalUrl;
            return this;
        }

        public Map<String, Object> getProperties() {
            return properties;
        }

        public ExportedItem setProperties(Map<String, Object> properties) {
            this.properties = properties;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationExportResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationExportResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationExportResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationExportResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationExportResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationExportResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationExportResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationExportResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public String getContentType() {
        return contentType;
    }

    public IntegrationExportResult setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public ExportStats getStats() {
        return stats;
    }

    public IntegrationExportResult setStats(ExportStats stats) {
        this.stats = stats;
        return this;
    }

    public List<ExportIssue> getIssues() {
        return issues;
    }

    public IntegrationExportResult setIssues(List<ExportIssue> issues) {
        this.issues = issues;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationExportResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public List<ExportedItem> getExportedItems() {
        return exportedItems;
    }

    public IntegrationExportResult setExportedItems(List<ExportedItem> exportedItems) {
        this.exportedItems = exportedItems;
        return this;
    }

    public Map<String, String> getExportedUrls() {
        return exportedUrls;
    }

    public IntegrationExportResult setExportedUrls(Map<String, String> exportedUrls) {
        this.exportedUrls = exportedUrls;
        return this;
    }

    public Long getAdoTestRunId() {
        return adoTestRunId;
    }

    public IntegrationExportResult setAdoTestRunId(Long adoTestRunId) {
        this.adoTestRunId = adoTestRunId;
        return this;
    }

    public String getAdoTestRunUrl() {
        return adoTestRunUrl;
    }

    public IntegrationExportResult setAdoTestRunUrl(String adoTestRunUrl) {
        this.adoTestRunUrl = adoTestRunUrl;
        return this;
    }

    public String getAdoGitCommitId() {
        return adoGitCommitId;
    }

    public IntegrationExportResult setAdoGitCommitId(String adoGitCommitId) {
        this.adoGitCommitId = adoGitCommitId;
        return this;
    }

    public String getAdoGitCommitUrl() {
        return adoGitCommitUrl;
    }

    public IntegrationExportResult setAdoGitCommitUrl(String adoGitCommitUrl) {
        this.adoGitCommitUrl = adoGitCommitUrl;
        return this;
    }
}
```

## 9. ResourceNotFoundException.java

```java
package com.cstestforge.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested resource is not found
 */
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    
    private String resourceName;
    private String fieldName;
    private Object fieldValue;

    /**
     * Constructor with resource details
     * 
     * @param resourceName Name of the resource
     * @param fieldName Name of the field
     * @param fieldValue Value of the field
     */
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s: '%s'", resourceName, fieldName, fieldValue));
        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }

    /**
     * Constructor with message
     * 
     * @param message Error message
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructor with message and cause
     * 
     * @param message Error message
     * @param cause The cause
     */
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * Get resource name
     * 
     * @return Resource name
     */
    public String getResourceName() {
        return resourceName;
    }

    /**
     * Get field name
     * 
     * @return Field name
     */
    public String getFieldName() {
        return fieldName;
    }

    /**
     * Get field value
     * 
     * @return Field value
     */
    public Object getFieldValue() {
        return fieldValue;
    }
}
```

## 10. StorageException.java

```java
package com.cstestforge.exception;

/**
 * Exception thrown when storage operations fail
 */
public class StorageException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor with message
     * 
     * @param message Error message
     */
    public StorageException(String message) {
        super(message);
    }

    /**
     * Constructor with message and cause
     * 
     * @param message Error message
     * @param cause The cause
     */
    public StorageException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## 11. HttpPatch.java

```java
package com.cstestforge.util.http;

import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;

import java.net.URI;

/**
 * HTTP PATCH method implementation
 * 
 * Apache HttpClient does not provide a built-in implementation of the PATCH method,
 * so we need to create our own class to support PATCH requests to Azure DevOps API.
 */
public class HttpPatch extends HttpEntityEnclosingRequestBase {

    /**
     * The HTTP PATCH method name
     */
    public static final String METHOD_NAME = "PATCH";

    /**
     * Default constructor
     */
    public HttpPatch() {
        super();
    }

    /**
     * Constructor with URI
     * 
     * @param uri The target URI
     */
    public HttpPatch(final URI uri) {
        super();
        setURI(uri);
    }

    /**
     * Constructor with URI string
     * 
     * @param uri The target URI string
     */
    public HttpPatch(final String uri) {
        super();
        setURI(URI.create(uri));
    }

    @Override
    public String getMethod() {
        return METHOD_NAME;
    }
}
```

## 12. IntegrationRepository.java

```java
package com.cstestforge.repository.integration;

import com.cstestforge.model.integration.Integration;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for integration data
 */
public interface IntegrationRepository {

    /**
     * Find all integrations for a project
     * 
     * @param projectId The project ID
     * @return List of integrations
     */
    List<Integration> findAllByProjectId(String projectId);

    /**
     * Find an integration by ID and project ID
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return The integration, if found
     */
    Optional<Integration> findByIdAndProjectId(String integrationId, String projectId);

    /**
     * Save an integration
     * 
     * @param integration The integration to save
     * @return The saved integration
     */
    Integration save(Integration integration);

    /**
     * Delete an integration
     * 
     * @param integration The integration to delete
     * @return True if the integration was deleted successfully
     */
    boolean delete(Integration integration);

    /**
     * Check if an integration exists
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return True if the integration exists
     */
    boolean existsByIdAndProjectId(String integrationId, String projectId);
}
```

## 13. FileSystemIntegrationRepository.java

```java
package com.cstestforge.repository.integration;

import com.cstestforge.exception.StorageException;
import com.cstestforge.model.integration.Integration;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * File system implementation of IntegrationRepository
 */
@Repository
public class FileSystemIntegrationRepository implements IntegrationRepository {

    private static final Logger logger = LoggerFactory.getLogger(FileSystemIntegrationRepository.class);
    
    private final ObjectMapper objectMapper;
    private final String dataDirectory;
    
    /**
     * Constructor
     * 
     * @param objectMapper JSON object mapper
     * @param dataDirectory Base directory for storing data
     */
    public FileSystemIntegrationRepository(
            ObjectMapper objectMapper,
            @Value("${app.data.directory:./data}") String dataDirectory) {
        this.objectMapper = objectMapper;
        this.dataDirectory = dataDirectory;
        
        // Ensure data directory exists
        createDirectoryIfNotExists(Paths.get(dataDirectory));
    }

    @Override
    public List<Integration> findAllByProjectId(String projectId) {
        logger.debug("Finding all integrations for project: {}", projectId);
        
        Path projectIntegrationsDir = getProjectIntegrationsDirectory(projectId);
        if (!Files.exists(projectIntegrationsDir)) {
            return new ArrayList<>();
        }
        
        try (Stream<Path> paths = Files.list(projectIntegrationsDir)) {
            return paths
                .filter(path -> path.toString().endsWith(".json"))
                .map(this::readIntegrationFromFile)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Error reading integrations for project: {}", projectId, e);
            throw new StorageException("Error reading integrations", e);
        }
    }

    @Override
    public Optional<Integration> findByIdAndProjectId(String integrationId, String projectId) {
        logger.debug("Finding integration: {} for project: {}", integrationId, projectId);
        
        Path integrationFile = getIntegrationFilePath(projectId, integrationId);
        if (!Files.exists(integrationFile)) {
            return Optional.empty();
        }
        
        return readIntegrationFromFile(integrationFile);
    }

    @Override
    public Integration save(Integration integration) {
        logger.debug("Saving integration: {}", integration.getId());
        
        // Ensure project directory exists
        Path projectDir = getProjectIntegrationsDirectory(integration.getProjectId().toString());
        createDirectoryIfNotExists(projectDir);
        
        // Generate ID if not provided
        if (integration.getId() == null) {
            integration.setId(generateId());
        }
        
        // Set timestamps
        LocalDateTime now = LocalDateTime.now();
        if (integration.getCreatedAt() == null) {
            integration.setCreatedAt(now);
        }
        integration.setUpdatedAt(now);
        
        // Write to file
        Path integrationFile = getIntegrationFilePath(
                integration.getProjectId().toString(), 
                integration.getId().toString());
        
        try {
            objectMapper.writeValue(integrationFile.toFile(), integration);
            logger.debug("Successfully saved integration: {}", integration.getId());
            return integration;
        } catch (IOException e) {
            logger.error("Error saving integration: {}", integration.getId(), e);
            throw new StorageException("Error saving integration", e);
        }
    }

    @Override
    public boolean delete(Integration integration) {
        logger.debug("Deleting integration: {}", integration.getId());
        
        Path integrationFile = getIntegrationFilePath(
                integration.getProjectId().toString(),
                integration.getId().toString());
        
        try {
            return Files.deleteIfExists(integrationFile);
        } catch (IOException e) {
            logger.error("Error deleting integration: {}", integration.getId(), e);
            throw new StorageException("Error deleting integration", e);
        }
    }

    @Override
    public boolean existsByIdAndProjectId(String integrationId, String projectId) {
        Path integrationFile = getIntegrationFilePath(projectId, integrationId);
        return Files.exists(integrationFile);
    }

    /**
     * Read integration from JSON file
     * 
     * @param filePath Path to the integration file
     * @return The integration, if successfully read
     */
    private Optional<Integration> readIntegrationFromFile(Path filePath) {
        try {
            Integration integration = objectMapper.readValue(filePath.toFile(), Integration.class);
            return Optional.of(integration);
        } catch (IOException e) {
            logger.error("Error reading integration file: {}", filePath, e);
            return Optional.empty();
        }
    }

    /**
     * Get the project integrations directory
     * 
     * @param projectId The project ID
     * @return Path to the project integrations directory
     */
    private Path getProjectIntegrationsDirectory(String projectId) {
        return Paths.get(dataDirectory, "projects", projectId, "integrations");
    }

    /**
     * Get the path to an integration file
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Path to the integration file
     */
    private Path getIntegrationFilePath(String projectId, String integrationId) {
        return getProjectIntegrationsDirectory(projectId)
                .resolve(integrationId + ".json");
    }

    /**
     * Create a directory if it doesn't exist
     * 
     * @param directory Path to the directory
     */
    private void createDirectoryIfNotExists(Path directory) {
        if (!Files.exists(directory)) {
            try {
                Files.createDirectories(directory);
                logger.debug("Created directory: {}", directory);
            } catch (IOException e) {
                logger.error("Error creating directory: {}", directory, e);
                throw new StorageException("Error creating directory", e);
            }
        }
    }

    /**
     * Generate a unique ID
     * 
     * @return A unique ID
     */
    private Long generateId() {
        return System.currentTimeMillis();
    }
}
```

## 14. ProxyConfig.java

```java
package com.cstestforge.config;

import com.cstestforge.model.integration.IntegrationSyncOptions;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.util.StringUtils;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Configuration for HTTP proxy
 */
@Configuration
public class ProxyConfig {

    private static final Logger logger = LoggerFactory.getLogger(ProxyConfig.class);
    
    @Value("${http.proxy.host:#{null}}")
    private String proxyHost;
    
    @Value("${http.proxy.port:0}")
    private int proxyPort;
    
    @Value("${http.proxy.username:#{null}}")
    private String proxyUsername;
    
    @Value("${http.proxy.password:#{null}}")
    private String proxyPassword;
    
    @Value("${http.proxy.nonProxyHosts:localhost|127.0.0.1}")
    private String nonProxyHosts;
    
    @Value("${http.connection.timeout:30000}")
    private int connectionTimeout;
    
    @Value("${http.socket.timeout:30000}")
    private int socketTimeout;
    
    @Value("${http.connection.request.timeout:30000}")
    private int connectionRequestTimeout;

    /**
     * Create a DefaultHttpClient with proxy settings from application properties
     * 
     * @return HttpClient with proxy settings
     */
    @Bean
    public CloseableHttpClient httpClient() {
        HttpClientBuilder clientBuilder = HttpClients.custom();
        
        // Set timeouts
        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                .setConnectTimeout(connectionTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout);
        
        // Configure proxy if set
        if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            logger.info("Configuring HTTP client with proxy: {}:{}", proxyHost, proxyPort);
            
            HttpHost proxy = new HttpHost(proxyHost, proxyPort);
            requestConfigBuilder.setProxy(proxy);
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxyUsername) && StringUtils.hasText(proxyPassword)) {
                logger.info("Configuring proxy authentication for user: {}", proxyUsername);
                
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxyHost, proxyPort),
                        new UsernamePasswordCredentials(proxyUsername, proxyPassword));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
        return clientBuilder.build();
    }
    
    /**
     * Apply proxy settings from application.properties to the HttpClientBuilder
     * 
     * @param clientBuilder The HttpClientBuilder to configure
     * @return The configured HttpClientBuilder
     */
    public HttpClientBuilder applyDefaultProxySettings(HttpClientBuilder clientBuilder) {
        // Configure proxy if set
        if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            logger.debug("Applying default proxy settings: {}:{}", proxyHost, proxyPort);
            
            HttpHost proxy = new HttpHost(proxyHost, proxyPort);
            
            // Set request config with proxy
            RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                    .setConnectTimeout(connectionTimeout)
                    .setSocketTimeout(socketTimeout)
                    .setConnectionRequestTimeout(connectionRequestTimeout)
                    .setProxy(proxy);
            
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxyUsername) && StringUtils.hasText(proxyPassword)) {
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxyHost, proxyPort),
                        new UsernamePasswordCredentials(proxyUsername, proxyPassword));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        return clientBuilder;
    }
    
    /**
     * Apply custom proxy settings to the HttpClientBuilder
     * 
     * @param clientBuilder The HttpClientBuilder to configure
     * @param proxySettings The proxy settings to apply
     * @return The configured HttpClientBuilder
     */
    public HttpClientBuilder applyCustomProxySettings(
            HttpClientBuilder clientBuilder, 
            IntegrationSyncOptions.ProxySettings proxySettings) {
        
        if (proxySettings != null && StringUtils.hasText(proxySettings.getHost()) 
                && proxySettings.getPort() != null && proxySettings.getPort() > 0) {
            
            logger.debug("Applying custom proxy settings: {}:{}", 
                    proxySettings.getHost(), proxySettings.getPort());
            
            HttpHost proxy = new HttpHost(proxySettings.getHost(), proxySettings.getPort());
            
            // Set request config with proxy
            RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                    .setConnectTimeout(connectionTimeout)
                    .setSocketTimeout(socketTimeout)
                    .setConnectionRequestTimeout(connectionRequestTimeout)
                    .setProxy(proxy);
            
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxySettings.getUsername()) 
                    && StringUtils.hasText(proxySettings.getPassword())) {
                
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxySettings.getHost(), proxySettings.getPort()),
                        new UsernamePasswordCredentials(
                                proxySettings.getUsername(), 
                                proxySettings.getPassword()));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        return clientBuilder;
    }
    
    /**
     * Get the list of non-proxy hosts
     * 
     * @return List of non-proxy hosts
     */
    public List<String> getNonProxyHosts() {
        if (StringUtils.hasText(nonProxyHosts)) {
            return Arrays.stream(nonProxyHosts.split("\\|"))
                    .filter(StringUtils::hasText)
                    .collect(Collectors.toList());
        }
        return List.of("localhost", "127.0.0.1");
    }
    
    /**
     * Check if a host should bypass the proxy
     * 
     * @param host The host to check
     * @return True if the host should bypass the proxy
     */
    public boolean shouldBypassProxy(String host) {
        if (!StringUtils.hasText(host)) {
            return false;
        }
        
        List<String> bypassHosts = getNonProxyHosts();
        for (String bypassHost : bypassHosts) {
            if (bypassHost.startsWith("*") && host.endsWith(bypassHost.substring(1))) {
                return true;
            } else if (bypassHost.endsWith("*") && host.startsWith(bypassHost.substring(0, bypassHost.length() - 1))) {
                return true;
            } else if (host.equals(bypassHost)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Create a HttpClient with custom proxy settings
     * 
     * @param proxySettings Custom proxy settings
     * @return HttpClient with custom proxy settings
     */
    public CloseableHttpClient createHttpClient(IntegrationSyncOptions.ProxySettings proxySettings) {
        HttpClientBuilder clientBuilder = HttpClients.custom();
        
        // Set timeouts
        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                .setConnectTimeout(connectionTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout);
        
        // Apply custom proxy settings if provided, otherwise use default
        if (proxySettings != null && StringUtils.hasText(proxySettings.getHost()) 
                && proxySettings.getPort() != null && proxySettings.getPort() > 0) {
            
            applyCustomProxySettings(clientBuilder, proxySettings);
        } else if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            applyDefaultProxySettings(clientBuilder);
        } else {
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
        }
        
        return clientBuilder.build();
    }
}
```

package com.cstestforge.service.integration;

import com.cstestforge.config.ProxyConfig;
import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.integration.*;
import com.cstestforge.repository.integration.IntegrationRepository;
import com.cstestforge.util.http.HttpPatch;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.*;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import java.util.Base64;

/**
 * Implementation of IntegrationService for Azure DevOps and ADO Git
 */
@Service
public class IntegrationServiceImpl implements IntegrationService {

    private static final Logger logger = LoggerFactory.getLogger(IntegrationServiceImpl.class);
    
    private static final String TYPE_AZURE_DEVOPS = "azure-devops";
    private static final String TYPE_AZURE_DEVOPS_GIT = "azure-devops-git";
    
    private static final String ADO_API_VERSION = "7.1";
    private static final String ADO_API_VERSION_PREVIEW = "7.1-preview.1";
    
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'");
    
    @Value("${app.data.directory:./data}")
    private String dataDirectory;
    
    @Value("${app.integrations.schemas.directory:./config/integration-schemas}")
    private String schemasDirectory;
    
    @Autowired
    private IntegrationRepository integrationRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private ProxyConfig proxyConfig;
    
    private Map<String, IntegrationSettingsSchema> settingsSchemas = new HashMap<>();
    
    @PostConstruct
    public void init() {
        loadSettingsSchemas();
    }

    @Override
    public List<Integration> getAllIntegrations(String projectId) {
        logger.info("Getting all integrations for project: {}", projectId);
        return integrationRepository.findAllByProjectId(projectId);
    }

    @Override
    public Integration getIntegrationById(String projectId, String integrationId) {
        logger.info("Getting integration: {} for project: {}", integrationId, projectId);
        
        return integrationRepository.findByIdAndProjectId(integrationId, projectId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Integration", "id", integrationId));
    }

    @Override
    public Integration createIntegration(String projectId, Integration integration) {
        logger.info("Creating integration for project: {}", projectId);
        
        validateIntegrationType(integration.getType());
        
        // Set project ID
        integration.setProjectId(Long.parseLong(projectId));
        integration.setStatus("Not Connected");
        integration.setCreatedAt(LocalDateTime.now());
        integration.setEnabled(true);
        
        return integrationRepository.save(integration);
    }

    @Override
    public Integration updateIntegration(String projectId, String integrationId, Integration integrationDetails) {
        logger.info("Updating integration: {} for project: {}", integrationId, projectId);
        
        Integration existingIntegration = getIntegrationById(projectId, integrationId);
        
        // Validate integration type if changed
        if (!existingIntegration.getType().equals(integrationDetails.getType())) {
            validateIntegrationType(integrationDetails.getType());
        }
        
        // Update fields
        existingIntegration.setName(integrationDetails.getName());
        existingIntegration.setDescription(integrationDetails.getDescription());
        existingIntegration.setType(integrationDetails.getType());
        existingIntegration.setSettings(integrationDetails.getSettings());
        existingIntegration.setEnabled(integrationDetails.isEnabled());
        existingIntegration.setUpdatedAt(LocalDateTime.now());
        
        return integrationRepository.save(existingIntegration);
    }

    @Override
    public boolean deleteIntegration(String projectId, String integrationId) {
        logger.info("Deleting integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        
        return integrationRepository.delete(integration);
    }

    @Override
    public IntegrationTestResult testIntegrationConnection(String projectId, String integrationId) {
        logger.info("Testing connection for integration: {} in project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationTestResult result = new IntegrationTestResult();
        result.setIntegrationId(integration.getId());
        result.setTestedAt(LocalDateTime.now());
        
        long startTime = System.currentTimeMillis();
        
        // Add test steps based on integration type
        List<IntegrationTestResult.TestStep> testSteps = new ArrayList<>();
        boolean isSuccessful = false;
        
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                isSuccessful = testAzureDevOpsConnection(integration, testSteps, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                isSuccessful = testAzureDevOpsGitConnection(integration, testSteps, result);
            } else {
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
                isSuccessful = false;
            }
        } catch (Exception e) {
            logger.error("Error testing connection", e);
            result.setMessage("Connection test failed: " + e.getMessage());
            result.setErrorCode("CONNECTION_ERROR");
            result.setErrorDetail(e.getMessage());
            isSuccessful = false;
        }
        
        // Set test result
        result.setSuccessful(isSuccessful);
        if (isSuccessful) {
            if (result.getMessage() == null) {
                result.setMessage("Connection test successful");
            }
            
            // Update integration status
            integration.setStatus("Connected");
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        } else {
            if (result.getMessage() == null) {
                result.setMessage("Connection test failed");
            }
            
            // Update integration status
            integration.setStatus("Connection Failed");
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        }
        
        // Set test steps and response time
        result.setTestSteps(testSteps);
        result.setResponseTimeMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Test connection to Azure DevOps
     */
    private boolean testAzureDevOpsConnection(
            Integration integration, 
            List<IntegrationTestResult.TestStep> testSteps,
            IntegrationTestResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Validate required settings
        if (!StringUtils.hasText(organization)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps organization is required");
            result.setErrorCode("MISSING_ORGANIZATION");
            return false;
        }
        
        if (!StringUtils.hasText(project)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps project is required");
            result.setErrorCode("MISSING_PROJECT");
            return false;
        }
        
        if (!StringUtils.hasText(pat)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps Personal Access Token (PAT) is required");
            result.setErrorCode("MISSING_PAT");
            return false;
        }
        
        // Step 1: Authenticate with Azure DevOps
        IntegrationTestResult.TestStep authStep = new IntegrationTestResult.TestStep()
                .setName("Authenticate")
                .setDescription("Authenticating with Azure DevOps using PAT");
        
        long authStartTime = System.currentTimeMillis();
        
        try {
            // Use project API as authentication test
            String projectApiUrl = String.format("https://dev.azure.com/%s/_apis/projects/%s", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(projectApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        authStep.setSuccessful(true)
                                .setMessage("Authentication successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        authStep.setSuccessful(false)
                                .setMessage("Authentication failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("AUTH_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Authentication error", e);
            authStep.setSuccessful(false)
                    .setMessage("Authentication failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("AUTH_ERROR");
        }
        
        authStep.setExecutionTimeMs(System.currentTimeMillis() - authStartTime);
        testSteps.add(authStep);
        
        if (!authStep.isSuccessful()) {
            return false;
        }
        
        // Step 2: Test access to Test Plans API
        IntegrationTestResult.TestStep testPlansStep = new IntegrationTestResult.TestStep()
                .setName("Test Plans API")
                .setDescription("Testing access to Azure DevOps Test Plans API");
        
        long testPlansStartTime = System.currentTimeMillis();
        
        try {
            String testPlansApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/plans", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlansApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Add test plan count to connection details
                        List<Map<String, Object>> plans = (List<Map<String, Object>>) responseMap.get("value");
                        result.getConnectionDetails().put("testPlanCount", plans != null ? plans.size() : 0);
                        
                        testPlansStep.setSuccessful(true)
                                .setMessage("Test Plans API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        testPlansStep.setSuccessful(false)
                                .setMessage("Test Plans API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("TEST_PLANS_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Test Plans API error", e);
            testPlansStep.setSuccessful(false)
                    .setMessage("Test Plans API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("TEST_PLANS_API_ERROR");
        }
        
        testPlansStep.setExecutionTimeMs(System.currentTimeMillis() - testPlansStartTime);
        testSteps.add(testPlansStep);
        
        if (!testPlansStep.isSuccessful()) {
            return false;
        }
        
        // Step 3: Test access to Work Items API
        IntegrationTestResult.TestStep workItemsStep = new IntegrationTestResult.TestStep()
                .setName("Work Items API")
                .setDescription("Testing access to Azure DevOps Work Items API");
        
        long workItemsStartTime = System.currentTimeMillis();
        
        try {
            String workItemsApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/wit/workitems?$top=1&workItemType=Test Case", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(workItemsApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        workItemsStep.setSuccessful(true)
                                .setMessage("Work Items API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        workItemsStep.setSuccessful(false)
                                .setMessage("Work Items API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("WORK_ITEMS_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Work Items API error", e);
            workItemsStep.setSuccessful(false)
                    .setMessage("Work Items API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("WORK_ITEMS_API_ERROR");
        }
        
        workItemsStep.setExecutionTimeMs(System.currentTimeMillis() - workItemsStartTime);
        testSteps.add(workItemsStep);
        
        return workItemsStep.isSuccessful();
    }
    
    /**
     * Test connection to Azure DevOps Git
     */
    private boolean testAzureDevOpsGitConnection(
            Integration integration, 
            List<IntegrationTestResult.TestStep> testSteps,
            IntegrationTestResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Validate required settings
        if (!StringUtils.hasText(organization)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps organization is required");
            result.setErrorCode("MISSING_ORGANIZATION");
            return false;
        }
        
        if (!StringUtils.hasText(project)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps project is required");
            result.setErrorCode("MISSING_PROJECT");
            return false;
        }
        
        if (!StringUtils.hasText(repositoryId)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps repository ID is required");
            result.setErrorCode("MISSING_REPOSITORY_ID");
            return false;
        }
        
        if (!StringUtils.hasText(pat)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps Personal Access Token (PAT) is required");
            result.setErrorCode("MISSING_PAT");
            return false;
        }
        
        // Step 1: Authenticate with Azure DevOps
        IntegrationTestResult.TestStep authStep = new IntegrationTestResult.TestStep()
                .setName("Authenticate")
                .setDescription("Authenticating with Azure DevOps using PAT");
        
        long authStartTime = System.currentTimeMillis();
        
        try {
            // Use repository API as authentication test
            String repoApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s", 
                    organization, project, repositoryId);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(repoApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Store repository name in connection details
                        result.getConnectionDetails().put("repositoryName", responseMap.get("name"));
                        
                        authStep.setSuccessful(true)
                                .setMessage("Authentication successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        authStep.setSuccessful(false)
                                .setMessage("Authentication failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("AUTH_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Authentication error", e);
            authStep.setSuccessful(false)
                    .setMessage("Authentication failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("AUTH_ERROR");
        }
        
        authStep.setExecutionTimeMs(System.currentTimeMillis() - authStartTime);
        testSteps.add(authStep);
        
        if (!authStep.isSuccessful()) {
            return false;
        }
        
        // Step 2: Test access to Branches API
        IntegrationTestResult.TestStep branchesStep = new IntegrationTestResult.TestStep()
                .setName("Branches API")
                .setDescription("Testing access to Azure DevOps Git Branches API");
        
        long branchesStartTime = System.currentTimeMillis();
        
        try {
            String branchesApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/", 
                    organization, project, repositoryId);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchesApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Store branch count in connection details
                        List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                        result.getConnectionDetails().put("branchCount", branches != null ? branches.size() : 0);
                        
                        // Store default branch if found
                        if (branches != null && !branches.isEmpty()) {
                            for (Map<String, Object> branch : branches) {
                                String name = (String) branch.get("name");
                                if (name != null && (name.endsWith("/main") || name.endsWith("/master"))) {
                                    result.getConnectionDetails().put("defaultBranch", 
                                            name.substring(name.lastIndexOf('/') + 1));
                                    break;
                                }
                            }
                        }
                        
                        branchesStep.setSuccessful(true)
                                .setMessage("Branches API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        branchesStep.setSuccessful(false)
                                .setMessage("Branches API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("BRANCHES_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Branches API error", e);
            branchesStep.setSuccessful(false)
                    .setMessage("Branches API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("BRANCHES_API_ERROR");
        }
        
        branchesStep.setExecutionTimeMs(System.currentTimeMillis() - branchesStartTime);
        testSteps.add(branchesStep);
        
        return branchesStep.isSuccessful();
    }

    @Override
    public IntegrationSyncResult syncWithIntegration(
            String projectId, String integrationId, IntegrationSyncOptions syncOptions) {
        
        logger.info("Syncing with integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationSyncResult result = new IntegrationSyncResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDirection(syncOptions != null ? syncOptions.getDirection() : "PULL");
        result.setDryRun(syncOptions != null && syncOptions.isDryRun());
        
        long startTime = System.currentTimeMillis();
        
        // Perform sync based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                syncWithAzureDevOps(integration, syncOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                syncWithAzureDevOpsGit(integration, syncOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during sync", e);
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        // Update integration last sync time
        if (result.isSuccessful() && !result.isDryRun()) {
            integration.setLastSyncAt(LocalDateTime.now());
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        }
        
        return result;
    }
    
    /**
     * Synchronize with Azure DevOps
     */
    private void syncWithAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Prepare sync options if null
        if (syncOptions == null) {
            syncOptions = new IntegrationSyncOptions();
        }
        
        // Default content types if not specified
        if (syncOptions.getContentTypes() == null || syncOptions.getContentTypes().isEmpty()) {
            syncOptions.setContentTypes(Arrays.asList("TEST_CASE", "TEST_SUITE", "TEST_PLAN"));
        }
        
        // Determine sync direction
        String direction = syncOptions.getDirection();
        if (direction == null) {
            direction = "PULL";
        }
        
        // Initialize stats for each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = new IntegrationSyncResult.SyncStats()
                    .setContentType(contentType)
                    .setTotalProcessed(0)
                    .setCreated(0)
                    .setUpdated(0)
                    .setDeleted(0)
                    .setSkipped(0)
                    .setErrors(0)
                    .setConflicts(0);
            
            result.getStats().put(contentType, stats);
        }
        
        // Implement sync based on direction
        try {
            if ("PULL".equals(direction)) {
                // Pull data from Azure DevOps to CS Test Forge
                pullFromAzureDevOps(integration, syncOptions, result);
            } else if ("PUSH".equals(direction)) {
                // Push data from CS Test Forge to Azure DevOps
                pushToAzureDevOps(integration, syncOptions, result);
            } else if ("BIDIRECTIONAL".equals(direction)) {
                // Pull first, then push
                pullFromAzureDevOps(integration, syncOptions, result);
                pushToAzureDevOps(integration, syncOptions, result);
            } else {
                throw new IllegalArgumentException("Invalid sync direction: " + direction);
            }
            
            // Set success message
            result.setSuccessful(true);
            if (result.isDryRun()) {
                result.setMessage("Sync dry run completed successfully");
            } else {
                result.setMessage("Sync completed successfully");
            }
        } catch (Exception e) {
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
            
            // Add error to each content type
            for (IntegrationSyncResult.SyncStats stats : result.getStats().values()) {
                stats.setErrors(stats.getErrors() + 1);
            }
        }
    }
    
    /**
     * Pull data from Azure DevOps to CS Test Forge
     */
    private void pullFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_PLAN":
                    pullTestPlansFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_SUITE":
                    pullTestSuitesFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_CASE":
                    pullTestCasesFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                default:
                    logger.warn("Unsupported content type for pull: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for pull: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Pull test plans from Azure DevOps
     */
    private void pullTestPlansFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan ID if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            if (testPlanId != null) {
                // Get specific test plan
                String testPlanUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d", 
                        organization, project, testPlanId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlanUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> testPlan = objectMapper.readValue(responseBody, Map.class);
                        
                        // Process test plan
                        processTestPlan(integration, syncOptions, stats, result, testPlan);
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test plan " + testPlanId + ": Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            } else {
                // Get all test plans
                String testPlansUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans", 
                        organization, project);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlansUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testPlans = (List<Map<String, Object>>) responseMap.get("value");
                        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                        
                        // Process test plans (limited by maxItems)
                        int processed = 0;
                        for (Map<String, Object> testPlan : testPlans) {
                            if (processed >= maxItems) {
                                break;
                            }
                            
                            processTestPlan(integration, syncOptions, stats, result, testPlan);
                            processed++;
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test plans: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            }
        }
    }
    
    /**
     * Process a test plan from Azure DevOps
     */
    private void processTestPlan(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Map<String, Object> testPlan) {
        
        // Extract test plan details
        Number id = (Number) testPlan.get("id");
        String name = (String) testPlan.get("name");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        try {
            // Prepare directory structure
            Path projectTestPlansDir = Paths.get(
                    dataDirectory, 
                    "projects", 
                    integration.getProjectId().toString(), 
                    "test-plans");
            Files.createDirectories(projectTestPlansDir);
            
            // Convert Azure DevOps test plan to CS Test Forge format
            Map<String, Object> formattedTestPlan = new HashMap<>(testPlan);
            
            // Add metadata for tracking
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("syncSource", "azure-devops");
            metadata.put("lastSyncedAt", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
            formattedTestPlan.put("metadata", metadata);
            
            // Save or update test plan
            Path testPlanFile = projectTestPlansDir.resolve(id + ".json");
            boolean exists = Files.exists(testPlanFile);
            
            // Synchronization flags
            boolean forceSync = syncOptions.isForceSync();
            String conflictResolution = syncOptions.getConflictResolution();
            
            if (exists && !forceSync) {
                // Check for conflicts
                try {
                    String existingJson = new String(Files.readAllBytes(testPlanFile), StandardCharsets.UTF_8);
                    Map<String, Object> existingTestPlan = objectMapper.readValue(existingJson, Map.class);
                    
                    // Get revision details
                    Number existingRev = (Number) existingTestPlan.get("revision");
                    Number newRev = (Number) formattedTestPlan.get("revision");
                    
                    if (existingRev != null && newRev != null && existingRev.intValue() >= newRev.intValue()) {
                        // Existing test plan is newer or same revision
                        if ("SKIP".equals(conflictResolution)) {
                            stats.setSkipped(stats.getSkipped() + 1);
                            return;
                        } else if ("MERGE".equals(conflictResolution)) {
                            // Merge test plans, preferring existing for conflicts
                            formattedTestPlan = mergeTestPlans(existingTestPlan, formattedTestPlan);
                        }
                        // For "LATEST_WINS", we'll just overwrite
                    }
                } catch (IOException e) {
                    logger.warn("Failed to read existing test plan: {}", id, e);
                    // Continue with overwrite on read error
                }
            }
            
            // Write to file
            objectMapper.writeValue(testPlanFile.toFile(), formattedTestPlan);
            
            // Update test plan index
            updateTestPlanIndex(integration.getProjectId().toString(), id.toString(), name);
            
            if (exists) {
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                stats.setCreated(stats.getCreated() + 1);
            }
            
            logger.info("Processed test plan: {} ({})", name, id);
        } catch (Exception e) {
            logger.error("Error processing test plan: {} ({})", name, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_PLAN")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test plan: " + e.getMessage())
                            .setCode("PROCESS_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
        }
    }
    
    /**
     * Merge two test plans, preferring the first for conflicts
     */
    private Map<String, Object> mergeTestPlans(
            Map<String, Object> existingTestPlan, 
            Map<String, Object> newTestPlan) {
        
        Map<String, Object> mergedTestPlan = new HashMap<>(existingTestPlan);
        
        // Override with values from new test plan, except for id, revision, and metadata
        for (Map.Entry<String, Object> entry : newTestPlan.entrySet()) {
            String key = entry.getKey();
            if (!"id".equals(key) && !"revision".equals(key) && !"metadata".equals(key)) {
                mergedTestPlan.put(key, entry.getValue());
            }
        }
        
        // Merge metadata
        Map<String, Object> existingMetadata = (Map<String, Object>) existingTestPlan.getOrDefault("metadata", new HashMap<>());
        Map<String, Object> newMetadata = (Map<String, Object>) newTestPlan.getOrDefault("metadata", new HashMap<>());
        
        existingMetadata.put("lastSyncedAt", newMetadata.getOrDefault("lastSyncedAt", 
                LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)));
        mergedTestPlan.put("metadata", existingMetadata);
        
        return mergedTestPlan;
    }
    
    /**
     * Update test plan index
     */
    private void updateTestPlanIndex(String projectId, String testPlanId, String name) throws IOException {
        Path projectTestPlansDir = Paths.get(dataDirectory, "projects", projectId, "test-plans");
        Path indexFile = projectTestPlansDir.resolve("index.json");
        
        Map<String, Object> index;
        if (Files.exists(indexFile)) {
            String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
            index = objectMapper.readValue(indexContent, Map.class);
        } else {
            index = new HashMap<>();
            index.put("testPlans", new HashMap<>());
        }
        
        Map<String, Object> testPlans = (Map<String, Object>) index.get("testPlans");
        Map<String, Object> testPlanEntry = new HashMap<>();
        testPlanEntry.put("id", testPlanId);
        testPlanEntry.put("name", name);
        testPlanEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        testPlans.put(testPlanId, testPlanEntry);
        
        // Write updated index
        objectMapper.writeValue(indexFile.toFile(), index);
    }
    
    /**
     * Pull test suites from Azure DevOps
     */
    private void pullTestSuitesFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan and suite IDs if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null) {
            // Cannot get suites without a test plan ID
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_SUITE")
                            .setMessage("Test plan ID is required to pull test suites")
                            .setCode("MISSING_TEST_PLAN_ID"));
            stats.setErrors(stats.getErrors() + 1);
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            if (testSuiteId != null) {
                // Get specific test suite
                String testSuiteUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d", 
                        organization, project, testPlanId, testSuiteId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testSuiteUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> testSuite = objectMapper.readValue(responseBody, Map.class);
                        
                        // Process test suite
                        processTestSuite(integration, syncOptions, stats, result, testPlanId, testSuite);
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test suite " + testSuiteId + ": Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            } else {
                // Get all test suites in the test plan
                String testSuitesUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites", 
                        organization, project, testPlanId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testSuitesUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testSuites = (List<Map<String, Object>>) responseMap.get("value");
                        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                        
                        // Process test suites (limited by maxItems)
                        int processed = 0;
                        for (Map<String, Object> testSuite : testSuites) {
                            if (processed >= maxItems) {
                                break;
                            }
                            
                            processTestSuite(integration, syncOptions, stats, result, testPlanId, testSuite);
                            processed++;
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test suites: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            }
        }
    }
    
    /**
     * Process a test suite from Azure DevOps
     */
    private void processTestSuite(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Long testPlanId,
            Map<String, Object> testSuite) {
        
        // Extract test suite details
        Number id = (Number) testSuite.get("id");
        String name = (String) testSuite.get("name");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        try {
            // Prepare directory structure for test suites
            Path testSuitesDir = Paths.get(
                    dataDirectory, 
                    "projects", 
                    integration.getProjectId().toString(), 
                    "test-plans", 
                    testPlanId.toString(),
                    "suites");
            Files.createDirectories(testSuitesDir);
            
            // Convert Azure DevOps test suite to CS Test Forge format
            Map<String, Object> formattedTestSuite = new HashMap<>(testSuite);
            
            // Add metadata for tracking
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("syncSource", "azure-devops");
            metadata.put("lastSyncedAt", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
            metadata.put("testPlanId", testPlanId);
            formattedTestSuite.put("metadata", metadata);
            
            // Save or update test suite
            Path testSuiteFile = testSuitesDir.resolve(id + ".json");
            boolean exists = Files.exists(testSuiteFile);
            
            // Synchronization flags
            boolean forceSync = syncOptions.isForceSync();
            String conflictResolution = syncOptions.getConflictResolution();
            
            if (exists && !forceSync) {
                // Check for conflicts
                try {
                    String existingJson = new String(Files.readAllBytes(testSuiteFile), StandardCharsets.UTF_8);
                    Map<String, Object> existingTestSuite = objectMapper.readValue(existingJson, Map.class);
                    
                    // Compare revisions if available
                    Number existingRev = (Number) existingTestSuite.get("revision");
                    Number newRev = (Number) formattedTestSuite.get("revision");
                    
                    if (existingRev != null && newRev != null && existingRev.intValue() >= newRev.intValue()) {
                        // Existing test suite is newer or same revision
                        if ("SKIP".equals(conflictResolution)) {
                            stats.setSkipped(stats.getSkipped() + 1);
                            return;
                        } else if ("MERGE".equals(conflictResolution)) {
                            // Merge test suites, preferring existing for conflicts
                            formattedTestSuite = mergeTestSuites(existingTestSuite, formattedTestSuite);
                        }
                        // For "LATEST_WINS", we'll just overwrite
                    }
                } catch (IOException e) {
                    logger.warn("Failed to read existing test suite: {}", id, e);
                    // Continue with overwrite on read error
                }
            }
            
            // Write to file
            objectMapper.writeValue(testSuiteFile.toFile(), formattedTestSuite);
            
            // Update test suite index
            updateTestSuiteIndex(integration.getProjectId().toString(), testPlanId.toString(), 
                    id.toString(), name);
            
            if (exists) {
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                stats.setCreated(stats.getCreated() + 1);
            }
            
            logger.info("Processed test suite: {} ({}) in plan {}", name, id, testPlanId);
        } catch (Exception e) {
            logger.error("Error processing test suite: {} ({}) in plan {}", name, id, testPlanId, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_SUITE")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test suite: " + e.getMessage())
                            .setCode("PROCESS_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e),
                                    "testPlanId", testPlanId)));
        }
    }
    
    /**
     * Merge two test suites, preferring the first for conflicts
     */
    private Map<String, Object> mergeTestSuites(
            Map<String, Object> existingTestSuite, 
            Map<String, Object> newTestSuite) {
        
        Map<String, Object> mergedTestSuite = new HashMap<>(existingTestSuite);
        
        // Override with values from new test suite, except for id, revision, and metadata
        for (Map.Entry<String, Object> entry : newTestSuite.entrySet()) {
            String key = entry.getKey();
            if (!"id".equals(key) && !"revision".equals(key) && !"metadata".equals(key)) {
                mergedTestSuite.put(key, entry.getValue());
            }
        }
        
        // Merge metadata
        Map<String, Object> existingMetadata = (Map<String, Object>) existingTestSuite.getOrDefault("metadata", new HashMap<>());
        Map<String, Object> newMetadata = (Map<String, Object>) newTestSuite.getOrDefault("metadata", new HashMap<>());
        
        existingMetadata.put("lastSyncedAt", newMetadata.getOrDefault("lastSyncedAt", 
                LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)));
        mergedTestSuite.put("metadata", existingMetadata);
        
        return mergedTestSuite;
    }
    
    /**
     * Update test suite index
     */
    private void updateTestSuiteIndex(
            String projectId, 
            String testPlanId, 
            String testSuiteId, 
            String name) throws IOException {
        
        Path testPlanSuitesDir = Paths.get(
                dataDirectory, 
                "projects", 
                projectId, 
                "test-plans", 
                testPlanId.toString(), 
                "suites");
        
        Path indexFile = testPlanSuitesDir.resolve("index.json");
        
        Map<String, Object> index;
        if (Files.exists(indexFile)) {
            String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
            index = objectMapper.readValue(indexContent, Map.class);
        } else {
            index = new HashMap<>();
            index.put("testSuites", new HashMap<>());
        }
        
        Map<String, Object> testSuites = (Map<String, Object>) index.get("testSuites");
        Map<String, Object> testSuiteEntry = new HashMap<>();
        testSuiteEntry.put("id", testSuiteId);
        testSuiteEntry.put("name", name);
        testSuiteEntry.put("testPlanId", testPlanId);
        testSuiteEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        testSuites.put(testSuiteId, testSuiteEntry);
        
        // Write updated index
        objectMapper.writeValue(indexFile.toFile(), index);
    }
    
    /**
     * Pull test cases from Azure DevOps
     */
    private void pullTestCasesFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan and suite IDs if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null || testSuiteId == null) {
            // Check if work item query is provided as an alternative
            String workItemQuery = syncOptions.getAdoWorkItemQuery();
            
            if (StringUtils.hasText(workItemQuery)) {
                // Pull test cases using work item query
                pullTestCasesByQuery(integration, syncOptions, stats, result, workItemQuery);
                return;
            }
            
            // Cannot get test cases without either a test plan/suite or a query
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_CASE")
                            .setMessage("Test plan ID and suite ID are required to pull test cases, or provide a work item query")
                            .setCode("MISSING_IDS"));
            stats.setErrors(stats.getErrors() + 1);
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            // Get test cases in the test suite
            String testCasesUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                    organization, project, testPlanId, testSuiteId);
            
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> testPoints = (List<Map<String, Object>>) responseMap.get("value");
                    int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                    
                    // Process each test point to get the associated work item (test case)
                    int processed = 0;
                    for (Map<String, Object> testPoint : testPoints) {
                        if (processed >= maxItems) {
                            break;
                        }
                        
                        Map<String, Object> workItemReference = (Map<String, Object>) testPoint.get("workItem");
                        if (workItemReference == null) {
                            continue;
                        }
                        
                        Number workItemId = (Number) workItemReference.get("id");
                        
                        // Get full test case details
                        String workItemUrl = String.format(
                                "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                                organization, project, workItemId.longValue());
                        
                        HttpGet wiGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                        wiGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        wiGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        try (CloseableHttpResponse wiResponse = httpClient.execute(wiGet)) {
                            int wiStatusCode = wiResponse.getStatusLine().getStatusCode();
                            
                            if (wiStatusCode == HttpStatus.SC_OK) {
                                String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                Map<String, Object> workItem = objectMapper.readValue(wiResponseBody, Map.class);
                                
                                // Process test case work item
                                processTestCase(integration, syncOptions, stats, result, 
                                        testPlanId, testSuiteId, workItem, testPoint);
                                processed++;
                            } else {
                                String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                throw new Exception("Failed to get test case work item " + workItemId + 
                                        ": Status code " + wiStatusCode + ", Response: " + wiResponseBody);
                            }
                        }
                    }
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get test cases: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Pull test cases using a work item query
     */
    private void pullTestCasesByQuery(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String workItemQuery) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            // Execute the work item query
            String wiqlUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/wit/wiql?api-version=%s", 
                    organization, project, ADO_API_VERSION);
            
            HttpPost httpPost = new HttpPost(wiqlUrl);
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            // Create WIQL request body
            Map<String, Object> wiqlRequest = new HashMap<>();
            wiqlRequest.put("query", workItemQuery);
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(wiqlRequest), 
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> workItems = (List<Map<String, Object>>) responseMap.get("workItems");
                    if (workItems == null || workItems.isEmpty()) {
                        logger.info("No work items found for query: {}", workItemQuery);
                        return;
                    }
                    
                    int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                    
                    // Process each work item (test case)
                    int processed = 0;
                    for (Map<String, Object> workItemRef : workItems) {
                        if (processed >= maxItems) {
                            break;
                        }
                        
                        Number workItemId = (Number) workItemRef.get("id");
                        
                        // Get full test case details
                        String workItemUrl = String.format(
                                "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                                organization, project, workItemId.longValue());
                        
                        HttpGet wiGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                        wiGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        wiGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        try (CloseableHttpResponse wiResponse = httpClient.execute(wiGet)) {
                            int wiStatusCode = wiResponse.getStatusLine().getStatusCode();
                            
                            if (wiStatusCode == HttpStatus.SC_OK) {
                                String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                Map<String, Object> workItem = objectMapper.readValue(wiResponseBody, Map.class);
                                
                                // Only process if it's a test case
                                Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
                                String workItemType = (String) fields.get("System.WorkItemType");
                                
                                if ("Test Case".equals(workItemType)) {
                                    // Process test case work item
                                    processTestCase(integration, syncOptions, stats, result, null, null, workItem, null);
                                    processed++;
                                }
                            } else {
                                String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                throw new Exception("Failed to get test case work item " + workItemId + 
                                        ": Status code " + wiStatusCode + ", Response: " + wiResponseBody);
                            }
                        }
                    }
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to execute work item query: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Process a test case from Azure DevOps
     */
    private void processTestCase(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Long testPlanId,
            Long testSuiteId,
            Map<String, Object> workItem,
            Map<String, Object> testPoint) {
        
        // Extract test case details
        Number id = (Number) workItem.get("id");
        Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
        String title = (String) fields.get("System.Title");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        try {
            // Prepare directory structure
            Path projectTestCasesDir = Paths.get(
                    dataDirectory, 
                    "projects", 
                    integration.getProjectId().toString(), 
                    "test-cases");
            Files.createDirectories(projectTestCasesDir);
            
            // Convert Azure DevOps work item to CS Test Forge test case format
            Map<String, Object> testCase = convertWorkItemToTestCase(workItem, testPoint);
            
            // Add test plan and suite references if provided
            if (testPlanId != null && testSuiteId != null) {
                Map<String, Object> references = new HashMap<>();
                references.put("testPlanId", testPlanId);
                references.put("testSuiteId", testSuiteId);
                
                if (testPoint != null) {
                    references.put("testPointId", testPoint.get("id"));
                    
                    // Add configuration information if present
                    Map<String, Object> configuration = (Map<String, Object>) testPoint.get("configuration");
                    if (configuration != null) {
                        references.put("configurationId", configuration.get("id"));
                        references.put("configurationName", configuration.get("name"));
                    }
                }
                
                testCase.put("references", references);
            }
            
            // Save or update test case
            Path testCaseFile = projectTestCasesDir.resolve(id + ".json");
            boolean exists = Files.exists(testCaseFile);
            
            // Synchronization flags
            boolean forceSync = syncOptions.isForceSync();
            String conflictResolution = syncOptions.getConflictResolution();
            
            if (exists && !forceSync) {
                // Check if update is needed based on conflict resolution strategy
                String existingJson = new String(Files.readAllBytes(testCaseFile), StandardCharsets.UTF_8);
                Map<String, Object> existingTestCase = objectMapper.readValue(existingJson, Map.class);
                
                // Get revision numbers for comparison
                Number existingRev = (Number) existingTestCase.get("revision");
                Number newRev = (Number) testCase.get("revision");
                
                if (existingRev != null && newRev != null && existingRev.intValue() >= newRev.intValue()) {
                    // Existing test case is newer or same revision
                    if ("SKIP".equals(conflictResolution)) {
                        stats.setSkipped(stats.getSkipped() + 1);
                        return;
                    } else if ("MERGE".equals(conflictResolution)) {
                        // Merge the two test cases, preferring existing values for conflicts
                        testCase = mergeTestCases(existingTestCase, testCase);
                    }
                    // For "LATEST_WINS", we'll just overwrite with the new test case
                }
            }
            
            // Write the test case to file
            objectMapper.writeValue(testCaseFile.toFile(), testCase);
            
            // Update test case index
            updateTestCaseIndex(integration.getProjectId().toString(), id.toString(), title);
            
            // Update relationship files for test plan/suite associations
            if (testPlanId != null && testSuiteId != null) {
                updateTestCaseRelationships(
                        integration.getProjectId().toString(), 
                        id.toString(), 
                        testPlanId, 
                        testSuiteId);
            }
            
            // Download and save attachments if included
            if (syncOptions.isIncludeAttachments()) {
                Object relations = workItem.get("relations");
                if (relations != null && relations instanceof List) {
                    List<Map<String, Object>> relationsList = (List<Map<String, Object>>) relations;
                    Path attachmentsDir = projectTestCasesDir.resolve("attachments").resolve(id.toString());
                    Files.createDirectories(attachmentsDir);
                    
                    int attachmentsImported = downloadAttachments(
                            integration, 
                            id.toString(), 
                            relationsList, 
                            attachmentsDir);
                    
                    // Update stats for attachments
                    Map<String, Object> additionalStats = stats.getAdditionalStats();
                    int currentAttachments = additionalStats.containsKey("attachmentsImported") 
                            ? ((Number) additionalStats.get("attachmentsImported")).intValue() 
                            : 0;
                    additionalStats.put("attachmentsImported", currentAttachments + attachmentsImported);
                }
            }
            
            if (exists) {
                // Update existing test case
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                // Create new test case
                stats.setCreated(stats.getCreated() + 1);
            }
            
            logger.info("Processed test case: {} ({})", title, id);
        } catch (Exception e) {
            logger.error("Error processing test case: {} ({})", title, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_CASE")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test case: " + e.getMessage())
                            .setCode("PROCESS_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
        }
    }
    
    /**
     * Convert an Azure DevOps work item to a CS Test Forge test case
     */
    private Map<String, Object> convertWorkItemToTestCase(
            Map<String, Object> workItem, 
            Map<String, Object> testPoint) {
        
        Map<String, Object> testCase = new HashMap<>();
        Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
        
        // Basic work item fields
        testCase.put("id", workItem.get("id"));
        testCase.put("externalId", workItem.get("id"));
        testCase.put("externalUrl", workItem.get("url"));
        testCase.put("revision", workItem.get("rev"));
        testCase.put("name", fields.get("System.Title"));
        testCase.put("description", fields.get("System.Description"));
        testCase.put("createdBy", fields.get("System.CreatedBy"));
        testCase.put("createdDate", fields.get("System.CreatedDate"));
        testCase.put("changedBy", fields.get("System.ChangedBy"));
        testCase.put("changedDate", fields.get("System.ChangedDate"));
        testCase.put("state", fields.get("System.State"));
        testCase.put("priority", fields.get("Microsoft.VSTS.Common.Priority"));
        testCase.put("automationStatus", fields.get("Microsoft.VSTS.TCM.AutomationStatus"));
        
        // Test specific fields
        testCase.put("steps", convertTestSteps(fields.get("Microsoft.VSTS.TCM.Steps")));
        testCase.put("parameters", extractTestParameters(fields.get("Microsoft.VSTS.TCM.Parameters")));
        
        // Add test point data if available
        if (testPoint != null) {
            Map<String, Object> testPointData = new HashMap<>();
            testPointData.put("id", testPoint.get("id"));
            testPointData.put("url", testPoint.get("url"));
            testPointData.put("outcome", testPoint.get("outcome"));
            testPointData.put("state", testPoint.get("state"));
            testCase.put("testPoint", testPointData);
        }
        
        // Add custom fields that may be present
        for (Map.Entry<String, Object> entry : fields.entrySet()) {
            String key = entry.getKey();
            if (key.startsWith("Custom.") || (key.startsWith("Microsoft.VSTS.TCM.") && !testCase.containsKey(key))) {
                testCase.put(key, entry.getValue());
            }
        }
        
        // Add metadata for tracking
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("syncSource", "azure-devops");
        metadata.put("lastSyncedAt", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        testCase.put("metadata", metadata);
        
        return testCase;
    }
    
    /**
     * Convert Azure DevOps test steps to CS Test Forge format
     */
    private List<Map<String, Object>> convertTestSteps(Object stepsXml) {
        List<Map<String, Object>> steps = new ArrayList<>();
        
        if (stepsXml == null || !(stepsXml instanceof String) || ((String) stepsXml).isEmpty()) {
            return steps;
        }
        
        try {
            // Parse HTML/XML content
            Document doc = Jsoup.parse((String) stepsXml);
            Elements stepElements = doc.select("step");
            
            for (Element stepElement : stepElements) {
                Map<String, Object> step = new HashMap<>();
                
                // Extract action
                Element actionElement = stepElement.selectFirst("parameterizedString[name=Action]");
                if (actionElement != null) {
                    step.put("action", actionElement.text());
                }
                
                // Extract expected result
                Element expectedElement = stepElement.selectFirst("parameterizedString[name=Expected]");
                if (expectedElement != null) {
                    step.put("expectedResult", expectedElement.text());
                }
                
                // Extract parameters if any
                Elements paramElements = stepElement.select("parameterizedString param");
                if (!paramElements.isEmpty()) {
                    List<Map<String, Object>> params = new ArrayList<>();
                    for (Element paramElement : paramElements) {
                        Map<String, Object> param = new HashMap<>();
                        param.put("name", paramElement.attr("name"));
                        param.put("value", paramElement.text());
                        params.add(param);
                    }
                    step.put("parameters", params);
                }
                
                steps.add(step);
            }
        } catch (Exception e) {
            logger.error("Error parsing test steps XML", e);
        }
        
        return steps;
    }
    
    /**
     * Extract test parameters from parameter string
     */
    private List<Map<String, Object>> extractTestParameters(Object parameterString) {
        List<Map<String, Object>> parameters = new ArrayList<>();
        
        if (parameterString == null || !(parameterString instanceof String) || ((String) parameterString).isEmpty()) {
            return parameters;
        }
        
        try {
            // Parameters are often in a CSV-like format
            String[] lines = ((String) parameterString).split("\n");
            
            if (lines.length > 1) {
                // First line contains headers
                String[] headers = lines[0].split(",");
                
                // Process each data row
                for (int i = 1; i < lines.length; i++) {
                    String line = lines[i];
                    if (line.trim().isEmpty()) {
                        continue;
                    }
                    
                    String[] values = line.split(",");
                    Map<String, Object> paramSet = new HashMap<>();
                    
                    for (int j = 0; j < headers.length && j < values.length; j++) {
                        paramSet.put(headers[j].trim(), values[j].trim());
                    }
                    
                    parameters.add(paramSet);
                }
            }
        } catch (Exception e) {
            logger.error("Error parsing test parameters", e);
        }
        
        return parameters;
    }
    
    /**
     * Merge two test cases, preferring the first for conflicts
     */
    private Map<String, Object> mergeTestCases(
            Map<String, Object> existingTestCase, 
            Map<String, Object> newTestCase) {
        
        Map<String, Object> mergedTestCase = new HashMap<>(existingTestCase);
        
        // Override with values from new test case, except for id, revision, and metadata
        for (Map.Entry<String, Object> entry : newTestCase.entrySet()) {
            String key = entry.getKey();
            if (!"id".equals(key) && !"revision".equals(key) && !"metadata".equals(key)) {
                mergedTestCase.put(key, entry.getValue());
            }
        }
        
        // Merge metadata
        Map<String, Object> existingMetadata = (Map<String, Object>) existingTestCase.getOrDefault("metadata", new HashMap<>());
        Map<String, Object> newMetadata = (Map<String, Object>) newTestCase.getOrDefault("metadata", new HashMap<>());
        
        existingMetadata.put("lastSyncedAt", newMetadata.getOrDefault("lastSyncedAt", 
                LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)));
        mergedTestCase.put("metadata", existingMetadata);
        
        return mergedTestCase;
    }
    
    /**
     * Update test case index
     */
    private void updateTestCaseIndex(String projectId, String testCaseId, String name) throws IOException {
        Path projectTestCasesDir = Paths.get(dataDirectory, "projects", projectId, "test-cases");
        Path indexFile = projectTestCasesDir.resolve("index.json");
        
        Map<String, Object> index;
        if (Files.exists(indexFile)) {
            String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
            index = objectMapper.readValue(indexContent, Map.class);
        } else {
            index = new HashMap<>();
            index.put("testCases", new HashMap<>());
        }
        
        Map<String, Object> testCases = (Map<String, Object>) index.get("testCases");
        Map<String, Object> testCaseEntry = new HashMap<>();
        testCaseEntry.put("id", testCaseId);
        testCaseEntry.put("name", name);
        testCaseEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        testCases.put(testCaseId, testCaseEntry);
        
        // Write updated index
        objectMapper.writeValue(indexFile.toFile(), index);
    }
    
    /**
     * Update test case relationships with test plans and suites
     */
    private void updateTestCaseRelationships(
            String projectId, 
            String testCaseId, 
            Long testPlanId, 
            Long testSuiteId) throws IOException {
        
        // Create relationships directory if it doesn't exist
        Path relationshipsDir = Paths.get(
                dataDirectory, 
                "projects", 
                projectId, 
                "relationships");
        Files.createDirectories(relationshipsDir);
        
        // Update test case to test plan relationship
        updateTestCaseToTestPlanRelationship(
                relationshipsDir, 
                testCaseId, 
                testPlanId.toString());
        
        // Update test case to test suite relationship
        updateTestCaseToTestSuiteRelationship(
                relationshipsDir, 
                testCaseId, 
                testPlanId.toString(), 
                testSuiteId.toString());
    }
    
    /**
     * Update test case to test plan relationship
     */
    private void updateTestCaseToTestPlanRelationship(
            Path relationshipsDir, 
            String testCaseId, 
            String testPlanId) throws IOException {
        
        Path tcToTpFile = relationshipsDir.resolve("testcase_to_testplan.json");
        
        Map<String, Object> relationships;
        if (Files.exists(tcToTpFile)) {
            String content = new String(Files.readAllBytes(tcToTpFile), StandardCharsets.UTF_8);
            relationships = objectMapper.readValue(content, Map.class);
        } else {
            relationships = new HashMap<>();
        }
        
        // Get or create test case entry
        Map<String, Object> testCaseEntry = (Map<String, Object>) relationships.get(testCaseId);
        if (testCaseEntry == null) {
            testCaseEntry = new HashMap<>();
            relationships.put(testCaseId, testCaseEntry);
        }
        
        // Get or create test plans list
        List<String> testPlans = (List<String>) testCaseEntry.get("testPlans");
        if (testPlans == null) {
            testPlans = new ArrayList<>();
            testCaseEntry.put("testPlans", testPlans);
        }
        
        // Add test plan if not already in the list
        if (!testPlans.contains(testPlanId)) {
            testPlans.add(testPlanId);
        }
        
        // Update last sync time
        testCaseEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        // Write updated relationships
        objectMapper.writeValue(tcToTpFile.toFile(), relationships);
    }
    
    /**
     * Update test case to test suite relationship
     */
    private void updateTestCaseToTestSuiteRelationship(
            Path relationshipsDir, 
            String testCaseId, 
            String testPlanId, 
            String testSuiteId) throws IOException {
        
        Path tcToTsFile = relationshipsDir.resolve("testcase_to_testsuite.json");
        
        Map<String, Object> relationships;
        if (Files.exists(tcToTsFile)) {
            String content = new String(Files.readAllBytes(tcToTsFile), StandardCharsets.UTF_8);
            relationships = objectMapper.readValue(content, Map.class);
        } else {
            relationships = new HashMap<>();
        }
        
        // Get or create test case entry
        Map<String, Object> testCaseEntry = (Map<String, Object>) relationships.get(testCaseId);
        if (testCaseEntry == null) {
            testCaseEntry = new HashMap<>();
            relationships.put(testCaseId, testCaseEntry);
        }
        
        // Get or create test suites map
        Map<String, List<String>> testSuites = (Map<String, List<String>>) testCaseEntry.get("testSuites");
        if (testSuites == null) {
            testSuites = new HashMap<>();
            testCaseEntry.put("testSuites", testSuites);
        }
        
        // Get or create test suites for this test plan
        List<String> suites = testSuites.get(testPlanId);
        if (suites == null) {
            suites = new ArrayList<>();
            testSuites.put(testPlanId, suites);
        }
        
        // Add test suite if not already in the list
        if (!suites.contains(testSuiteId)) {
            suites.add(testSuiteId);
        }
        
        // Update last sync time
        testCaseEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        // Write updated relationships
        objectMapper.writeValue(tcToTsFile.toFile(), relationships);
    }
    
    /**
     * Download attachments from Azure DevOps
     * 
     * @param integration The integration
     * @param itemId The item ID
     * @param relations List of relations
     * @param attachmentsDir Directory to save attachments
     * @return Number of attachments downloaded
     */
    private int downloadAttachments(
            Integration integration,
            String itemId,
            List<Map<String, Object>> relations,
            Path attachmentsDir) {
        
        int attachmentsDownloaded = 0;
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String pat = (String) settings.get("pat");
        
        try {
            Files.createDirectories(attachmentsDir);
            
            // Filter for attachment relations
            List<Map<String, Object>> attachmentRelations = relations.stream()
                    .filter(rel -> "AttachedFile".equals(rel.get("rel")))
                    .collect(Collectors.toList());
            
            // Download each attachment
            for (Map<String, Object> attachmentRel : attachmentRelations) {
                String attachmentUrl = (String) attachmentRel.get("url");
                String attachmentName = (String) attachmentRel.get("attributes").toString();
                
                // Extract file name from attributes or URL
                String fileName = null;
                if (attachmentName != null) {
                    // Try to extract from attributes
                    Pattern namePattern = Pattern.compile("name=([^,]+)");
                    Matcher matcher = namePattern.matcher(attachmentName);
                    if (matcher.find()) {
                        fileName = matcher.group(1);
                    }
                }
                
                if (fileName == null) {
                    // Extract from URL
                    fileName = attachmentUrl.substring(attachmentUrl.lastIndexOf('/') + 1);
                }
                
                // Download attachment
                try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                    HttpGet httpGet = new HttpGet(attachmentUrl);
                    httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                        int statusCode = response.getStatusLine().getStatusCode();
                        
                        if (statusCode == HttpStatus.SC_OK) {
                            // Save attachment to file
                            Path attachmentFile = attachmentsDir.resolve(fileName);
                            
                            try (InputStream inputStream = response.getEntity().getContent();
                                 FileOutputStream outputStream = new FileOutputStream(attachmentFile.toFile())) {
                                
                                byte[] buffer = new byte[8192];
                                int bytesRead;
                                while ((bytesRead = inputStream.read(buffer)) != -1) {
                                    outputStream.write(buffer, 0, bytesRead);
                                }
                            }
                            
                            attachmentsDownloaded++;
                            logger.info("Downloaded attachment '{}' for item {}", fileName, itemId);
                        } else {
                            logger.error("Failed to download attachment '{}' for item {}: Status code {}", 
                                    fileName, itemId, statusCode);
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error downloading attachments for item {}", itemId, e);
        }
        
        return attachmentsDownloaded;
    }
    
    /**
     * Push data from CS Test Forge to Azure DevOps
     */
    private void pushToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_PLAN":
                    pushTestPlansToAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_SUITE":
                    pushTestSuitesToAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_CASE":
                    pushTestCasesToAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_RESULT":
                    pushTestResultsToAzureDevOps(integration, syncOptions, stats, result);
                    break;
                default:
                    logger.warn("Unsupported content type for push: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for push: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Push test plans to Azure DevOps
     */
    private void pushTestPlansToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Test plans are typically created in Azure DevOps and imported to CS Test Forge
        // This implementation will focus on updating existing test plans rather than creating new ones
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plans directory
        Path testPlansDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-plans");
        
        if (!Files.exists(testPlansDir)) {
            logger.info("No test plans found to push");
            return;
        }
        
        // Get test plan index
        Path indexFile = testPlansDir.resolve("index.json");
        if (!Files.exists(indexFile)) {
            logger.info("No test plan index found");
            return;
        }
        
        String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
        Map<String, Object> index = objectMapper.readValue(indexContent, Map.class);
        
        Map<String, Object> testPlans = (Map<String, Object>) index.get("testPlans");
        if (testPlans == null || testPlans.isEmpty()) {
            logger.info("No test plans found in index");
            return;
        }
        
        // Filter test plans based on options
        List<String> testPlanIds = new ArrayList<>(testPlans.keySet());
        Long specificTestPlanId = syncOptions.getAdoTestPlanId();
        
        if (specificTestPlanId != null) {
            // Filter to specific test plan
            testPlanIds = testPlanIds.stream()
                    .filter(id -> specificTestPlanId.toString().equals(id))
                    .collect(Collectors.toList());
        }
        
        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
        boolean dryRun = syncOptions.isDryRun();
        
        // Process each test plan
        int processed = 0;
        for (String testPlanId : testPlanIds) {
            if (processed >= maxItems) {
                break;
            }
            
            Path testPlanFile = testPlansDir.resolve(testPlanId + ".json");
            if (!Files.exists(testPlanFile)) {
                continue;
            }
            
            String testPlanContent = new String(Files.readAllBytes(testPlanFile), StandardCharsets.UTF_8);
            Map<String, Object> testPlan = objectMapper.readValue(testPlanContent, Map.class);
            
            // Push test plan to Azure DevOps
            try {
                updateTestPlanInAzureDevOps(integration, syncOptions, testPlan, dryRun);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setUpdated(stats.getUpdated() + 1);
                
                logger.info("Updated test plan {} in Azure DevOps", testPlanId);
            } catch (Exception e) {
                logger.error("Error updating test plan {} in Azure DevOps", testPlanId, e);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setErrors(stats.getErrors() + 1);
                
                // Add error to result
                result.getIssues().add(
                        new IntegrationSyncResult.SyncIssue()
                                .setSeverity("ERROR")
                                .setContentType("TEST_PLAN")
                                .setItemId(testPlanId)
                                .setMessage("Failed to update test plan: " + e.getMessage())
                                .setCode("UPDATE_ERROR")
                                .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
            }
            
            processed++;
        }
    }
    
    /**
     * Update a test plan in Azure DevOps
     */
    private void updateTestPlanInAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            Map<String, Object> testPlan,
            boolean dryRun) throws Exception {
        
        if (dryRun) {
            return;
        }
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Extract test plan ID
        String testPlanId = testPlan.get("id").toString();
        
        // Create update payload
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Only update name and description fields
        String name = (String) testPlan.get("name");
        if (name != null) {
            Map<String, Object> nameOp = new HashMap<>();
            nameOp.put("op", "replace");
            nameOp.put("path", "/name");
            nameOp.put("value", name);
            operations.add(nameOp);
        }
        
        String description = (String) testPlan.get("description");
        if (description != null) {
            Map<String, Object> descOp = new HashMap<>();
            descOp.put("op", "replace");
            descOp.put("path", "/description");
            descOp.put("value", description);
            operations.add(descOp);
        }
        
        // Skip if no operations
        if (operations.isEmpty()) {
            return;
        }
        
        // Send update to Azure DevOps
        String testPlanUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/plans/%s",
                organization, project, testPlanId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPatch httpPatch = new HttpPatch(buildAzureDevOpsUri(testPlanUrl));
            httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPatch.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(operations),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPatch)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to update test plan: Status code " + statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Push test suites to Azure DevOps
     */
    private void pushTestSuitesToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Similar to test plans, test suites are typically created in Azure DevOps and imported
        // This implementation will focus on updating existing test suites
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan and suite IDs if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null) {
            logger.info("No test plan ID provided");
            return;
        }
        
        // Get test suites directory
        Path testSuitesDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-plans", 
                testPlanId.toString(), 
                "suites");
        
        if (!Files.exists(testSuitesDir)) {
            logger.info("No test suites found for test plan {}", testPlanId);
            return;
        }
        
        // Get test suite index
        Path indexFile = testSuitesDir.resolve("index.json");
        if (!Files.exists(indexFile)) {
            logger.info("No test suite index found for test plan {}", testPlanId);
            return;
        }
        
        String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
        Map<String, Object> index = objectMapper.readValue(indexContent, Map.class);
        
        Map<String, Object> testSuites = (Map<String, Object>) index.get("testSuites");
        if (testSuites == null || testSuites.isEmpty()) {
            logger.info("No test suites found in index for test plan {}", testPlanId);
            return;
        }
        
        // Filter test suites based on options
        List<String> testSuiteIds = new ArrayList<>(testSuites.keySet());
        
        if (testSuiteId != null) {
            // Filter to specific test suite
            testSuiteIds = testSuiteIds.stream()
                    .filter(id -> testSuiteId.toString().equals(id))
                    .collect(Collectors.toList());
        }
        
        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
        boolean dryRun = syncOptions.isDryRun();
        
        // Process each test suite
        int processed = 0;
        for (String suiteId : testSuiteIds) {
            if (processed >= maxItems) {
                break;
            }
            
            Path testSuiteFile = testSuitesDir.resolve(suiteId + ".json");
            if (!Files.exists(testSuiteFile)) {
                continue;
            }
            
            String testSuiteContent = new String(Files.readAllBytes(testSuiteFile), StandardCharsets.UTF_8);
            Map<String, Object> testSuite = objectMapper.readValue(testSuiteContent, Map.class);
            
            // Push test suite to Azure DevOps
            try {
                updateTestSuiteInAzureDevOps(integration, syncOptions, testPlanId.toString(), testSuite, dryRun);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setUpdated(stats.getUpdated() + 1);
                
                logger.info("Updated test suite {} in Azure DevOps", suiteId);
            } catch (Exception e) {
                logger.error("Error updating test suite {} in Azure DevOps", suiteId, e);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setErrors(stats.getErrors() + 1);
                
                // Add error to result
                result.getIssues().add(
                        new IntegrationSyncResult.SyncIssue()
                                .setSeverity("ERROR")
                                .setContentType("TEST_SUITE")
                                .setItemId(suiteId)
                                .setMessage("Failed to update test suite: " + e.getMessage())
                                .setCode("UPDATE_ERROR")
                                .setDetails(Map.of("stackTrace", getStackTraceAsString(e),
                                        "testPlanId", testPlanId)));
            }
            
            processed++;
        }
    }
    
    /**
     * Update a test suite in Azure DevOps
     */
    private void updateTestSuiteInAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            String testPlanId,
            Map<String, Object> testSuite,
            boolean dryRun) throws Exception {
        
        if (dryRun) {
            return;
        }
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Extract test suite ID
        String testSuiteId = testSuite.get("id").toString();
        
        // Create update payload
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Only update name field
        String name = (String) testSuite.get("name");
        if (name != null) {
            Map<String, Object> nameOp = new HashMap<>();
            nameOp.put("op", "replace");
            nameOp.put("path", "/name");
            nameOp.put("value", name);
            operations.add(nameOp);
        }
        
        // Skip if no operations
        if (operations.isEmpty()) {
            return;
        }
        
        // Send update to Azure DevOps
        String testSuiteUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/plans/%s/suites/%s",
                organization, project, testPlanId, testSuiteId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPatch httpPatch = new HttpPatch(buildAzureDevOpsUri(testSuiteUrl));
            httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPatch.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(operations),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPatch)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to update test suite: Status code " + statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Push test cases to Azure DevOps
     */
    private void pushTestCasesToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test cases directory
        Path testCasesDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-cases");
        
        if (!Files.exists(testCasesDir)) {
            logger.info("No test cases found to push");
            return;
        }
        
        // Get test case index
        Path indexFile = testCasesDir.resolve("index.json");
        if (!Files.exists(indexFile)) {
            logger.info("No test case index found");
            return;
        }
        
        String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
        Map<String, Object> index = objectMapper.readValue(indexContent, Map.class);
        
        Map<String, Object> testCases = (Map<String, Object>) index.get("testCases");
        if (testCases == null || testCases.isEmpty()) {
            logger.info("No test cases found in index");
            return;
        }
        
        // Filter test cases based on options
        List<String> testCaseIds = new ArrayList<>(testCases.keySet());
        
        // Apply filters from sync options
        if (syncOptions.getFilters() != null && !syncOptions.getFilters().isEmpty()) {
            Map<String, Object> filters = syncOptions.getFilters();
            
            if (filters.containsKey("testCaseIds")) {
                List<String> filterIds = (List<String>) filters.get("testCaseIds");
                testCaseIds = testCaseIds.stream()
                        .filter(id -> filterIds.contains(id))
                        .collect(Collectors.toList());
            }
            
            // Add additional filters as needed
        }
        
        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
        boolean dryRun = syncOptions.isDryRun();
        
        // Process each test case
        int processed = 0;
        for (String testCaseId : testCaseIds) {
            if (processed >= maxItems) {
                break;
            }
            
            Path testCaseFile = testCasesDir.resolve(testCaseId + ".json");
            if (!Files.exists(testCaseFile)) {
                continue;
            }
            
            String testCaseContent = new String(Files.readAllBytes(testCaseFile), StandardCharsets.UTF_8);
            Map<String, Object> testCase = objectMapper.readValue(testCaseContent, Map.class);
            
            // Push test case to Azure DevOps
            try {
                updateTestCaseInAzureDevOps(integration, syncOptions, testCase, dryRun);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setUpdated(stats.getUpdated() + 1);
                
                logger.info("Updated test case {} in Azure DevOps", testCaseId);
            } catch (Exception e) {
                logger.error("Error updating test case {} in Azure DevOps", testCaseId, e);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setErrors(stats.getErrors() + 1);
                
                // Add error to result
                result.getIssues().add(
                        new IntegrationSyncResult.SyncIssue()
                                .setSeverity("ERROR")
                                .setContentType("TEST_CASE")
                                .setItemId(testCaseId)
                                .setMessage("Failed to update test case: " + e.getMessage())
                                .setCode("UPDATE_ERROR")
                                .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
            }
            
            processed++;
        }
    }
    
    /**
     * Update a test case in Azure DevOps
     */
    private void updateTestCaseInAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            Map<String, Object> testCase,
            boolean dryRun) throws Exception {
        
        if (dryRun) {
            return;
        }
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Extract test case ID
        String testCaseId = testCase.get("id").toString();
        
        // Create update payload for work item
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Map test case fields to Azure DevOps fields
        if (testCase.get("name") != null) {
            Map<String, Object> titleOp = new HashMap<>();
            titleOp.put("op", "replace");
            titleOp.put("path", "/fields/System.Title");
            titleOp.put("value", testCase.get("name"));
            operations.add(titleOp);
        }
        
        if (testCase.get("description") != null) {
            Map<String, Object> descOp = new HashMap<>();
            descOp.put("op", "replace");
            descOp.put("path", "/fields/System.Description");
            descOp.put("value", testCase.get("description"));
            operations.add(descOp);
        }
        
        if (testCase.get("priority") != null) {
            Map<String, Object> priorityOp = new HashMap<>();
            priorityOp.put("op", "replace");
            priorityOp.put("path", "/fields/Microsoft.VSTS.Common.Priority");
            priorityOp.put("value", testCase.get("priority"));
            operations.add(priorityOp);
        }
        
        if (testCase.get("automationStatus") != null) {
            Map<String, Object> autoOp = new HashMap<>();
            autoOp.put("op", "replace");
            autoOp.put("path", "/fields/Microsoft.VSTS.TCM.AutomationStatus");
            autoOp.put("value", testCase.get("automationStatus"));
            operations.add(autoOp);
        }
        
        // Handle test steps
        if (testCase.get("steps") != null) {
            String stepsXml = convertTestStepsToXml((List<Map<String, Object>>) testCase.get("steps"));
            if (stepsXml != null) {
                Map<String, Object> stepsOp = new HashMap<>();
                stepsOp.put("op", "replace");
                stepsOp.put("path", "/fields/Microsoft.VSTS.TCM.Steps");
                stepsOp.put("value", stepsXml);
                operations.add(stepsOp);
            }
        }
        
        // Handle test parameters
        if (testCase.get("parameters") != null) {
            String paramsString = convertTestParametersToString((List<Map<String, Object>>) testCase.get("parameters"));
            if (paramsString != null) {
                Map<String, Object> paramsOp = new HashMap<>();
                paramsOp.put("op", "replace");
                paramsOp.put("path", "/fields/Microsoft.VSTS.TCM.Parameters");
                paramsOp.put("value", paramsString);
                operations.add(paramsOp);
            }
        }
        
        // Skip if no operations
        if (operations.isEmpty()) {
            return;
        }
        
        // Send update to Azure DevOps
        String workItemUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/workitems/%s",
                organization, project, testCaseId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPatch httpPatch = new HttpPatch(buildAzureDevOpsUri(workItemUrl));
            httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPatch.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(operations),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPatch)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to update test case: Status code " + statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Convert test steps to XML format for Azure DevOps
     */
    private String convertTestStepsToXml(List<Map<String, Object>> steps) {
        if (steps == null || steps.isEmpty()) {
            return null;
        }
        
        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        xml.append("<steps id=\"0\">\n");
        
        for (Map<String, Object> step : steps) {
            xml.append("  <step id=\"").append(steps.indexOf(step) + 1).append("\">\n");
            
            // Action
            String action = (String) step.get("action");
            if (action != null) {
                xml.append("    <parameterizedString isformatted=\"true\" name=\"Action\">");
                xml.append(escapeXml(action));
                xml.append("</parameterizedString>\n");
            } else {
                xml.append("    <parameterizedString isformatted=\"true\" name=\"Action\"></parameterizedString>\n");
            }
            
            // Expected result
            String expected = (String) step.get("expectedResult");
            if (expected != null) {
                xml.append("    <parameterizedString isformatted=\"true\" name=\"Expected\">");
                xml.append(escapeXml(expected));
                xml.append("</parameterizedString>\n");
            } else {
                xml.append("    <parameterizedString isformatted=\"true\" name=\"Expected\"></parameterizedString>\n");
            }
            
            // Parameters
            List<Map<String, Object>> params = (List<Map<String, Object>>) step.get("parameters");
            if (params != null && !params.isEmpty()) {
                for (Map<String, Object> param : params) {
                    String name = (String) param.get("name");
                    String value = (String) param.get("value");
                    
                    if (name != null) {
                        xml.append("    <param name=\"").append(escapeXml(name)).append("\">");
                        xml.append(value != null ? escapeXml(value) : "");
                        xml.append("</param>\n");
                    }
                }
            }
            
            xml.append("  </step>\n");
        }
        
        xml.append("</steps>");
        return xml.toString();
    }
    
    /**
     * Convert test parameters to string format for Azure DevOps
     */
    private String convertTestParametersToString(List<Map<String, Object>> parameters) {
        if (parameters == null || parameters.isEmpty()) {
            return null;
        }
        
        StringBuilder csv = new StringBuilder();
        
        // Extract all column names
        Set<String> columnNames = new HashSet<>();
        for (Map<String, Object> param : parameters) {
            columnNames.addAll(param.keySet());
        }
        
        // Write header row
        csv.append(String.join(",", columnNames)).append("\n");
        
        // Write data rows
        for (Map<String, Object> param : parameters) {
            List<String> values = new ArrayList<>();
            
            for (String columnName : columnNames) {
                Object value = param.get(columnName);
                values.add(value != null ? value.toString() : "");
            }
            
            csv.append(String.join(",", values)).append("\n");
        }
        
        return csv.toString();
    }
    
    /**
     * Push test results to Azure DevOps
     */
    private void pushTestResultsToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plan and suite IDs
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null || testSuiteId == null) {
            logger.info("Test plan ID and suite ID are required to push test results");
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_RESULT")
                            .setMessage("Test plan ID and suite ID are required to push test results")
                            .setCode("MISSING_IDS"));
            stats.setErrors(stats.getErrors() + 1);
            return;
        }
        
        // Get test results directory
        Path testResultsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-results");
        
        if (!Files.exists(testResultsDir)) {
            logger.info("No test results found to push");
            return;
        }
        
        // Get test results index
        Path indexFile = testResultsDir.resolve("index.json");
        if (!Files.exists(indexFile)) {
            logger.info("No test results index found");
            return;
        }
        
        String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
        Map<String, Object> index = objectMapper.readValue(indexContent, Map.class);
        
        Map<String, Object> testResults = (Map<String, Object>) index.get("testResults");
        if (testResults == null || testResults.isEmpty()) {
            logger.info("No test results found in index");
            return;
        }
        
        // Create a test run in Azure DevOps
        if (syncOptions.isDryRun()) {
            logger.info("Dry run - would create test run in Azure DevOps");
            stats.setSkipped(stats.getSkipped() + testResults.size());
            return;
        }
        
        try {
            // Create test run
            Map<String, Object> testRun = createTestRunInAzureDevOps(
                    integration, syncOptions, testPlanId, testSuiteId);
            
            if (testRun == null || testRun.get("id") == null) {
                throw new Exception("Failed to create test run in Azure DevOps");
            }
            
            Number testRunId = (Number) testRun.get("id");
            
            // Store test run ID and URL in result
            result.setAdoTestRunId(testRunId.longValue());
            result.setAdoTestRunUrl((String) testRun.get("url"));
            
            // Process each test result
            int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
            int processed = 0;
            
            for (String resultId : testResults.keySet()) {
                if (processed >= maxItems) {
                    break;
                }
                
                Map<String, Object> resultEntry = (Map<String, Object>) testResults.get(resultId);
                String testCaseId = (String) resultEntry.get("testCaseId");
                
                if (testCaseId == null) {
                    continue;
                }
                
                Path resultFile = testResultsDir.resolve(resultId + ".json");
                if (!Files.exists(resultFile)) {
                    continue;
                }
                
                String resultContent = new String(Files.readAllBytes(resultFile), StandardCharsets.UTF_8);
                Map<String, Object> resultData = objectMapper.readValue(resultContent, Map.class);
                
                // Push test result to Azure DevOps
                try {
                    addTestResultToRun(
                            integration, syncOptions, testRunId.toString(), testCaseId, resultData);
                    
                    // Update stats
                    stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                    stats.setCreated(stats.getCreated() + 1);
                    
                    logger.info("Added test result {} to test run {} in Azure DevOps", resultId, testRunId);
                } catch (Exception e) {
                    logger.error("Error adding test result {} to test run {} in Azure DevOps", resultId, testRunId, e);
                    
                    // Update stats
                    stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                    stats.setErrors(stats.getErrors() + 1);
                    
                    // Add error to result
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("ERROR")
                                    .setContentType("TEST_RESULT")
                                    .setItemId(resultId)
                                    .setMessage("Failed to add test result: " + e.getMessage())
                                    .setCode("ADD_ERROR")
                                    .setDetails(Map.of("stackTrace", getStackTraceAsString(e),
                                            "testRunId", testRunId)));
                }
                
                processed++;
            }
        } catch (Exception e) {
            logger.error("Error creating test run in Azure DevOps", e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_RESULT")
                            .setMessage("Failed to create test run: " + e.getMessage())
                            .setCode("CREATE_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
        }
    }
    
    /**
     * Create a test run in Azure DevOps
     */
    private Map<String, Object> createTestRunInAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            Long testPlanId,
            Long testSuiteId) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Create test run payload
        Map<String, Object> testRun = new HashMap<>();
        
        // Generate test run name
        String testRunTitleFormat = syncOptions.getAdoTestRunTitleFormat();
        if (testRunTitleFormat == null) {
            testRunTitleFormat = "CS Test Forge Test Run - {date}";
        }
        
        String testRunName = testRunTitleFormat.replace("{date}", 
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        
        testRun.put("name", testRunName);
        testRun.put("state", "InProgress");
        
        // Set plan and suite
        Map<String, Object> plan = new HashMap<>();
        plan.put("id", testPlanId);
        testRun.put("plan", plan);
        
        testRun.put("pointIds", new ArrayList<>());
        
        // Send API request
        String testRunsUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/runs",
                organization, project);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testRunsUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(testRun),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to create test run: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                return objectMapper.readValue(responseBody, Map.class);
            }
        }
    }
    
    /**
     * Add a test result to a test run in Azure DevOps
     */
    private void addTestResultToRun(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            String testRunId,
            String testCaseId,
            Map<String, Object> resultData) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Create test result payload
        List<Map<String, Object>> results = new ArrayList<>();
        Map<String, Object> result = new HashMap<>();
        
        // Set test case details
        result.put("testCaseTitle", resultData.get("name"));
        result.put("testCase", Map.of("id", testCaseId));
        
        // Set outcome
        String outcome = (String) resultData.get("outcome");
        if (outcome == null) {
            outcome = "Passed"; // Default to passed
        }
        result.put("outcome", outcome);
        
        // Set other details
        result.put("state", "Completed");
        result.put("comment", resultData.get("comment"));
        result.put("durationInMs", resultData.get("durationMs"));
        
        // Add error message if failed
        if ("Failed".equals(outcome)) {
            result.put("errorMessage", resultData.get("errorMessage"));
            result.put("stackTrace", resultData.get("stackTrace"));
        }
        
        // Add test step results if available
        if (resultData.get("stepResults") != null) {
            List<Map<String, Object>> stepResults = new ArrayList<>();
            List<Map<String, Object>> sourceStepResults = (List<Map<String, Object>>) resultData.get("stepResults");
            
            for (Map<String, Object> sourceStep : sourceStepResults) {
                Map<String, Object> stepResult = new HashMap<>();
                stepResult.put("outcome", sourceStep.get("outcome"));
                stepResult.put("stepIdentifier", sourceStep.get("stepId"));
                stepResult.put("comment", sourceStep.get("comment"));
                
                if ("Failed".equals(sourceStep.get("outcome"))) {
                    stepResult.put("errorMessage", sourceStep.get("errorMessage"));
                }
                
                stepResults.add(stepResult);
            }
            
            result.put("testStepResults", stepResults);
        }
        
        // Add result to list
        results.add(result);
        
        // Send API request
        String testResultsUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/runs/%s/results",
                organization, project, testRunId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testResultsUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(results),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to add test result: Status code " + statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Synchronize with Azure DevOps Git
     */
    private void syncWithAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Prepare sync options if null
        if (syncOptions == null) {
            syncOptions = new IntegrationSyncOptions();
        }
        
        // Default content types if not specified
        if (syncOptions.getContentTypes() == null || syncOptions.getContentTypes().isEmpty()) {
            syncOptions.setContentTypes(Arrays.asList("TEST_SCRIPT", "TEST_RESULT"));
        }
        
        // Determine sync direction
        String direction = syncOptions.getDirection();
        if (direction == null) {
            direction = "PULL";
        }
        
        // Initialize stats for each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = new IntegrationSyncResult.SyncStats()
                    .setContentType(contentType)
                    .setTotalProcessed(0)
                    .setCreated(0)
                    .setUpdated(0)
                    .setDeleted(0)
                    .setSkipped(0)
                    .setErrors(0)
                    .setConflicts(0);
            
            result.getStats().put(contentType, stats);
        }
        
        // Implement sync based on direction
        try {
            if ("PULL".equals(direction)) {
                // Pull data from Azure DevOps Git to CS Test Forge
                pullFromAzureDevOpsGit(integration, syncOptions, result);
            } else if ("PUSH".equals(direction)) {
                // Push data from CS Test Forge to Azure DevOps Git
                pushToAzureDevOpsGit(integration, syncOptions, result);
            } else if ("BIDIRECTIONAL".equals(direction)) {
                // Pull first, then push
                pullFromAzureDevOpsGit(integration, syncOptions, result);
                pushToAzureDevOpsGit(integration, syncOptions, result);
            } else {
                throw new IllegalArgumentException("Invalid sync direction: " + direction);
            }
            
            // Set success message
            result.setSuccessful(true);
            if (result.isDryRun()) {
                result.setMessage("Sync dry run completed successfully");
            } else {
                result.setMessage("Sync completed successfully");
            }
        } catch (Exception e) {
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
            
            // Add error to each content type
            for (IntegrationSyncResult.SyncStats stats : result.getStats().values()) {
                stats.setErrors(stats.getErrors() + 1);
            }
        }
    }
    
    /**
     * Pull data from Azure DevOps Git to CS Test Forge
     */
    private void pullFromAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get repository details
        String repoUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s",
                organization, project, repositoryId);
        
        Map<String, Object> repository = null;
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(repoUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode != HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get repository details: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                repository = objectMapper.readValue(responseBody, Map.class);
            }
        }
        
        if (repository == null) {
            throw new Exception("Repository not found");
        }
        
        // Get branch to use
        String branch = syncOptions.getAdoGitBranch();
        if (branch == null) {
            branch = "main"; // Default to main branch
            
            // Try to find default branch from repository
            if (repository.get("defaultBranch") != null) {
                String defaultBranch = (String) repository.get("defaultBranch");
                if (defaultBranch.startsWith("refs/heads/")) {
                    branch = defaultBranch.substring("refs/heads/".length());
                }
            }
        }
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_SCRIPT":
                    pullTestScriptsFromAzureDevOpsGit(integration, syncOptions, stats, result, branch);
                    break;
                default:
                    logger.warn("Unsupported content type for pull from Git: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for pull from Git: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Pull test scripts from Azure DevOps Git
     */
    private void pullTestScriptsFromAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String branch) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get path pattern to pull
        String pathPattern = syncOptions.getAdoGitPathPattern();
        if (pathPattern == null) {
            pathPattern = "**/*"; // Default to all files
        }
        
        // Get file extensions to filter
        List<String> fileExtensions = null;
        if (syncOptions.getAdoGitFileExtensions() != null && !syncOptions.getAdoGitFileExtensions().isEmpty()) {
            fileExtensions = syncOptions.getAdoGitFileExtensions();
        } else {
            // Default to typical test script extensions
            fileExtensions = Arrays.asList(".feature", ".spec.js", ".test.js", ".spec.ts", ".test.ts", ".py", ".java");
        }
        
        // Get items from Git repository
        List<Map<String, Object>> items = getItemsFromGitRepository(
                integration, syncOptions, repositoryId, branch, pathPattern);
        
        if (items == null || items.isEmpty()) {
            logger.info("No items found in Git repository matching pattern: {}", pathPattern);
            return;
        }
        
        // Filter items by file extension
        List<Map<String, Object>> filteredItems = new ArrayList<>();
        if (fileExtensions != null) {
            for (Map<String, Object> item : items) {
                String path = (String) item.get("path");
                if (path != null) {
                    for (String ext : fileExtensions) {
                        if (path.endsWith(ext)) {
                            filteredItems.add(item);
                            break;
                        }
                    }
                }
            }
        } else {
            filteredItems = items;
        }
        
        // Process items
        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
        boolean dryRun = syncOptions.isDryRun();
        
        int processed = 0;
        for (Map<String, Object> item : filteredItems) {
            if (processed >= maxItems) {
                break;
            }
            
            String path = (String) item.get("path");
            String objectId = (String) item.get("objectId");
            
            if (path == null || objectId == null) {
                continue;
            }
            
            // Skip folders
            if ("folder".equals(item.get("gitObjectType"))) {
                continue;
            }
            
            try {
                // Get file content
                byte[] content = getFileContent(integration, syncOptions, repositoryId, objectId);
                
                if (content == null) {
                    logger.warn("Failed to get content for file: {}", path);
                    continue;
                }
                
                // Process file
                if (!dryRun) {
                    processGitFile(integration, path, content);
                }
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                
                if (dryRun) {
                    stats.setSkipped(stats.getSkipped() + 1);
                } else {
                    stats.setCreated(stats.getCreated() + 1);
                }
                
                logger.info("Processed file from Git: {}", path);
            } catch (Exception e) {
                logger.error("Error processing file from Git: {}", path, e);
                
                // Update stats
                stats.setTotalProcessed(stats.getTotalProcessed() + 1);
                stats.setErrors(stats.getErrors() + 1);
                
                // Add error to result
                result.getIssues().add(
                        new IntegrationSyncResult.SyncIssue()
                                .setSeverity("ERROR")
                                .setContentType("TEST_SCRIPT")
                                .setItemId(path)
                                .setMessage("Failed to process file: " + e.getMessage())
                                .setCode("PROCESS_ERROR")
                                .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
            }
            
            processed++;
        }
    }
    
    /**
     * Get items from Git repository
     */
    private List<Map<String, Object>> getItemsFromGitRepository(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            String repositoryId,
            String branch,
            String pathPattern) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Build URL for Git items
        String itemsUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/items?recursionLevel=Full&versionDescriptor.version=%s&versionDescriptor.versionType=branch&scopePath=%s",
                organization, project, repositoryId, branch, pathPattern);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(itemsUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode != HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get items from Git repository: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                return (List<Map<String, Object>>) responseMap.get("value");
            }
        }
    }
    
    /**
     * Get file content from Git repository
     */
    private byte[] getFileContent(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            String repositoryId,
            String objectId) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Build URL for Git item content
        String contentUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/blobs/%s",
                organization, project, repositoryId, objectId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(contentUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, "application/octet-stream");
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode != HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get file content: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                HttpEntity entity = response.getEntity();
                if (entity != null) {
                    try (InputStream inputStream = entity.getContent()) {
                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                        byte[] buffer = new byte[4096];
                        int bytesRead;
                        while ((bytesRead = inputStream.read(buffer)) != -1) {
                            outputStream.write(buffer, 0, bytesRead);
                        }
                        return outputStream.toByteArray();
                    }
                }
                
                return null;
            }
        }
    }
    
    /**
     * Process a file from Git
     */
    private void processGitFile(
            Integration integration,
            String path,
            byte[] content) throws Exception {
        
        // Extract file name and extension
        String fileName = path.substring(path.lastIndexOf('/') + 1);
        String extension = fileName.contains(".") ? fileName.substring(fileName.lastIndexOf('.')) : "";
        
        // Determine file type based on extension
        String fileType;
        if (extension.equals(".feature")) {
            fileType = "FEATURE";
        } else if (extension.equals(".js") || extension.equals(".ts") || extension.contains(".test") || extension.contains(".spec")) {
            fileType = "TEST_SCRIPT";
        } else if (extension.equals(".java")) {
            fileType = "JAVA_TEST";
        } else if (extension.equals(".py")) {
            fileType = "PYTHON_TEST";
        } else {
            fileType = "OTHER";
        }
        
        // Create directory structure
        Path scriptsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-scripts", 
                fileType);
        Files.createDirectories(scriptsDir);
        
        // Create normalized file name
        String normalizedPath = path.replaceAll("[^a-zA-Z0-9.-]", "_");
        
        // Save file
        Path targetFile = scriptsDir.resolve(normalizedPath);
        Files.write(targetFile, content);
        
        // Update index
        updateScriptIndex(integration.getProjectId().toString(), fileType, normalizedPath, path);
    }
    
    /**
     * Update script index
     */
    private void updateScriptIndex(
            String projectId, 
            String fileType, 
            String normalizedPath, 
            String originalPath) throws IOException {
        
        Path scriptsDir = Paths.get(
                dataDirectory, 
                "projects", 
                projectId, 
                "test-scripts");
        
        Path indexFile = scriptsDir.resolve("index.json");
        
        Map<String, Object> index;
        if (Files.exists(indexFile)) {
            String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
            index = objectMapper.readValue(indexContent, Map.class);
        } else {
            index = new HashMap<>();
            index.put("scripts", new HashMap<>());
        }
        
        Map<String, Object> scripts = (Map<String, Object>) index.get("scripts");
        Map<String, Object> scriptEntry = new HashMap<>();
        scriptEntry.put("path", normalizedPath);
        scriptEntry.put("originalPath", originalPath);
        scriptEntry.put("type", fileType);
        scriptEntry.put("lastUpdated", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        scripts.put(normalizedPath, scriptEntry);
        
        // Write updated index
        objectMapper.writeValue(indexFile.toFile(), index);
    }
    
    /**
     * Push data from CS Test Forge to Azure DevOps Git
     */
    private void pushToAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get branch to use
        String branch = syncOptions.getAdoGitBranch();
        if (branch == null) {
            branch = "main"; // Default to main branch
        }
        
        // Get base path for files
        String basePath = syncOptions.getAdoGitBasePath();
        if (basePath == null) {
            basePath = "test-results"; // Default to test-results folder
        }
        
        // Get file format
        String fileFormat = syncOptions.getAdoGitFileFormat();
        if (fileFormat == null) {
            fileFormat = "html"; // Default to HTML format
        }
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_RESULT":
                    pushTestResultsToAzureDevOpsGit(integration, syncOptions, stats, result, branch, basePath, fileFormat);
                    break;
                default:
                    logger.warn("Unsupported content type for push to Git: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for push to Git: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Push test results to Azure DevOps Git
     */
    private void pushTestResultsToAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String branch,
            String basePath,
            String fileFormat) throws Exception {
        
        // Get test results directory
        Path testResultsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-results");
        
        if (!Files.exists(testResultsDir)) {
            logger.info("No test results found to push");
            return;
        }
        
        // Get test results index
        Path indexFile = testResultsDir.resolve("index.json");
        if (!Files.exists(indexFile)) {
            logger.info("No test results index found");
            return;
        }
        
        String indexContent = new String(Files.readAllBytes(indexFile), StandardCharsets.UTF_8);
        Map<String, Object> index = objectMapper.readValue(indexContent, Map.class);
        
        Map<String, Object> testResults = (Map<String, Object>) index.get("testResults");
        if (testResults == null || testResults.isEmpty()) {
            logger.info("No test results found in index");
            return;
        }
        
        // Check if dry run
        boolean dryRun = syncOptions.isDryRun();
        if (dryRun) {
            logger.info("Dry run - would push {} test results to Git", testResults.size());
            stats.setSkipped(stats.getSkipped() + testResults.size());
            return;
        }
        
        // Generate report
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String reportFileName = String.format("test-report-%s.%s", timestamp, fileFormat);
        String reportPath = basePath + "/" + reportFileName;
        
        byte[] reportContent = generateTestReport(integration, testResults, fileFormat);
        
        if (reportContent == null) {
            throw new Exception("Failed to generate test report");
        }
        
        // Create commit message
        String commitMessage = "Test results report generated at " + timestamp;
        if (syncOptions.getAdoGitCommitMessageFormat() != null) {
            commitMessage = syncOptions.getAdoGitCommitMessageFormat()
                    .replace("{timestamp}", timestamp)
                    .replace("{count}", String.valueOf(testResults.size()));
        }
        
        // Push to Git
        String commitId = createCommitInGit(
                integration, syncOptions, repositoryId, branch, reportPath, reportContent, commitMessage);
        
        if (commitId != null) {
            // Update stats
            stats.setTotalProcessed(testResults.size());
            stats.setCreated(1);
            
            // Add commit details to result
            result.setAdoGitCommitId(commitId);
            
            // Add commit URL
            String commitUrl = String.format(
                    "https://dev.azure.com/%s/%s/_git/%s/commit/%s",
                    integration.getSettings().get("organization"),
                    integration.getSettings().get("project"),
                    repositoryId,
                    commitId);
            result.setAdoGitCommitUrl(commitUrl);
            
            logger.info("Pushed test report to Git: {}", reportPath);
        } else {
            // Update stats
            stats.setTotalProcessed(testResults.size());
            stats.setErrors(1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_RESULT")
                            .setMessage("Failed to push test report to Git")
                            .setCode("PUSH_ERROR"));
        }
    }
    
    /**
     * Generate test report
     */
    private byte[] generateTestReport(
            Integration integration,
            Map<String, Object> testResults,
            String format) throws Exception {
        
        // Load test results
        List<Map<String, Object>> results = new ArrayList<>();
        Path testResultsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-results");
        
        for (String resultId : testResults.keySet()) {
            Path resultFile = testResultsDir.resolve(resultId + ".json");
            if (Files.exists(resultFile)) {
                String resultContent = new String(Files.readAllBytes(resultFile), StandardCharsets.UTF_8);
                Map<String, Object> resultData = objectMapper.readValue(resultContent, Map.class);
                results.add(resultData);
            }
        }
        
        // Generate report based on format
        if ("html".equalsIgnoreCase(format)) {
            return generateHtmlReport(results);
        } else if ("xml".equalsIgnoreCase(format)) {
            return generateXmlReport(results);
        } else if ("json".equalsIgnoreCase(format)) {
            return generateJsonReport(results);
        } else if ("md".equalsIgnoreCase(format) || "markdown".equalsIgnoreCase(format)) {
            return generateMarkdownReport(results);
        } else {
            // Default to HTML
            return generateHtmlReport(results);
        }
    }
    
    /**
     * Generate HTML report
     */
    private byte[] generateHtmlReport(List<Map<String, Object>> results) throws Exception {
        StringBuilder html = new StringBuilder();
        
        // Calculate summary statistics
        int total = results.size();
        int passed = 0;
        int failed = 0;
        int skipped = 0;
        
        for (Map<String, Object> result : results) {
            String outcome = (String) result.get("outcome");
            if ("Passed".equals(outcome)) {
                passed++;
            } else if ("Failed".equals(outcome)) {
                failed++;
            } else {
                skipped++;
            }
        }
        
        // Build HTML report
        html.append("<!DOCTYPE html>\n");
        html.append("<html lang=\"en\">\n");
        html.append("<head>\n");
        html.append("  <meta charset=\"UTF-8\">\n");
        html.append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        html.append("  <title>Test Results Report</title>\n");
        html.append("  <style>\n");
        html.append("    body { font-family: Arial, sans-serif; margin: 20px; }\n");
        html.append("    h1 { color: #333; }\n");
        html.append("    .summary { display: flex; margin-bottom: 20px; }\n");
        html.append("    .summary-item { margin-right: 20px; padding: 10px; border-radius: 5px; color: white; }\n");
        html.append("    .total { background-color: #007BFF; }\n");
        html.append("    .passed { background-color: #28A745; }\n");
        html.append("    .failed { background-color: #DC3545; }\n");
        html.append("    .skipped { background-color: #FFC107; color: #333; }\n");
        html.append("    table { width: 100%; border-collapse: collapse; }\n");
        html.append("    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }\n");
        html.append("    th { background-color: #f2f2f2; }\n");
        html.append("    .status-passed { color: #28A745; }\n");
        html.append("    .status-failed { color: #DC3545; }\n");
        html.append("    .status-skipped { color: #FFC107; }\n");
        html.append("  </style>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        html.append("  <h1>Test Results Report</h1>\n");
        html.append("  <p>Generated on: " + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) + "</p>\n");
        
        // Summary section
        html.append("  <h2>Summary</h2>\n");
        html.append("  <div class=\"summary\">\n");
        html.append("    <div class=\"summary-item total\">Total: " + total + "</div>\n");
        html.append("    <div class=\"summary-item passed\">Passed: " + passed + "</div>\n");
        html.append("    <div class=\"summary-item failed\">Failed: " + failed + "</div>\n");
        html.append("    <div class=\"summary-item skipped\">Skipped: " + skipped + "</div>\n");
        html.append("  </div>\n");
        
        // Results table
        html.append("  <h2>Test Results</h2>\n");
        html.append("  <table>\n");
        html.append("    <thead>\n");
        html.append("      <tr>\n");
        html.append("        <th>Test Case</th>\n");
        html.append("        <th>Status</th>\n");
        html.append("        <th>Duration</th>\n");
        html.append("        <th>Error</th>\n");
        html.append("      </tr>\n");
        html.append("    </thead>\n");
        html.append("    <tbody>\n");
        
        for (Map<String, Object> result : results) {
            String name = (String) result.get("name");
            String outcome = (String) result.get("outcome");
            String statusClass = "status-" + (outcome != null ? outcome.toLowerCase() : "skipped");
            
            html.append("      <tr>\n");
            html.append("        <td>" + name + "</td>\n");
            html.append("        <td class=\"" + statusClass + "\">" + (outcome != null ? outcome : "Skipped") + "</td>\n");
            
            // Duration
            Number duration = (Number) result.get("durationMs");
            String durationStr = duration != null ? formatDuration(duration.longValue()) : "N/A";
            html.append("        <td>" + durationStr + "</td>\n");
            
            // Error message
            String error = (String) result.get("errorMessage");
            html.append("        <td>" + (error != null ? escapeHtml(error) : "") + "</td>\n");
            
            html.append("      </tr>\n");
        }
        
        html.append("    </tbody>\n");
        html.append("  </table>\n");
        
        html.append("</body>\n");
        html.append("</html>");
        
        return html.toString().getBytes(StandardCharsets.UTF_8);
    }
    
    /**
     * Generate XML report
     */
    private byte[] generateXmlReport(List<Map<String, Object>> results) throws Exception {
        StringBuilder xml = new StringBuilder();
        
        // Calculate summary statistics
        int total = results.size();
        int passed = 0;
        int failed = 0;
        int skipped = 0;
        
        for (Map<String, Object> result : results) {
            String outcome = (String) result.get("outcome");
            if ("Passed".equals(outcome)) {
                passed++;
            } else if ("Failed".equals(outcome)) {
                failed++;
            } else {
                skipped++;
            }
        }
        
        // Build XML report
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        xml.append("<testsuites>\n");
        xml.append("  <testsuite name=\"CS Test Forge Results\" tests=\"" + total + "\" failures=\"" + failed + "\" skipped=\"" + skipped + "\">\n");
        
        for (Map<String, Object> result : results) {
            String name = (String) result.get("name");
            String outcome = (String) result.get("outcome");
            Number duration = (Number) result.get("durationMs");
            String error = (String) result.get("errorMessage");
            String stackTrace = (String) result.get("stackTrace");
            
            xml.append("    <testcase name=\"" + escapeXml(name) + "\" time=\"" + (duration != null ? duration.doubleValue() / 1000.0 : 0) + "\"");
            
            if ("Failed".equals(outcome)) {
                xml.append(">\n");
                xml.append("      <failure message=\"" + (error != null ? escapeXml(error) : "Test failed") + "\">");
                xml.append(stackTrace != null ? escapeXml(stackTrace) : "");
                xml.append("</failure>\n");
                xml.append("    </testcase>\n");
            } else if (!"Passed".equals(outcome)) {
                xml.append(">\n");
                xml.append("      <skipped/>\n");
                xml.append("    </testcase>\n");
            } else {
                xml.append("/>\n");
            }
        }
        
        xml.append("  </testsuite>\n");
        xml.append("</testsuites>");
        
        return xml.toString().getBytes(StandardCharsets.UTF_8);
    }
    
    /**
     * Generate JSON report
     */
    private byte[] generateJsonReport(List<Map<String, Object>> results) throws Exception {
        // Calculate summary statistics
        int total = results.size();
        int passed = 0;
        int failed = 0;
        int skipped = 0;
        
        for (Map<String, Object> result : results) {
            String outcome = (String) result.get("outcome");
            if ("Passed".equals(outcome)) {
                passed++;
            } else if ("Failed".equals(outcome)) {
                failed++;
            } else {
                skipped++;
            }
        }
        
        // Build JSON report
        Map<String, Object> report = new HashMap<>();
        report.put("generatedAt", LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME));
        
        Map<String, Object> summary = new HashMap<>();
        summary.put("total", total);
        summary.put("passed", passed);
        summary.put("failed", failed);
        summary.put("skipped", skipped);
        report.put("summary", summary);
        
        report.put("results", results);
        
        return objectMapper.writeValueAsBytes(report);
    }
    
    /**
     * Generate Markdown report
     */
    private byte[] generateMarkdownReport(List<Map<String, Object>> results) throws Exception {
        StringBuilder md = new StringBuilder();
        
        // Calculate summary statistics
        int total = results.size();
        int passed = 0;
        int failed = 0;
        int skipped = 0;
        
        for (Map<String, Object> result : results) {
            String outcome = (String) result.get("outcome");
            if ("Passed".equals(outcome)) {
                passed++;
            } else if ("Failed".equals(outcome)) {
                failed++;
            } else {
                skipped++;
            }
        }
        
        // Build Markdown report
        md.append("# Test Results Report\n\n");
        md.append("Generated on: " + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) + "\n\n");
        
        // Summary section
        md.append("## Summary\n\n");
        md.append("- Total: " + total + "\n");
        md.append("- Passed: " + passed + "\n");
        md.append("- Failed: " + failed + "\n");
        md.append("- Skipped: " + skipped + "\n\n");
        
        // Results table
        md.append("## Test Results\n\n");
        md.append("| Test Case | Status | Duration | Error |\n");
        md.append("| --- | --- | --- | --- |\n");
        
        for (Map<String, Object> result : results) {
            String name = (String) result.get("name");
            String outcome = (String) result.get("outcome");
            Number duration = (Number) result.get("durationMs");
            String durationStr = duration != null ? formatDuration(duration.longValue()) : "N/A";
            String error = (String) result.get("errorMessage");
            
            md.append("| " + name + " | " + (outcome != null ? outcome : "Skipped") + " | " + durationStr + " | " + (error != null ? error : "") + " |\n");
        }
        
        return md.toString().getBytes(StandardCharsets.UTF_8);
    }
    
    /**
     * Create a commit in Git
     */
    private String createCommitInGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            String repositoryId,
            String branch,
            String filePath,
            byte[] content,
            String commitMessage) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get the latest commit on the branch
        String getRefUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s",
                organization, project, repositoryId, branch);
        
        String latestCommitId = null;
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(getRefUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode != HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get branch reference: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                List<Map<String, Object>> refs = (List<Map<String, Object>>) responseMap.get("value");
                if (refs != null && !refs.isEmpty()) {
                    for (Map<String, Object> ref : refs) {
                        String name = (String) ref.get("name");
                        if (name != null && name.equals("refs/heads/" + branch)) {
                            Map<String, Object> objectId = (Map<String, Object>) ref.get("objectId");
                            if (objectId != null) {
                                latestCommitId = (String) objectId;
                                break;
                            }
                        }
                    }
                }
                
                // If branch not found, try to create it if option is set
                if (latestCommitId == null && syncOptions.isAdoGitCreateBranch()) {
                    // Need to get default branch commit ID
                    String defaultBranch = "main";
                    
                    // Try to get default branch from repository
                    String repoUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/git/repositories/%s",
                            organization, project, repositoryId);
                    
                    HttpGet repoGet = new HttpGet(buildAzureDevOpsUri(repoUrl));
                    repoGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    repoGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse repoResponse = httpClient.execute(repoGet)) {
                        int repoStatusCode = repoResponse.getStatusLine().getStatusCode();
                        
                        if (repoStatusCode == HttpStatus.SC_OK) {
                            String repoResponseBody = EntityUtils.toString(repoResponse.getEntity());
                            Map<String, Object> repoMap = objectMapper.readValue(repoResponseBody, Map.class);
                            
                            String defaultBranchRef = (String) repoMap.get("defaultBranch");
                            if (defaultBranchRef != null && defaultBranchRef.startsWith("refs/heads/")) {
                                defaultBranch = defaultBranchRef.substring("refs/heads/".length());
                            }
                        }
                    }
                    
                    // Get default branch commit ID
                    String defaultBranchRefUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s",
                            organization, project, repositoryId, defaultBranch);
                    
                    HttpGet defaultBranchGet = new HttpGet(buildAzureDevOpsUri(defaultBranchRefUrl));
                    defaultBranchGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    defaultBranchGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse defaultBranchResponse = httpClient.execute(defaultBranchGet)) {
                        int dbStatusCode = defaultBranchResponse.getStatusLine().getStatusCode();
                        
                        if (dbStatusCode == HttpStatus.SC_OK) {
                            String dbResponseBody = EntityUtils.toString(defaultBranchResponse.getEntity());
                            Map<String, Object> dbResponseMap = objectMapper.readValue(dbResponseBody, Map.class);
                            
                            List<Map<String, Object>> dbRefs = (List<Map<String, Object>>) dbResponseMap.get("value");
                            if (dbRefs != null && !dbRefs.isEmpty()) {
                                for (Map<String, Object> ref : dbRefs) {
                                    String name = (String) ref.get("name");
                                    if (name != null && name.equals("refs/heads/" + defaultBranch)) {
                                        Map<String, Object> objectId = (Map<String, Object>) ref.get("objectId");
                                        if (objectId != null) {
                                            latestCommitId = (String) objectId;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (latestCommitId != null) {
                        // Create the branch
                        String createBranchUrl = String.format(
                                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs",
                                organization, project, repositoryId);
                        
                        HttpPost createBranchPost = new HttpPost(buildAzureDevOpsUri(createBranchUrl));
                        createBranchPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                        createBranchPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        createBranchPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        List<Map<String, Object>> refUpdates = new ArrayList<>();
                        Map<String, Object> refUpdate = new HashMap<>();
                        refUpdate.put("name", "refs/heads/" + branch);
                        refUpdate.put("oldObjectId", "0000000000000000000000000000000000000000");
                        refUpdate.put("newObjectId", latestCommitId);
                        refUpdates.add(refUpdate);
                        
                        createBranchPost.setEntity(new StringEntity(
                                objectMapper.writeValueAsString(Map.of("refUpdates", refUpdates)),
                                ContentType.APPLICATION_JSON));
                        
                        try (CloseableHttpResponse createBranchResponse = httpClient.execute(createBranchPost)) {
                            int cbStatusCode = createBranchResponse.getStatusLine().getStatusCode();
                            
                            if (cbStatusCode < 200 || cbStatusCode >= 300) {
                                String cbResponseBody = EntityUtils.toString(createBranchResponse.getEntity());
                                throw new Exception("Failed to create branch: Status code " + cbStatusCode + ", Response: " + cbResponseBody);
                            }
                        }
                    } else {
                        throw new Exception("Branch not found and could not determine base commit ID for new branch");
                    }
                } else if (latestCommitId == null) {
                    throw new Exception("Branch not found and create branch option not enabled");
                }
            }
        }
        
        // Create a push with the changes
        String pushUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/pushes",
                organization, project, repositoryId);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(pushUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            // Build the push request
            Map<String, Object> push = new HashMap<>();
            
            // Create commit
            List<Map<String, Object>> commits = new ArrayList<>();
            Map<String, Object> commit = new HashMap<>();
            commit.put("comment", commitMessage);
            
            // Add file changes
            List<Map<String, Object>> changes = new ArrayList<>();
            Map<String, Object> change = new HashMap<>();
            change.put("changeType", "add");
            change.put("item", Map.of("path", filePath));
            
            // Encode content as base64
            String base64Content = Base64.getEncoder().encodeToString(content);
            change.put("newContent", Map.of("content", base64Content, "contentType", "base64"));
            
            changes.add(change);
            commit.put("changes", changes);
            commits.add(commit);
            
            // Add ref update
            Map<String, Object> refUpdate = new HashMap<>();
            refUpdate.put("name", "refs/heads/" + branch);
            refUpdate.put("oldObjectId", latestCommitId);
            
            push.put("commits", commits);
            push.put("refUpdates", List.of(refUpdate));
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(push),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to push changes: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                return (String) responseMap.get("commitId");
            }
        }
    }
    
    @Override
    public List<IntegrationType> getAvailableIntegrationTypes() {
        logger.info("Getting available integration types");
        
        List<IntegrationType> types = new ArrayList<>();
        
        // Azure DevOps
        IntegrationType azureDevOps = new IntegrationType()
                .setId(TYPE_AZURE_DEVOPS)
                .setName("Azure DevOps")
                .setDescription("Integration with Azure DevOps test plans and test cases")
                .setIconUrl("/assets/images/integrations/azure-devops.png")
                .setSupportedFeatures(Arrays.asList(
                        "TEST_CASE_SYNC", 
                        "TEST_PLAN_SYNC", 
                        "TEST_RESULT_EXPORT"))
                .setVersion("1.0")
                .setEnabled(true);
        
        types.add(azureDevOps);
        
        // Azure DevOps Git
        IntegrationType azureDevOpsGit = new IntegrationType()
                .setId(TYPE_AZURE_DEVOPS_GIT)
                .setName("Azure DevOps Git")
                .setDescription("Integration with Azure DevOps Git repositories")
                .setIconUrl("/assets/images/integrations/azure-devops-git.png")
                .setSupportedFeatures(Arrays.asList(
                        "TEST_SCRIPT_IMPORT", 
                        "TEST_RESULT_EXPORT"))
                .setVersion("1.0")
                .setEnabled(true);
        
        types.add(azureDevOpsGit);
        
        return types;
    }
    
    @Override
    public IntegrationSettingsSchema getSettingsSchemaForType(String type) {
        logger.info("Getting settings schema for integration type: {}", type);
        
        // Validate integration type
        validateIntegrationType(type);
        
        // Load schema from cache
        IntegrationSettingsSchema schema = settingsSchemas.get(type);
        if (schema != null) {
            return schema;
        }
        
        // Otherwise, create schema dynamically
        schema = createSettingsSchema(type);
        settingsSchemas.put(type, schema);
        
        return schema;
    }
    
    @Override
    public IntegrationImportResult importFromIntegration(
            String projectId, String integrationId, IntegrationImportOptions importOptions) {
        
        logger.info("Importing from integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationImportResult result = new IntegrationImportResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDryRun(importOptions.isDryRun());
        result.setContentType(importOptions.getContentType());
        result.setTargetFolderId(importOptions.getTargetFolderId());
        
        long startTime = System.currentTimeMillis();
        
        // Create stats object
        IntegrationImportResult.ImportStats stats = new IntegrationImportResult.ImportStats();
        result.setStats(stats);
        
        // Perform import based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                importFromAzureDevOps(integration, importOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                importFromAzureDevOpsGit(integration, importOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during import", e);
            result.setSuccessful(false);
            result.setMessage("Import failed: " + e.getMessage());
            result.setErrorCode("IMPORT_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Import from Azure DevOps
     */
    private void importFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Check content type
        String contentType = importOptions.getContentType();
        if (contentType == null) {
            contentType = "TEST_CASE"; // Default to TEST_CASE
        }
        
        // Perform import based on content type
        if ("TEST_CASE".equals(contentType)) {
            importTestCasesFromAzureDevOps(integration, importOptions, result);
        } else if ("TEST_PLAN".equals(contentType)) {
            importTestPlansFromAzureDevOps(integration, importOptions, result);
        } else {
            throw new Exception("Unsupported content type for import: " + contentType);
        }
    }
    
    /**
     * Import test cases from Azure DevOps
     */
    private void importTestCasesFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Determine import strategy
        List<Long> workItemIds = importOptions.getAdoWorkItemIds();
        Long testPlanId = importOptions.getAdoTestPlanId();
        Long testSuiteId = importOptions.getAdoTestSuiteId();
        String workItemQuery = importOptions.getAdoWorkItemQuery();
        
        // Create HttpClient with proxy settings if provided
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            List<Map<String, Object>> workItems = new ArrayList<>();
            
            // Strategy 1: Import specific work items
            if (workItemIds != null && !workItemIds.isEmpty()) {
                for (Long workItemId : workItemIds) {
                    String workItemUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all",
                            organization, project, workItemId);
                    
                    HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                    httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                        int statusCode = response.getStatusLine().getStatusCode();
                        
                        if (statusCode == HttpStatus.SC_OK) {
                            String responseBody = EntityUtils.toString(response.getEntity());
                            Map<String, Object> workItem = objectMapper.readValue(responseBody, Map.class);
                            
                            // Check if it's a test case
                            Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
                            if (fields != null && "Test Case".equals(fields.get("System.WorkItemType"))) {
                                workItems.add(workItem);
                            }
                        } else {
                            logger.warn("Failed to get work item {}: Status code {}", workItemId, statusCode);
                        }
                    }
                }
            }
            // Strategy 2: Import from test plan/suite
            else if (testPlanId != null && testSuiteId != null) {
                String testCasesUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases",
                        organization, project, testPlanId, testSuiteId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testPoints = (List<Map<String, Object>>) responseMap.get("value");
                        if (testPoints != null) {
                            for (Map<String, Object> testPoint : testPoints) {
                                Map<String, Object> workItemRef = (Map<String, Object>) testPoint.get("workItem");
                                if (workItemRef != null) {
                                    Long workItemId = ((Number) workItemRef.get("id")).longValue();
                                    
                                    String workItemUrl = String.format(
                                            "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all",
                                            organization, project, workItemId);
                                    
                                    HttpGet wiGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                                    wiGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                                    wiGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                                    
                                    try (CloseableHttpResponse wiResponse = httpClient.execute(wiGet)) {
                                        int wiStatusCode = wiResponse.getStatusLine().getStatusCode();
                                        
                                        if (wiStatusCode == HttpStatus.SC_OK) {
                                            String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                            Map<String, Object> workItem = objectMapper.readValue(wiResponseBody, Map.class);
                                            workItems.add(workItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Strategy 3: Import using query
            else if (StringUtils.hasText(workItemQuery)) {
                String wiqlUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/wit/wiql?api-version=%s",
                        organization, project, ADO_API_VERSION);
                
                HttpPost httpPost = new HttpPost(wiqlUrl);
                httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                Map<String, Object> wiqlRequest = new HashMap<>();
                wiqlRequest.put("query", workItemQuery);
                
                httpPost.setEntity(new StringEntity(
                        objectMapper.writeValueAsString(wiqlRequest),
                        ContentType.APPLICATION_JSON));
                
                try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> workItemRefs = (List<Map<String, Object>>) responseMap.get("workItems");
                        if (workItemRefs != null) {
                            for (Map<String, Object> workItemRef : workItemRefs) {
                                Long workItemId = ((Number) workItemRef.get("id")).longValue();
                                
                                String workItemUrl = String.format(
                                        "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all",
                                        organization, project, workItemId);
                                
                                HttpGet wiGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                                wiGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                                wiGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                                
                                try (CloseableHttpResponse wiResponse = httpClient.execute(wiGet)) {
                                    int wiStatusCode = wiResponse.getStatusLine().getStatusCode();
                                    
                                    if (wiStatusCode == HttpStatus.SC_OK) {
                                        String wiResponseBody = EntityUtils.toString(wiResponse.getEntity());
                                        Map<String, Object> workItem = objectMapper.readValue(wiResponseBody, Map.class);
                                        
                                        // Filter for test cases only
                                        Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
                                        if (fields != null && "Test Case".equals(fields.get("System.WorkItemType"))) {
                                            workItems.add(workItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else {
                throw new Exception("No import strategy provided");
            }
            
            // Update stats
            int totalFound = workItems.size();
            result.getStats().setTotalFound(totalFound);
            
            // Apply max items limit
            Integer maxItems = importOptions.getMaxItems();
            if (maxItems != null && maxItems > 0 && workItems.size() > maxItems) {
                workItems = workItems.subList(0, maxItems);
            }
            
            // Process each test case
            boolean dryRun = importOptions.isDryRun();
            boolean overwriteExisting = importOptions.isOverwriteExisting();
            Long targetFolderId = importOptions.getTargetFolderId();
            
            // Process and import test cases
            for (Map<String, Object> workItem : workItems) {
                try {
                    // Convert to test case
                    Map<String, Object> testCase = convertWorkItemToTestCase(workItem, null);
                    
                    // Skip if dry run
                    if (dryRun) {
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        continue;
                    }
                    
                    // Import the test case
                    ImportedItem importedItem = importTestCaseToSystem(
                            integration, importOptions, testCase, overwriteExisting, targetFolderId);
                    
                    if (importedItem != null) {
                        result.getImportedItems().add(importedItem);
                        
                        if ("created".equals(importedItem.getAction())) {
                            result.getStats().setCreated(result.getStats().getCreated() + 1);
                        } else if ("updated".equals(importedItem.getAction())) {
                            result.getStats().setUpdated(result.getStats().getUpdated() + 1);
                        } else {
                            result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        }
                    } else {
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                    }
                    
                    // Download and import attachments if needed
                    if (importOptions.isIncludeAttachments()) {
                        Object relations = workItem.get("relations");
                        if (relations != null && relations instanceof List) {
                            List<Map<String, Object>> relationsList = (List<Map<String, Object>>) relations;
                            String workItemId = testCase.get("id").toString();
                            
                            // Create attachments directory
                            Path attachmentsDir = Paths.get(
                                    dataDirectory, 
                                    "projects", 
                                    integration.getProjectId().toString(), 
                                    "test-cases", 
                                    "attachments", 
                                    workItemId);
                            Files.createDirectories(attachmentsDir);
                            
                            int attachmentsImported = downloadAttachments(
                                    integration, workItemId, relationsList, attachmentsDir);
                            
                            result.getStats().setAttachmentsImported(
                                    result.getStats().getAttachmentsImported() + attachmentsImported);
                        }
                    }
                } catch (Exception e) {
                    logger.error("Error importing test case: {}", workItem.get("id"), e);
                    result.getStats().setErrors(result.getStats().getErrors() + 1);
                    
                    // Add import issue
                    ImportIssue issue = new ImportIssue()
                            .setSeverity("ERROR")
                            .setExternalItemId(workItem.get("id").toString())
                            .setMessage("Failed to import test case: " + e.getMessage())
                            .setCode("IMPORT_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e)));
                    
                    result.getIssues().add(issue);
                }
                
                result.getStats().setTotalProcessed(result.getStats().getTotalProcessed() + 1);
            }
            
            // Set success status
            result.setSuccessful(true);
            result.setMessage("Import completed successfully");
        }
    }
    
    /**
     * Import test plans from Azure DevOps
     */
    private void importTestPlansFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan ID if specified
        Long testPlanId = importOptions.getAdoTestPlanId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            List<Map<String, Object>> testPlans = new ArrayList<>();
            
            if (testPlanId != null) {
                // Get specific test plan
                String testPlanUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d",
                        organization, project, testPlanId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlanUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> testPlan = objectMapper.readValue(responseBody, Map.class);
                        testPlans.add(testPlan);
                    } else {
                        throw new Exception("Failed to get test plan: Status code " + statusCode);
                    }
                }
            } else {
                // Get all test plans
                String testPlansUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans",
                        organization, project);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlansUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> plans = (List<Map<String, Object>>) responseMap.get("value");
                        if (plans != null) {
                            testPlans.addAll(plans);
                        }
                    } else {
                        throw new Exception("Failed to get test plans: Status code " + statusCode);
                    }
                }
            }
            
            // Update stats
            int totalFound = testPlans.size();
            result.getStats().setTotalFound(totalFound);
            
            // Apply max items limit
            Integer maxItems = importOptions.getMaxItems();
            if (maxItems != null && maxItems > 0 && testPlans.size() > maxItems) {
                testPlans = testPlans.subList(0, maxItems);
            }
            
            // Process each test plan
            boolean dryRun = importOptions.isDryRun();
            boolean overwriteExisting = importOptions.isOverwriteExisting();
            Long targetFolderId = importOptions.getTargetFolderId();
            
            for (Map<String, Object> testPlan : testPlans) {
                try {
                    // Skip if dry run
                    if (dryRun) {
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        continue;
                    }
                    
                    // Import the test plan
                    ImportedItem importedItem = importTestPlanToSystem(
                            integration, importOptions, testPlan, overwriteExisting, targetFolderId);
                    
                    if (importedItem != null) {
                        result.getImportedItems().add(importedItem);
                        
                        if ("created".equals(importedItem.getAction())) {
                            result.getStats().setCreated(result.getStats().getCreated() + 1);
                        } else if ("updated".equals(importedItem.getAction())) {
                            result.getStats().setUpdated(result.getStats().getUpdated() + 1);
                        } else {
                            result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        }
                        
                        // Import test suites if include children is enabled
                        if (importOptions.isIncludeChildren()) {
                            Number planId = (Number) testPlan.get("id");
                            
                            // Get test suites
                            String testSuitesUrl = String.format(
                                    "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites",
                                    organization, project, planId.longValue());
                            
                            HttpGet suitesGet = new HttpGet(buildAzureDevOpsUri(testSuitesUrl));
                            suitesGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                            suitesGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                            
                            try (CloseableHttpResponse suitesResponse = httpClient.execute(suitesGet)) {
                                int suitesStatusCode = suitesResponse.getStatusLine().getStatusCode();
                                
                                if (suitesStatusCode == HttpStatus.SC_OK) {
                                    String suitesResponseBody = EntityUtils.toString(suitesResponse.getEntity());
                                    Map<String, Object> suitesResponseMap = objectMapper.readValue(suitesResponseBody, Map.class);
                                    
                                    List<Map<String, Object>> suites = (List<Map<String, Object>>) suitesResponseMap.get("value");
                                    if (suites != null) {
                                        for (Map<String, Object> suite : suites) {
                                            try {
                                                ImportedItem suiteItem = importTestSuiteToSystem(
                                                        integration, importOptions, planId.toString(), suite, 
                                                        overwriteExisting, importedItem.getLocalItemId());
                                                
                                                if (suiteItem != null) {
                                                    result.getImportedItems().add(suiteItem);
                                                    result.getStats().setChildItemsImported(
                                                            result.getStats().getChildItemsImported() + 1);
                                                }
                                            } catch (Exception e) {
                                                logger.error("Error importing test suite: {}", suite.get("id"), e);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                    }
                } catch (Exception e) {
                    logger.error("Error importing test plan: {}", testPlan.get("id"), e);
                    result.getStats().setErrors(result.getStats().getErrors() + 1);
                    
                    // Add import issue
                    ImportIssue issue = new ImportIssue()
                            .setSeverity("ERROR")
                            .setExternalItemId(testPlan.get("id").toString())
                            .setMessage("Failed to import test plan: " + e.getMessage())
                            .setCode("IMPORT_ERROR")
                            .setDetails(Map.of("stackTrace", getStackTraceAsString(e)));
                    
                    result.getIssues().add(issue);
                }
                
                result.getStats().setTotalProcessed(result.getStats().getTotalProcessed() + 1);
            }
            
            // Set success status
            result.setSuccessful(true);
            result.setMessage("Import completed successfully");
        }
    }
    
    /**
     * Import from Azure DevOps Git
     */
    private void importFromAzureDevOpsGit(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Check content type
        String contentType = importOptions.getContentType();
        if (contentType == null) {
            contentType = "TEST_SCRIPT"; // Default to TEST_SCRIPT
        }
        
        // Perform import based on content type
        if ("TEST_SCRIPT".equals(contentType)) {
            importTestScriptsFromAzureDevOpsGit(integration, importOptions, result);
        } else {
            throw new Exception("Unsupported content type for import: " + contentType);
        }
    }
    
    /**
     * Import test scripts from Azure DevOps Git
     */
    private void importTestScriptsFromAzureDevOpsGit(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get repository details
        String repoUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s",
                organization, project, repositoryId);
        
        Map<String, Object> repository = null;
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(repoUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode != HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get repository details: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                repository = objectMapper.readValue(responseBody, Map.class);
            }
        }
        
        if (repository == null) {
            throw new Exception("Repository not found");
        }
        
        // Get branch to use
        String branch = importOptions.getAdoGitBranch();
        if (branch == null) {
            branch = "main"; // Default to main branch
            
            // Try to find default branch from repository
            if (repository.get("defaultBranch") != null) {
                String defaultBranch = (String) repository.get("defaultBranch");
                if (defaultBranch.startsWith("refs/heads/")) {
                    branch = defaultBranch.substring("refs/heads/".length());
                }
            }
        }
        
        // Get path pattern to pull
        String pathPattern = importOptions.getAdoGitPathPattern();
        if (pathPattern == null) {
            pathPattern = "**/*"; // Default to all files
        }
        
        // Get file extensions to filter
        List<String> fileExtensions = importOptions.getAdoGitFileExtensions();
        if (fileExtensions == null || fileExtensions.isEmpty()) {
            // Default to typical test script extensions
            fileExtensions = Arrays.asList(".feature", ".spec.js", ".test.js", ".spec.ts", ".test.ts", ".py", ".java");
        }
        
        // Get items from Git repository
        List<Map<String, Object>> items = getItemsFromGitRepository(
                integration, importOptions, repositoryId, branch, pathPattern);
        
        if (items == null || items.isEmpty()) {
            logger.info("No items found in Git repository matching pattern: {}", pathPattern);
            result.setSuccessful(true);
            result.setMessage("No items found matching the specified criteria");
            return;
        }
        
        // Filter items by file extension
        List<Map<String, Object>> filteredItems = new ArrayList<>();
        if (fileExtensions != null) {
            for (Map<String, Object> item : items) {
                String path = (String) item.get("path");
                if (path != null) {
                    for (String ext : fileExtensions) {
                        if (path.endsWith(ext)) {
                            filteredItems.add(item);
                            break;
                        }
                    }
                }
            }
        } else {
            filteredItems = items;
        }
        
        // Update stats
        result.getStats().setTotalFound(filteredItems.size());
        
        // Apply max items limit
        Integer maxItems = importOptions.getMaxItems();
        if (maxItems != null && maxItems > 0 && filteredItems.size() > maxItems) {
            filteredItems = filteredItems.subList(0, maxItems);
        }
        
        // Process items
        boolean dryRun = importOptions.isDryRun();
        boolean overwriteExisting = importOptions.isOverwriteExisting();
        Long targetFolderId = importOptions.getTargetFolderId();
        
        for (Map<String, Object> item : filteredItems) {
            String path = (String) item.get("path");
            String objectId = (String) item.get("objectId");
            
            if (path == null || objectId == null) {
                continue;
            }
            
            // Skip folders
            if ("folder".equals(item.get("gitObjectType"))) {
                continue;
            }
            
            try {
                // Get file content
                byte[] content = getFileContent(integration, importOptions, repositoryId, objectId);
                
                if (content == null) {
                    logger.warn("Failed to get content for file: {}", path);
                    continue;
                }
                
                // Skip if dry run
                if (dryRun) {
                    result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                    continue;
                }
                
                // Import the file
                ImportedItem importedItem = importScriptToSystem(
                        integration, importOptions, path, content, overwriteExisting, targetFolderId);
                
                if (importedItem != null) {
                    result.getImportedItems().add(importedItem);
                    
                    if ("created".equals(importedItem.getAction())) {
                        result.getStats().setCreated(result.getStats().getCreated() + 1);
                    } else if ("updated".equals(importedItem.getAction())) {
                        result.getStats().setUpdated(result.getStats().getUpdated() + 1);
                    } else {
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                    }
                } else {
                    result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                }
            } catch (Exception e) {
                logger.error("Error importing file: {}", path, e);
                result.getStats().setErrors(result.getStats().getErrors() + 1);
                
                // Add import issue
                ImportIssue issue = new ImportIssue()
                        .setSeverity("ERROR")
                        .setExternalItemId(path)
                        .setMessage("Failed to import file: " + e.getMessage())
                        .setCode("IMPORT_ERROR")
                        .setDetails(Map.of("stackTrace", getStackTraceAsString(e)));
                
                result.getIssues().add(issue);
            }
            
            result.getStats().setTotalProcessed(result.getStats().getTotalProcessed() + 1);
        }
        
        // Set success status
        result.setSuccessful(true);
        result.setMessage("Import completed successfully");
    }
    
    /**
     * Import test case to system
     */
    private ImportedItem importTestCaseToSystem(
            Integration integration,
            IntegrationImportOptions importOptions,
            Map<String, Object> testCase,
            boolean overwriteExisting,
            Long targetFolderId) throws Exception {
        
        // Prepare directory structure
        Path testCasesDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-cases");
        Files.createDirectories(testCasesDir);
        
        // Get test case ID
        String testCaseId = testCase.get("id").toString();
        String testCaseName = (String) testCase.get("name");
        
        // Apply field mappings if provided
        if (importOptions.getFieldMappings() != null && !importOptions.getFieldMappings().isEmpty()) {
            testCase = applyFieldMappings(testCase, importOptions.getFieldMappings());
        }
        
        // Check if test case already exists
        Path testCaseFile = testCasesDir.resolve(testCaseId + ".json");
        boolean exists = Files.exists(testCaseFile);
        
        if (exists && !overwriteExisting) {
            // Skip existing test case
            return new ImportedItem()
                    .setExternalItemId(testCaseId)
                    .setName(testCaseName)
                    .setAction("skipped");
        }
        
        // Add target folder ID if provided
        if (targetFolderId != null) {
            testCase.put("folderId", targetFolderId);
        }
        
        // Save test case
        objectMapper.writeValue(testCaseFile.toFile(), testCase);
        
        // Update test case index
        updateTestCaseIndex(integration.getProjectId().toString(), testCaseId, testCaseName);
        
        // Create imported item
        return new ImportedItem()
                .setExternalItemId(testCaseId)
                .setLocalItemId(Long.parseLong(testCaseId))
                .setName(testCaseName)
                .setAction(exists ? "updated" : "created")
                .setProperties(Map.of(
                        "type", "TEST_CASE",
                        "source", "azure-devops"));
    }
    
    /**
     * Import test plan to system
     */
    private ImportedItem importTestPlanToSystem(
            Integration integration,
            IntegrationImportOptions importOptions,
            Map<String, Object> testPlan,
            boolean overwriteExisting,
            Long targetFolderId) throws Exception {
        
        // Prepare directory structure
        Path testPlansDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-plans");
        Files.createDirectories(testPlansDir);
        
        // Get test plan ID
        String testPlanId = testPlan.get("id").toString();
        String testPlanName = (String) testPlan.get("name");
        
        // Apply field mappings if provided
        if (importOptions.getFieldMappings() != null && !importOptions.getFieldMappings().isEmpty()) {
            testPlan = applyFieldMappings(testPlan, importOptions.getFieldMappings());
        }
        
        // Check if test plan already exists
        Path testPlanFile = testPlansDir.resolve(testPlanId + ".json");
        boolean exists = Files.exists(testPlanFile);
        
        if (exists && !overwriteExisting) {
            // Skip existing test plan
            return new ImportedItem()
                    .setExternalItemId(testPlanId)
                    .setName(testPlanName)
                    .setAction("skipped");
        }
        
        // Add target folder ID if provided
        if (targetFolderId != null) {
            testPlan.put("folderId", targetFolderId);
        }
        
        // Save test plan
        objectMapper.writeValue(testPlanFile.toFile(), testPlan);
        
        // Update test plan index
        updateTestPlanIndex(integration.getProjectId().toString(), testPlanId, testPlanName);
        
        // Create imported item
        return new ImportedItem()
                .setExternalItemId(testPlanId)
                .setLocalItemId(Long.parseLong(testPlanId))
                .setName(testPlanName)
                .setAction(exists ? "updated" : "created")
                .setProperties(Map.of(
                        "type", "TEST_PLAN",
                        "source", "azure-devops"));
    }
    
    /**
     * Import test suite to system
     */
    private ImportedItem importTestSuiteToSystem(
            Integration integration,
            IntegrationImportOptions importOptions,
            String testPlanId,
            Map<String, Object> testSuite,
            boolean overwriteExisting,
            Long parentId) throws Exception {
        
        // Prepare directory structure
        Path testSuitesDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-plans", 
                testPlanId, 
                "suites");
        Files.createDirectories(testSuitesDir);
        
        // Get test suite ID
        String testSuiteId = testSuite.get("id").toString();
        String testSuiteName = (String) testSuite.get("name");
        
        // Apply field mappings if provided
        if (importOptions.getFieldMappings() != null && !importOptions.getFieldMappings().isEmpty()) {
            testSuite = applyFieldMappings(testSuite, importOptions.getFieldMappings());
        }
        
        // Check if test suite already exists
        Path testSuiteFile = testSuitesDir.resolve(testSuiteId + ".json");
        boolean exists = Files.exists(testSuiteFile);
        
        if (exists && !overwriteExisting) {
            // Skip existing test suite
            return new ImportedItem()
                    .setExternalItemId(testSuiteId)
                    .setName(testSuiteName)
                    .setAction("skipped");
        }
        
        // Add parent ID if provided
        if (parentId != null) {
            testSuite.put("parentId", parentId);
        }
        
        // Add test plan ID
        testSuite.put("testPlanId", testPlanId);
        
        // Save test suite
        objectMapper.writeValue(testSuiteFile.toFile(), testSuite);
        
        // Update test suite index
        updateTestSuiteIndex(integration.getProjectId().toString(), testPlanId, testSuiteId, testSuiteName);
        
        // Create imported item
        return new ImportedItem()
                .setExternalItemId(testSuiteId)
                .setLocalItemId(Long.parseLong(testSuiteId))
                .setName(testSuiteName)
                .setAction(exists ? "updated" : "created")
                .setProperties(Map.of(
                        "type", "TEST_SUITE",
                        "testPlanId", testPlanId,
                        "source", "azure-devops"));
    }
    
    /**
     * Import script to system
     */
    private ImportedItem importScriptToSystem(
            Integration integration,
            IntegrationImportOptions importOptions,
            String path,
            byte[] content,
            boolean overwriteExisting,
            Long targetFolderId) throws Exception {
        
        // Extract file name and extension
        String fileName = path.substring(path.lastIndexOf('/') + 1);
        String extension = fileName.contains(".") ? fileName.substring(fileName.lastIndexOf('.')) : "";
        
        // Determine file type based on extension
        String fileType;
        if (extension.equals(".feature")) {
            fileType = "FEATURE";
        } else if (extension.equals(".js") || extension.equals(".ts") || extension.contains(".test") || extension.contains(".spec")) {
            fileType = "TEST_SCRIPT";
        } else if (extension.equals(".java")) {
            fileType = "JAVA_TEST";
        } else if (extension.equals(".py")) {
            fileType = "PYTHON_TEST";
        } else {
            fileType = "OTHER";
        }
        
        // Create directory structure
        Path scriptsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-scripts", 
                fileType);
        Files.createDirectories(scriptsDir);
        
        // Create normalized file name
        String normalizedPath = path.replaceAll("[^a-zA-Z0-9.-]", "_");
        
        // Check if file already exists
        Path targetFile = scriptsDir.resolve(normalizedPath);
        boolean exists = Files.exists(targetFile);
        
        if (exists && !overwriteExisting) {
            // Skip existing file
            return new ImportedItem()
                    .setExternalItemId(path)
                    .setName(fileName)
                    .setAction("skipped");
        }
        
        // Save file
        Files.write(targetFile, content);
        
        // Update script index
        updateScriptIndex(integration.getProjectId().toString(), fileType, normalizedPath, path);
        
        // Create imported item
        return new ImportedItem()
                .setExternalItemId(path)
                .setLocalItemId(targetFile.hashCode())
                .setName(fileName)
                .setAction(exists ? "updated" : "created")
                .setProperties(Map.of(
                        "type", fileType,
                        "path", normalizedPath,
                        "source", "azure-devops-git"));
    }
    
    /**
     * Apply field mappings
     */
    private Map<String, Object> applyFieldMappings(
            Map<String, Object> item,
            List<FieldMapping> fieldMappings) {
        
        // Clone item to avoid modifying original
        Map<String, Object> mappedItem = new HashMap<>(item);
        
        for (FieldMapping mapping : fieldMappings) {
            String sourceField = mapping.getSourceField();
            String targetField = mapping.getTargetField();
            String transformation = mapping.getTransformation();
            Object defaultValue = mapping.getDefaultValue();
            
            if (sourceField == null || targetField == null) {
                continue;
            }
            
            // Get source value
            Object sourceValue = item.get(sourceField);
            
            // Apply default value if source is null
            if (sourceValue == null && defaultValue != null) {
                sourceValue = defaultValue;
            }
            
            // Skip if still null
            if (sourceValue == null) {
                continue;
            }
            
            // Apply transformation if specified
            if (transformation != null && sourceValue instanceof String) {
                String strValue = (String) sourceValue;
                
                switch (transformation) {
                    case "UPPERCASE":
                        sourceValue = strValue.toUpperCase();
                        break;
                    case "LOWERCASE":
                        sourceValue = strValue.toLowerCase();
                        break;
                    case "TRIM":
                        sourceValue = strValue.trim();
                        break;
                    // Add more transformations as needed
                }
            }
            
            // Set target field
            mappedItem.put(targetField, sourceValue);
        }
        
        return mappedItem;
    }

    @Override
    public IntegrationExportResult exportToIntegration(
            String projectId, String integrationId, IntegrationExportOptions exportOptions) {
        
        logger.info("Exporting to integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationExportResult result = new IntegrationExportResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDryRun(exportOptions.isDryRun());
        result.setContentType(exportOptions.getContentType());
        
        long startTime = System.currentTimeMillis();
        
        // Create stats object
        IntegrationExportResult.ExportStats stats = new IntegrationExportResult.ExportStats();
        result.setStats(stats);
        
        // Perform export based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                exportToAzureDevOps(integration, exportOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                exportToAzureDevOpsGit(integration, exportOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during export", e);
            result.setSuccessful(false);
            result.setMessage("Export failed: " + e.getMessage());
            result.setErrorCode("EXPORT_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Export to Azure DevOps
     */
    private void exportToAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Check content type
        String contentType = exportOptions.getContentType();
        if (contentType == null) {
            contentType = "TEST_RESULT"; // Default to TEST_RESULT
        }
        
        // Perform export based on content type
        if ("TEST_RESULT".equals(contentType)) {
            exportTestResultsToAzureDevOps(integration, exportOptions, result);
        } else if ("TEST_CASE".equals(contentType)) {
            exportTestCasesToAzureDevOps(integration, exportOptions, result);
        } else {
            throw new Exception("Unsupported content type for export: " + contentType);
        }
    }
    
    /**
     * Export test results to Azure DevOps
     */
    private void exportTestResultsToAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plan and suite IDs
        String adoProject = exportOptions.getAdoProject();
        if (adoProject == null) {
            adoProject = project;
        }
        
        Long testPlanId = exportOptions.getAdoTestPlanId();
        Long testSuiteId = exportOptions.getAdoTestSuiteId();
        
        if (testPlanId == null || testSuiteId == null) {
            throw new Exception("Test plan ID and suite ID are required to export test results");
        }
        
        // Get test results to export
        List<Map<String, Object>> testResults = getTestResultsForExport(integration, exportOptions);
        
        if (testResults.isEmpty()) {
            result.setSuccessful(true);
            result.setMessage("No test results found to export");
            return;
        }
        
        // Update stats
        result.getStats().setTotalSelected(testResults.size());
        
        // Check if dry run
        boolean dryRun = exportOptions.isDryRun();
        if (dryRun) {
            result.getStats().setSkipped(testResults.size());
            result.setSuccessful(true);
            result.setMessage("Dry run completed - would export " + testResults.size() + " test results");
            return;
        }
        
        // Create a test run in Azure DevOps
        boolean createNewTestRun = exportOptions.isAdoCreateNewTestRun();
        String testRunTitle = exportOptions.getAdoTestRunTitleFormat();
        if (testRunTitle == null) {
            testRunTitle = "CS Test Forge Test Run - {date}";
        }
        
        testRunTitle = testRunTitle.replace("{date}", 
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        
        Map<String, Object> testRun = createTestRunInAzureDevOps(
                integration, exportOptions, testPlanId, testSuiteId, testRunTitle, adoProject);
        
        if (testRun == null || testRun.get("id") == null) {
            throw new Exception("Failed to create test run in Azure DevOps");
        }
        
        Number testRunId = (Number) testRun.get("id");
        
        // Store test run ID and URL in result
        result.setAdoTestRunId(testRunId.longValue());
        result.setAdoTestRunUrl((String) testRun.get("url"));
        
        // Add test results to run
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            for (Map<String, Object> testResult : testResults) {
                try {
                    // Map test case ID to ADO work item ID
                    String testCaseId = testResult.get("testCaseId").toString();
                    String adoWorkItemId = mapTestCaseIdToAdoWorkItemId(integration, testCaseId);
                    
                    if (adoWorkItemId == null) {
                        // Skip if no mapping found
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        
                        // Add export issue
                        result.getIssues().add(
                                new ExportIssue()
                                        .setSeverity("WARNING")
                                        .setLocalItemId(Long.parseLong(testCaseId))
                                        .setMessage("No mapping found for test case ID: " + testCaseId)
                                        .setCode("NO_MAPPING"));
                        
                        continue;
                    }
                    
                    // Create test result payload
                    Map<String, Object> adoTestResult = createAdoTestResultPayload(
                            testResult, adoWorkItemId, testRunId.toString());
                    
                    // Add test result to run
                    String testResultsUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/test/runs/%s/results",
                            organization, adoProject, testRunId);
                    
                    HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testResultsUrl));
                    httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                    httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    httpPost.setEntity(new StringEntity(
                            objectMapper.writeValueAsString(List.of(adoTestResult)),
                            ContentType.APPLICATION_JSON));
                    
                    try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                        int statusCode = response.getStatusLine().getStatusCode();
                        
                        if (statusCode < 200 || statusCode >= 300) {
                            String responseBody = EntityUtils.toString(response.getEntity());
                            throw new Exception("Failed to add test result: Status code " + statusCode + ", Response: " + responseBody);
                        }
                        
                        // Update stats
                        result.getStats().setCreated(result.getStats().getCreated() + 1);
                        
                        // Add exported item
                        result.getExportedItems().add(
                                new ExportedItem()
                                        .setLocalItemId(Long.parseLong(testCaseId))
                                        .setExternalItemId(adoWorkItemId)
                                        .setName((String) testResult.get("name"))
                                        .setAction("created")
                                        .setExternalUrl(testRun.get("url") + "/testresult?resultId=" + adoTestResult.get("id")));
                    }
                } catch (Exception e) {
                    logger.error("Error exporting test result: {}", testResult.get("id"), e);
                    result.getStats().setErrors(result.getStats().getErrors() + 1);
                    
                    // Add export issue
                    result.getIssues().add(
                            new ExportIssue()
                                    .setSeverity("ERROR")
                                    .setLocalItemId(Long.parseLong(testResult.get("testCaseId").toString()))
                                    .setMessage("Failed to export test result: " + e.getMessage())
                                    .setCode("EXPORT_ERROR")
                                    .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
                }
                
                result.getStats().setTotalProcessed(result.getStats().getTotalProcessed() + 1);
            }
        }
        
        // Set success status
        result.setSuccessful(true);
        result.setMessage("Export completed successfully");
    }
    
    /**
     * Export test cases to Azure DevOps
     */
    private void exportTestCasesToAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get project to export to
        String adoProject = exportOptions.getAdoProject();
        if (adoProject == null) {
            adoProject = project;
        }
        
        // Get area path if specified
        String areaPath = exportOptions.getAdoAreaPath();
        
        // Get test cases to export
        List<Map<String, Object>> testCases = getTestCasesForExport(integration, exportOptions);
        
        if (testCases.isEmpty()) {
            result.setSuccessful(true);
            result.setMessage("No test cases found to export");
            return;
        }
        
        // Update stats
        result.getStats().setTotalSelected(testCases.size());
        
        // Check if dry run
        boolean dryRun = exportOptions.isDryRun();
        if (dryRun) {
            result.getStats().setSkipped(testCases.size());
            result.setSuccessful(true);
            result.setMessage("Dry run completed - would export " + testCases.size() + " test cases");
            return;
        }
        
        // Process each test case
        boolean updateExisting = exportOptions.isAdoUpdateExistingTestCases();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            for (Map<String, Object> testCase : testCases) {
                try {
                    // Check if test case already exists in ADO
                    String testCaseId = testCase.get("id").toString();
                    String adoWorkItemId = mapTestCaseIdToAdoWorkItemId(integration, testCaseId);
                    
                    if (adoWorkItemId != null && updateExisting) {
                        // Update existing test case
                        updateTestCaseInAzureDevOps(
                                integration, exportOptions, testCase, adoWorkItemId, adoProject);
                        
                        // Update stats
                        result.getStats().setUpdated(result.getStats().getUpdated() + 1);
                        
                        // Add exported item
                        result.getExportedItems().add(
                                new ExportedItem()
                                        .setLocalItemId(Long.parseLong(testCaseId))
                                        .setExternalItemId(adoWorkItemId)
                                        .setName((String) testCase.get("name"))
                                        .setAction("updated")
                                        .setExternalUrl(String.format(
                                                "https://dev.azure.com/%s/%s/_workitems/edit/%s",
                                                organization, adoProject, adoWorkItemId)));
                    } else if (adoWorkItemId == null) {
                        // Create new test case
                        String newWorkItemId = createTestCaseInAzureDevOps(
                                integration, exportOptions, testCase, areaPath, adoProject);
                        
                        if (newWorkItemId != null) {
                            // Update stats
                            result.getStats().setCreated(result.getStats().getCreated() + 1);
                            
                            // Add exported item
                            result.getExportedItems().add(
                                    new ExportedItem()
                                            .setLocalItemId(Long.parseLong(testCaseId))
                                            .setExternalItemId(newWorkItemId)
                                            .setName((String) testCase.get("name"))
                                            .setAction("created")
                                            .setExternalUrl(String.format(
                                                    "https://dev.azure.com/%s/%s/_workitems/edit/%s",
                                                    organization, adoProject, newWorkItemId)));
                            
                            // Create mapping
                            createTestCaseMapping(integration, testCaseId, newWorkItemId);
                        } else {
                            // Skip if creation failed
                            result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                            
                            // Add export issue
                            result.getIssues().add(
                                    new ExportIssue()
                                            .setSeverity("ERROR")
                                            .setLocalItemId(Long.parseLong(testCaseId))
                                            .setMessage("Failed to create test case in Azure DevOps")
                                            .setCode("CREATE_ERROR"));
                        }
                    } else {
                        // Skip if exists but update not enabled
                        result.getStats().setSkipped(result.getStats().getSkipped() + 1);
                        
                        // Add exported item
                        result.getExportedItems().add(
                                new ExportedItem()
                                        .setLocalItemId(Long.parseLong(testCaseId))
                                        .setExternalItemId(adoWorkItemId)
                                        .setName((String) testCase.get("name"))
                                        .setAction("skipped")
                                        .setExternalUrl(String.format(
                                                "https://dev.azure.com/%s/%s/_workitems/edit/%s",
                                                organization, adoProject, adoWorkItemId)));
                    }
                } catch (Exception e) {
                    logger.error("Error exporting test case: {}", testCase.get("id"), e);
                    result.getStats().setErrors(result.getStats().getErrors() + 1);
                    
                    // Add export issue
                    result.getIssues().add(
                            new ExportIssue()
                                    .setSeverity("ERROR")
                                    .setLocalItemId(Long.parseLong(testCase.get("id").toString()))
                                    .setMessage("Failed to export test case: " + e.getMessage())
                                    .setCode("EXPORT_ERROR")
                                    .setDetails(Map.of("stackTrace", getStackTraceAsString(e))));
                }
                
                result.getStats().setTotalProcessed(result.getStats().getTotalProcessed() + 1);
            }
        }
        
        // Set success status
        result.setSuccessful(true);
        result.setMessage("Export completed successfully");
    }
    
    /**
     * Map test case ID to ADO work item ID
     */
    private String mapTestCaseIdToAdoWorkItemId(Integration integration, String testCaseId) throws IOException {
        // Check if mapping exists
        Path mappingsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "mappings");
        
        if (!Files.exists(mappingsDir)) {
            return null;
        }
        
        Path mappingFile = mappingsDir.resolve("testcase_to_workitem.json");
        
        if (!Files.exists(mappingFile)) {
            return null;
        }
        
        // Load mappings
        String mappingContent = new String(Files.readAllBytes(mappingFile), StandardCharsets.UTF_8);
        Map<String, Object> mappings = objectMapper.readValue(mappingContent, Map.class);
        
        return (String) mappings.get(testCaseId);
    }
    
    /**
     * Create test case mapping
     */
    private void createTestCaseMapping(Integration integration, String testCaseId, String workItemId) throws IOException {
        // Create mappings directory
        Path mappingsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "mappings");
        Files.createDirectories(mappingsDir);
        
        Path mappingFile = mappingsDir.resolve("testcase_to_workitem.json");
        
        // Load existing mappings or create new
        Map<String, Object> mappings;
        if (Files.exists(mappingFile)) {
            String mappingContent = new String(Files.readAllBytes(mappingFile), StandardCharsets.UTF_8);
            mappings = objectMapper.readValue(mappingContent, Map.class);
        } else {
            mappings = new HashMap<>();
        }
        
        // Add mapping
        mappings.put(testCaseId, workItemId);
        
        // Save mappings
        objectMapper.writeValue(mappingFile.toFile(), mappings);
    }
    
    /**
     * Get test results for export
     */
    private List<Map<String, Object>> getTestResultsForExport(
            Integration integration,
            IntegrationExportOptions exportOptions) throws Exception {
        
        List<Map<String, Object>> results = new ArrayList<>();
        
        // Get test results directory
        Path testResultsDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-results");
        
        if (!Files.exists(testResultsDir)) {
            return results;
        }
        
        // Load results based on selection criteria
        List<Long> itemIds = exportOptions.getItemIds();
        Long folderId = exportOptions.getFolderId();
        Map<String, Object> filters = exportOptions.getFilters();
        
        // Strategy 1: Export specific item IDs
        if (itemIds != null && !itemIds.isEmpty()) {
            for (Long itemId : itemIds) {
                Path resultFile = testResultsDir.resolve(itemId + ".json");
                if (Files.exists(resultFile)) {
                    String resultContent = new String(Files.readAllBytes(resultFile), StandardCharsets.UTF_8);
                    Map<String, Object> result = objectMapper.readValue(resultContent, Map.class);
                    results.add(result);
                }
            }
        }
        // Strategy 2: Export by folder ID
        else if (folderId != null) {
            // Get all results and filter by folder ID
            try (Stream<Path> paths = Files.list(testResultsDir)) {
                List<Path> resultFiles = paths
                        .filter(path -> path.toString().endsWith(".json"))
                        .collect(Collectors.toList());
                
                for (Path resultFile : resultFiles) {
                    String resultContent = new String(Files.readAllBytes(resultFile), StandardCharsets.UTF_8);
                    Map<String, Object> result = objectMapper.readValue(resultContent, Map.class);
                    
                    // Check folder ID
                    Object resultFolderId = result.get("folderId");
                    if (resultFolderId != null && folderId.equals(resultFolderId)) {
                        results.add(result);
                    }
                }
            }
        }
        // Strategy 3: Export all (with optional filters)
        else {
            // Get all results
            try (Stream<Path> paths = Files.list(testResultsDir)) {
                List<Path> resultFiles = paths
                        .filter(path -> path.toString().endsWith(".json"))
                        .collect(Collectors.toList());
                
                for (Path resultFile : resultFiles) {
                    String resultContent = new String(Files.readAllBytes(resultFile), StandardCharsets.UTF_8);
                    Map<String, Object> result = objectMapper.readValue(resultContent, Map.class);
                    
                    // Apply filters if provided
                    if (filters != null && !filters.isEmpty()) {
                        boolean matchesFilters = true;
                        
                        for (Map.Entry<String, Object> filter : filters.entrySet()) {
                            String key = filter.getKey();
                            Object value = filter.getValue();
                            
                            if (!result.containsKey(key) || !Objects.equals(result.get(key), value)) {
                                matchesFilters = false;
                                break;
                            }
                        }
                        
                        if (matchesFilters) {
                            results.add(result);
                        }
                    } else {
                        results.add(result);
                    }
                }
            }
        }
        
        // Apply max items limit
        Integer maxItems = exportOptions.getMaxItems();
        if (maxItems != null && maxItems > 0 && results.size() > maxItems) {
            results = results.subList(0, maxItems);
        }
        
        return results;
    }
    
    /**
     * Get test cases for export
     */
    private List<Map<String, Object>> getTestCasesForExport(
            Integration integration,
            IntegrationExportOptions exportOptions) throws Exception {
        
        List<Map<String, Object>> testCases = new ArrayList<>();
        
        // Get test cases directory
        Path testCasesDir = Paths.get(
                dataDirectory, 
                "projects", 
                integration.getProjectId().toString(), 
                "test-cases");
        
        if (!Files.exists(testCasesDir)) {
            return testCases;
        }
        
        // Load test cases based on selection criteria
        List<Long> itemIds = exportOptions.getItemIds();
        Long folderId = exportOptions.getFolderId();
        Map<String, Object> filters = exportOptions.getFilters();
        
        // Strategy 1: Export specific item IDs
        if (itemIds != null && !itemIds.isEmpty()) {
            for (Long itemId : itemIds) {
                Path testCaseFile = testCasesDir.resolve(itemId + ".json");
                if (Files.exists(testCaseFile)) {
                    String testCaseContent = new String(Files.readAllBytes(testCaseFile), StandardCharsets.UTF_8);
                    Map<String, Object> testCase = objectMapper.readValue(testCaseContent, Map.class);
                    testCases.add(testCase);
                }
            }
        }
        // Strategy 2: Export by folder ID
        else if (folderId != null) {
            // Get all test cases and filter by folder ID
            try (Stream<Path> paths = Files.list(testCasesDir)) {
                List<Path> testCaseFiles = paths
                        .filter(path -> path.toString().endsWith(".json"))
                        .collect(Collectors.toList());
                
                for (Path testCaseFile : testCaseFiles) {
                    String testCaseContent = new String(Files.readAllBytes(testCaseFile), StandardCharsets.UTF_8);
                    Map<String, Object> testCase = objectMapper.readValue(testCaseContent, Map.class);
                    
                    // Check folder ID
                    Object testCaseFolderId = testCase.get("folderId");
                    if (testCaseFolderId != null && folderId.equals(testCaseFolderId)) {
                        testCases.add(testCase);
                    }
                }
            }
        }
        // Strategy 3: Export all (with optional filters)
        else {
            // Get all test cases
            try (Stream<Path> paths = Files.list(testCasesDir)) {
                List<Path> testCaseFiles = paths
                        .filter(path -> path.toString().endsWith(".json"))
                        .collect(Collectors.toList());
                
                for (Path testCaseFile : testCaseFiles) {
                    String testCaseContent = new String(Files.readAllBytes(testCaseFile), StandardCharsets.UTF_8);
                    Map<String, Object> testCase = objectMapper.readValue(testCaseContent, Map.class);
                    
                    // Apply filters if provided
                    if (filters != null && !filters.isEmpty()) {
                        boolean matchesFilters = true;
                        
                        for (Map.Entry<String, Object> filter : filters.entrySet()) {
                            String key = filter.getKey();
                            Object value = filter.getValue();
                            
                            if (!testCase.containsKey(key) || !Objects.equals(testCase.get(key), value)) {
                                matchesFilters = false;
                                break;
                            }
                        }
                        
                        if (matchesFilters) {
                            testCases.add(testCase);
                        }
                    } else {
                        testCases.add(testCase);
                    }
                }
            }
        }
        
        // Apply max items limit
        Integer maxItems = exportOptions.getMaxItems();
        if (maxItems != null && maxItems > 0 && testCases.size() > maxItems) {
            testCases = testCases.subList(0, maxItems);
        }
        
        return testCases;
    }
    
    /**
     * Create test run in Azure DevOps
     */
    private Map<String, Object> createTestRunInAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            Long testPlanId,
            Long testSuiteId,
            String testRunTitle,
            String adoProject) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Use specified project if provided
        if (adoProject == null) {
            adoProject = project;
        }
        
        // Create test run payload
        Map<String, Object> testRun = new HashMap<>();
        testRun.put("name", testRunTitle);
        
        // Set test run status if provided
        String testRunStatus = exportOptions.getAdoTestRunStatus();
        if (testRunStatus != null) {
            testRun.put("state", testRunStatus);
        } else {
            testRun.put("state", "InProgress");
        }
        
        // Set plan and suite
        Map<String, Object> plan = new HashMap<>();
        plan.put("id", testPlanId);
        testRun.put("plan", plan);
        
        // Send API request
        String testRunsUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/runs",
                organization, adoProject);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testRunsUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(testRun),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to create test run: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                return objectMapper.readValue(responseBody, Map.class);
            }
        }
    }
    
    /**
     * Create ADO test result payload
     */
    private Map<String, Object> createAdoTestResultPayload(
            Map<String, Object> testResult,
            String workItemId,
            String testRunId) {
        
        Map<String, Object> payload = new HashMap<>();
        
        // Test case reference
        Map<String, Object> testCase = new HashMap<>();
        testCase.put("id", workItemId);
        payload.put("testCase", testCase);
        
        // Test case title
        payload.put("testCaseTitle", testResult.get("name"));
        
        // Outcome and state
        String outcome = (String) testResult.get("outcome");
        if (outcome == null) {
            outcome = "Passed"; // Default to passed
        }
        payload.put("outcome", outcome);
        payload.put("state", "Completed");
        
        // Other properties
        payload.put("comment", testResult.get("comment"));
        
        // Duration
        Number duration = (Number) testResult.get("durationMs");
        if (duration != null) {
            payload.put("durationInMs", duration);
        }
        
        // Error details
        if ("Failed".equals(outcome)) {
            payload.put("errorMessage", testResult.get("errorMessage"));
            payload.put("stackTrace", testResult.get("stackTrace"));
        }
        
        // Test step results
        if (testResult.get("stepResults") != null) {
            List<Map<String, Object>> stepResults = new ArrayList<>();
            List<Map<String, Object>> sourceSteps = (List<Map<String, Object>>) testResult.get("stepResults");
            
            for (Map<String, Object> sourceStep : sourceSteps) {
                Map<String, Object> stepResult = new HashMap<>();
                stepResult.put("outcome", sourceStep.get("outcome"));
                stepResult.put("stepIdentifier", sourceStep.get("stepId"));
                stepResult.put("comment", sourceStep.get("comment"));
                
                if ("Failed".equals(sourceStep.get("outcome"))) {
                    stepResult.put("errorMessage", sourceStep.get("errorMessage"));
                }
                
                stepResults.add(stepResult);
            }
            
            payload.put("testActionResultDeltas", stepResults);
        }
        
        return payload;
    }
    
    /**
     * Create test case in Azure DevOps
     */
    private String createTestCaseInAzureDevOps(
            Integration integration,
            IntegrationExportOptions exportOptions,
            Map<String, Object> testCase,
            String areaPath,
            String adoProject) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Use specified project if provided
        if (adoProject == null) {
            adoProject = project;
        }
        
        // Create work item payload
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Set work item type
        Map<String, Object> typeOp = new HashMap<>();
        typeOp.put("op", "add");
        typeOp.put("path", "/fields/System.WorkItemType");
        typeOp.put("value", "Test Case");
        operations.add(typeOp);
        
        // Set title
        Map<String, Object> titleOp = new HashMap<>();
        titleOp.put("op", "add");
        titleOp.put("path", "/fields/System.Title");
        titleOp.put("value", testCase.get("name"));
        operations.add(titleOp);
        
        // Set description
        if (testCase.get("description") != null) {
            Map<String, Object> descOp = new HashMap<>();
            descOp.put("op", "add");
            descOp.put("path", "/fields/System.Description");
            descOp.put("value", testCase.get("description"));
            operations.add(descOp);
        }
        
        // Set area path if provided
        if (StringUtils.hasText(areaPath)) {
            Map<String, Object> areaOp = new HashMap<>();
            areaOp.put("op", "add");
            areaOp.put("path", "/fields/System.AreaPath");
            areaOp.put("value", areaPath);
            operations.add(areaOp);
        }
        
        // Set priority if provided
        if (testCase.get("priority") != null) {
            Map<String, Object> priorityOp = new HashMap<>();
            priorityOp.put("op", "add");
            priorityOp.put("path", "/fields/Microsoft.VSTS.Common.Priority");
            priorityOp.put("value", testCase.get("priority"));
            operations.add(priorityOp);
        }
        
        // Set automation status if provided
        if (testCase.get("automationStatus") != null) {
            Map<String, Object> autoOp = new HashMap<>();
            autoOp.put("op", "add");
            autoOp.put("path", "/fields/Microsoft.VSTS.TCM.AutomationStatus");
            autoOp.put("value", testCase.get("automationStatus"));
            operations.add(autoOp);
        }
        
        // Set test steps if provided
        if (testCase.get("steps") != null) {
            String stepsXml = convertTestStepsToXml((List<Map<String, Object>>) testCase.get("steps"));
            if (stepsXml != null) {
                Map<String, Object> stepsOp = new HashMap<>();
                stepsOp.put("op", "add");
                stepsOp.put("path", "/fields/Microsoft.VSTS.TCM.Steps");
                stepsOp.put("value", stepsXml);
                operations.add(stepsOp);
            }
        }
        
        // Set parameters if provided
        if (testCase.get("parameters") != null) {
            String paramsString = convertTestParametersToString((List<Map<String, Object>>) testCase.get("parameters"));
            if (paramsString != null) {
                Map<String, Object> paramsOp = new HashMap<>();
                paramsOp.put("op", "add");
                paramsOp.put("path", "/fields/Microsoft.VSTS.TCM.Parameters");
                paramsOp.put("value", paramsString);
                operations.add(paramsOp);
            }
        }
        
        // Send API request
        String workItemUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/workitems/$Test Case?api-version=%s",
                organization, adoProject, ADO_API_VERSION);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            HttpPost httpPost = new HttpPost(workItemUrl);
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, "application/json-patch+json");
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPost.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(operations),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to create test case: Status code " + statusCode + ", Response: " + responseBody);
                }
                
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                return responseMap.get("id").toString();
            }
        }
    }
    
    /**
     * Update test case in Azure DevOps
     */
    private void updateTestCaseInAzureDevOps(
            Integration integration,
            IntegrationExportOptions exportOptions,
            Map<String, Object> testCase,
            String workItemId,
            String adoProject) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Use specified project if provided
        if (adoProject == null) {
            adoProject = project;
        }
        
        // Create work item update payload
        List<Map<String, Object>> operations = new ArrayList<>();
        
        // Update title
        Map<String, Object> titleOp = new HashMap<>();
        titleOp.put("op", "replace");
        titleOp.put("path", "/fields/System.Title");
        titleOp.put("value", testCase.get("name"));
        operations.add(titleOp);
        
        // Update description
        if (testCase.get("description") != null) {
            Map<String, Object> descOp = new HashMap<>();
            descOp.put("op", "replace");
            descOp.put("path", "/fields/System.Description");
            descOp.put("value", testCase.get("description"));
            operations.add(descOp);
        }
        
        // Update priority if provided
        if (testCase.get("priority") != null) {
            Map<String, Object> priorityOp = new HashMap<>();
            priorityOp.put("op", "replace");
            priorityOp.put("path", "/fields/Microsoft.VSTS.Common.Priority");
            priorityOp.put("value", testCase.get("priority"));
            operations.add(priorityOp);
        }
        
        // Update automation status if provided
        if (testCase.get("automationStatus") != null) {
            Map<String, Object> autoOp = new HashMap<>();
            autoOp.put("op", "replace");
            autoOp.put("path", "/fields/Microsoft.VSTS.TCM.AutomationStatus");
            autoOp.put("value", testCase.get("automationStatus"));
            operations.add(autoOp);
        }
        
        // Update test steps if provided
        if (testCase.get("steps") != null) {
            String stepsXml = convertTestStepsToXml((List<Map<String, Object>>) testCase.get("steps"));
            if (stepsXml != null) {
                Map<String, Object> stepsOp = new HashMap<>();
                stepsOp.put("op", "replace");
                stepsOp.put("path", "/fields/Microsoft.VSTS.TCM.Steps");
                stepsOp.put("value", stepsXml);
                operations.add(stepsOp);
            }
        }
        
        // Update parameters if provided
        if (testCase.get("parameters") != null) {
            String paramsString = convertTestParametersToString((List<Map<String, Object>>) testCase.get("parameters"));
            if (paramsString != null) {
                Map<String, Object> paramsOp = new HashMap<>();
                paramsOp.put("op", "replace");
                paramsOp.put("path", "/fields/Microsoft.VSTS.TCM.Parameters");
                paramsOp.put("value", paramsString);
                operations.add(paramsOp);
            }
        }
        
        // Skip if no operations
        if (operations.isEmpty()) {
            return;
        }
        
        // Send API request
        String workItemUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/workitems/%s?api-version=%s",
                organization, adoProject, workItemId, ADO_API_VERSION);
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            HttpPatch httpPatch = new HttpPatch(workItemUrl);
            httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, "application/json-patch+json");
            httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            httpPatch.setEntity(new StringEntity(
                    objectMapper.writeValueAsString(operations),
                    ContentType.APPLICATION_JSON));
            
            try (CloseableHttpResponse response = httpClient.execute(httpPatch)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode < 200 || statusCode >= 300) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to update test case: Status code " + statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Export to Azure DevOps Git
     */
    private void exportToAzureDevOpsGit(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Check content type
        String contentType = exportOptions.getContentType();
        if (contentType == null) {
            contentType = "TEST_RESULT"; // Default to TEST_RESULT
        }
        
        // Perform export based on content type
        if ("TEST_RESULT".equals(contentType)) {
            exportTestResultsToAzureDevOpsGit(integration, exportOptions, result);
        } else {
            throw new Exception("Unsupported content type for export: " + contentType);
        }
    }
    
    /**
     * Export test results to Azure DevOps Git
     */
    private void exportTestResultsToAzureDevOpsGit(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get branch to use
        String branch = exportOptions.getAdoGitBranch();
        if (branch == null) {
            branch = "main"; // Default to main branch
        }
        
        // Get base path for files
        String basePath = exportOptions.getAdoGitBasePath();
        if (basePath == null) {
            basePath = "test-results"; // Default to test-results folder
        }
        
        // Get file format
        String fileFormat = exportOptions.getAdoGitFileFormat();
        if (fileFormat == null) {
            fileFormat = "html"; // Default to HTML format
        }
        
        // Get test results to export
        List<Map<String, Object>> testResults = getTestResultsForExport(integration, exportOptions);
        
        if (testResults.isEmpty()) {
            result.setSuccessful(true);
            result.setMessage("No test results found to export");
            return;
        }
        
        // Update stats
        result.getStats().setTotalSelected(testResults.size());
        
        // Check if dry run
        boolean dryRun = exportOptions.isDryRun();
        if (dryRun) {
            result.getStats().setSkipped(testResults.size());
            result.setSuccessful(true);
            result.setMessage("Dry run completed - would export " + testResults.size() + " test results");
            return;
        }
        
        // Generate report
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String reportFileName = String.format("test-report-%s.%s", timestamp, fileFormat);
        String reportPath = basePath + "/" + reportFileName;
        
        byte[] reportContent = generateTestReport(integration, testResults, fileFormat);
        
        if (reportContent == null) {
            throw new Exception("Failed to generate test report");
        }
        
        // Create commit message
        String commitMessage = "Test results report generated at " + timestamp;
        if (exportOptions.getAdoGitCommitMessageFormat() != null) {
            commitMessage = exportOptions.getAdoGitCommitMessageFormat()
                    .replace("{timestamp}", timestamp)
                    .replace("{count}", String.valueOf(testResults.size()));
        }
        
        // Push to Git
        String commitId = createCommitInGit(
                integration, exportOptions, repositoryId, branch, reportPath, reportContent, commitMessage);
        
        if (commitId != null) {
            // Update stats
            result.getStats().setCreated(1);
            result.getStats().setTotalProcessed(testResults.size());
            
            // Add commit details to result
            result.setAdoGitCommitId(commitId);
            
            // Add commit URL
            String commitUrl = String.format(
                    "https://dev.azure.com/%s/%s/_git/%s/commit/%s",
                    organization, project, repositoryId, commitId);
            result.setAdoGitCommitUrl(commitUrl);
            
            // Add URL to exported URLs
            result.getExportedUrls().put("report", String.format(
                    "https://dev.azure.com/%s/%s/_git/%s?path=/%s",
                    organization, project, repositoryId, reportPath));
            
            logger.info("Exported test report to Git: {}", reportPath);
        } else {
            // Update stats
            result.getStats().setErrors(1);
            result.getStats().setTotalProcessed(testResults.size());
            
            // Add error to result
            result.getIssues().add(
                    new ExportIssue()
                            .setSeverity("ERROR")
                            .setMessage("Failed to export test report to Git")
                            .setCode("EXPORT_ERROR"));
        }
        
        // Set success status
        result.setSuccessful(true);
        result.setMessage("Export completed successfully");
    }
    
    /**
     * Create settings schema for integration type
     */
    private IntegrationSettingsSchema createSettingsSchema(String type) {
        IntegrationSettingsSchema schema = new IntegrationSettingsSchema();
        schema.setIntegrationType(type);
        schema.setVersion("1.0");
        
        List<IntegrationSettingsSchema.SettingsField> fields = new ArrayList<>();
        
        if (TYPE_AZURE_DEVOPS.equals(type)) {
            // Organization field
            IntegrationSettingsSchema.SettingsField orgField = new IntegrationSettingsSchema.SettingsField()
                    .setId("organization")
                    .setName("Organization")
                    .setDescription("Azure DevOps organization name")
                    .setType("string")
                    .setRequired(true);
            fields.add(orgField);
            
            // Project field
            IntegrationSettingsSchema.SettingsField projectField = new IntegrationSettingsSchema.SettingsField()
                    .setId("project")
                    .setName("Project")
                    .setDescription("Azure DevOps project name")
                    .setType("string")
                    .setRequired(true);
            fields.add(projectField);
            
            // PAT field
            IntegrationSettingsSchema.SettingsField patField = new IntegrationSettingsSchema.SettingsField()
                    .setId("pat")
                    .setName("Personal Access Token")
                    .setDescription("Azure DevOps Personal Access Token with appropriate permissions")
                    .setType("string")
                    .setRequired(true);
            
            // Add validation for PAT
            patField.getValidation().put("minLength", 40);
            
            // Add UI hints for PAT
            patField.getUiHints().put("inputType", "password");
            
            fields.add(patField);
            
            // Proxy settings
            IntegrationSettingsSchema.SettingsField proxyHostField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyHost")
                    .setName("Proxy Host")
                    .setDescription("HTTP proxy host (leave empty if no proxy is needed)")
                    .setType("string")
                    .setRequired(false);
            fields.add(proxyHostField);
            
            IntegrationSettingsSchema.SettingsField proxyPortField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyPort")
                    .setName("Proxy Port")
                    .setDescription("HTTP proxy port")
                    .setType("integer")
                    .setRequired(false);
            fields.add(proxyPortField);
            
            IntegrationSettingsSchema.SettingsField proxyUserField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyUsername")
                    .setName("Proxy Username")
                    .setDescription("HTTP proxy username (if authentication is required)")
                    .setType("string")
                    .setRequired(false);
            fields.add(proxyUserField);
            
            IntegrationSettingsSchema.SettingsField proxyPassField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyPassword")
                    .setName("Proxy Password")
                    .setDescription("HTTP proxy password (if authentication is required)")
                    .setType("string")
                    .setRequired(false);
            
            // Add UI hints for proxy password
            proxyPassField.getUiHints().put("inputType", "password");
            
            fields.add(proxyPassField);
        }
        else if (TYPE_AZURE_DEVOPS_GIT.equals(type)) {
            // Organization field
            IntegrationSettingsSchema.SettingsField orgField = new IntegrationSettingsSchema.SettingsField()
                    .setId("organization")
                    .setName("Organization")
                    .setDescription("Azure DevOps organization name")
                    .setType("string")
                    .setRequired(true);
            fields.add(orgField);
            
            // Project field
            IntegrationSettingsSchema.SettingsField projectField = new IntegrationSettingsSchema.SettingsField()
                    .setId("project")
                    .setName("Project")
                    .setDescription("Azure DevOps project name")
                    .setType("string")
                    .setRequired(true);
            fields.add(projectField);
            
            // Repository ID field
            IntegrationSettingsSchema.SettingsField repoField = new IntegrationSettingsSchema.SettingsField()
                    .setId("repositoryId")
                    .setName("Repository ID")
                    .setDescription("Azure DevOps Git repository ID")
                    .setType("string")
                    .setRequired(true);
            fields.add(repoField);
            
            // PAT field
            IntegrationSettingsSchema.SettingsField patField = new IntegrationSettingsSchema.SettingsField()
                    .setId("pat")
                    .setName("Personal Access Token")
                    .setDescription("Azure DevOps Personal Access Token with appropriate permissions")
                    .setType("string")
                    .setRequired(true);
            
            // Add validation for PAT
            patField.getValidation().put("minLength", 40);
            
            // Add UI hints for PAT
            patField.getUiHints().put("inputType", "password");
            
            fields.add(patField);
            
            // Default branch field
            IntegrationSettingsSchema.SettingsField branchField = new IntegrationSettingsSchema.SettingsField()
                    .setId("defaultBranch")
                    .setName("Default Branch")
                    .setDescription("Default branch to use")
                    .setType("string")
                    .setRequired(false)
                    .setDefaultValue("main");
            fields.add(branchField);
            
            // Proxy settings
            IntegrationSettingsSchema.SettingsField proxyHostField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyHost")
                    .setName("Proxy Host")
                    .setDescription("HTTP proxy host (leave empty if no proxy is needed)")
                    .setType("string")
                    .setRequired(false);
            fields.add(proxyHostField);
            
            IntegrationSettingsSchema.SettingsField proxyPortField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyPort")
                    .setName("Proxy Port")
                    .setDescription("HTTP proxy port")
                    .setType("integer")
                    .setRequired(false);
            fields.add(proxyPortField);
            
            IntegrationSettingsSchema.SettingsField proxyUserField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyUsername")
                    .setName("Proxy Username")
                    .setDescription("HTTP proxy username (if authentication is required)")
                    .setType("string")
                    .setRequired(false);
            fields.add(proxyUserField);
            
            IntegrationSettingsSchema.SettingsField proxyPassField = new IntegrationSettingsSchema.SettingsField()
                    .setId("proxyPassword")
                    .setName("Proxy Password")
                    .setDescription("HTTP proxy password (if authentication is required)")
                    .setType("string")
                    .setRequired(false);
            
            // Add UI hints for proxy password
            proxyPassField.getUiHints().put("inputType", "password");
            
            fields.add(proxyPassField);
        }
        
        schema.setFields(fields);
        
        return schema;
    }
    
    /**
     * Validate integration type
     */
    private void validateIntegrationType(String type) {
        if (!TYPE_AZURE_DEVOPS.equals(type) && !TYPE_AZURE_DEVOPS_GIT.equals(type)) {
            throw new IllegalArgumentException("Unsupported integration type: " + type);
        }
    }
    
    /**
     * Load settings schemas from files or create them dynamically
     */
    private void loadSettingsSchemas() {
        logger.info("Loading integration settings schemas");
        
        // Check if schemas directory exists
        Path schemasDirPath = Paths.get(schemasDirectory);
        if (!Files.exists(schemasDirPath)) {
            try {
                Files.createDirectories(schemasDirPath);
            } catch (IOException e) {
                logger.warn("Failed to create schemas directory: {}", schemasDirectory, e);
            }
        }
        
        // Load schemas from files or create dynamically
        for (String type : new String[] { TYPE_AZURE_DEVOPS, TYPE_AZURE_DEVOPS_GIT }) {
            Path schemaFile = schemasDirPath.resolve(type + ".json");
            
            if (Files.exists(schemaFile)) {
                try {
                    String schemaContent = new String(Files.readAllBytes(schemaFile), StandardCharsets.UTF_8);
                    IntegrationSettingsSchema schema = objectMapper.readValue(schemaContent, IntegrationSettingsSchema.class);
                    settingsSchemas.put(type, schema);
                    
                    logger.info("Loaded settings schema for integration type: {}", type);
                } catch (IOException e) {
                    logger.error("Failed to load settings schema for integration type: {}", type, e);
                    
                    // Create schema dynamically if loading fails
                    IntegrationSettingsSchema schema = createSettingsSchema(type);
                    settingsSchemas.put(type, schema);
                    
                    // Save schema to file
                    try {
                        objectMapper.writeValue(schemaFile.toFile(), schema);
                        logger.info("Created and saved settings schema for integration type: {}", type);
                    } catch (IOException ex) {
                        logger.error("Failed to save settings schema for integration type: {}", type, ex);
                    }
                }
            } else {
                // Create schema dynamically
                IntegrationSettingsSchema schema = createSettingsSchema(type);
                settingsSchemas.put(type, schema);
                
                // Save schema to file
                try {
                    objectMapper.writeValue(schemaFile.toFile(), schema);
                    logger.info("Created and saved settings schema for integration type: {}", type);
                } catch (IOException e) {
                    logger.error("Failed to save settings schema for integration type: {}", type, e);
                }
            }
        }
    }
    
    /**
     * Create Azure DevOps HTTP client with proxy settings
     */
    private CloseableHttpClient createAzureDevOpsHttpClient(Integration integration) {
        return createAzureDevOpsHttpClient(integration, null);
    }
    
    /**
     * Create Azure DevOps HTTP client with specific proxy settings
     */
    private CloseableHttpClient createAzureDevOpsHttpClient(
            Integration integration, 
            IntegrationSyncOptions.ProxySettings proxySettings) {
        
        Map<String, Object> settings = integration.getSettings();
        
        // Use proxy settings from the method parameter first
        if (proxySettings != null && StringUtils.hasText(proxySettings.getHost()) 
                && proxySettings.getPort() != null && proxySettings.getPort() > 0) {
            
            return proxyConfig.createHttpClient(proxySettings);
        }
        
        // Then check integration settings for proxy settings
        String proxyHost = (String) settings.get("proxyHost");
        Integer proxyPort = settings.get("proxyPort") instanceof Number ? 
                ((Number) settings.get("proxyPort")).intValue() : null;
        String proxyUsername = (String) settings.get("proxyUsername");
        String proxyPassword = (String) settings.get("proxyPassword");
        
        if (StringUtils.hasText(proxyHost) && proxyPort != null && proxyPort > 0) {
            IntegrationSyncOptions.ProxySettings integrationProxySettings = new IntegrationSyncOptions.ProxySettings()
                    .setHost(proxyHost)
                    .setPort(proxyPort)
                    .setUsername(proxyUsername)
                    .setPassword(proxyPassword);
            
            return proxyConfig.createHttpClient(integrationProxySettings);
        }
        
        // Use default proxy settings from application.properties
        return proxyConfig.httpClient();
    }
    
    /**
     * Build Azure DevOps URI with API version
     */
    private URI buildAzureDevOpsUri(String url) throws URISyntaxException {
        URIBuilder builder = new URIBuilder(url);
        
        // Add API version if not already present
        if (builder.getQueryParams().stream()
                .noneMatch(p -> "api-version".equals(p.getName()))) {
            builder.addParameter("api-version", ADO_API_VERSION);
        }
        
        return builder.build();
    }
    
    /**
     * Get Azure DevOps authorization header
     */
    private String getAzureDevOpsAuthHeader(String pat) {
        String auth = ":" + pat;
        byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.UTF_8));
        return "Basic " + new String(encodedAuth, StandardCharsets.UTF_8);
    }
    
    /**
     * Format duration in milliseconds to readable string
     */
    private String formatDuration(long durationMs) {
        if (durationMs < 1000) {
            return durationMs + " ms";
        } else if (durationMs < 60000) {
            return String.format("%.2f s", durationMs / 1000.0);
        } else {
            long minutes = durationMs / 60000;
            long seconds = (durationMs % 60000) / 1000;
            return String.format("%d min %d s", minutes, seconds);
        }
    }
    
    /**
     * Escape XML special characters
     */
    private String escapeXml(String input) {
        if (input == null) {
            return "";
        }
        
        return input.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&apos;");
    }
    
    /**
     * Escape HTML special characters
     */
    private String escapeHtml(String input) {
        if (input == null) {
            return "";
        }
        
        return input.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
    
    /**
     * Get stack trace as string
     */
    private String getStackTraceAsString(Exception e) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        return sw.toString();
    }
    
    /**
     * Add a failed test step to the list
     */
    private void addFailedTestStep(List<IntegrationTestResult.TestStep> testSteps, String name, String message) {
        testSteps.add(new IntegrationTestResult.TestStep()
                .setName(name)
                .setDescription(message)
                .setSuccessful(false)
                .setMessage(message)
                .setExecutionTimeMs(0L));
    }
}



# CS Test Forge Application Configuration

# Application data directory
app.data.directory=./data

# Integration schemas directory
app.integrations.schemas.directory=./config/integration-schemas

# HTTP Proxy Settings
# Uncomment and configure these properties to use a proxy
# http.proxy.host=proxy.example.com
# http.proxy.port=8080
# http.proxy.username=username
# http.proxy.password=password
# http.proxy.nonProxyHosts=localhost|127.0.0.1

# HTTP Connection Settings
http.connection.timeout=30000
http.socket.timeout=30000
http.connection.request.timeout=30000

# Logging Configuration
logging.level.root=INFO
logging.level.com.cstestforge=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.file.name=logs/cstestforge.log
logging.file.max-size=10MB
logging.file.max-history=10

# Server Configuration
server.port=8080
server.servlet.context-path=/
server.compression.enabled=true
server.error.include-message=always

# File Upload Settings
spring.servlet.multipart.max-file-size=25MB
spring.servlet.multipart.max-request-size=25MB

# Jackson JSON Configuration
spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
spring.jackson.deserialization.FAIL_ON_UNKNOWN_PROPERTIES=false
spring.jackson.default-property-inclusion=non_null

# Security Configuration
# Uncomment and configure these properties for production use
# security.require-ssl=true
# server.ssl.key-store=classpath:keystore.p12
# server.ssl.key-store-password=changeit
# server.ssl.key-store-type=PKCS12
# server.ssl.key-alias=cstestforge



/**
 * Integration Controller
 * Handles REST endpoints for external system integrations
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.integration.*;
import com.cstestforge.service.integration.IntegrationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/v1/projects/{projectId}/integrations")
@CrossOrigin(origins = "*", maxAge = 3600)
public class IntegrationController {
    private static final Logger logger = LoggerFactory.getLogger(IntegrationController.class);
    
    @Autowired
    private IntegrationService integrationService;
    
    /**
     * Get all integrations for a project
     * @param projectId The project ID
     * @return List of integrations
     */
    @GetMapping
    public ResponseEntity<ApiResponse> getAllIntegrations(@PathVariable String projectId) {
        logger.info("Request to get all integrations for project: {}", projectId);
        
        try {
            List<Integration> integrations = integrationService.getAllIntegrations(projectId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integrations retrieved successfully")
                .setData(integrations);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Get integration by ID
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Integration details
     */
    @GetMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> getIntegrationById(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to get integration: {} in project: {}", integrationId, projectId);
        
        try {
            Integration integration = integrationService.getIntegrationById(projectId, integrationId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration retrieved successfully")
                .setData(integration);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Create a new integration
     * @param projectId The project ID
     * @param integration The integration to create
     * @return Created integration details
     */
    @PostMapping
    public ResponseEntity<ApiResponse> createIntegration(
            @PathVariable String projectId,
            @Valid @RequestBody Integration integration) {
        logger.info("Request to create integration in project: {}", projectId);
        
        try {
            Integration createdIntegration = integrationService.createIntegration(projectId, integration);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration created successfully")
                .setData(createdIntegration);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Project not found: {}", projectId, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to create integration", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to create integration: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Update an integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param integrationDetails The updated integration details
     * @return Updated integration details
     */
    @PutMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> updateIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @Valid @RequestBody Integration integrationDetails) {
        logger.info("Request to update integration: {} in project: {}", integrationId, projectId);
        
        try {
            Integration updatedIntegration = integrationService.updateIntegration(
                    projectId, integrationId, integrationDetails);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration updated successfully")
                .setData(updatedIntegration);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Failed to update integration", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Failed to update integration: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Delete an integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Response with deletion confirmation
     */
    @DeleteMapping("/{integrationId}")
    public ResponseEntity<ApiResponse> deleteIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to delete integration: {} in project: {}", integrationId, projectId);
        
        try {
            boolean deleted = integrationService.deleteIntegration(projectId, integrationId);
            
            if (deleted) {
                ApiResponse response = new ApiResponse()
                    .setSuccess(true)
                    .setMessage("Integration deleted successfully");
                
                return ResponseEntity.ok(response);
            } else {
                ApiResponse response = new ApiResponse()
                    .setSuccess(false)
                    .setMessage("Failed to delete integration");
                
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    }
    
    /**
     * Test an integration connection
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Connection test result
     */
    @PostMapping("/{integrationId}/test")
    public ResponseEntity<ApiResponse> testIntegrationConnection(
            @PathVariable String projectId,
            @PathVariable String integrationId) {
        logger.info("Request to test integration connection: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationTestResult result = integrationService.testIntegrationConnection(projectId, integrationId);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration connection test completed")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Integration connection test failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Integration connection test failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Sync data with integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param syncOptions Sync options
     * @return Sync result
     */
    @PostMapping("/{integrationId}/sync")
    public ResponseEntity<ApiResponse> syncWithIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody(required = false) IntegrationSyncOptions syncOptions) {
        logger.info("Request to sync with integration: {} in project: {}", integrationId, projectId);
        
        try {
            // If syncOptions is null, use default options
            if (syncOptions == null) {
                syncOptions = new IntegrationSyncOptions();
            }
            
            IntegrationSyncResult result = integrationService.syncWithIntegration(
                    projectId, integrationId, syncOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration sync completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Integration sync failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Integration sync failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Get available integration types
     * @return List of available integration types
     */
    @GetMapping("/types")
    public ResponseEntity<ApiResponse> getIntegrationTypes() {
        logger.info("Request to get available integration types");
        
        List<IntegrationType> types = integrationService.getAvailableIntegrationTypes();
        
        ApiResponse response = new ApiResponse()
            .setSuccess(true)
            .setMessage("Integration types retrieved successfully")
            .setData(types);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get integration settings schema for a specific type
     * @param type The integration type
     * @return Settings schema for the integration type
     */
    @GetMapping("/types/{type}/schema")
    public ResponseEntity<ApiResponse> getIntegrationSettingsSchema(@PathVariable String type) {
        logger.info("Request to get settings schema for integration type: {}", type);
        
        try {
            IntegrationSettingsSchema schema = integrationService.getSettingsSchemaForType(type);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration settings schema retrieved successfully")
                .setData(schema);
            
            return ResponseEntity.ok(response);
        } catch (IllegalArgumentException e) {
            logger.error("Invalid integration type: {}", type, e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Invalid integration type: " + type);
            
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
    }
    
    /**
     * Import test cases from integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param importOptions Import options
     * @return Import result
     */
    @PostMapping("/{integrationId}/import")
    public ResponseEntity<ApiResponse> importFromIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody IntegrationImportOptions importOptions) {
        logger.info("Request to import from integration: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationImportResult result = integrationService.importFromIntegration(
                    projectId, integrationId, importOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Import from integration completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Import from integration failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Import from integration failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    /**
     * Export test results to integration
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param exportOptions Export options
     * @return Export result
     */
    @PostMapping("/{integrationId}/export")
    public ResponseEntity<ApiResponse> exportToIntegration(
            @PathVariable String projectId,
            @PathVariable String integrationId,
            @RequestBody IntegrationExportOptions exportOptions) {
        logger.info("Request to export to integration: {} in project: {}", integrationId, projectId);
        
        try {
            IntegrationExportResult result = integrationService.exportToIntegration(
                    projectId, integrationId, exportOptions);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Export to integration completed successfully")
                .setData(result);
            
            return ResponseEntity.ok(response);
        } catch (ResourceNotFoundException e) {
            logger.error("Resource not found: {}", e.getMessage(), e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage(e.getMessage());
            
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        } catch (Exception e) {
            logger.error("Export to integration failed", e);
            
            ApiResponse response = new ApiResponse()
                .setSuccess(false)
                .setMessage("Export to integration failed: " + e.getMessage());
            
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents an external system integration configuration
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Integration {

    /** Unique identifier for the integration */
    private Long id;

    /** Project ID this integration belongs to */
    private Long projectId;

    /** Integration name */
    @NotBlank(message = "Name is required")
    private String name;

    /** Integration type identifier */
    @NotBlank(message = "Type is required")
    private String type;

    /** Description of this integration */
    private String description;

    /** Connection status */
    private String status;

    /** Integration configuration settings */
    @NotNull(message = "Settings are required")
    private Map<String, Object> settings = new HashMap<>();

    /** Integration metadata and statistics */
    private Map<String, Object> metadata = new HashMap<>();

    /** Creation timestamp */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createdAt;

    /** Last update timestamp */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime updatedAt;

    /** Last sync timestamp */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime lastSyncAt;

    /** Flag indicating whether this integration is enabled */
    private boolean enabled = true;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public Integration setId(Long id) {
        this.id = id;
        return this;
    }

    public Long getProjectId() {
        return projectId;
    }

    public Integration setProjectId(Long projectId) {
        this.projectId = projectId;
        return this;
    }

    public String getName() {
        return name;
    }

    public Integration setName(String name) {
        this.name = name;
        return this;
    }

    public String getType() {
        return type;
    }

    public Integration setType(String type) {
        this.type = type;
        return this;
    }

    public String getDescription() {
        return description;
    }

    public Integration setDescription(String description) {
        this.description = description;
        return this;
    }

    public String getStatus() {
        return status;
    }

    public Integration setStatus(String status) {
        this.status = status;
        return this;
    }

    public Map<String, Object> getSettings() {
        return settings;
    }

    public Integration setSettings(Map<String, Object> settings) {
        this.settings = settings;
        return this;
    }

    public Map<String, Object> getMetadata() {
        return metadata;
    }

    public Integration setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
        return this;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public Integration setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public Integration setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }

    public LocalDateTime getLastSyncAt() {
        return lastSyncAt;
    }

    public Integration setLastSyncAt(LocalDateTime lastSyncAt) {
        this.lastSyncAt = lastSyncAt;
        return this;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public Integration setEnabled(boolean enabled) {
        this.enabled = enabled;
        return this;
    }
}



package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a supported integration type
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationType {

    /** Unique identifier for the integration type */
    private String id;

    /** Display name for the integration type */
    private String name;

    /** Description of the integration type */
    private String description;

    /** URL to the icon for this integration type */
    private String iconUrl;

    /** Supported features for this integration type */
    private List<String> supportedFeatures = new ArrayList<>();

    /** Version of this integration type */
    private String version;

    /** Flag indicating whether this integration type is enabled */
    private boolean enabled = true;

    // Getters and Setters
    public String getId() {
        return id;
    }

    public IntegrationType setId(String id) {
        this.id = id;
        return this;
    }

    public String getName() {
        return name;
    }

    public IntegrationType setName(String name) {
        this.name = name;
        return this;
    }

    public String getDescription() {
        return description;
    }

    public IntegrationType setDescription(String description) {
        this.description = description;
        return this;
    }

    public String getIconUrl() {
        return iconUrl;
    }

    public IntegrationType setIconUrl(String iconUrl) {
        this.iconUrl = iconUrl;
        return this;
    }

    public List<String> getSupportedFeatures() {
        return supportedFeatures;
    }

    public IntegrationType setSupportedFeatures(List<String> supportedFeatures) {
        this.supportedFeatures = supportedFeatures;
        return this;
    }

    public String getVersion() {
        return version;
    }

    public IntegrationType setVersion(String version) {
        this.version = version;
        return this;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public IntegrationType setEnabled(boolean enabled) {
        this.enabled = enabled;
        return this;
    }
}



package com.cstestforge.service.integration;

import com.cstestforge.model.integration.*;

import java.util.List;

/**
 * Service interface for handling external system integrations
 */
public interface IntegrationService {

    /**
     * Get all integrations for a project
     * 
     * @param projectId The project ID
     * @return List of integrations
     */
    List<Integration> getAllIntegrations(String projectId);

    /**
     * Get an integration by ID
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return The integration
     */
    Integration getIntegrationById(String projectId, String integrationId);

    /**
     * Create a new integration
     * 
     * @param projectId The project ID
     * @param integration The integration to create
     * @return The created integration
     */
    Integration createIntegration(String projectId, Integration integration);

    /**
     * Update an existing integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param integrationDetails The updated integration details
     * @return The updated integration
     */
    Integration updateIntegration(String projectId, String integrationId, Integration integrationDetails);

    /**
     * Delete an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return True if the integration was deleted successfully
     */
    boolean deleteIntegration(String projectId, String integrationId);

    /**
     * Test connection to an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Result of the connection test
     */
    IntegrationTestResult testIntegrationConnection(String projectId, String integrationId);

    /**
     * Synchronize with an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param syncOptions Synchronization options
     * @return Result of the synchronization
     */
    IntegrationSyncResult syncWithIntegration(String projectId, String integrationId, IntegrationSyncOptions syncOptions);

    /**
     * Get available integration types
     * 
     * @return List of available integration types
     */
    List<IntegrationType> getAvailableIntegrationTypes();

    /**
     * Get settings schema for an integration type
     * 
     * @param type The integration type
     * @return Settings schema for the integration type
     */
    IntegrationSettingsSchema getSettingsSchemaForType(String type);

    /**
     * Import test cases from an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param importOptions Import options
     * @return Result of the import
     */
    IntegrationImportResult importFromIntegration(String projectId, String integrationId, IntegrationImportOptions importOptions);

    /**
     * Export test results to an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param exportOptions Export options
     * @return Result of the export
     */
    IntegrationExportResult exportToIntegration(String projectId, String integrationId, IntegrationExportOptions exportOptions);
}


pom.xml updates
--

<!-- For MultipartEntityBuilder -->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpmime</artifactId>
    <version>4.5.13</version>
</dependency>

<!-- For Jsoup HTML/XML parsing -->
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.14.3</version>
</dependency>
