/**
 * Integration Controller
 * Handles REST endpoints for external system integrations
 */
package com.cstestforge.controller;

import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.common.ApiResponse;
import com.cstestforge.model.integration.*;
import com.cstestforge.service.IntegrationService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/projects/{projectId}/integrations")
@Api(tags = "Integration Management", description = "Operations for managing external system integrations")
public class IntegrationController {

    private static final Logger logger = LoggerFactory.getLogger(IntegrationController.class);

    @Autowired
    private IntegrationService integrationService;

    @GetMapping
    @ApiOperation(value = "Get all integrations for a project")
    public ResponseEntity<ApiResponse> getAllIntegrations(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId) {
        
        logger.info("Getting all integrations for project: {}", projectId);
        List<Integration> integrations = integrationService.getAllIntegrations(projectId);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Retrieved all integrations successfully")
                .setData(integrations);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{integrationId}")
    @ApiOperation(value = "Get integration by ID")
    public ResponseEntity<ApiResponse> getIntegrationById(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId) {
        
        logger.info("Getting integration with ID: {} for project: {}", integrationId, projectId);
        Integration integration = integrationService.getIntegrationById(projectId, integrationId);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Retrieved integration successfully")
                .setData(integration);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping
    @ApiOperation(value = "Create new integration")
    public ResponseEntity<ApiResponse> createIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration details", required = true)
            @Valid @RequestBody Integration integration) {
        
        logger.info("Creating new integration for project: {}", projectId);
        Integration createdIntegration = integrationService.createIntegration(projectId, integration);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration created successfully")
                .setData(createdIntegration);
        
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PutMapping("/{integrationId}")
    @ApiOperation(value = "Update integration")
    public ResponseEntity<ApiResponse> updateIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId,
            @ApiParam(value = "Updated integration details", required = true)
            @Valid @RequestBody Integration integration) {
        
        logger.info("Updating integration with ID: {} for project: {}", integrationId, projectId);
        Integration updatedIntegration = integrationService.updateIntegration(projectId, integrationId, integration);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Integration updated successfully")
                .setData(updatedIntegration);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @DeleteMapping("/{integrationId}")
    @ApiOperation(value = "Delete integration")
    public ResponseEntity<ApiResponse> deleteIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId) {
        
        logger.info("Deleting integration with ID: {} for project: {}", integrationId, projectId);
        boolean deleted = integrationService.deleteIntegration(projectId, integrationId);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(deleted)
                .setMessage(deleted ? "Integration deleted successfully" : "Failed to delete integration");
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/{integrationId}/test-connection")
    @ApiOperation(value = "Test integration connection")
    public ResponseEntity<ApiResponse> testConnection(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId) {
        
        logger.info("Testing connection for integration with ID: {} for project: {}", integrationId, projectId);
        IntegrationTestResult result = integrationService.testIntegrationConnection(projectId, integrationId);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(result.isSuccessful())
                .setMessage(result.isSuccessful() ? "Connection test successful" : "Connection test failed")
                .setData(result);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/{integrationId}/sync")
    @ApiOperation(value = "Synchronize with external system")
    public ResponseEntity<ApiResponse> syncWithIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId,
            @ApiParam(value = "Synchronization options")
            @RequestBody(required = false) IntegrationSyncOptions syncOptions) {
        
        logger.info("Syncing with integration ID: {} for project: {}", integrationId, projectId);
        IntegrationSyncResult result = integrationService.syncWithIntegration(projectId, integrationId, syncOptions);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(result.isSuccessful())
                .setMessage(result.isSuccessful() ? "Synchronization successful" : "Synchronization failed")
                .setData(result);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/types")
    @ApiOperation(value = "Get available integration types")
    public ResponseEntity<ApiResponse> getAvailableIntegrationTypes() {
        
        logger.info("Getting available integration types");
        List<IntegrationType> types = integrationService.getAvailableIntegrationTypes();
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Retrieved available integration types successfully")
                .setData(types);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/types/{type}/schema")
    @ApiOperation(value = "Get settings schema for integration type")
    public ResponseEntity<ApiResponse> getSettingsSchemaForType(
            @ApiParam(value = "Integration type", required = true)
            @PathVariable String type) {
        
        logger.info("Getting settings schema for integration type: {}", type);
        IntegrationSettingsSchema schema = integrationService.getSettingsSchemaForType(type);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(true)
                .setMessage("Retrieved settings schema successfully")
                .setData(schema);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/{integrationId}/import")
    @ApiOperation(value = "Import data from integration")
    public ResponseEntity<ApiResponse> importFromIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId,
            @ApiParam(value = "Import options", required = true)
            @RequestBody IntegrationImportOptions importOptions) {
        
        logger.info("Importing data from integration ID: {} for project: {}", integrationId, projectId);
        IntegrationImportResult result = integrationService.importFromIntegration(projectId, integrationId, importOptions);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(result.isSuccessful())
                .setMessage(result.isSuccessful() ? "Import successful" : "Import failed")
                .setData(result);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/{integrationId}/export")
    @ApiOperation(value = "Export data to integration")
    public ResponseEntity<ApiResponse> exportToIntegration(
            @ApiParam(value = "Project ID", required = true)
            @PathVariable Long projectId,
            @ApiParam(value = "Integration ID", required = true)
            @PathVariable Long integrationId,
            @ApiParam(value = "Export options", required = true)
            @RequestBody IntegrationExportOptions exportOptions) {
        
        logger.info("Exporting data to integration ID: {} for project: {}", integrationId, projectId);
        IntegrationExportResult result = integrationService.exportToIntegration(projectId, integrationId, exportOptions);
        
        ApiResponse response = new ApiResponse()
                .setSuccess(result.isSuccessful())
                .setMessage(result.isSuccessful() ? "Export successful" : "Export failed")
                .setData(result);
        
        return new ResponseEntity<>(response, HttpStatus.OK);
    }
}

package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ApiModel(description = "Represents an external system integration configuration")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Integration {

    @ApiModelProperty(value = "Unique identifier for the integration", example = "1")
    private Long id;

    @ApiModelProperty(value = "Project ID this integration belongs to", example = "100")
    private Long projectId;

    @NotBlank(message = "Name is required")
    @ApiModelProperty(value = "Integration name", required = true, example = "Azure DevOps Project XYZ")
    private String name;

    @NotBlank(message = "Type is required")
    @ApiModelProperty(value = "Integration type identifier", required = true, example = "azure-devops")
    private String type;

    @ApiModelProperty(value = "Description of this integration", example = "Integration with Azure DevOps for Project XYZ")
    private String description;

    @ApiModelProperty(value = "Connection status", example = "Connected")
    private String status;

    @NotNull(message = "Settings are required")
    @ApiModelProperty(value = "Integration configuration settings", required = true)
    private Map<String, Object> settings = new HashMap<>();

    @ApiModelProperty(value = "Integration metadata and statistics")
    private Map<String, Object> metadata = new HashMap<>();

    @ApiModelProperty(value = "Creation timestamp")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createdAt;

    @ApiModelProperty(value = "Last update timestamp")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime updatedAt;

    @ApiModelProperty(value = "Last sync timestamp")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime lastSyncAt;

    @ApiModelProperty(value = "Flag indicating whether this integration is enabled")
    private boolean enabled = true;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public Integration setId(Long id) {
        this.id = id;
        return this;
    }

    public Long getProjectId() {
        return projectId;
    }

    public Integration setProjectId(Long projectId) {
        this.projectId = projectId;
        return this;
    }

    public String getName() {
        return name;
    }

    public Integration setName(String name) {
        this.name = name;
        return this;
    }

    public String getType() {
        return type;
    }

    public Integration setType(String type) {
        this.type = type;
        return this;
    }

    public String getDescription() {
        return description;
    }

    public Integration setDescription(String description) {
        this.description = description;
        return this;
    }

    public String getStatus() {
        return status;
    }

    public Integration setStatus(String status) {
        this.status = status;
        return this;
    }

    public Map<String, Object> getSettings() {
        return settings;
    }

    public Integration setSettings(Map<String, Object> settings) {
        this.settings = settings;
        return this;
    }

    public Map<String, Object> getMetadata() {
        return metadata;
    }

    public Integration setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
        return this;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public Integration setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public Integration setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }

    public LocalDateTime getLastSyncAt() {
        return lastSyncAt;
    }

    public Integration setLastSyncAt(LocalDateTime lastSyncAt) {
        this.lastSyncAt = lastSyncAt;
        return this;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public Integration setEnabled(boolean enabled) {
        this.enabled = enabled;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.List;

@ApiModel(description = "Represents a supported integration type")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationType {

    @ApiModelProperty(value = "Unique identifier for the integration type", example = "azure-devops")
    private String id;

    @ApiModelProperty(value = "Display name for the integration type", example = "Azure DevOps")
    private String name;

    @ApiModelProperty(value = "Description of the integration type", example = "Integration with Azure DevOps for test case management and Git repositories")
    private String description;

    @ApiModelProperty(value = "URL to the icon for this integration type", example = "/assets/images/integrations/azure-devops.png")
    private String iconUrl;

    @ApiModelProperty(value = "Supported features for this integration type")
    private List<String> supportedFeatures = new ArrayList<>();

    @ApiModelProperty(value = "Version of this integration type", example = "1.0")
    private String version;

    @ApiModelProperty(value = "Flag indicating whether this integration type is enabled", example = "true")
    private boolean enabled = true;

    // Getters and Setters
    public String getId() {
        return id;
    }

    public IntegrationType setId(String id) {
        this.id = id;
        return this;
    }

    public String getName() {
        return name;
    }

    public IntegrationType setName(String name) {
        this.name = name;
        return this;
    }

    public String getDescription() {
        return description;
    }

    public IntegrationType setDescription(String description) {
        this.description = description;
        return this;
    }

    public String getIconUrl() {
        return iconUrl;
    }

    public IntegrationType setIconUrl(String iconUrl) {
        this.iconUrl = iconUrl;
        return this;
    }

    public List<String> getSupportedFeatures() {
        return supportedFeatures;
    }

    public IntegrationType setSupportedFeatures(List<String> supportedFeatures) {
        this.supportedFeatures = supportedFeatures;
        return this;
    }

    public String getVersion() {
        return version;
    }

    public IntegrationType setVersion(String version) {
        this.version = version;
        return this;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public IntegrationType setEnabled(boolean enabled) {
        this.enabled = enabled;
        return this;
    }
}

package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Schema definition for integration settings")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSettingsSchema {

    @ApiModelProperty(value = "Integration type this schema applies to", example = "azure-devops")
    private String integrationType;

    @ApiModelProperty(value = "Schema version", example = "1.0")
    private String version;

    @ApiModelProperty(value = "List of field definitions")
    private List<SettingsField> fields = new ArrayList<>();

    @ApiModelProperty(value = "Additional validation rules for this schema")
    private Map<String, Object> validationRules = new HashMap<>();

    @ApiModelProperty(value = "UI hints for rendering the settings form")
    private Map<String, Object> uiHints = new HashMap<>();

    // Nested class for field definition
    @ApiModel(description = "Definition of a settings field")
    public static class SettingsField {
        
        @ApiModelProperty(value = "Field identifier", example = "pat")
        private String id;
        
        @ApiModelProperty(value = "Field display name", example = "Personal Access Token")
        private String name;
        
        @ApiModelProperty(value = "Field description", example = "Azure DevOps Personal Access Token with appropriate permissions")
        private String description;
        
        @ApiModelProperty(value = "Field type", example = "password", allowableValues = "text,password,number,boolean,select,textarea,url")
        private String type;
        
        @ApiModelProperty(value = "Flag indicating if this field is required", example = "true")
        private boolean required = false;
        
        @ApiModelProperty(value = "Default value for this field")
        private Object defaultValue;
        
        @ApiModelProperty(value = "Field validation constraints")
        private Map<String, Object> validation = new HashMap<>();
        
        @ApiModelProperty(value = "Available options for select type")
        private List<Map<String, Object>> options = new ArrayList<>();
        
        @ApiModelProperty(value = "UI hints for this field")
        private Map<String, Object> uiHints = new HashMap<>();

        // Getters and Setters
        public String getId() {
            return id;
        }

        public SettingsField setId(String id) {
            this.id = id;
            return this;
        }

        public String getName() {
            return name;
        }

        public SettingsField setName(String name) {
            this.name = name;
            return this;
        }

        public String getDescription() {
            return description;
        }

        public SettingsField setDescription(String description) {
            this.description = description;
            return this;
        }

        public String getType() {
            return type;
        }

        public SettingsField setType(String type) {
            this.type = type;
            return this;
        }

        public boolean isRequired() {
            return required;
        }

        public SettingsField setRequired(boolean required) {
            this.required = required;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public SettingsField setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }

        public Map<String, Object> getValidation() {
            return validation;
        }

        public SettingsField setValidation(Map<String, Object> validation) {
            this.validation = validation;
            return this;
        }

        public List<Map<String, Object>> getOptions() {
            return options;
        }

        public SettingsField setOptions(List<Map<String, Object>> options) {
            this.options = options;
            return this;
        }

        public Map<String, Object> getUiHints() {
            return uiHints;
        }

        public SettingsField setUiHints(Map<String, Object> uiHints) {
            this.uiHints = uiHints;
            return this;
        }
    }

    // Getters and Setters
    public String getIntegrationType() {
        return integrationType;
    }

    public IntegrationSettingsSchema setIntegrationType(String integrationType) {
        this.integrationType = integrationType;
        return this;
    }

    public String getVersion() {
        return version;
    }

    public IntegrationSettingsSchema setVersion(String version) {
        this.version = version;
        return this;
    }

    public List<SettingsField> getFields() {
        return fields;
    }

    public IntegrationSettingsSchema setFields(List<SettingsField> fields) {
        this.fields = fields;
        return this;
    }

    public Map<String, Object> getValidationRules() {
        return validationRules;
    }

    public IntegrationSettingsSchema setValidationRules(Map<String, Object> validationRules) {
        this.validationRules = validationRules;
        return this;
    }

    public Map<String, Object> getUiHints() {
        return uiHints;
    }

    public IntegrationSettingsSchema setUiHints(Map<String, Object> uiHints) {
        this.uiHints = uiHints;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Result of testing an integration connection")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationTestResult {

    @ApiModelProperty(value = "Integration ID", example = "1")
    private Long integrationId;

    @ApiModelProperty(value = "Flag indicating if the test was successful", example = "true")
    private boolean successful;

    @ApiModelProperty(value = "Status message", example = "Successfully connected to Azure DevOps")
    private String message;

    @ApiModelProperty(value = "Error code if the test failed", example = "AUTH_ERROR")
    private String errorCode;

    @ApiModelProperty(value = "Detailed error message if the test failed", example = "Authentication failed: Invalid credentials")
    private String errorDetail;

    @ApiModelProperty(value = "Timestamp of the test")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime testedAt;

    @ApiModelProperty(value = "Connection details retrieved from the integration")
    private Map<String, Object> connectionDetails = new HashMap<>();

    @ApiModelProperty(value = "Test steps and their results")
    private List<TestStep> testSteps = new ArrayList<>();

    @ApiModelProperty(value = "Response time in milliseconds", example = "543")
    private Long responseTimeMs;

    // Nested class for test steps
    @ApiModel(description = "Individual test step and its result")
    public static class TestStep {
        
        @ApiModelProperty(value = "Step name", example = "Authenticate")
        private String name;
        
        @ApiModelProperty(value = "Step description", example = "Authenticating with Azure DevOps using provided PAT")
        private String description;
        
        @ApiModelProperty(value = "Flag indicating if this step was successful", example = "true")
        private boolean successful;
        
        @ApiModelProperty(value = "Status message for this step", example = "Authentication successful")
        private String message;
        
        @ApiModelProperty(value = "Execution time of this step in milliseconds", example = "150")
        private Long executionTimeMs;

        // Getters and Setters
        public String getName() {
            return name;
        }

        public TestStep setName(String name) {
            this.name = name;
            return this;
        }

        public String getDescription() {
            return description;
        }

        public TestStep setDescription(String description) {
            this.description = description;
            return this;
        }

        public boolean isSuccessful() {
            return successful;
        }

        public TestStep setSuccessful(boolean successful) {
            this.successful = successful;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public TestStep setMessage(String message) {
            this.message = message;
            return this;
        }

        public Long getExecutionTimeMs() {
            return executionTimeMs;
        }

        public TestStep setExecutionTimeMs(Long executionTimeMs) {
            this.executionTimeMs = executionTimeMs;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationTestResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationTestResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationTestResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationTestResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationTestResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getTestedAt() {
        return testedAt;
    }

    public IntegrationTestResult setTestedAt(LocalDateTime testedAt) {
        this.testedAt = testedAt;
        return this;
    }

    public Map<String, Object> getConnectionDetails() {
        return connectionDetails;
    }

    public IntegrationTestResult setConnectionDetails(Map<String, Object> connectionDetails) {
        this.connectionDetails = connectionDetails;
        return this;
    }

    public List<TestStep> getTestSteps() {
        return testSteps;
    }

    public IntegrationTestResult setTestSteps(List<TestStep> testSteps) {
        this.testSteps = testSteps;
        return this;
    }

    public Long getResponseTimeMs() {
        return responseTimeMs;
    }

    public IntegrationTestResult setResponseTimeMs(Long responseTimeMs) {
        this.responseTimeMs = responseTimeMs;
        return this;
    }
}



package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Options for synchronizing with an external system")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSyncOptions {

    @ApiModelProperty(value = "Direction of synchronization", example = "PULL", allowableValues = "PULL,PUSH,BIDIRECTIONAL")
    private String direction = "PULL";

    @ApiModelProperty(value = "Content types to synchronize")
    private List<String> contentTypes = new ArrayList<>();

    @ApiModelProperty(value = "Filters to apply during synchronization")
    private Map<String, Object> filters = new HashMap<>();

    @ApiModelProperty(value = "Flag to force sync even if no changes detected", example = "false")
    private boolean forceSync = false;

    @ApiModelProperty(value = "Flag to only perform a dry run without making changes", example = "false")
    private boolean dryRun = false;

    @ApiModelProperty(value = "Maximum items to sync per content type", example = "100")
    private Integer maxItems;

    @ApiModelProperty(value = "Conflict resolution strategy", example = "LATEST_WINS", allowableValues = "LATEST_WINS,SOURCE_WINS,TARGET_WINS,MANUAL")
    private String conflictResolution = "LATEST_WINS";

    @ApiModelProperty(value = "Additional options specific to the integration type")
    private Map<String, Object> additionalOptions = new HashMap<>();

    // Options specifically for Azure DevOps
    @ApiModelProperty(value = "Azure DevOps project to sync with", example = "MyProject")
    private String adoProject;

    @ApiModelProperty(value = "Azure DevOps team to sync with", example = "MyTeam")
    private String adoTeam;

    @ApiModelProperty(value = "Azure DevOps test plan ID to sync with", example = "12345")
    private Long adoTestPlanId;

    @ApiModelProperty(value = "Azure DevOps test suite ID to sync with", example = "67890")
    private Long adoTestSuiteId;

    @ApiModelProperty(value = "Azure DevOps work item query to sync with", example = "SELECT * FROM WorkItems WHERE [System.WorkItemType] = 'Test Case'")
    private String adoWorkItemQuery;

    // Options specifically for Azure DevOps Git
    @ApiModelProperty(value = "Azure DevOps Git repository ID to sync with", example = "MyRepository")
    private String adoGitRepositoryId;

    @ApiModelProperty(value = "Azure DevOps Git branch to sync with", example = "main")
    private String adoGitBranch;

    @ApiModelProperty(value = "Path pattern for files to sync in Git", example = "tests/**/*.js")
    private String adoGitPathPattern;

    // Proxy settings that can be applied during sync
    @ApiModelProperty(value = "Proxy settings to use during synchronization")
    private ProxySettings proxySettings;

    // Nested class for proxy settings
    @ApiModel(description = "Proxy settings for integration connections")
    public static class ProxySettings {
        
        @ApiModelProperty(value = "Proxy host", example = "proxy.example.com")
        private String host;
        
        @ApiModelProperty(value = "Proxy port", example = "8080")
        private Integer port;
        
        @ApiModelProperty(value = "Proxy username if authentication is required")
        private String username;
        
        @ApiModelProperty(value = "Proxy password if authentication is required")
        private String password;
        
        @ApiModelProperty(value = "Non-proxy hosts (hosts that shouldn't use the proxy)", example = "localhost|127.0.0.1")
        private String nonProxyHosts;

        // Getters and Setters
        public String getHost() {
            return host;
        }

        public ProxySettings setHost(String host) {
            this.host = host;
            return this;
        }

        public Integer getPort() {
            return port;
        }

        public ProxySettings setPort(Integer port) {
            this.port = port;
            return this;
        }

        public String getUsername() {
            return username;
        }

        public ProxySettings setUsername(String username) {
            this.username = username;
            return this;
        }

        public String getPassword() {
            return password;
        }

        public ProxySettings setPassword(String password) {
            this.password = password;
            return this;
        }

        public String getNonProxyHosts() {
            return nonProxyHosts;
        }

        public ProxySettings setNonProxyHosts(String nonProxyHosts) {
            this.nonProxyHosts = nonProxyHosts;
            return this;
        }
    }

    // Getters and Setters
    public String getDirection() {
        return direction;
    }

    public IntegrationSyncOptions setDirection(String direction) {
        this.direction = direction;
        return this;
    }

    public List<String> getContentTypes() {
        return contentTypes;
    }

    public IntegrationSyncOptions setContentTypes(List<String> contentTypes) {
        this.contentTypes = contentTypes;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationSyncOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isForceSync() {
        return forceSync;
    }

    public IntegrationSyncOptions setForceSync(boolean forceSync) {
        this.forceSync = forceSync;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationSyncOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationSyncOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public String getConflictResolution() {
        return conflictResolution;
    }

    public IntegrationSyncOptions setConflictResolution(String conflictResolution) {
        this.conflictResolution = conflictResolution;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationSyncOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationSyncOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationSyncOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationSyncOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationSyncOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public String getAdoWorkItemQuery() {
        return adoWorkItemQuery;
    }

    public IntegrationSyncOptions setAdoWorkItemQuery(String adoWorkItemQuery) {
        this.adoWorkItemQuery = adoWorkItemQuery;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationSyncOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationSyncOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitPathPattern() {
        return adoGitPathPattern;
    }

    public IntegrationSyncOptions setAdoGitPathPattern(String adoGitPathPattern) {
        this.adoGitPathPattern = adoGitPathPattern;
        return this;
    }

    public ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationSyncOptions setProxySettings(ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Result of an integration synchronization operation")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationSyncResult {

    @ApiModelProperty(value = "Integration ID", example = "1")
    private Long integrationId;

    @ApiModelProperty(value = "Flag indicating if the sync was successful", example = "true")
    private boolean successful;

    @ApiModelProperty(value = "Status message", example = "Synchronized 24 test cases successfully")
    private String message;

    @ApiModelProperty(value = "Error code if the sync failed", example = "SYNC_ERROR")
    private String errorCode;

    @ApiModelProperty(value = "Detailed error message if the sync failed", example = "Failed to sync test cases: Network error")
    private String errorDetail;

    @ApiModelProperty(value = "Start timestamp of the sync operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    @ApiModelProperty(value = "Completion timestamp of the sync operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    @ApiModelProperty(value = "Duration of the sync operation in milliseconds", example = "5432")
    private Long durationMs;

    @ApiModelProperty(value = "Sync statistics per content type")
    private Map<String, SyncStats> stats = new HashMap<>();

    @ApiModelProperty(value = "List of sync issues encountered")
    private List<SyncIssue> issues = new ArrayList<>();

    @ApiModelProperty(value = "Sync direction that was performed", example = "PULL", allowableValues = "PULL,PUSH,BIDIRECTIONAL")
    private String direction;

    @ApiModelProperty(value = "Flag indicating if this was a dry run", example = "false")
    private boolean dryRun;

    // Nested class for sync statistics
    @ApiModel(description = "Synchronization statistics for a content type")
    public static class SyncStats {
        
        @ApiModelProperty(value = "Content type", example = "TEST_CASE")
        private String contentType;
        
        @ApiModelProperty(value = "Total items processed", example = "50")
        private int totalProcessed;
        
        @ApiModelProperty(value = "New items created", example = "10")
        private int created;
        
        @ApiModelProperty(value = "Existing items updated", example = "15")
        private int updated;
        
        @ApiModelProperty(value = "Items deleted", example = "5")
        private int deleted;
        
        @ApiModelProperty(value = "Items skipped (no changes)", example = "20")
        private int skipped;
        
        @ApiModelProperty(value = "Items with errors", example = "0")
        private int errors;
        
        @ApiModelProperty(value = "Items with conflicts", example = "3")
        private int conflicts;
        
        @ApiModelProperty(value = "Additional statistics specific to content type")
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public String getContentType() {
            return contentType;
        }

        public SyncStats setContentType(String contentType) {
            this.contentType = contentType;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public SyncStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public SyncStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public SyncStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getDeleted() {
            return deleted;
        }

        public SyncStats setDeleted(int deleted) {
            this.deleted = deleted;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public SyncStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public SyncStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getConflicts() {
            return conflicts;
        }

        public SyncStats setConflicts(int conflicts) {
            this.conflicts = conflicts;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public SyncStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    // Nested class for sync issues
    @ApiModel(description = "Issue encountered during synchronization")
    public static class SyncIssue {
        
        @ApiModelProperty(value = "Issue severity", example = "ERROR", allowableValues = "INFO,WARNING,ERROR")
        private String severity;
        
        @ApiModelProperty(value = "Content type", example = "TEST_CASE")
        private String contentType;
        
        @ApiModelProperty(value = "Item ID", example = "12345")
        private String itemId;
        
        @ApiModelProperty(value = "Issue message", example = "Failed to update test case: Invalid field value")
        private String message;
        
        @ApiModelProperty(value = "Issue code", example = "INVALID_FIELD")
        private String code;
        
        @ApiModelProperty(value = "Additional details about the issue")
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public SyncIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public String getContentType() {
            return contentType;
        }

        public SyncIssue setContentType(String contentType) {
            this.contentType = contentType;
            return this;
        }

        public String getItemId() {
            return itemId;
        }

        public SyncIssue setItemId(String itemId) {
            this.itemId = itemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public SyncIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public SyncIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public SyncIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationSyncResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationSyncResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationSyncResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationSyncResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationSyncResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationSyncResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationSyncResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationSyncResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public Map<String, SyncStats> getStats() {
        return stats;
    }

    public IntegrationSyncResult setStats(Map<String, SyncStats> stats) {
        this.stats = stats;
        return this;
    }

    public List<SyncIssue> getIssues() {
        return issues;
    }

    public IntegrationSyncResult setIssues(List<SyncIssue> issues) {
        this.issues = issues;
        return this;
    }

    public String getDirection() {
        return direction;
    }

    public IntegrationSyncResult setDirection(String direction) {
        this.direction = direction;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationSyncResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }
}

package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Options for importing data from an external system")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationImportOptions {

    @ApiModelProperty(value = "Content type to import", example = "TEST_CASE", allowableValues = "TEST_CASE,TEST_SUITE,TEST_SCRIPT,TEST_PLAN")
    private String contentType;

    @ApiModelProperty(value = "Target folder ID to import into", example = "12345")
    private Long targetFolderId;

    @ApiModelProperty(value = "Filters to apply during import")
    private Map<String, Object> filters = new HashMap<>();

    @ApiModelProperty(value = "Flag to overwrite existing items", example = "false")
    private boolean overwriteExisting = false;

    @ApiModelProperty(value = "Flag to only perform a dry run without making changes", example = "false")
    private boolean dryRun = false;

    @ApiModelProperty(value = "Maximum items to import", example = "100")
    private Integer maxItems;

    @ApiModelProperty(value = "Flag to include child items in the import", example = "true")
    private boolean includeChildren = true;

    @ApiModelProperty(value = "Flag to include attachments in the import", example = "true")
    private boolean includeAttachments = true;

    @ApiModelProperty(value = "Additional options specific to the integration type")
    private Map<String, Object> additionalOptions = new HashMap<>();

    // Options specifically for Azure DevOps
    @ApiModelProperty(value = "Azure DevOps project to import from", example = "MyProject")
    private String adoProject;

    @ApiModelProperty(value = "Azure DevOps team to import from", example = "MyTeam")
    private String adoTeam;

    @ApiModelProperty(value = "Azure DevOps test plan ID to import from", example = "12345")
    private Long adoTestPlanId;

    @ApiModelProperty(value = "Azure DevOps test suite ID to import from", example = "67890")
    private Long adoTestSuiteId;

    @ApiModelProperty(value = "Azure DevOps work item IDs to import", example = "[1234, 5678]")
    private List<Long> adoWorkItemIds = new ArrayList<>();

    @ApiModelProperty(value = "Azure DevOps work item query to import from", example = "SELECT * FROM WorkItems WHERE [System.WorkItemType] = 'Test Case'")
    private String adoWorkItemQuery;

    @ApiModelProperty(value = "Azure DevOps area path to import from", example = "MyProject\\Area\\Path")
    private String adoAreaPath;

    @ApiModelProperty(value = "Azure DevOps iteration path to import from", example = "MyProject\\Iteration\\Path")
    private String adoIterationPath;

    // Options specifically for Azure DevOps Git
    @ApiModelProperty(value = "Azure DevOps Git repository ID to import from", example = "MyRepository")
    private String adoGitRepositoryId;

    @ApiModelProperty(value = "Azure DevOps Git branch to import from", example = "main")
    private String adoGitBranch;

    @ApiModelProperty(value = "Path pattern for files to import from Git", example = "tests/**/*.js")
    private String adoGitPathPattern;

    @ApiModelProperty(value = "File extensions to filter by when importing from Git", example = "[\".js\", \".ts\"]")
    private List<String> adoGitFileExtensions = new ArrayList<>();

    @ApiModelProperty(value = "Flag to only import files changed since last import", example = "true")
    private boolean adoGitOnlyChangedFiles = false;

    @ApiModelProperty(value = "Commit ID to import from (if not latest)", example = "a1b2c3d4e5f6g7h8i9j0")
    private String adoGitCommitId;

    // Import mapping fields
    @ApiModelProperty(value = "Field mappings for import")
    private List<FieldMapping> fieldMappings = new ArrayList<>();

    // Proxy settings that can be applied during import
    @ApiModelProperty(value = "Proxy settings to use during import")
    private IntegrationSyncOptions.ProxySettings proxySettings;

    // Nested class for field mappings
    @ApiModel(description = "Mapping between external system field and local field")
    public static class FieldMapping {
        
        @ApiModelProperty(value = "Source field in external system", example = "Microsoft.VSTS.TCM.Steps")
        private String sourceField;
        
        @ApiModelProperty(value = "Target field in CS Test Forge", example = "testSteps")
        private String targetField;
        
        @ApiModelProperty(value = "Transformation to apply during mapping", example = "CONVERT_HTML_TO_MARKDOWN")
        private String transformation;
        
        @ApiModelProperty(value = "Default value to use if source field is empty")
        private Object defaultValue;

        // Getters and Setters
        public String getSourceField() {
            return sourceField;
        }

        public FieldMapping setSourceField(String sourceField) {
            this.sourceField = sourceField;
            return this;
        }

        public String getTargetField() {
            return targetField;
        }

        public FieldMapping setTargetField(String targetField) {
            this.targetField = targetField;
            return this;
        }

        public String getTransformation() {
            return transformation;
        }

        public FieldMapping setTransformation(String transformation) {
            this.transformation = transformation;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public FieldMapping setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }
    }

    // Getters and Setters
    public String getContentType() {
        return contentType;
    }

    public IntegrationImportOptions setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public Long getTargetFolderId() {
        return targetFolderId;
    }

    public IntegrationImportOptions setTargetFolderId(Long targetFolderId) {
        this.targetFolderId = targetFolderId;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationImportOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isOverwriteExisting() {
        return overwriteExisting;
    }

    public IntegrationImportOptions setOverwriteExisting(boolean overwriteExisting) {
        this.overwriteExisting = overwriteExisting;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationImportOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationImportOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public boolean isIncludeChildren() {
        return includeChildren;
    }

    public IntegrationImportOptions setIncludeChildren(boolean includeChildren) {
        this.includeChildren = includeChildren;
        return this;
    }

    public boolean isIncludeAttachments() {
        return includeAttachments;
    }

    public IntegrationImportOptions setIncludeAttachments(boolean includeAttachments) {
        this.includeAttachments = includeAttachments;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationImportOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationImportOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationImportOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationImportOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationImportOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public List<Long> getAdoWorkItemIds() {
        return adoWorkItemIds;
    }

    public IntegrationImportOptions setAdoWorkItemIds(List<Long> adoWorkItemIds) {
        this.adoWorkItemIds = adoWorkItemIds;
        return this;
    }

    public String getAdoWorkItemQuery() {
        return adoWorkItemQuery;
    }

    public IntegrationImportOptions setAdoWorkItemQuery(String adoWorkItemQuery) {
        this.adoWorkItemQuery = adoWorkItemQuery;
        return this;
    }

    public String getAdoAreaPath() {
        return adoAreaPath;
    }

    public IntegrationImportOptions setAdoAreaPath(String adoAreaPath) {
        this.adoAreaPath = adoAreaPath;
        return this;
    }

    public String getAdoIterationPath() {
        return adoIterationPath;
    }

    public IntegrationImportOptions setAdoIterationPath(String adoIterationPath) {
        this.adoIterationPath = adoIterationPath;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationImportOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationImportOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitPathPattern() {
        return adoGitPathPattern;
    }

    public IntegrationImportOptions setAdoGitPathPattern(String adoGitPathPattern) {
        this.adoGitPathPattern = adoGitPathPattern;
        return this;
    }

    public List<String> getAdoGitFileExtensions() {
        return adoGitFileExtensions;
    }

    public IntegrationImportOptions setAdoGitFileExtensions(List<String> adoGitFileExtensions) {
        this.adoGitFileExtensions = adoGitFileExtensions;
        return this;
    }

    public boolean isAdoGitOnlyChangedFiles() {
        return adoGitOnlyChangedFiles;
    }

    public IntegrationImportOptions setAdoGitOnlyChangedFiles(boolean adoGitOnlyChangedFiles) {
        this.adoGitOnlyChangedFiles = adoGitOnlyChangedFiles;
        return this;
    }

    public String getAdoGitCommitId() {
        return adoGitCommitId;
    }

    public IntegrationImportOptions setAdoGitCommitId(String adoGitCommitId) {
        this.adoGitCommitId = adoGitCommitId;
        return this;
    }

    public List<FieldMapping> getFieldMappings() {
        return fieldMappings;
    }

    public IntegrationImportOptions setFieldMappings(List<FieldMapping> fieldMappings) {
        this.fieldMappings = fieldMappings;
        return this;
    }

    public IntegrationSyncOptions.ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationImportOptions setProxySettings(IntegrationSyncOptions.ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Result of importing data from an external system")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationImportResult {

    @ApiModelProperty(value = "Integration ID", example = "1")
    private Long integrationId;

    @ApiModelProperty(value = "Flag indicating if the import was successful", example = "true")
    private boolean successful;

    @ApiModelProperty(value = "Status message", example = "Imported 24 test cases successfully")
    private String message;

    @ApiModelProperty(value = "Error code if the import failed", example = "IMPORT_ERROR")
    private String errorCode;

    @ApiModelProperty(value = "Detailed error message if the import failed", example = "Failed to import test cases: Network error")
    private String errorDetail;

    @ApiModelProperty(value = "Start timestamp of the import operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    @ApiModelProperty(value = "Completion timestamp of the import operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    @ApiModelProperty(value = "Duration of the import operation in milliseconds", example = "5432")
    private Long durationMs;

    @ApiModelProperty(value = "Content type that was imported", example = "TEST_CASE")
    private String contentType;

    @ApiModelProperty(value = "Target folder ID that was imported into", example = "12345")
    private Long targetFolderId;

    @ApiModelProperty(value = "Import statistics")
    private ImportStats stats = new ImportStats();

    @ApiModelProperty(value = "List of issues encountered during import")
    private List<ImportIssue> issues = new ArrayList<>();

    @ApiModelProperty(value = "Flag indicating if this was a dry run", example = "false")
    private boolean dryRun;

    @ApiModelProperty(value = "Imported items details")
    private List<ImportedItem> importedItems = new ArrayList<>();

    // Nested class for import statistics
    @ApiModel(description = "Statistics of the import operation")
    public static class ImportStats {
        
        @ApiModelProperty(value = "Total items found in the external system", example = "50")
        private int totalFound;
        
        @ApiModelProperty(value = "Total items processed during import", example = "45")
        private int totalProcessed;
        
        @ApiModelProperty(value = "New items created", example = "30")
        private int created;
        
        @ApiModelProperty(value = "Existing items updated", example = "10")
        private int updated;
        
        @ApiModelProperty(value = "Items skipped (filtered out or errors)", example = "5")
        private int skipped;
        
        @ApiModelProperty(value = "Items with errors", example = "0")
        private int errors;
        
        @ApiModelProperty(value = "Total attachments imported", example = "15")
        private int attachmentsImported;
        
        @ApiModelProperty(value = "Total child items imported", example = "25")
        private int childItemsImported;
        
        @ApiModelProperty(value = "Additional statistics specific to content type")
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public int getTotalFound() {
            return totalFound;
        }

        public ImportStats setTotalFound(int totalFound) {
            this.totalFound = totalFound;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public ImportStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public ImportStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public ImportStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public ImportStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public ImportStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getAttachmentsImported() {
            return attachmentsImported;
        }

        public ImportStats setAttachmentsImported(int attachmentsImported) {
            this.attachmentsImported = attachmentsImported;
            return this;
        }

        public int getChildItemsImported() {
            return childItemsImported;
        }

        public ImportStats setChildItemsImported(int childItemsImported) {
            this.childItemsImported = childItemsImported;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public ImportStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    // Nested class for import issues
    @ApiModel(description = "Issue encountered during import")
    public static class ImportIssue {
        
        @ApiModelProperty(value = "Issue severity", example = "ERROR", allowableValues = "INFO,WARNING,ERROR")
        private String severity;
        
        @ApiModelProperty(value = "External item ID", example = "12345")
        private String externalItemId;
        
        @ApiModelProperty(value = "Issue message", example = "Failed to import test case: Invalid field value")
        private String message;
        
        @ApiModelProperty(value = "Issue code", example = "INVALID_FIELD")
        private String code;
        
        @ApiModelProperty(value = "Additional details about the issue")
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public ImportIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public String getExternalItemId() {
            return externalItemId;
        }

        public ImportIssue setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public ImportIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public ImportIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public ImportIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    // Nested class for imported item details
    @ApiModel(description = "Details of an imported item")
    public static class ImportedItem {
        
        @ApiModelProperty(value = "External item ID", example = "12345")
        private String externalItemId;
        
        @ApiModelProperty(value = "Local item ID", example = "67890")
        private Long localItemId;
        
        @ApiModelProperty(value = "Item name or title", example = "Login Test Case")
        private String name;
        
        @ApiModelProperty(value = "Import action performed", example = "CREATED", allowableValues = "CREATED,UPDATED,SKIPPED,ERROR")
        private String action;
        
        @ApiModelProperty(value = "Additional properties about the imported item")
        private Map<String, Object> properties = new HashMap<>();

        // Getters and Setters
        public String getExternalItemId() {
            return externalItemId;
        }

        public ImportedItem setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public Long getLocalItemId() {
            return localItemId;
        }

        public ImportedItem setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getName() {
            return name;
        }

        public ImportedItem setName(String name) {
            this.name = name;
            return this;
        }

        public String getAction() {
            return action;
        }

        public ImportedItem setAction(String action) {
            this.action = action;
            return this;
        }

        public Map<String, Object> getProperties() {
            return properties;
        }

        public ImportedItem setProperties(Map<String, Object> properties) {
            this.properties = properties;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationImportResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationImportResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationImportResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationImportResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationImportResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationImportResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationImportResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationImportResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public String getContentType() {
        return contentType;
    }

    public IntegrationImportResult setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public Long getTargetFolderId() {
        return targetFolderId;
    }

    public IntegrationImportResult setTargetFolderId(Long targetFolderId) {
        this.targetFolderId = targetFolderId;
        return this;
    }

    public ImportStats getStats() {
        return stats;
    }

    public IntegrationImportResult setStats(ImportStats stats) {
        this.stats = stats;
        return this;
    }

    public List<ImportIssue> getIssues() {
        return issues;
    }

    public IntegrationImportResult setIssues(List<ImportIssue> issues) {
        this.issues = issues;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationImportResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public List<ImportedItem> getImportedItems() {
        return importedItems;
    }

    public IntegrationImportResult setImportedItems(List<ImportedItem> importedItems) {
        this.importedItems = importedItems;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Options for exporting data to an external system")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationExportOptions {

    @ApiModelProperty(value = "Content type to export", example = "TEST_RESULT", allowableValues = "TEST_RESULT,TEST_EXECUTION,TEST_REPORT")
    private String contentType;

    @ApiModelProperty(value = "List of item IDs to export")
    private List<Long> itemIds = new ArrayList<>();

    @ApiModelProperty(value = "Folder ID containing items to export", example = "12345")
    private Long folderId;

    @ApiModelProperty(value = "Filters to apply during export")
    private Map<String, Object> filters = new HashMap<>();

    @ApiModelProperty(value = "Flag to only perform a dry run without making changes", example = "false")
    private boolean dryRun = false;

    @ApiModelProperty(value = "Maximum items to export", example = "100")
    private Integer maxItems;

    @ApiModelProperty(value = "Flag to include attachments in the export", example = "true")
    private boolean includeAttachments = true;

    @ApiModelProperty(value = "Flag to include screenshots in the export", example = "true")
    private boolean includeScreenshots = true;

    @ApiModelProperty(value = "Timestamp format for export", example = "yyyy-MM-dd HH:mm:ss")
    private String timestampFormat;

    @ApiModelProperty(value = "Additional options specific to the integration type")
    private Map<String, Object> additionalOptions = new HashMap<>();

    // Options specifically for Azure DevOps
    @ApiModelProperty(value = "Azure DevOps project to export to", example = "MyProject")
    private String adoProject;

    @ApiModelProperty(value = "Azure DevOps team to export to", example = "MyTeam")
    private String adoTeam;

    @ApiModelProperty(value = "Azure DevOps test plan ID to export to", example = "12345")
    private Long adoTestPlanId;

    @ApiModelProperty(value = "Azure DevOps test suite ID to export to", example = "67890")
    private Long adoTestSuiteId;

    @ApiModelProperty(value = "Azure DevOps area path to export to", example = "MyProject\\Area\\Path")
    private String adoAreaPath;

    @ApiModelProperty(value = "Azure DevOps test run title format", example = "Test Run - {date} - {suite}")
    private String adoTestRunTitleFormat;

    @ApiModelProperty(value = "Azure DevOps test run status to set", example = "Completed")
    private String adoTestRunStatus;

    @ApiModelProperty(value = "Flag to create new test runs in ADO", example = "true")
    private boolean adoCreateNewTestRun = true;

    @ApiModelProperty(value = "Flag to update existing test cases in ADO", example = "true")
    private boolean adoUpdateExistingTestCases = true;

    // Options specifically for Azure DevOps Git
    @ApiModelProperty(value = "Azure DevOps Git repository ID to export to", example = "MyRepository")
    private String adoGitRepositoryId;

    @ApiModelProperty(value = "Azure DevOps Git branch to export to", example = "main")
    private String adoGitBranch;

    @ApiModelProperty(value = "Base path for files to export to Git", example = "test-results/")
    private String adoGitBasePath;

    @ApiModelProperty(value = "Commit message format", example = "Test results export - {date}")
    private String adoGitCommitMessageFormat;

    @ApiModelProperty(value = "Azure DevOps Git file format", example = "HTML", allowableValues = "HTML,MARKDOWN,JSON,XML")
    private String adoGitFileFormat;

    @ApiModelProperty(value = "Flag to create new branch if it doesn't exist", example = "false")
    private boolean adoGitCreateBranch = false;

    // Export mapping fields
    @ApiModelProperty(value = "Field mappings for export")
    private List<FieldMapping> fieldMappings = new ArrayList<>();

    // Proxy settings that can be applied during export
    @ApiModelProperty(value = "Proxy settings to use during export")
    private IntegrationSyncOptions.ProxySettings proxySettings;

    // Nested class for field mappings
    @ApiModel(description = "Mapping between local field and external system field")
    public static class FieldMapping {
        
        @ApiModelProperty(value = "Source field in CS Test Forge", example = "testSteps")
        private String sourceField;
        
        @ApiModelProperty(value = "Target field in external system", example = "Microsoft.VSTS.TCM.Steps")
        private String targetField;
        
        @ApiModelProperty(value = "Transformation to apply during mapping", example = "CONVERT_MARKDOWN_TO_HTML")
        private String transformation;
        
        @ApiModelProperty(value = "Default value to use if source field is empty")
        private Object defaultValue;

        // Getters and Setters
        public String getSourceField() {
            return sourceField;
        }

        public FieldMapping setSourceField(String sourceField) {
            this.sourceField = sourceField;
            return this;
        }

        public String getTargetField() {
            return targetField;
        }

        public FieldMapping setTargetField(String targetField) {
            this.targetField = targetField;
            return this;
        }

        public String getTransformation() {
            return transformation;
        }

        public FieldMapping setTransformation(String transformation) {
            this.transformation = transformation;
            return this;
        }

        public Object getDefaultValue() {
            return defaultValue;
        }

        public FieldMapping setDefaultValue(Object defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }
    }

    // Getters and Setters
    public String getContentType() {
        return contentType;
    }

    public IntegrationExportOptions setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public List<Long> getItemIds() {
        return itemIds;
    }

    public IntegrationExportOptions setItemIds(List<Long> itemIds) {
        this.itemIds = itemIds;
        return this;
    }

    public Long getFolderId() {
        return folderId;
    }

    public IntegrationExportOptions setFolderId(Long folderId) {
        this.folderId = folderId;
        return this;
    }

    public Map<String, Object> getFilters() {
        return filters;
    }

    public IntegrationExportOptions setFilters(Map<String, Object> filters) {
        this.filters = filters;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationExportOptions setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public Integer getMaxItems() {
        return maxItems;
    }

    public IntegrationExportOptions setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    public boolean isIncludeAttachments() {
        return includeAttachments;
    }

    public IntegrationExportOptions setIncludeAttachments(boolean includeAttachments) {
        this.includeAttachments = includeAttachments;
        return this;
    }

    public boolean isIncludeScreenshots() {
        return includeScreenshots;
    }

    public IntegrationExportOptions setIncludeScreenshots(boolean includeScreenshots) {
        this.includeScreenshots = includeScreenshots;
        return this;
    }

    public String getTimestampFormat() {
        return timestampFormat;
    }

    public IntegrationExportOptions setTimestampFormat(String timestampFormat) {
        this.timestampFormat = timestampFormat;
        return this;
    }

    public Map<String, Object> getAdditionalOptions() {
        return additionalOptions;
    }

    public IntegrationExportOptions setAdditionalOptions(Map<String, Object> additionalOptions) {
        this.additionalOptions = additionalOptions;
        return this;
    }

    public String getAdoProject() {
        return adoProject;
    }

    public IntegrationExportOptions setAdoProject(String adoProject) {
        this.adoProject = adoProject;
        return this;
    }

    public String getAdoTeam() {
        return adoTeam;
    }

    public IntegrationExportOptions setAdoTeam(String adoTeam) {
        this.adoTeam = adoTeam;
        return this;
    }

    public Long getAdoTestPlanId() {
        return adoTestPlanId;
    }

    public IntegrationExportOptions setAdoTestPlanId(Long adoTestPlanId) {
        this.adoTestPlanId = adoTestPlanId;
        return this;
    }

    public Long getAdoTestSuiteId() {
        return adoTestSuiteId;
    }

    public IntegrationExportOptions setAdoTestSuiteId(Long adoTestSuiteId) {
        this.adoTestSuiteId = adoTestSuiteId;
        return this;
    }

    public String getAdoAreaPath() {
        return adoAreaPath;
    }

    public IntegrationExportOptions setAdoAreaPath(String adoAreaPath) {
        this.adoAreaPath = adoAreaPath;
        return this;
    }

    public String getAdoTestRunTitleFormat() {
        return adoTestRunTitleFormat;
    }

    public IntegrationExportOptions setAdoTestRunTitleFormat(String adoTestRunTitleFormat) {
        this.adoTestRunTitleFormat = adoTestRunTitleFormat;
        return this;
    }

    public String getAdoTestRunStatus() {
        return adoTestRunStatus;
    }

    public IntegrationExportOptions setAdoTestRunStatus(String adoTestRunStatus) {
        this.adoTestRunStatus = adoTestRunStatus;
        return this;
    }

    public boolean isAdoCreateNewTestRun() {
        return adoCreateNewTestRun;
    }

    public IntegrationExportOptions setAdoCreateNewTestRun(boolean adoCreateNewTestRun) {
        this.adoCreateNewTestRun = adoCreateNewTestRun;
        return this;
    }

    public boolean isAdoUpdateExistingTestCases() {
        return adoUpdateExistingTestCases;
    }

    public IntegrationExportOptions setAdoUpdateExistingTestCases(boolean adoUpdateExistingTestCases) {
        this.adoUpdateExistingTestCases = adoUpdateExistingTestCases;
        return this;
    }

    public String getAdoGitRepositoryId() {
        return adoGitRepositoryId;
    }

    public IntegrationExportOptions setAdoGitRepositoryId(String adoGitRepositoryId) {
        this.adoGitRepositoryId = adoGitRepositoryId;
        return this;
    }

    public String getAdoGitBranch() {
        return adoGitBranch;
    }

    public IntegrationExportOptions setAdoGitBranch(String adoGitBranch) {
        this.adoGitBranch = adoGitBranch;
        return this;
    }

    public String getAdoGitBasePath() {
        return adoGitBasePath;
    }

    public IntegrationExportOptions setAdoGitBasePath(String adoGitBasePath) {
        this.adoGitBasePath = adoGitBasePath;
        return this;
    }

    public String getAdoGitCommitMessageFormat() {
        return adoGitCommitMessageFormat;
    }

    public IntegrationExportOptions setAdoGitCommitMessageFormat(String adoGitCommitMessageFormat) {
        this.adoGitCommitMessageFormat = adoGitCommitMessageFormat;
        return this;
    }

    public String getAdoGitFileFormat() {
        return adoGitFileFormat;
    }

    public IntegrationExportOptions setAdoGitFileFormat(String adoGitFileFormat) {
        this.adoGitFileFormat = adoGitFileFormat;
        return this;
    }

    public boolean isAdoGitCreateBranch() {
        return adoGitCreateBranch;
    }

    public IntegrationExportOptions setAdoGitCreateBranch(boolean adoGitCreateBranch) {
        this.adoGitCreateBranch = adoGitCreateBranch;
        return this;
    }

    public List<FieldMapping> getFieldMappings() {
        return fieldMappings;
    }

    public IntegrationExportOptions setFieldMappings(List<FieldMapping> fieldMappings) {
        this.fieldMappings = fieldMappings;
        return this;
    }

    public IntegrationSyncOptions.ProxySettings getProxySettings() {
        return proxySettings;
    }

    public IntegrationExportOptions setProxySettings(IntegrationSyncOptions.ProxySettings proxySettings) {
        this.proxySettings = proxySettings;
        return this;
    }
}


package com.cstestforge.model.integration;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@ApiModel(description = "Result of exporting data to an external system")
@JsonInclude(JsonInclude.Include.NON_NULL)
public class IntegrationExportResult {

    @ApiModelProperty(value = "Integration ID", example = "1")
    private Long integrationId;

    @ApiModelProperty(value = "Flag indicating if the export was successful", example = "true")
    private boolean successful;

    @ApiModelProperty(value = "Status message", example = "Exported 15 test results successfully")
    private String message;

    @ApiModelProperty(value = "Error code if the export failed", example = "EXPORT_ERROR")
    private String errorCode;

    @ApiModelProperty(value = "Detailed error message if the export failed", example = "Failed to export test results: Network error")
    private String errorDetail;

    @ApiModelProperty(value = "Start timestamp of the export operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startedAt;

    @ApiModelProperty(value = "Completion timestamp of the export operation")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime completedAt;

    @ApiModelProperty(value = "Duration of the export operation in milliseconds", example = "3214")
    private Long durationMs;

    @ApiModelProperty(value = "Content type that was exported", example = "TEST_RESULT")
    private String contentType;

    @ApiModelProperty(value = "Export statistics")
    private ExportStats stats = new ExportStats();

    @ApiModelProperty(value = "List of issues encountered during export")
    private List<ExportIssue> issues = new ArrayList<>();

    @ApiModelProperty(value = "Flag indicating if this was a dry run", example = "false")
    private boolean dryRun;

    @ApiModelProperty(value = "Exported items details")
    private List<ExportedItem> exportedItems = new ArrayList<>();

    @ApiModelProperty(value = "URLs to exported resources in the external system")
    private Map<String, String> exportedUrls = new HashMap<>();

    // Specific to Azure DevOps
    @ApiModelProperty(value = "Azure DevOps test run ID created", example = "12345")
    private Long adoTestRunId;

    @ApiModelProperty(value = "Azure DevOps test run URL", example = "https://dev.azure.com/organization/project/_test/runs/12345")
    private String adoTestRunUrl;

    // Specific to Azure DevOps Git
    @ApiModelProperty(value = "Azure DevOps Git commit ID", example = "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0")
    private String adoGitCommitId;

    @ApiModelProperty(value = "Azure DevOps Git commit URL", example = "https://dev.azure.com/organization/project/_git/repository/commit/a1b2c3d4e5")
    private String adoGitCommitUrl;

    // Nested class for export statistics
    @ApiModel(description = "Statistics of the export operation")
    public static class ExportStats {
        
        @ApiModelProperty(value = "Total items selected for export", example = "20")
        private int totalSelected;
        
        @ApiModelProperty(value = "Total items processed during export", example = "18")
        private int totalProcessed;
        
        @ApiModelProperty(value = "New items created in the external system", example = "12")
        private int created;
        
        @ApiModelProperty(value = "Existing items updated in the external system", example = "6")
        private int updated;
        
        @ApiModelProperty(value = "Items skipped (filtered out or errors)", example = "2")
        private int skipped;
        
        @ApiModelProperty(value = "Items with errors", example = "0")
        private int errors;
        
        @ApiModelProperty(value = "Total attachments exported", example = "8")
        private int attachmentsExported;
        
        @ApiModelProperty(value = "Total screenshots exported", example = "15")
        private int screenshotsExported;
        
        @ApiModelProperty(value = "Additional statistics specific to content type")
        private Map<String, Object> additionalStats = new HashMap<>();

        // Getters and Setters
        public int getTotalSelected() {
            return totalSelected;
        }

        public ExportStats setTotalSelected(int totalSelected) {
            this.totalSelected = totalSelected;
            return this;
        }

        public int getTotalProcessed() {
            return totalProcessed;
        }

        public ExportStats setTotalProcessed(int totalProcessed) {
            this.totalProcessed = totalProcessed;
            return this;
        }

        public int getCreated() {
            return created;
        }

        public ExportStats setCreated(int created) {
            this.created = created;
            return this;
        }

        public int getUpdated() {
            return updated;
        }

        public ExportStats setUpdated(int updated) {
            this.updated = updated;
            return this;
        }

        public int getSkipped() {
            return skipped;
        }

        public ExportStats setSkipped(int skipped) {
            this.skipped = skipped;
            return this;
        }

        public int getErrors() {
            return errors;
        }

        public ExportStats setErrors(int errors) {
            this.errors = errors;
            return this;
        }

        public int getAttachmentsExported() {
            return attachmentsExported;
        }

        public ExportStats setAttachmentsExported(int attachmentsExported) {
            this.attachmentsExported = attachmentsExported;
            return this;
        }

        public int getScreenshotsExported() {
            return screenshotsExported;
        }

        public ExportStats setScreenshotsExported(int screenshotsExported) {
            this.screenshotsExported = screenshotsExported;
            return this;
        }

        public Map<String, Object> getAdditionalStats() {
            return additionalStats;
        }

        public ExportStats setAdditionalStats(Map<String, Object> additionalStats) {
            this.additionalStats = additionalStats;
            return this;
        }
    }

    // Nested class for export issues
    @ApiModel(description = "Issue encountered during export")
    public static class ExportIssue {
        
        @ApiModelProperty(value = "Issue severity", example = "ERROR", allowableValues = "INFO,WARNING,ERROR")
        private String severity;
        
        @ApiModelProperty(value = "Local item ID", example = "12345")
        private Long localItemId;
        
        @ApiModelProperty(value = "Issue message", example = "Failed to export test result: Invalid field value")
        private String message;
        
        @ApiModelProperty(value = "Issue code", example = "INVALID_FIELD")
        private String code;
        
        @ApiModelProperty(value = "Additional details about the issue")
        private Map<String, Object> details = new HashMap<>();

        // Getters and Setters
        public String getSeverity() {
            return severity;
        }

        public ExportIssue setSeverity(String severity) {
            this.severity = severity;
            return this;
        }

        public Long getLocalItemId() {
            return localItemId;
        }

        public ExportIssue setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getMessage() {
            return message;
        }

        public ExportIssue setMessage(String message) {
            this.message = message;
            return this;
        }

        public String getCode() {
            return code;
        }

        public ExportIssue setCode(String code) {
            this.code = code;
            return this;
        }

        public Map<String, Object> getDetails() {
            return details;
        }

        public ExportIssue setDetails(Map<String, Object> details) {
            this.details = details;
            return this;
        }
    }

    // Nested class for exported item details
    @ApiModel(description = "Details of an exported item")
    public static class ExportedItem {
        
        @ApiModelProperty(value = "Local item ID", example = "12345")
        private Long localItemId;
        
        @ApiModelProperty(value = "External item ID", example = "67890")
        private String externalItemId;
        
        @ApiModelProperty(value = "Item name or title", example = "Login Test Result")
        private String name;
        
        @ApiModelProperty(value = "Export action performed", example = "CREATED", allowableValues = "CREATED,UPDATED,SKIPPED,ERROR")
        private String action;
        
        @ApiModelProperty(value = "URL to the item in the external system", example = "https://dev.azure.com/organization/project/_test/runs/12345/results/67890")
        private String externalUrl;
        
        @ApiModelProperty(value = "Additional properties about the exported item")
        private Map<String, Object> properties = new HashMap<>();

        // Getters and Setters
        public Long getLocalItemId() {
            return localItemId;
        }

        public ExportedItem setLocalItemId(Long localItemId) {
            this.localItemId = localItemId;
            return this;
        }

        public String getExternalItemId() {
            return externalItemId;
        }

        public ExportedItem setExternalItemId(String externalItemId) {
            this.externalItemId = externalItemId;
            return this;
        }

        public String getName() {
            return name;
        }

        public ExportedItem setName(String name) {
            this.name = name;
            return this;
        }

        public String getAction() {
            return action;
        }

        public ExportedItem setAction(String action) {
            this.action = action;
            return this;
        }

        public String getExternalUrl() {
            return externalUrl;
        }

        public ExportedItem setExternalUrl(String externalUrl) {
            this.externalUrl = externalUrl;
            return this;
        }

        public Map<String, Object> getProperties() {
            return properties;
        }

        public ExportedItem setProperties(Map<String, Object> properties) {
            this.properties = properties;
            return this;
        }
    }

    // Getters and Setters
    public Long getIntegrationId() {
        return integrationId;
    }

    public IntegrationExportResult setIntegrationId(Long integrationId) {
        this.integrationId = integrationId;
        return this;
    }

    public boolean isSuccessful() {
        return successful;
    }

    public IntegrationExportResult setSuccessful(boolean successful) {
        this.successful = successful;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public IntegrationExportResult setMessage(String message) {
        this.message = message;
        return this;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public IntegrationExportResult setErrorCode(String errorCode) {
        this.errorCode = errorCode;
        return this;
    }

    public String getErrorDetail() {
        return errorDetail;
    }

    public IntegrationExportResult setErrorDetail(String errorDetail) {
        this.errorDetail = errorDetail;
        return this;
    }

    public LocalDateTime getStartedAt() {
        return startedAt;
    }

    public IntegrationExportResult setStartedAt(LocalDateTime startedAt) {
        this.startedAt = startedAt;
        return this;
    }

    public LocalDateTime getCompletedAt() {
        return completedAt;
    }

    public IntegrationExportResult setCompletedAt(LocalDateTime completedAt) {
        this.completedAt = completedAt;
        return this;
    }

    public Long getDurationMs() {
        return durationMs;
    }

    public IntegrationExportResult setDurationMs(Long durationMs) {
        this.durationMs = durationMs;
        return this;
    }

    public String getContentType() {
        return contentType;
    }

    public IntegrationExportResult setContentType(String contentType) {
        this.contentType = contentType;
        return this;
    }

    public ExportStats getStats() {
        return stats;
    }

    public IntegrationExportResult setStats(ExportStats stats) {
        this.stats = stats;
        return this;
    }

    public List<ExportIssue> getIssues() {
        return issues;
    }

    public IntegrationExportResult setIssues(List<ExportIssue> issues) {
        this.issues = issues;
        return this;
    }

    public boolean isDryRun() {
        return dryRun;
    }

    public IntegrationExportResult setDryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }

    public List<ExportedItem> getExportedItems() {
        return exportedItems;
    }

    public IntegrationExportResult setExportedItems(List<ExportedItem> exportedItems) {
        this.exportedItems = exportedItems;
        return this;
    }

    public Map<String, String> getExportedUrls() {
        return exportedUrls;
    }

    public IntegrationExportResult setExportedUrls(Map<String, String> exportedUrls) {
        this.exportedUrls = exportedUrls;
        return this;
    }

    public Long getAdoTestRunId() {
        return adoTestRunId;
    }

    public IntegrationExportResult setAdoTestRunId(Long adoTestRunId) {
        this.adoTestRunId = adoTestRunId;
        return this;
    }

    public String getAdoTestRunUrl() {
        return adoTestRunUrl;
    }

    public IntegrationExportResult setAdoTestRunUrl(String adoTestRunUrl) {
        this.adoTestRunUrl = adoTestRunUrl;
        return this;
    }

    public String getAdoGitCommitId() {
        return adoGitCommitId;
    }

    public IntegrationExportResult setAdoGitCommitId(String adoGitCommitId) {
        this.adoGitCommitId = adoGitCommitId;
        return this;
    }

    public String getAdoGitCommitUrl() {
        return adoGitCommitUrl;
    }

    public IntegrationExportResult setAdoGitCommitUrl(String adoGitCommitUrl) {
        this.adoGitCommitUrl = adoGitCommitUrl;
        return this;
    }
}



package com.cstestforge.service.integration;

import com.cstestforge.model.integration.*;

import java.util.List;

/**
 * Service interface for handling external system integrations
 */
public interface IntegrationService {

    /**
     * Get all integrations for a project
     * 
     * @param projectId The project ID
     * @return List of integrations
     */
    List<Integration> getAllIntegrations(String projectId);

    /**
     * Get an integration by ID
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return The integration
     */
    Integration getIntegrationById(String projectId, String integrationId);

    /**
     * Create a new integration
     * 
     * @param projectId The project ID
     * @param integration The integration to create
     * @return The created integration
     */
    Integration createIntegration(String projectId, Integration integration);

    /**
     * Update an existing integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param integrationDetails The updated integration details
     * @return The updated integration
     */
    Integration updateIntegration(String projectId, String integrationId, Integration integrationDetails);

    /**
     * Delete an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return True if the integration was deleted successfully
     */
    boolean deleteIntegration(String projectId, String integrationId);

    /**
     * Test connection to an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Result of the connection test
     */
    IntegrationTestResult testIntegrationConnection(String projectId, String integrationId);

    /**
     * Synchronize with an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param syncOptions Synchronization options
     * @return Result of the synchronization
     */
    IntegrationSyncResult syncWithIntegration(String projectId, String integrationId, IntegrationSyncOptions syncOptions);

    /**
     * Get available integration types
     * 
     * @return List of available integration types
     */
    List<IntegrationType> getAvailableIntegrationTypes();

    /**
     * Get settings schema for an integration type
     * 
     * @param type The integration type
     * @return Settings schema for the integration type
     */
    IntegrationSettingsSchema getSettingsSchemaForType(String type);

    /**
     * Import test cases from an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param importOptions Import options
     * @return Result of the import
     */
    IntegrationImportResult importFromIntegration(String projectId, String integrationId, IntegrationImportOptions importOptions);

    /**
     * Export test results to an integration
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @param exportOptions Export options
     * @return Result of the export
     */
    IntegrationExportResult exportToIntegration(String projectId, String integrationId, IntegrationExportOptions exportOptions);
}


package com.cstestforge.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Exception thrown when a requested resource is not found
 */
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    
    private String resourceName;
    private String fieldName;
    private Object fieldValue;

    /**
     * Constructor with resource details
     * 
     * @param resourceName Name of the resource
     * @param fieldName Name of the field
     * @param fieldValue Value of the field
     */
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s: '%s'", resourceName, fieldName, fieldValue));
        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }

    /**
     * Constructor with message
     * 
     * @param message Error message
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructor with message and cause
     * 
     * @param message Error message
     * @param cause The cause
     */
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    /**
     * Get resource name
     * 
     * @return Resource name
     */
    public String getResourceName() {
        return resourceName;
    }

    /**
     * Get field name
     * 
     * @return Field name
     */
    public String getFieldName() {
        return fieldName;
    }

    /**
     * Get field value
     * 
     * @return Field value
     */
    public Object getFieldValue() {
        return fieldValue;
    }
}


package com.cstestforge.repository.integration;

import com.cstestforge.model.integration.Integration;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for integration data
 */
public interface IntegrationRepository {

    /**
     * Find all integrations for a project
     * 
     * @param projectId The project ID
     * @return List of integrations
     */
    List<Integration> findAllByProjectId(String projectId);

    /**
     * Find an integration by ID and project ID
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return The integration, if found
     */
    Optional<Integration> findByIdAndProjectId(String integrationId, String projectId);

    /**
     * Save an integration
     * 
     * @param integration The integration to save
     * @return The saved integration
     */
    Integration save(Integration integration);

    /**
     * Delete an integration
     * 
     * @param integration The integration to delete
     * @return True if the integration was deleted successfully
     */
    boolean delete(Integration integration);

    /**
     * Check if an integration exists
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return True if the integration exists
     */
    boolean existsByIdAndProjectId(String integrationId, String projectId);
}

package com.cstestforge.repository.integration;

import com.cstestforge.exception.StorageException;
import com.cstestforge.model.integration.Integration;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * File system implementation of IntegrationRepository
 */
@Repository
public class FileSystemIntegrationRepository implements IntegrationRepository {

    private static final Logger logger = LoggerFactory.getLogger(FileSystemIntegrationRepository.class);
    
    private final ObjectMapper objectMapper;
    private final String dataDirectory;
    
    /**
     * Constructor
     * 
     * @param objectMapper JSON object mapper
     * @param dataDirectory Base directory for storing data
     */
    public FileSystemIntegrationRepository(
            ObjectMapper objectMapper,
            @Value("${app.data.directory:./data}") String dataDirectory) {
        this.objectMapper = objectMapper;
        this.dataDirectory = dataDirectory;
        
        // Ensure data directory exists
        createDirectoryIfNotExists(Paths.get(dataDirectory));
    }

    @Override
    public List<Integration> findAllByProjectId(String projectId) {
        logger.debug("Finding all integrations for project: {}", projectId);
        
        Path projectIntegrationsDir = getProjectIntegrationsDirectory(projectId);
        if (!Files.exists(projectIntegrationsDir)) {
            return new ArrayList<>();
        }
        
        try (Stream<Path> paths = Files.list(projectIntegrationsDir)) {
            return paths
                .filter(path -> path.toString().endsWith(".json"))
                .map(this::readIntegrationFromFile)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
        } catch (IOException e) {
            logger.error("Error reading integrations for project: {}", projectId, e);
            throw new StorageException("Error reading integrations", e);
        }
    }

    @Override
    public Optional<Integration> findByIdAndProjectId(String integrationId, String projectId) {
        logger.debug("Finding integration: {} for project: {}", integrationId, projectId);
        
        Path integrationFile = getIntegrationFilePath(projectId, integrationId);
        if (!Files.exists(integrationFile)) {
            return Optional.empty();
        }
        
        return readIntegrationFromFile(integrationFile);
    }

    @Override
    public Integration save(Integration integration) {
        logger.debug("Saving integration: {}", integration.getId());
        
        // Ensure project directory exists
        Path projectDir = getProjectIntegrationsDirectory(integration.getProjectId().toString());
        createDirectoryIfNotExists(projectDir);
        
        // Generate ID if not provided
        if (integration.getId() == null) {
            integration.setId(generateId());
        }
        
        // Set timestamps
        LocalDateTime now = LocalDateTime.now();
        if (integration.getCreatedAt() == null) {
            integration.setCreatedAt(now);
        }
        integration.setUpdatedAt(now);
        
        // Write to file
        Path integrationFile = getIntegrationFilePath(
                integration.getProjectId().toString(), 
                integration.getId().toString());
        
        try {
            objectMapper.writeValue(integrationFile.toFile(), integration);
            logger.debug("Successfully saved integration: {}", integration.getId());
            return integration;
        } catch (IOException e) {
            logger.error("Error saving integration: {}", integration.getId(), e);
            throw new StorageException("Error saving integration", e);
        }
    }

    @Override
    public boolean delete(Integration integration) {
        logger.debug("Deleting integration: {}", integration.getId());
        
        Path integrationFile = getIntegrationFilePath(
                integration.getProjectId().toString(),
                integration.getId().toString());
        
        try {
            return Files.deleteIfExists(integrationFile);
        } catch (IOException e) {
            logger.error("Error deleting integration: {}", integration.getId(), e);
            throw new StorageException("Error deleting integration", e);
        }
    }

    @Override
    public boolean existsByIdAndProjectId(String integrationId, String projectId) {
        Path integrationFile = getIntegrationFilePath(projectId, integrationId);
        return Files.exists(integrationFile);
    }

    /**
     * Read integration from JSON file
     * 
     * @param filePath Path to the integration file
     * @return The integration, if successfully read
     */
    private Optional<Integration> readIntegrationFromFile(Path filePath) {
        try {
            Integration integration = objectMapper.readValue(filePath.toFile(), Integration.class);
            return Optional.of(integration);
        } catch (IOException e) {
            logger.error("Error reading integration file: {}", filePath, e);
            return Optional.empty();
        }
    }

    /**
     * Get the project integrations directory
     * 
     * @param projectId The project ID
     * @return Path to the project integrations directory
     */
    private Path getProjectIntegrationsDirectory(String projectId) {
        return Paths.get(dataDirectory, "projects", projectId, "integrations");
    }

    /**
     * Get the path to an integration file
     * 
     * @param projectId The project ID
     * @param integrationId The integration ID
     * @return Path to the integration file
     */
    private Path getIntegrationFilePath(String projectId, String integrationId) {
        return getProjectIntegrationsDirectory(projectId)
                .resolve(integrationId + ".json");
    }

    /**
     * Create a directory if it doesn't exist
     * 
     * @param directory Path to the directory
     */
    private void createDirectoryIfNotExists(Path directory) {
        if (!Files.exists(directory)) {
            try {
                Files.createDirectories(directory);
                logger.debug("Created directory: {}", directory);
            } catch (IOException e) {
                logger.error("Error creating directory: {}", directory, e);
                throw new StorageException("Error creating directory", e);
            }
        }
    }

    /**
     * Generate a unique ID
     * 
     * @return A unique ID
     */
    private Long generateId() {
        return System.currentTimeMillis();
    }
}


package com.cstestforge.exception;

/**
 * Exception thrown when storage operations fail
 */
public class StorageException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /**
     * Constructor with message
     * 
     * @param message Error message
     */
    public StorageException(String message) {
        super(message);
    }

    /**
     * Constructor with message and cause
     * 
     * @param message Error message
     * @param cause The cause
     */
    public StorageException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.cstestforge.util.http;

import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;

import java.net.URI;

/**
 * HTTP PATCH method implementation
 * 
 * Apache HttpClient does not provide a built-in implementation of the PATCH method,
 * so we need to create our own class to support PATCH requests to Azure DevOps API.
 */
public class HttpPatch extends HttpEntityEnclosingRequestBase {

    /**
     * The HTTP PATCH method name
     */
    public static final String METHOD_NAME = "PATCH";

    /**
     * Default constructor
     */
    public HttpPatch() {
        super();
    }

    /**
     * Constructor with URI
     * 
     * @param uri The target URI
     */
    public HttpPatch(final URI uri) {
        super();
        setURI(uri);
    }

    /**
     * Constructor with URI string
     * 
     * @param uri The target URI string
     */
    public HttpPatch(final String uri) {
        super();
        setURI(URI.create(uri));
    }

    @Override
    public String getMethod() {
        return METHOD_NAME;
    }
}

package com.cstestforge.config;

import com.cstestforge.model.integration.IntegrationSyncOptions;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.util.StringUtils;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Configuration for HTTP proxy
 */
@Configuration
public class ProxyConfig {

    private static final Logger logger = LoggerFactory.getLogger(ProxyConfig.class);
    
    @Value("${http.proxy.host:#{null}}")
    private String proxyHost;
    
    @Value("${http.proxy.port:0}")
    private int proxyPort;
    
    @Value("${http.proxy.username:#{null}}")
    private String proxyUsername;
    
    @Value("${http.proxy.password:#{null}}")
    private String proxyPassword;
    
    @Value("${http.proxy.nonProxyHosts:localhost|127.0.0.1}")
    private String nonProxyHosts;
    
    @Value("${http.connection.timeout:30000}")
    private int connectionTimeout;
    
    @Value("${http.socket.timeout:30000}")
    private int socketTimeout;
    
    @Value("${http.connection.request.timeout:30000}")
    private int connectionRequestTimeout;

    /**
     * Create a DefaultHttpClient with proxy settings from application properties
     * 
     * @return HttpClient with proxy settings
     */
    @Bean
    public CloseableHttpClient httpClient() {
        HttpClientBuilder clientBuilder = HttpClients.custom();
        
        // Set timeouts
        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                .setConnectTimeout(connectionTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout);
        
        // Configure proxy if set
        if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            logger.info("Configuring HTTP client with proxy: {}:{}", proxyHost, proxyPort);
            
            HttpHost proxy = new HttpHost(proxyHost, proxyPort);
            requestConfigBuilder.setProxy(proxy);
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxyUsername) && StringUtils.hasText(proxyPassword)) {
                logger.info("Configuring proxy authentication for user: {}", proxyUsername);
                
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxyHost, proxyPort),
                        new UsernamePasswordCredentials(proxyUsername, proxyPassword));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
        return clientBuilder.build();
    }
    
    /**
     * Apply proxy settings from application.properties to the HttpClientBuilder
     * 
     * @param clientBuilder The HttpClientBuilder to configure
     * @return The configured HttpClientBuilder
     */
    public HttpClientBuilder applyDefaultProxySettings(HttpClientBuilder clientBuilder) {
        // Configure proxy if set
        if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            logger.debug("Applying default proxy settings: {}:{}", proxyHost, proxyPort);
            
            HttpHost proxy = new HttpHost(proxyHost, proxyPort);
            
            // Set request config with proxy
            RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                    .setConnectTimeout(connectionTimeout)
                    .setSocketTimeout(socketTimeout)
                    .setConnectionRequestTimeout(connectionRequestTimeout)
                    .setProxy(proxy);
            
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxyUsername) && StringUtils.hasText(proxyPassword)) {
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxyHost, proxyPort),
                        new UsernamePasswordCredentials(proxyUsername, proxyPassword));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        return clientBuilder;
    }
    
    /**
     * Apply custom proxy settings to the HttpClientBuilder
     * 
     * @param clientBuilder The HttpClientBuilder to configure
     * @param proxySettings The proxy settings to apply
     * @return The configured HttpClientBuilder
     */
    public HttpClientBuilder applyCustomProxySettings(
            HttpClientBuilder clientBuilder, 
            IntegrationSyncOptions.ProxySettings proxySettings) {
        
        if (proxySettings != null && StringUtils.hasText(proxySettings.getHost()) 
                && proxySettings.getPort() != null && proxySettings.getPort() > 0) {
            
            logger.debug("Applying custom proxy settings: {}:{}", 
                    proxySettings.getHost(), proxySettings.getPort());
            
            HttpHost proxy = new HttpHost(proxySettings.getHost(), proxySettings.getPort());
            
            // Set request config with proxy
            RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                    .setConnectTimeout(connectionTimeout)
                    .setSocketTimeout(socketTimeout)
                    .setConnectionRequestTimeout(connectionRequestTimeout)
                    .setProxy(proxy);
            
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
            
            // Add proxy authentication if set
            if (StringUtils.hasText(proxySettings.getUsername()) 
                    && StringUtils.hasText(proxySettings.getPassword())) {
                
                CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                credentialsProvider.setCredentials(
                        new AuthScope(proxySettings.getHost(), proxySettings.getPort()),
                        new UsernamePasswordCredentials(
                                proxySettings.getUsername(), 
                                proxySettings.getPassword()));
                
                clientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }
        }
        
        return clientBuilder;
    }
    
    /**
     * Get the list of non-proxy hosts
     * 
     * @return List of non-proxy hosts
     */
    public List<String> getNonProxyHosts() {
        if (StringUtils.hasText(nonProxyHosts)) {
            return Arrays.stream(nonProxyHosts.split("\\|"))
                    .filter(StringUtils::hasText)
                    .collect(Collectors.toList());
        }
        return List.of("localhost", "127.0.0.1");
    }
    
    /**
     * Check if a host should bypass the proxy
     * 
     * @param host The host to check
     * @return True if the host should bypass the proxy
     */
    public boolean shouldBypassProxy(String host) {
        if (!StringUtils.hasText(host)) {
            return false;
        }
        
        List<String> bypassHosts = getNonProxyHosts();
        for (String bypassHost : bypassHosts) {
            if (bypassHost.startsWith("*") && host.endsWith(bypassHost.substring(1))) {
                return true;
            } else if (bypassHost.endsWith("*") && host.startsWith(bypassHost.substring(0, bypassHost.length() - 1))) {
                return true;
            } else if (host.equals(bypassHost)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Create a HttpClient with custom proxy settings
     * 
     * @param proxySettings Custom proxy settings
     * @return HttpClient with custom proxy settings
     */
    public CloseableHttpClient createHttpClient(IntegrationSyncOptions.ProxySettings proxySettings) {
        HttpClientBuilder clientBuilder = HttpClients.custom();
        
        // Set timeouts
        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()
                .setConnectTimeout(connectionTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout);
        
        // Apply custom proxy settings if provided, otherwise use default
        if (proxySettings != null && StringUtils.hasText(proxySettings.getHost()) 
                && proxySettings.getPort() != null && proxySettings.getPort() > 0) {
            
            applyCustomProxySettings(clientBuilder, proxySettings);
        } else if (StringUtils.hasText(proxyHost) && proxyPort > 0) {
            applyDefaultProxySettings(clientBuilder);
        } else {
            clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());
        }
        
        return clientBuilder.build();
    }
}

package com.cstestforge.service.integration;

import com.cstestforge.config.ProxyConfig;
import com.cstestforge.exception.ResourceNotFoundException;
import com.cstestforge.model.integration.*;
import com.cstestforge.repository.integration.IntegrationRepository;
import com.cstestforge.util.http.HttpPatch;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.*;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;
import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Implementation of IntegrationService for Azure DevOps and ADO Git
 */
@Service
public class IntegrationServiceImpl implements IntegrationService {

    private static final Logger logger = LoggerFactory.getLogger(IntegrationServiceImpl.class);
    
    private static final String TYPE_AZURE_DEVOPS = "azure-devops";
    private static final String TYPE_AZURE_DEVOPS_GIT = "azure-devops-git";
    
    private static final String ADO_API_VERSION = "7.1";
    private static final String ADO_API_VERSION_PREVIEW = "7.1-preview.1";
    
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'");
    
    @Value("${app.data.directory:./data}")
    private String dataDirectory;
    
    @Value("${app.integrations.schemas.directory:./config/integration-schemas}")
    private String schemasDirectory;
    
    @Autowired
    private IntegrationRepository integrationRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private ProxyConfig proxyConfig;
    
    private Map<String, IntegrationSettingsSchema> settingsSchemas = new HashMap<>();
    
    @PostConstruct
    public void init() {
        // Load settings schemas
        loadSettingsSchemas();
    }

    @Override
    public List<Integration> getAllIntegrations(String projectId) {
        logger.info("Getting all integrations for project: {}", projectId);
        
        return integrationRepository.findAllByProjectId(projectId);
    }

    @Override
    public Integration getIntegrationById(String projectId, String integrationId) {
        logger.info("Getting integration: {} for project: {}", integrationId, projectId);
        
        return integrationRepository.findByIdAndProjectId(integrationId, projectId)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "Integration", "id", integrationId));
    }

    @Override
    public Integration createIntegration(String projectId, Integration integration) {
        logger.info("Creating integration for project: {}", projectId);
        
        validateIntegrationType(integration.getType());
        
        // Set project ID
        integration.setProjectId(Long.parseLong(projectId));
        integration.setStatus("Not Connected");
        integration.setCreatedAt(LocalDateTime.now());
        integration.setEnabled(true);
        
        return integrationRepository.save(integration);
    }

    @Override
    public Integration updateIntegration(String projectId, String integrationId, Integration integrationDetails) {
        logger.info("Updating integration: {} for project: {}", integrationId, projectId);
        
        Integration existingIntegration = getIntegrationById(projectId, integrationId);
        
        // Validate integration type if changed
        if (!existingIntegration.getType().equals(integrationDetails.getType())) {
            validateIntegrationType(integrationDetails.getType());
        }
        
        // Update fields
        existingIntegration.setName(integrationDetails.getName());
        existingIntegration.setDescription(integrationDetails.getDescription());
        existingIntegration.setType(integrationDetails.getType());
        existingIntegration.setSettings(integrationDetails.getSettings());
        existingIntegration.setEnabled(integrationDetails.isEnabled());
        existingIntegration.setUpdatedAt(LocalDateTime.now());
        
        return integrationRepository.save(existingIntegration);
    }

    @Override
    public boolean deleteIntegration(String projectId, String integrationId) {
        logger.info("Deleting integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        
        return integrationRepository.delete(integration);
    }

    @Override
    public IntegrationTestResult testIntegrationConnection(String projectId, String integrationId) {
        logger.info("Testing connection for integration: {} in project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationTestResult result = new IntegrationTestResult();
        result.setIntegrationId(integration.getId());
        result.setTestedAt(LocalDateTime.now());
        
        long startTime = System.currentTimeMillis();
        
        // Add test steps based on integration type
        List<IntegrationTestResult.TestStep> testSteps = new ArrayList<>();
        boolean isSuccessful = false;
        
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                isSuccessful = testAzureDevOpsConnection(integration, testSteps, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                isSuccessful = testAzureDevOpsGitConnection(integration, testSteps, result);
            } else {
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
                isSuccessful = false;
            }
        } catch (Exception e) {
            logger.error("Error testing connection", e);
            result.setMessage("Connection test failed: " + e.getMessage());
            result.setErrorCode("CONNECTION_ERROR");
            result.setErrorDetail(e.getMessage());
            isSuccessful = false;
        }
        
        // Set test result
        result.setSuccessful(isSuccessful);
        if (isSuccessful) {
            if (result.getMessage() == null) {
                result.setMessage("Connection test successful");
            }
            
            // Update integration status
            integration.setStatus("Connected");
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        } else {
            if (result.getMessage() == null) {
                result.setMessage("Connection test failed");
            }
            
            // Update integration status
            integration.setStatus("Connection Failed");
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        }
        
        // Set test steps and response time
        result.setTestSteps(testSteps);
        result.setResponseTimeMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Test connection to Azure DevOps
     * 
     * @param integration The integration to test
     * @param testSteps List to add test steps to
     * @param result The test result to update
     * @return True if the connection was successful
     */
    private boolean testAzureDevOpsConnection(
            Integration integration, 
            List<IntegrationTestResult.TestStep> testSteps,
            IntegrationTestResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Validate required settings
        if (!StringUtils.hasText(organization)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps organization is required");
            result.setErrorCode("MISSING_ORGANIZATION");
            return false;
        }
        
        if (!StringUtils.hasText(project)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps project is required");
            result.setErrorCode("MISSING_PROJECT");
            return false;
        }
        
        if (!StringUtils.hasText(pat)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps Personal Access Token (PAT) is required");
            result.setErrorCode("MISSING_PAT");
            return false;
        }
        
        // Step 1: Authenticate with Azure DevOps
        IntegrationTestResult.TestStep authStep = new IntegrationTestResult.TestStep()
                .setName("Authenticate")
                .setDescription("Authenticating with Azure DevOps using PAT");
        
        long authStartTime = System.currentTimeMillis();
        
        try {
            // Use project API as authentication test
            String projectApiUrl = String.format("https://dev.azure.com/%s/_apis/projects/%s", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(projectApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        authStep.setSuccessful(true)
                                .setMessage("Authentication successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        authStep.setSuccessful(false)
                                .setMessage("Authentication failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("AUTH_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Authentication error", e);
            authStep.setSuccessful(false)
                    .setMessage("Authentication failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("AUTH_ERROR");
        }
        
        authStep.setExecutionTimeMs(System.currentTimeMillis() - authStartTime);
        testSteps.add(authStep);
        
        if (!authStep.isSuccessful()) {
            return false;
        }
        
        // Step 2: Test access to Test Plans API
        IntegrationTestResult.TestStep testPlansStep = new IntegrationTestResult.TestStep()
                .setName("Test Plans API")
                .setDescription("Testing access to Azure DevOps Test Plans API");
        
        long testPlansStartTime = System.currentTimeMillis();
        
        try {
            String testPlansApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/plans", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlansApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Add test plan count to connection details
                        List<Map<String, Object>> plans = (List<Map<String, Object>>) responseMap.get("value");
                        result.getConnectionDetails().put("testPlanCount", plans != null ? plans.size() : 0);
                        
                        testPlansStep.setSuccessful(true)
                                .setMessage("Test Plans API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        testPlansStep.setSuccessful(false)
                                .setMessage("Test Plans API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("TEST_PLANS_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Test Plans API error", e);
            testPlansStep.setSuccessful(false)
                    .setMessage("Test Plans API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("TEST_PLANS_API_ERROR");
        }
        
        testPlansStep.setExecutionTimeMs(System.currentTimeMillis() - testPlansStartTime);
        testSteps.add(testPlansStep);
        
        if (!testPlansStep.isSuccessful()) {
            return false;
        }
        
        // Step 3: Test access to Work Items API
        IntegrationTestResult.TestStep workItemsStep = new IntegrationTestResult.TestStep()
                .setName("Work Items API")
                .setDescription("Testing access to Azure DevOps Work Items API");
        
        long workItemsStartTime = System.currentTimeMillis();
        
        try {
            String workItemsApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/wit/workitems?$top=1&workItemType=Test Case", 
                    organization, project);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(workItemsApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        workItemsStep.setSuccessful(true)
                                .setMessage("Work Items API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        workItemsStep.setSuccessful(false)
                                .setMessage("Work Items API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("WORK_ITEMS_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Work Items API error", e);
            workItemsStep.setSuccessful(false)
                    .setMessage("Work Items API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("WORK_ITEMS_API_ERROR");
        }
        
        workItemsStep.setExecutionTimeMs(System.currentTimeMillis() - workItemsStartTime);
        testSteps.add(workItemsStep);
        
        return workItemsStep.isSuccessful();
    }
    
    /**
     * Test connection to Azure DevOps Git
     * 
     * @param integration The integration to test
     * @param testSteps List to add test steps to
     * @param result The test result to update
     * @return True if the connection was successful
     */
    private boolean testAzureDevOpsGitConnection(
            Integration integration, 
            List<IntegrationTestResult.TestStep> testSteps,
            IntegrationTestResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Validate required settings
        if (!StringUtils.hasText(organization)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps organization is required");
            result.setErrorCode("MISSING_ORGANIZATION");
            return false;
        }
        
        if (!StringUtils.hasText(project)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps project is required");
            result.setErrorCode("MISSING_PROJECT");
            return false;
        }
        
        if (!StringUtils.hasText(repositoryId)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps repository ID is required");
            result.setErrorCode("MISSING_REPOSITORY_ID");
            return false;
        }
        
        if (!StringUtils.hasText(pat)) {
            addFailedTestStep(testSteps, "Validate Settings", 
                    "Azure DevOps Personal Access Token (PAT) is required");
            result.setErrorCode("MISSING_PAT");
            return false;
        }
        
        // Step 1: Authenticate with Azure DevOps
        IntegrationTestResult.TestStep authStep = new IntegrationTestResult.TestStep()
                .setName("Authenticate")
                .setDescription("Authenticating with Azure DevOps using PAT");
        
        long authStartTime = System.currentTimeMillis();
        
        try {
            // Use repository API as authentication test
            String repoApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s", 
                    organization, project, repositoryId);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(repoApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Store repository name in connection details
                        result.getConnectionDetails().put("repositoryName", responseMap.get("name"));
                        
                        authStep.setSuccessful(true)
                                .setMessage("Authentication successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        authStep.setSuccessful(false)
                                .setMessage("Authentication failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("AUTH_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Authentication error", e);
            authStep.setSuccessful(false)
                    .setMessage("Authentication failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("AUTH_ERROR");
        }
        
        authStep.setExecutionTimeMs(System.currentTimeMillis() - authStartTime);
        testSteps.add(authStep);
        
        if (!authStep.isSuccessful()) {
            return false;
        }
        
        // Step 2: Test access to Branches API
        IntegrationTestResult.TestStep branchesStep = new IntegrationTestResult.TestStep()
                .setName("Branches API")
                .setDescription("Testing access to Azure DevOps Git Branches API");
        
        long branchesStartTime = System.currentTimeMillis();
        
        try {
            String branchesApiUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/", 
                    organization, project, repositoryId);
            
            try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration)) {
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchesApiUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(
                                responseBody, Map.class);
                        
                        // Store branch count in connection details
                        List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                        result.getConnectionDetails().put("branchCount", branches != null ? branches.size() : 0);
                        
                        // Store default branch if found
                        if (branches != null && !branches.isEmpty()) {
                            for (Map<String, Object> branch : branches) {
                                String name = (String) branch.get("name");
                                if (name != null && (name.endsWith("/main") || name.endsWith("/master"))) {
                                    result.getConnectionDetails().put("defaultBranch", 
                                            name.substring(name.lastIndexOf('/') + 1));
                                    break;
                                }
                            }
                        }
                        
                        branchesStep.setSuccessful(true)
                                .setMessage("Branches API access successful");
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        branchesStep.setSuccessful(false)
                                .setMessage("Branches API access failed: Status code " + statusCode);
                        result.setErrorDetail("API response: " + responseBody);
                        result.setErrorCode("BRANCHES_API_ERROR");
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Branches API error", e);
            branchesStep.setSuccessful(false)
                    .setMessage("Branches API access failed: " + e.getMessage());
            result.setErrorDetail(e.getMessage());
            result.setErrorCode("BRANCHES_API_ERROR");
        }
        
        branchesStep.setExecutionTimeMs(System.currentTimeMillis() - branchesStartTime);
        testSteps.add(branchesStep);
        
        return branchesStep.isSuccessful();
    }
    
    /**
     * Add a failed test step to the list
     * 
     * @param testSteps List to add test step to
     * @param name Step name
     * @param message Error message
     */
    private void addFailedTestStep(List<IntegrationTestResult.TestStep> testSteps, String name, String message) {
        testSteps.add(new IntegrationTestResult.TestStep()
                .setName(name)
                .setDescription(message)
                .setSuccessful(false)
                .setMessage(message)
                .setExecutionTimeMs(0L));
    }
    
    @Override
    public IntegrationSyncResult syncWithIntegration(
            String projectId, String integrationId, IntegrationSyncOptions syncOptions) {
        
        logger.info("Syncing with integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationSyncResult result = new IntegrationSyncResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDirection(syncOptions != null ? syncOptions.getDirection() : "PULL");
        result.setDryRun(syncOptions != null && syncOptions.isDryRun());
        
        long startTime = System.currentTimeMillis();
        
        // Perform sync based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                syncWithAzureDevOps(integration, syncOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                syncWithAzureDevOpsGit(integration, syncOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during sync", e);
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        // Update integration last sync time
        if (result.isSuccessful() && !result.isDryRun()) {
            integration.setLastSyncAt(LocalDateTime.now());
            integration.setUpdatedAt(LocalDateTime.now());
            integrationRepository.save(integration);
        }
        
        return result;
    }
    
    /**
     * Synchronize with Azure DevOps
     * 
     * @param integration The integration to sync with
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void syncWithAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Prepare sync options if null
        if (syncOptions == null) {
            syncOptions = new IntegrationSyncOptions();
        }
        
        // Default content types if not specified
        if (syncOptions.getContentTypes() == null || syncOptions.getContentTypes().isEmpty()) {
            syncOptions.setContentTypes(Arrays.asList("TEST_CASE", "TEST_SUITE", "TEST_PLAN"));
        }
        
        // Determine sync direction
        String direction = syncOptions.getDirection();
        if (direction == null) {
            direction = "PULL";
        }
        
        // Initialize stats for each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = new IntegrationSyncResult.SyncStats()
                    .setContentType(contentType)
                    .setTotalProcessed(0)
                    .setCreated(0)
                    .setUpdated(0)
                    .setDeleted(0)
                    .setSkipped(0)
                    .setErrors(0)
                    .setConflicts(0);
            
            result.getStats().put(contentType, stats);
        }
        
        // Implement sync based on direction
        try {
            if ("PULL".equals(direction)) {
                // Pull data from Azure DevOps to CS Test Forge
                pullFromAzureDevOps(integration, syncOptions, result);
            } else if ("PUSH".equals(direction)) {
                // Push data from CS Test Forge to Azure DevOps
                pushToAzureDevOps(integration, syncOptions, result);
            } else if ("BIDIRECTIONAL".equals(direction)) {
                // Pull first, then push
                pullFromAzureDevOps(integration, syncOptions, result);
                pushToAzureDevOps(integration, syncOptions, result);
            } else {
                throw new IllegalArgumentException("Invalid sync direction: " + direction);
            }
            
            // Set success message
            result.setSuccessful(true);
            if (result.isDryRun()) {
                result.setMessage("Sync dry run completed successfully");
            } else {
                result.setMessage("Sync completed successfully");
            }
        } catch (Exception e) {
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
            
            // Add error to each content type
            for (IntegrationSyncResult.SyncStats stats : result.getStats().values()) {
                stats.setErrors(stats.getErrors() + 1);
            }
        }
    }
    
    /**
     * Pull data from Azure DevOps to CS Test Forge
     * 
     * @param integration The integration to pull from
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void pullFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_PLAN":
                    pullTestPlansFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_SUITE":
                    pullTestSuitesFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                case "TEST_CASE":
                    pullTestCasesFromAzureDevOps(integration, syncOptions, stats, result);
                    break;
                default:
                    logger.warn("Unsupported content type for pull: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for pull: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Pull test plans from Azure DevOps
     * 
     * @param integration The integration to pull from
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     */
    private void pullTestPlansFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get specific test plan ID if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            if (testPlanId != null) {
                // Get specific test plan
                String testPlanUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d", 
                        organization, project, testPlanId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlanUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> testPlan = objectMapper.readValue(responseBody, Map.class);
                        
                        // Process test plan
                        processTestPlan(integration, syncOptions, stats, result, testPlan);
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test plan " + testPlanId + ": Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            } else {
                // Get all test plans
                String testPlansUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans", 
                        organization, project);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testPlansUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testPlans = (List<Map<String, Object>>) responseMap.get("value");
                        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                        
                        // Process test plans (limited by maxItems)
                        int processed = 0;
                        for (Map<String, Object> testPlan : testPlans) {
                            if (processed >= maxItems) {
                                break;
                            }
                            
                            processTestPlan(integration, syncOptions, stats, result, testPlan);
                            processed++;
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test plans: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            }
        }
    }
    
    /**
     * Process a test plan from Azure DevOps
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param testPlan The test plan data
     */
    private void processTestPlan(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Map<String, Object> testPlan) {
        
        // Extract test plan details
        Number id = (Number) testPlan.get("id");
        String name = (String) testPlan.get("name");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        // Create or update test plan in CS Test Forge
        try {
            // In a real implementation, this would interact with your test plan repository
            // For now, we'll just log the action and update stats
            logger.info("Processing test plan: {} ({})", name, id);
            
            // Check if test plan already exists
            boolean exists = false;  // In real impl, check against repository
            
            if (exists) {
                // Update existing test plan
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                // Create new test plan
                stats.setCreated(stats.getCreated() + 1);
            }
        } catch (Exception e) {
            logger.error("Error processing test plan: {} ({})", name, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_PLAN")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test plan: " + e.getMessage())
                            .setCode("PROCESS_ERROR"));
        }
    }
    
    /**
     * Pull test suites from Azure DevOps
     * 
     * @param integration The integration to pull from
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     */
    private void pullTestSuitesFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plan ID and test suite ID if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null) {
            logger.warn("Test plan ID is required to pull test suites");
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("WARNING")
                            .setContentType("TEST_SUITE")
                            .setMessage("Test plan ID is required to pull test suites")
                            .setCode("MISSING_TEST_PLAN_ID"));
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            if (testSuiteId != null) {
                // Get specific test suite
                String testSuiteUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d", 
                        organization, project, testPlanId, testSuiteId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testSuiteUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> testSuite = objectMapper.readValue(responseBody, Map.class);
                        
                        // Process test suite
                        processTestSuite(integration, syncOptions, stats, result, testSuite, testPlanId);
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test suite " + testSuiteId + ": Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            } else {
                // Get all test suites for the plan
                String testSuitesUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites", 
                        organization, project, testPlanId);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testSuitesUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testSuites = (List<Map<String, Object>>) responseMap.get("value");
                        int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                        
                        // Process test suites (limited by maxItems)
                        int processed = 0;
                        for (Map<String, Object> testSuite : testSuites) {
                            if (processed >= maxItems) {
                                break;
                            }
                            
                            processTestSuite(integration, syncOptions, stats, result, testSuite, testPlanId);
                            processed++;
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get test suites: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
            }
        }
    }
    
    /**
     * Process a test suite from Azure DevOps
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param testSuite The test suite data
     * @param testPlanId The test plan ID
     */
    private void processTestSuite(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Map<String, Object> testSuite,
            Long testPlanId) {
        
        // Extract test suite details
        Number id = (Number) testSuite.get("id");
        String name = (String) testSuite.get("name");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        // Create or update test suite in CS Test Forge
        try {
            // In a real implementation, this would interact with your test suite repository
            // For now, we'll just log the action and update stats
            logger.info("Processing test suite: {} ({}) in plan {}", name, id, testPlanId);
            
            // Check if test suite already exists
            boolean exists = false;  // In real impl, check against repository
            
            if (exists) {
                // Update existing test suite
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                // Create new test suite
                stats.setCreated(stats.getCreated() + 1);
            }
        } catch (Exception e) {
            logger.error("Error processing test suite: {} ({})", name, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_SUITE")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test suite: " + e.getMessage())
                            .setCode("PROCESS_ERROR"));
        }
    }
    
    /**
     * Pull test cases from Azure DevOps
     * 
     * @param integration The integration to pull from
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     */
    private void pullTestCasesFromAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plan ID and test suite ID if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            if (testPlanId != null && testSuiteId != null) {
                // Get test cases for specific test suite
                pullTestCasesForSuite(
                        integration, syncOptions, stats, result, 
                        httpClient, organization, project, pat, testPlanId, testSuiteId);
            } else if (syncOptions.getAdoWorkItemQuery() != null) {
                // Get test cases using WIQL query
                pullTestCasesUsingWiql(
                        integration, syncOptions, stats, result,
                        httpClient, organization, project, pat);
            } else if (syncOptions.getAdoAreaPath() != null) {
                // Get test cases for area path
                pullTestCasesForAreaPath(
                        integration, syncOptions, stats, result,
                        httpClient, organization, project, pat);
            } else {
                // Get all test cases using default query
                pullAllTestCases(
                        integration, syncOptions, stats, result,
                        httpClient, organization, project, pat);
            }
        }
    }
    
    /**
     * Pull test cases for a specific test suite
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     * @param testPlanId The test plan ID
     * @param testSuiteId The test suite ID
     */
    private void pullTestCasesForSuite(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat,
            Long testPlanId,
            Long testSuiteId) throws Exception {
        
        // Get test cases for suite
        String testCasesUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                organization, project, testPlanId, testSuiteId);
        
        HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
        httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
        httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
        
        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            int statusCode = response.getStatusLine().getStatusCode();
            
            if (statusCode == HttpStatus.SC_OK) {
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                List<Map<String, Object>> testCaseRefs = (List<Map<String, Object>>) responseMap.get("value");
                int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                
                // Process test cases (limited by maxItems)
                int processed = 0;
                for (Map<String, Object> testCaseRef : testCaseRefs) {
                    if (processed >= maxItems) {
                        break;
                    }
                    
                    // Get test case ID
                    Number testCaseId = (Number) testCaseRef.get("id");
                    
                    // Get detailed test case work item
                    getAndProcessTestCaseWorkItem(
                            integration, syncOptions, stats, result,
                            httpClient, organization, project, pat, testCaseId.intValue());
                    
                    processed++;
                }
            } else {
                String responseBody = EntityUtils.toString(response.getEntity());
                throw new Exception("Failed to get test cases for suite " + testSuiteId + ": Status code " + 
                        statusCode + ", Response: " + responseBody);
            }
        }
    }
    
    /**
     * Pull test cases using a WIQL query
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void pullTestCasesUsingWiql(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Execute WIQL query
        String wiqlUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/wiql", 
                organization, project);
        
        HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(wiqlUrl));
        httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
        httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
        httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
        
        // Create request body
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("query", syncOptions.getAdoWorkItemQuery());
        
        StringEntity entity = new StringEntity(
                objectMapper.writeValueAsString(requestBody),
                ContentType.APPLICATION_JSON);
        httpPost.setEntity(entity);
        
        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            int statusCode = response.getStatusLine().getStatusCode();
            
            if (statusCode == HttpStatus.SC_OK) {
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                List<Map<String, Object>> workItems = (List<Map<String, Object>>) responseMap.get("workItems");
                int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                
                // Process work items (limited by maxItems)
                int processed = 0;
                for (Map<String, Object> workItem : workItems) {
                    if (processed >= maxItems) {
                        break;
                    }
                    
                    // Get work item ID
                    Number workItemId = (Number) workItem.get("id");
                    
                    // Get detailed work item
                    getAndProcessTestCaseWorkItem(
                            integration, syncOptions, stats, result,
                            httpClient, organization, project, pat, workItemId.intValue());
                    
                    processed++;
                }
            } else {
                String responseBody = EntityUtils.toString(response.getEntity());
                throw new Exception("Failed to execute WIQL query: Status code " + 
                        statusCode + ", Response: " + responseBody);
            }
        }
    }
    
    /**
     * Pull test cases for an area path
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void pullTestCasesForAreaPath(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Create WIQL query for area path
        String areaPath = syncOptions.getAdoAreaPath();
        String query = "SELECT [System.Id] FROM WorkItems " +
                "WHERE [System.WorkItemType] = 'Test Case' " +
                "AND [System.AreaPath] UNDER '" + areaPath + "' " +
                "ORDER BY [System.Id]";
        
        // Set query in sync options
        syncOptions.setAdoWorkItemQuery(query);
        
        // Execute WIQL query
        pullTestCasesUsingWiql(integration, syncOptions, stats, result, httpClient, organization, project, pat);
    }
    
    /**
     * Pull all test cases
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void pullAllTestCases(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Create WIQL query for all test cases
        String query = "SELECT [System.Id] FROM WorkItems " +
                "WHERE [System.WorkItemType] = 'Test Case' " +
                "ORDER BY [System.Id]";
        
        // Set query in sync options
        syncOptions.setAdoWorkItemQuery(query);
        
        // Execute WIQL query
        pullTestCasesUsingWiql(integration, syncOptions, stats, result, httpClient, organization, project, pat);
    }
    
    /**
     * Get and process a test case work item
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     * @param workItemId The work item ID
     */
    private void getAndProcessTestCaseWorkItem(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat,
            int workItemId) throws Exception {
        
        // Get work item details
        String workItemUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                organization, project, workItemId);
        
        HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
        httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
        httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
        
        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            int statusCode = response.getStatusLine().getStatusCode();
            
            if (statusCode == HttpStatus.SC_OK) {
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> workItem = objectMapper.readValue(responseBody, Map.class);
                
                // Process test case work item
                processTestCaseWorkItem(integration, syncOptions, stats, result, workItem, httpClient, organization, project, pat);
            } else {
                String responseBody = EntityUtils.toString(response.getEntity());
                throw new Exception("Failed to get work item " + workItemId + ": Status code " + 
                        statusCode + ", Response: " + responseBody);
            }
        }
    }
    
    /**
     * Process a test case work item
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param workItem The work item data
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void processTestCaseWorkItem(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            Map<String, Object> workItem,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) {
        
        // Extract work item details
        Number id = (Number) workItem.get("id");
        Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
        
        String title = (String) fields.get("System.Title");
        String state = (String) fields.get("System.State");
        String areaPath = (String) fields.get("System.AreaPath");
        String iterationPath = (String) fields.get("System.IterationPath");
        String steps = (String) fields.get("Microsoft.VSTS.TCM.Steps");
        
        // Update stats
        stats.setTotalProcessed(stats.getTotalProcessed() + 1);
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            stats.setSkipped(stats.getSkipped() + 1);
            return;
        }
        
        try {
            // Parse test steps HTML
            List<Map<String, String>> parsedSteps = parseTestStepsHtml(steps);
            
            // Download attachments if needed
            List<File> attachments = new ArrayList<>();
            if (syncOptions.isIncludeAttachments()) {
                attachments = downloadWorkItemAttachments(
                        workItem, httpClient, organization, project, pat);
            }
            
            // In a real implementation, this would interact with your test case repository
            // For now, we'll just log the action and update stats
            logger.info("Processing test case: {} ({})", title, id);
            
            // Check if test case already exists
            boolean exists = false;  // In real impl, check against repository
            
            if (exists) {
                // Update existing test case
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                // Create new test case
                stats.setCreated(stats.getCreated() + 1);
            }
            
            // Update attachments count in stats
            if (!attachments.isEmpty()) {
                stats.getAdditionalStats().put("attachmentsImported", attachments.size());
            }
        } catch (Exception e) {
            logger.error("Error processing test case: {} ({})", title, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_CASE")
                            .setItemId(id.toString())
                            .setMessage("Failed to process test case: " + e.getMessage())
                            .setCode("PROCESS_ERROR"));
        }
    }
    
    /**
     * Parse test steps HTML into structured data
     * 
     * @param stepsHtml The test steps HTML
     * @return List of test steps
     */
    private List<Map<String, String>> parseTestStepsHtml(String stepsHtml) {
        List<Map<String, String>> steps = new ArrayList<>();
        
        if (stepsHtml == null || stepsHtml.trim().isEmpty()) {
            return steps;
        }
        
        try {
            // Use JSoup to parse HTML
            Document doc = Jsoup.parse(stepsHtml);
            Elements divs = doc.select("div.step-list");
            
            // If no step-list divs found, try to parse as a table
            if (divs.isEmpty()) {
                Elements tables = doc.select("table");
                if (!tables.isEmpty()) {
                    Elements rows = tables.first().select("tr");
                    
                    // Skip header row if present
                    int startRow = rows.first().select("th").isEmpty() ? 0 : 1;
                    
                    for (int i = startRow; i < rows.size(); i++) {
                        Element row = rows.get(i);
                        Elements cells = row.select("td");
                        
                        if (cells.size() >= 2) {
                            Map<String, String> step = new HashMap<>();
                            step.put("action", cells.get(0).text());
                            step.put("expectedResult", cells.size() > 1 ? cells.get(1).text() : "");
                            steps.add(step);
                        }
                    }
                }
            } else {
                // Parse step-list divs
                for (Element div : divs) {
                    Elements stepDivs = div.select("div.step");
                    
                    for (Element stepDiv : stepDivs) {
                        Element actionDiv = stepDiv.selectFirst("div.action");
                        Element expectedDiv = stepDiv.selectFirst("div.expectedResult");
                        
                        Map<String, String> step = new HashMap<>();
                        step.put("action", actionDiv != null ? actionDiv.text() : "");
                        step.put("expectedResult", expectedDiv != null ? expectedDiv.text() : "");
                        steps.add(step);
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Error parsing test steps HTML", e);
            
            // Return a simple step with the raw HTML as fallback
            Map<String, String> fallbackStep = new HashMap<>();
            fallbackStep.put("action", "See test steps in Azure DevOps");
            fallbackStep.put("expectedResult", "");
            steps.add(fallbackStep);
        }
        
        return steps;
    }
    
    /**
     * Download attachments for a work item
     * 
     * @param workItem The work item data
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     * @return List of downloaded attachment files
     */
    private List<File> downloadWorkItemAttachments(
            Map<String, Object> workItem,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        List<File> attachments = new ArrayList<>();
        
        // Get relations section
        Map<String, Object> relations = (Map<String, Object>) workItem.get("relations");
        if (relations == null) {
            return attachments;
        }
        
        // Get attachments
        List<Map<String, Object>> attachmentRelations = new ArrayList<>();
        if (relations.containsKey("attachments")) {
            attachmentRelations = (List<Map<String, Object>>) relations.get("attachments");
        }
        
        // Download each attachment
        for (Map<String, Object> relation : attachmentRelations) {
            if (relation.containsKey("url")) {
                String url = (String) relation.get("url");
                String attributes = (String) relation.get("attributes");
                
                // Parse attributes to get file name
                Map<String, Object> attributesMap = objectMapper.readValue(attributes, Map.class);
                String fileName = (String) attributesMap.get("name");
                
                // Create download directory
                Number id = (Number) workItem.get("id");
                Path downloadDir = Paths.get(dataDirectory, "attachments", "work-items", id.toString());
                Files.createDirectories(downloadDir);
                
                // Download file
                HttpGet httpGet = new HttpGet(url);
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        // Save file
                        File attachmentFile = downloadDir.resolve(fileName).toFile();
                        try (InputStream inputStream = response.getEntity().getContent();
                             FileOutputStream outputStream = new FileOutputStream(attachmentFile)) {
                            
                            byte[] buffer = new byte[8192];
                            int bytesRead;
                            while ((bytesRead = inputStream.read(buffer)) != -1) {
                                outputStream.write(buffer, 0, bytesRead);
                            }
                            
                            attachments.add(attachmentFile);
                        }
                    }
                }
            }
        }
        
        return attachments;
    }
    
    /**
     * Push data from CS Test Forge to Azure DevOps
     * 
     * @param integration The integration to push to
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void pushToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Prepare sync options if null
        if (syncOptions == null) {
            syncOptions = new IntegrationSyncOptions();
        }
        
        // Default content types if not specified
        if (syncOptions.getContentTypes() == null || syncOptions.getContentTypes().isEmpty()) {
            syncOptions.setContentTypes(Arrays.asList("TEST_RESULT"));
        }
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_RESULT":
                    pushTestResultsToAzureDevOps(integration, syncOptions, stats, result);
                    break;
                default:
                    logger.warn("Unsupported content type for push: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for push: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Push test results to Azure DevOps
     * 
     * @param integration The integration to push to
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     */
    private void pushTestResultsToAzureDevOps(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Get test plan ID and test suite ID if specified
        Long testPlanId = syncOptions.getAdoTestPlanId();
        Long testSuiteId = syncOptions.getAdoTestSuiteId();
        
        if (testPlanId == null || testSuiteId == null) {
            logger.warn("Test plan ID and test suite ID are required to push test results");
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_RESULT")
                            .setMessage("Test plan ID and test suite ID are required to push test results")
                            .setCode("MISSING_IDS"));
            return;
        }
        
        // In a real implementation, this would get test results from your repository
        // Here we'll simulate pushing test results
        if (syncOptions.isDryRun()) {
            logger.info("Dry run: Skipping pushing test results");
            stats.setSkipped(10);  // Simulate 10 skipped test results
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            // Create a test run
            String testRunTitle = "Automated Test Run - " + LocalDateTime.now().format(DATETIME_FORMATTER);
            Map<String, Object> testRunPayload = new HashMap<>();
            testRunPayload.put("name", testRunTitle);
            testRunPayload.put("plan", new HashMap<String, Object>() {{
                put("id", testPlanId);
            }});
            
            // Add test suite ID if specified
            List<Map<String, Object>> testSuites = new ArrayList<>();
            testSuites.add(new HashMap<String, Object>() {{
                put("id", testSuiteId);
            }});
            testRunPayload.put("testSuites", testSuites);
            
            // Create test run
            String testRunsUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/runs", 
                    organization, project);
            
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testRunsUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            StringEntity entity = new StringEntity(
                    objectMapper.writeValueAsString(testRunPayload),
                    ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> testRun = objectMapper.readValue(responseBody, Map.class);
                    
                    // Get test run ID
                    Number testRunId = (Number) testRun.get("id");
                    
                    // Add test run ID to result
                    Map<String, Object> additionalStats = stats.getAdditionalStats();
                    additionalStats.put("testRunId", testRunId);
                    additionalStats.put("testRunUrl", String.format(
                            "https://dev.azure.com/%s/%s/_test/runs/%d", 
                            organization, project, testRunId.longValue()));
                    
                    // Get test case work items in the test suite
                    String testCasesUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                            organization, project, testPlanId, testSuiteId);
                    
                    HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
                    httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse testCasesResponse = httpClient.execute(httpGet)) {
                        if (testCasesResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                            String testCasesResponseBody = EntityUtils.toString(testCasesResponse.getEntity());
                            Map<String, Object> testCasesResponseMap = objectMapper.readValue(testCasesResponseBody, Map.class);
                            
                            List<Map<String, Object>> testCaseRefs = (List<Map<String, Object>>) testCasesResponseMap.get("value");
                            
                            // Submit test results for each test case
                            List<Map<String, Object>> testResults = new ArrayList<>();
                            
                            for (Map<String, Object> testCaseRef : testCaseRefs) {
                                Number testCaseId = (Number) testCaseRef.get("id");
                                
                                // Create a test result (passed, failed, or blocked)
                                String[] outcomes = {"Passed", "Failed", "Blocked"};
                                String outcome = outcomes[new Random().nextInt(outcomes.length)];
                                
                                Map<String, Object> testResult = new HashMap<>();
                                testResult.put("testCase", new HashMap<String, Object>() {{
                                    put("id", testCaseId);
                                }});
                                testResult.put("outcome", outcome);
                                testResult.put("state", "Completed");
                                testResult.put("comment", "Automated test result from CS Test Forge");
                                testResult.put("startedDate", LocalDateTime.now().minusMinutes(5).format(DATETIME_FORMATTER));
                                testResult.put("completedDate", LocalDateTime.now().format(DATETIME_FORMATTER));
                                
                                testResults.add(testResult);
                            }
                            
                            // Submit test results
                            String testResultsUrl = String.format(
                                    "https://dev.azure.com/%s/%s/_apis/test/runs/%d/results", 
                                    organization, project, testRunId.longValue());
                            
                            HttpPost testResultsPost = new HttpPost(buildAzureDevOpsUri(testResultsUrl));
                            testResultsPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                            testResultsPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                            testResultsPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                            
                            StringEntity testResultsEntity = new StringEntity(
                                    objectMapper.writeValueAsString(testResults),
                                    ContentType.APPLICATION_JSON);
                            testResultsPost.setEntity(testResultsEntity);
                            
                            try (CloseableHttpResponse testResultsResponse = httpClient.execute(testResultsPost)) {
                                if (testResultsResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK 
                                        || testResultsResponse.getStatusLine().getStatusCode() == HttpStatus.SC_CREATED) {
                                    
                                    // Update stats
                                    stats.setTotalProcessed(testResults.size());
                                    stats.setCreated(testResults.size());
                                    
                                    // Close the test run
                                    String updateTestRunUrl = String.format(
                                            "https://dev.azure.com/%s/%s/_apis/test/runs/%d", 
                                            organization, project, testRunId.longValue());
                                    
                                    Map<String, Object> updateTestRunPayload = new HashMap<>();
                                    updateTestRunPayload.put("state", "Completed");
                                    
                                    HttpPatch httpPatch = new HttpPatch(buildAzureDevOpsUri(updateTestRunUrl));
                                    httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                                    httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                                    httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                                    
                                    StringEntity updateEntity = new StringEntity(
                                            objectMapper.writeValueAsString(updateTestRunPayload),
                                            ContentType.APPLICATION_JSON);
                                    httpPatch.setEntity(updateEntity);
                                    
                                    try (CloseableHttpResponse updateResponse = httpClient.execute(httpPatch)) {
                                        if (updateResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                            logger.info("Test run completed successfully");
                                        } else {
                                            logger.warn("Failed to complete test run: Status code {}", 
                                                    updateResponse.getStatusLine().getStatusCode());
                                        }
                                    }
                                } else {
                                    String errorBody = EntityUtils.toString(testResultsResponse.getEntity());
                                    throw new Exception("Failed to submit test results: Status code " + 
                                            testResultsResponse.getStatusLine().getStatusCode() + 
                                            ", Response: " + errorBody);
                                }
                            }
                        } else {
                            String errorBody = EntityUtils.toString(testCasesResponse.getEntity());
                            throw new Exception("Failed to get test cases: Status code " + 
                                    testCasesResponse.getStatusLine().getStatusCode() + 
                                    ", Response: " + errorBody);
                        }
                    }
                } else {
                    String errorBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to create test run: Status code " + 
                            statusCode + ", Response: " + errorBody);
                }
            }
        }
    }
    
    /**
     * Synchronize with Azure DevOps Git
     * 
     * @param integration The integration to sync with
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void syncWithAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Prepare sync options if null
        if (syncOptions == null) {
            syncOptions = new IntegrationSyncOptions();
        }
        
        // Default content types if not specified
        if (syncOptions.getContentTypes() == null || syncOptions.getContentTypes().isEmpty()) {
            syncOptions.setContentTypes(Arrays.asList("TEST_SCRIPT"));
        }
        
        // Determine sync direction
        String direction = syncOptions.getDirection();
        if (direction == null) {
            direction = "PULL";
        }
        
        // Initialize stats for each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = new IntegrationSyncResult.SyncStats()
                    .setContentType(contentType)
                    .setTotalProcessed(0)
                    .setCreated(0)
                    .setUpdated(0)
                    .setDeleted(0)
                    .setSkipped(0)
                    .setErrors(0)
                    .setConflicts(0);
            
            result.getStats().put(contentType, stats);
        }
        
        // Implement sync based on direction
        try {
            if ("PULL".equals(direction)) {
                // Pull data from Azure DevOps Git to CS Test Forge
                pullFromAzureDevOpsGit(integration, syncOptions, result);
            } else if ("PUSH".equals(direction)) {
                // Push data from CS Test Forge to Azure DevOps Git
                pushToAzureDevOpsGit(integration, syncOptions, result);
            } else if ("BIDIRECTIONAL".equals(direction)) {
                // Pull first, then push
                pullFromAzureDevOpsGit(integration, syncOptions, result);
                pushToAzureDevOpsGit(integration, syncOptions, result);
            } else {
                throw new IllegalArgumentException("Invalid sync direction: " + direction);
            }
            
            // Set success message
            result.setSuccessful(true);
            if (result.isDryRun()) {
                result.setMessage("Sync dry run completed successfully");
            } else {
                result.setMessage("Sync completed successfully");
            }
        } catch (Exception e) {
            result.setSuccessful(false);
            result.setMessage("Sync failed: " + e.getMessage());
            result.setErrorCode("SYNC_ERROR");
            result.setErrorDetail(e.getMessage());
            
            // Add error to each content type
            for (IntegrationSyncResult.SyncStats stats : result.getStats().values()) {
                stats.setErrors(stats.getErrors() + 1);
            }
        }
    }
    
    /**
     * Pull data from Azure DevOps Git to CS Test Forge
     * 
     * @param integration The integration to pull from
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void pullFromAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get branch and path pattern if specified
        String branch = syncOptions.getAdoGitBranch();
        if (branch == null || branch.trim().isEmpty()) {
            branch = "main";  // Default branch
        }
        
        String pathPattern = syncOptions.getAdoGitPathPattern();
        if (pathPattern == null || pathPattern.trim().isEmpty()) {
            pathPattern = "**/*.js,**/*.ts,**/*.java";  // Default path pattern
        }
        
        List<String> fileExtensions = syncOptions.getAdoGitFileExtensions();
        if (fileExtensions == null || fileExtensions.isEmpty()) {
            fileExtensions = Arrays.asList(".js", ".ts", ".java");
        }
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_SCRIPT":
                    pullTestScriptsFromAzureDevOpsGit(
                            integration, syncOptions, stats, result,
                            organization, project, repositoryId, pat, branch, pathPattern, fileExtensions);
                    break;
                default:
                    logger.warn("Unsupported content type for Git pull: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for Git pull: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Pull test scripts from Azure DevOps Git
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param repositoryId The repository ID
     * @param pat The Personal Access Token
     * @param branch The branch
     * @param pathPattern The path pattern
     * @param fileExtensions The file extensions
     */
    private void pullTestScriptsFromAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String organization,
            String project,
            String repositoryId,
            String pat,
            String branch,
            String pathPattern,
            List<String> fileExtensions) throws Exception {
        
        // Get commit ID if specified
        String commitId = syncOptions.getAdoGitCommitId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            // Get the latest commit ID if not specified
            if (commitId == null || commitId.trim().isEmpty()) {
                String branchUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s", 
                        organization, project, repositoryId, branch);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                        if (branches != null && !branches.isEmpty()) {
                            for (Map<String, Object> branchObj : branches) {
                                String name = (String) branchObj.get("name");
                                if (name != null && name.endsWith("/" + branch)) {
                                    // Found the branch
                                    Map<String, Object> objectId = (Map<String, Object>) branchObj.get("objectId");
                                    commitId = (String) objectId;
                                    break;
                                }
                            }
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get branch: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
                
                if (commitId == null || commitId.trim().isEmpty()) {
                    throw new Exception("Could not determine latest commit ID for branch: " + branch);
                }
            }
            
            // Get the items in the repository
            String itemsUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/items", 
                    organization, project, repositoryId);
            
            // Build URL with query parameters
            URIBuilder uriBuilder = new URIBuilder(itemsUrl);
            uriBuilder.addParameter("scopePath", "/");
            uriBuilder.addParameter("recursionLevel", "Full");
            uriBuilder.addParameter("includeContentMetadata", "true");
            uriBuilder.addParameter("versionDescriptor.version", commitId);
            uriBuilder.addParameter("versionDescriptor.versionType", "commit");
            uriBuilder.addParameter("api-version", ADO_API_VERSION);
            
            HttpGet httpGet = new HttpGet(uriBuilder.build());
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> items = (List<Map<String, Object>>) responseMap.get("value");
                    
                    // Filter items based on path pattern and file extensions
                    List<Map<String, Object>> filteredItems = new ArrayList<>();
                    
                    for (Map<String, Object> item : items) {
                        String path = (String) item.get("path");
                        boolean isFolder = (boolean) item.get("isFolder");
                        
                        if (!isFolder) {
                            // Check file extension
                            boolean matchesExtension = false;
                            for (String ext : fileExtensions) {
                                if (path.endsWith(ext)) {
                                    matchesExtension = true;
                                    break;
                                }
                            }
                            
                            if (matchesExtension) {
                                // Check path pattern
                                String[] patterns = pathPattern.split(",");
                                for (String pattern : patterns) {
                                    if (matchesPathPattern(path, pattern.trim())) {
                                        filteredItems.add(item);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Update stats
                    stats.setTotalProcessed(filteredItems.size());
                    
                    // Skip if dry run
                    if (syncOptions.isDryRun()) {
                        stats.setSkipped(filteredItems.size());
                        return;
                    }
                    
                    // Download and process each file
                    int maxItems = syncOptions.getMaxItems() != null ? syncOptions.getMaxItems() : Integer.MAX_VALUE;
                    int processed = 0;
                    
                    for (Map<String, Object> item : filteredItems) {
                        if (processed >= maxItems) {
                            stats.setSkipped(stats.getSkipped() + (filteredItems.size() - processed));
                            break;
                        }
                        
                        String path = (String) item.get("path");
                        String downloadUrl = (String) item.get("url");
                        
                        // Download file content
                        HttpGet contentGet = new HttpGet(downloadUrl);
                        contentGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        contentGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        try (CloseableHttpResponse contentResponse = httpClient.execute(contentGet)) {
                            if (contentResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(contentResponse.getEntity());
                                
                                // Process the file
                                processGitTestScript(integration, syncOptions, stats, result, path, content);
                                processed++;
                            } else {
                                // Add error
                                String errorBody = EntityUtils.toString(contentResponse.getEntity());
                                result.getIssues().add(
                                        new IntegrationSyncResult.SyncIssue()
                                                .setSeverity("ERROR")
                                                .setContentType("TEST_SCRIPT")
                                                .setItemId(path)
                                                .setMessage("Failed to download file: Status code " + 
                                                        contentResponse.getStatusLine().getStatusCode() + 
                                                        ", Response: " + errorBody)
                                                .setCode("DOWNLOAD_ERROR"));
                                
                                stats.setErrors(stats.getErrors() + 1);
                            }
                        }
                    }
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get repository items: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Check if a path matches a pattern
     * 
     * @param path The path
     * @param pattern The pattern
     * @return True if the path matches the pattern
     */
    private boolean matchesPathPattern(String path, String pattern) {
        // Convert Git/glob pattern to regex
        String regex = pattern
                .replace(".", "\\.")
                .replace("**/", "(.*/)?")
                .replace("**", ".*")
                .replace("*", "[^/]*")
                .replace("?", "[^/]");
        
        return Pattern.matches(regex, path);
    }
    
    /**
     * Process a Git test script
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param path The file path
     * @param content The file content
     */
    private void processGitTestScript(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String path,
            String content) {
        
        try {
            // In a real implementation, this would interact with your test script repository
            // For now, we'll just log the action and update stats
            logger.info("Processing test script: {}", path);
            
            // Check if test script already exists
            boolean exists = false;  // In real impl, check against repository
            
            if (exists) {
                // Update existing test script
                stats.setUpdated(stats.getUpdated() + 1);
            } else {
                // Create new test script
                stats.setCreated(stats.getCreated() + 1);
            }
        } catch (Exception e) {
            logger.error("Error processing test script: {}", path, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationSyncResult.SyncIssue()
                            .setSeverity("ERROR")
                            .setContentType("TEST_SCRIPT")
                            .setItemId(path)
                            .setMessage("Failed to process test script: " + e.getMessage())
                            .setCode("PROCESS_ERROR"));
        }
    }
    
    /**
     * Push data from CS Test Forge to Azure DevOps Git
     * 
     * @param integration The integration to push to
     * @param syncOptions Sync options
     * @param result The sync result to update
     */
    private void pushToAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Get branch and base path if specified
        String branch = syncOptions.getAdoGitBranch();
        if (branch == null || branch.trim().isEmpty()) {
            branch = "main";  // Default branch
        }
        
        String basePath = syncOptions.getAdoGitBasePath();
        if (basePath == null || basePath.trim().isEmpty()) {
            basePath = "test-results/";
        }
        
        // Ensure base path ends with slash
        if (!basePath.endsWith("/")) {
            basePath += "/";
        }
        
        // Process each content type
        for (String contentType : syncOptions.getContentTypes()) {
            IntegrationSyncResult.SyncStats stats = result.getStats().get(contentType);
            
            switch (contentType) {
                case "TEST_RESULT":
                    pushTestResultsToAzureDevOpsGit(
                            integration, syncOptions, stats, result,
                            organization, project, repositoryId, pat, branch, basePath);
                    break;
                default:
                    logger.warn("Unsupported content type for Git push: {}", contentType);
                    result.getIssues().add(
                            new IntegrationSyncResult.SyncIssue()
                                    .setSeverity("WARNING")
                                    .setContentType(contentType)
                                    .setMessage("Unsupported content type for Git push: " + contentType)
                                    .setCode("UNSUPPORTED_CONTENT_TYPE"));
            }
        }
    }
    
    /**
     * Push test results to Azure DevOps Git
     * 
     * @param integration The integration
     * @param syncOptions Sync options
     * @param stats The stats to update
     * @param result The sync result to update
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param repositoryId The repository ID
     * @param pat The Personal Access Token
     * @param branch The branch
     * @param basePath The base path
     */
    private void pushTestResultsToAzureDevOpsGit(
            Integration integration, 
            IntegrationSyncOptions syncOptions,
            IntegrationSyncResult.SyncStats stats,
            IntegrationSyncResult result,
            String organization,
            String project,
            String repositoryId,
            String pat,
            String branch,
            String basePath) throws Exception {
        
        // Skip if dry run
        if (syncOptions.isDryRun()) {
            logger.info("Dry run: Skipping pushing test results to Git");
            stats.setSkipped(1);  // Simulate 1 skipped export
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, syncOptions.getProxySettings())) {
            // Get the latest commit ID for the branch
            String branchUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s", 
                    organization, project, repositoryId, branch);
            
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            String oldCommitId = null;
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                    if (branches != null && !branches.isEmpty()) {
                        for (Map<String, Object> branchObj : branches) {
                            String name = (String) branchObj.get("name");
                            if (name != null && name.endsWith("/" + branch)) {
                                // Found the branch
                                Map<String, Object> objectId = (Map<String, Object>) branchObj.get("objectId");
                                oldCommitId = (String) objectId;
                                break;
                            }
                        }
                    }
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get branch: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
            
            if (oldCommitId == null) {
                throw new Exception("Could not determine latest commit ID for branch: " + branch);
            }
            
            // In a real implementation, this would get test results from your repository
            // Here we'll generate a sample test result file
            
            // Generate timestamp for file name
            String timestamp = LocalDateTime.now().format(
                    DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            
            // Generate HTML test report
            String fileName = "test-report-" + timestamp + ".html";
            String filePath = basePath + fileName;
            String fileContent = generateSampleTestReport();
            
            // Create push request
            Map<String, Object> pushRequest = new HashMap<>();
            pushRequest.put("refUpdates", Arrays.asList(
                    new HashMap<String, Object>() {{
                        put("name", "refs/heads/" + branch);
                        put("oldObjectId", oldCommitId);
                    }}
            ));
            
            List<Map<String, Object>> commits = new ArrayList<>();
            Map<String, Object> commit = new HashMap<>();
            commit.put("comment", "Add test results report: " + fileName);
            
            List<Map<String, Object>> changes = new ArrayList<>();
            Map<String, Object> change = new HashMap<>();
            change.put("changeType", "add");
            change.put("item", new HashMap<String, Object>() {{
                put("path", filePath);
            }});
            change.put("newContent", new HashMap<String, Object>() {{
                put("content", fileContent);
                put("contentType", "rawtext");
            }});
            
            changes.add(change);
            commit.put("changes", changes);
            commits.add(commit);
            pushRequest.put("commits", commits);
            
            // Push to Git
            String pushUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/pushes", 
                    organization, project, repositoryId);
            
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(pushUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            StringEntity entity = new StringEntity(
                    objectMapper.writeValueAsString(pushRequest),
                    ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> pushResponse = objectMapper.readValue(responseBody, Map.class);
                    
                    // Get commit ID
                    List<Map<String, Object>> pushedCommits = (List<Map<String, Object>>) pushResponse.get("commits");
                    if (pushedCommits != null && !pushedCommits.isEmpty()) {
                        String commitId = (String) pushedCommits.get(0).get("commitId");
                        
                        // Add commit info to result
                        Map<String, Object> additionalStats = stats.getAdditionalStats();
                        additionalStats.put("commitId", commitId);
                        additionalStats.put("commitUrl", String.format(
                                "https://dev.azure.com/%s/%s/_git/%s/commit/%s", 
                                organization, project, repositoryId, commitId));
                        additionalStats.put("fileUrl", String.format(
                                "https://dev.azure.com/%s/%s/_git/%s?path=%s", 
                                organization, project, repositoryId, 
                                filePath.replace("/", "%2F")));
                    }
                    
                    // Update stats
                    stats.setTotalProcessed(1);
                    stats.setCreated(1);
                } else {
                    String errorBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to push to Git: Status code " + 
                            statusCode + ", Response: " + errorBody);
                }
            }
        }
    }
    
    /**
     * Generate a sample test report HTML
     * 
     * @return HTML test report
     */
    private String generateSampleTestReport() {
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>\n");
        html.append("<html>\n");
        html.append("<head>\n");
        html.append("    <title>Test Execution Report</title>\n");
        html.append("    <style>\n");
        html.append("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
        html.append("        h1 { color: #333; }\n");
        html.append("        table { border-collapse: collapse; width: 100%; }\n");
        html.append("        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
        html.append("        th { background-color: #f2f2f2; }\n");
        html.append("        tr.pass { background-color: #dff0d8; }\n");
        html.append("        tr.fail { background-color: #f2dede; }\n");
        html.append("        tr.block { background-color: #fcf8e3; }\n");
        html.append("        .summary { margin-bottom: 20px; }\n");
        html.append("    </style>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        html.append("    <h1>Test Execution Report</h1>\n");
        html.append("    <div class=\"summary\">\n");
        html.append("        <p><strong>Execution Date:</strong> " + 
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "</p>\n");
        html.append("        <p><strong>Executed By:</strong> CS Test Forge</p>\n");
        html.append("        <p><strong>Summary:</strong> 10 Tests (7 Passed, 2 Failed, 1 Blocked)</p>\n");
        html.append("    </div>\n");
        html.append("    <table>\n");
        html.append("        <tr>\n");
        html.append("            <th>ID</th>\n");
        html.append("            <th>Test Case</th>\n");
        html.append("            <th>Status</th>\n");
        html.append("            <th>Duration (s)</th>\n");
        html.append("            <th>Comments</th>\n");
        html.append("        </tr>\n");
        
        // Generate sample test results
        String[] statuses = {"pass", "pass", "pass", "fail", "pass", "pass", "block", "pass", "fail", "pass"};
        String[] testCases = {
                "Login with valid credentials", 
                "Login with invalid credentials", 
                "Password reset functionality", 
                "User registration with existing email", 
                "User profile update", 
                "Search functionality", 
                "Payment processing with invalid card", 
                "Product filtering", 
                "Checkout with empty cart", 
                "Logout functionality"};
        
        Random random = new Random();
        
        for (int i = 0; i < 10; i++) {
            String status = statuses[i];
            String testCase = testCases[i];
            int duration = random.nextInt(10) + 1;  // 1-10 seconds
            
            html.append("        <tr class=\"" + status + "\">\n");
            html.append("            <td>TC-" + (i+1) + "</td>\n");
            html.append("            <td>" + testCase + "</td>\n");
            html.append("            <td>" + status.substring(0, 1).toUpperCase() + status.substring(1) + "</td>\n");
            html.append("            <td>" + duration + "</td>\n");
            
            if ("fail".equals(status)) {
                html.append("            <td>Failed assertion: Expected result not achieved</td>\n");
            } else if ("block".equals(status)) {
                html.append("            <td>Test blocked due to dependency failure</td>\n");
            } else {
                html.append("            <td>Test executed successfully</td>\n");
            }
            
            html.append("        </tr>\n");
        }
        
        html.append("    </table>\n");
        html.append("</body>\n");
        html.append("</html>");
        
        return html.toString();
    }
    
    @Override
    public IntegrationImportResult importFromIntegration(
            String projectId, String integrationId, IntegrationImportOptions importOptions) {
        
        logger.info("Importing from integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationImportResult result = new IntegrationImportResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDryRun(importOptions != null && importOptions.isDryRun());
        result.setContentType(importOptions != null ? importOptions.getContentType() : null);
        result.setTargetFolderId(importOptions != null ? importOptions.getTargetFolderId() : null);
        
        long startTime = System.currentTimeMillis();
        
        // Perform import based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                importFromAzureDevOps(integration, importOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                importFromAzureDevOpsGit(integration, importOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during import", e);
            result.setSuccessful(false);
            result.setMessage("Import failed: " + e.getMessage());
            result.setErrorCode("IMPORT_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Import from Azure DevOps
     * 
     * @param integration The integration to import from
     * @param importOptions Import options
     * @param result The import result to update
     */
    private void importFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Validate content type
        String contentType = importOptions.getContentType();
        if (contentType == null || contentType.trim().isEmpty()) {
            contentType = "TEST_CASE";  // Default content type
        }
        
        // Import based on content type
        switch (contentType) {
            case "TEST_CASE":
                importTestCasesFromAzureDevOps(integration, importOptions, result);
                break;
            case "TEST_SUITE":
                importTestSuitesFromAzureDevOps(integration, importOptions, result);
                break;
            default:
                throw new IllegalArgumentException("Unsupported content type for import: " + contentType);
        }
    }

    /**
     * Import test cases from Azure DevOps
     * 
     * @param integration The integration to import from
     * @param importOptions Import options
     * @param result The import result to update
     */
    private void importTestCasesFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Set up import stats
        IntegrationImportResult.ImportStats stats = new IntegrationImportResult.ImportStats();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            // Determine import strategy
            if (importOptions.getAdoWorkItemIds() != null && !importOptions.getAdoWorkItemIds().isEmpty()) {
                // Import specific work items
                importSpecificTestCases(integration, importOptions, result, stats, 
                        httpClient, organization, project, pat);
            } else if (importOptions.getAdoTestPlanId() != null && importOptions.getAdoTestSuiteId() != null) {
                // Import from test suite
                importTestCasesFromSuite(integration, importOptions, result, stats,
                        httpClient, organization, project, pat);
            } else if (importOptions.getAdoWorkItemQuery() != null) {
                // Import using WIQL query
                importTestCasesUsingWiql(integration, importOptions, result, stats,
                        httpClient, organization, project, pat);
            } else if (importOptions.getAdoAreaPath() != null) {
                // Import from area path
                importTestCasesFromAreaPath(integration, importOptions, result, stats,
                        httpClient, organization, project, pat);
            } else {
                // Import all test cases
                importAllTestCases(integration, importOptions, result, stats,
                        httpClient, organization, project, pat);
            }
        }
        
        // Set import result
        result.setStats(stats);
        result.setSuccessful(true);
        result.setMessage("Import completed successfully");
    }
    
    /**
     * Import specific test cases
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importSpecificTestCases(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        List<Long> workItemIds = importOptions.getAdoWorkItemIds();
        stats.setTotalFound(workItemIds.size());
        
        // Skip if dry run
        if (importOptions.isDryRun()) {
            stats.setSkipped(workItemIds.size());
            return;
        }
        
        // Process each work item
        int processed = 0;
        int maxItems = importOptions.getMaxItems() != null ? importOptions.getMaxItems() : Integer.MAX_VALUE;
        
        for (Long workItemId : workItemIds) {
            if (processed >= maxItems) {
                stats.setSkipped(stats.getSkipped() + (workItemIds.size() - processed));
                break;
            }
            
            // Get work item details
            String workItemUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                    organization, project, workItemId);
            
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> workItem = objectMapper.readValue(responseBody, Map.class);
                    
                    // Process test case work item
                    importTestCaseWorkItem(integration, importOptions, result, stats, 
                            workItem, httpClient, organization, project, pat);
                    
                    processed++;
                } else {
                    stats.setErrors(stats.getErrors() + 1);
                    
                    // Add error to result
                    result.getIssues().add(
                            new IntegrationImportResult.ImportIssue()
                                    .setSeverity("ERROR")
                                    .setExternalItemId(workItemId.toString())
                                    .setMessage("Failed to get work item: Status code " + statusCode)
                                    .setCode("WORK_ITEM_ERROR"));
                }
            }
        }
        
        stats.setTotalProcessed(processed);
    }
    
    /**
     * Import test cases from a test suite
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importTestCasesFromSuite(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Get test cases for suite
        String testCasesUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                organization, project, 
                importOptions.getAdoTestPlanId(), 
                importOptions.getAdoTestSuiteId());
        
        HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
        httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
        httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
        
        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            int statusCode = response.getStatusLine().getStatusCode();
            
            if (statusCode == HttpStatus.SC_OK) {
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                List<Map<String, Object>> testCaseRefs = (List<Map<String, Object>>) responseMap.get("value");
                stats.setTotalFound(testCaseRefs.size());
                
                // Skip if dry run
                if (importOptions.isDryRun()) {
                    stats.setSkipped(testCaseRefs.size());
                    return;
                }
                
                // Process each test case
                int processed = 0;
                int maxItems = importOptions.getMaxItems() != null ? importOptions.getMaxItems() : Integer.MAX_VALUE;
                
                for (Map<String, Object> testCaseRef : testCaseRefs) {
                    if (processed >= maxItems) {
                        stats.setSkipped(stats.getSkipped() + (testCaseRefs.size() - processed));
                        break;
                    }
                    
                    // Get test case ID
                    Number testCaseId = (Number) testCaseRef.get("id");
                    
                    // Get detailed test case work item
                    String workItemUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                            organization, project, testCaseId.intValue());
                    
                    HttpGet workItemGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                    workItemGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    workItemGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse workItemResponse = httpClient.execute(workItemGet)) {
                        int workItemStatusCode = workItemResponse.getStatusLine().getStatusCode();
                        
                        if (workItemStatusCode == HttpStatus.SC_OK) {
                            String workItemResponseBody = EntityUtils.toString(workItemResponse.getEntity());
                            Map<String, Object> workItem = objectMapper.readValue(workItemResponseBody, Map.class);
                            
                            // Process test case work item
                            importTestCaseWorkItem(integration, importOptions, result, stats, 
                                    workItem, httpClient, organization, project, pat);
                            
                            processed++;
                        } else {
                            stats.setErrors(stats.getErrors() + 1);
                            
                            // Add error to result
                            result.getIssues().add(
                                    new IntegrationImportResult.ImportIssue()
                                            .setSeverity("ERROR")
                                            .setExternalItemId(testCaseId.toString())
                                            .setMessage("Failed to get work item: Status code " + workItemStatusCode)
                                            .setCode("WORK_ITEM_ERROR"));
                        }
                    }
                }
                
                stats.setTotalProcessed(processed);
            } else {
                throw new Exception("Failed to get test cases for suite: Status code " + statusCode);
            }
        }
    }
    
    /**
     * Import test cases using a WIQL query
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importTestCasesUsingWiql(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Execute WIQL query
        String wiqlUrl = String.format(
                "https://dev.azure.com/%s/%s/_apis/wit/wiql", 
                organization, project);
        
        HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(wiqlUrl));
        httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
        httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
        httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
        
        // Create request body
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("query", importOptions.getAdoWorkItemQuery());
        
        StringEntity entity = new StringEntity(
                objectMapper.writeValueAsString(requestBody),
                ContentType.APPLICATION_JSON);
        httpPost.setEntity(entity);
        
        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            int statusCode = response.getStatusLine().getStatusCode();
            
            if (statusCode == HttpStatus.SC_OK) {
                String responseBody = EntityUtils.toString(response.getEntity());
                Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                
                List<Map<String, Object>> workItems = (List<Map<String, Object>>) responseMap.get("workItems");
                stats.setTotalFound(workItems.size());
                
                // Skip if dry run
                if (importOptions.isDryRun()) {
                    stats.setSkipped(workItems.size());
                    return;
                }
                
                // Process each work item
                int processed = 0;
                int maxItems = importOptions.getMaxItems() != null ? importOptions.getMaxItems() : Integer.MAX_VALUE;
                
                for (Map<String, Object> workItemRef : workItems) {
                    if (processed >= maxItems) {
                        stats.setSkipped(stats.getSkipped() + (workItems.size() - processed));
                        break;
                    }
                    
                    // Get work item ID
                    Number workItemId = (Number) workItemRef.get("id");
                    
                    // Get detailed work item
                    String workItemUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                            organization, project, workItemId.intValue());
                    
                    HttpGet workItemGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                    workItemGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    workItemGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse workItemResponse = httpClient.execute(workItemGet)) {
                        int workItemStatusCode = workItemResponse.getStatusLine().getStatusCode();
                        
                        if (workItemStatusCode == HttpStatus.SC_OK) {
                            String workItemResponseBody = EntityUtils.toString(workItemResponse.getEntity());
                            Map<String, Object> workItem = objectMapper.readValue(workItemResponseBody, Map.class);
                            
                            // Process test case work item
                            importTestCaseWorkItem(integration, importOptions, result, stats, 
                                    workItem, httpClient, organization, project, pat);
                            
                            processed++;
                        } else {
                            stats.setErrors(stats.getErrors() + 1);
                            
                            // Add error to result
                            result.getIssues().add(
                                    new IntegrationImportResult.ImportIssue()
                                            .setSeverity("ERROR")
                                            .setExternalItemId(workItemId.toString())
                                            .setMessage("Failed to get work item: Status code " + workItemStatusCode)
                                            .setCode("WORK_ITEM_ERROR"));
                        }
                    }
                }
                
                stats.setTotalProcessed(processed);
            } else {
                throw new Exception("Failed to execute WIQL query: Status code " + statusCode);
            }
        }
    }
    
    /**
     * Import test cases from an area path
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importTestCasesFromAreaPath(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Create WIQL query for area path
        String areaPath = importOptions.getAdoAreaPath();
        String query = "SELECT [System.Id] FROM WorkItems " +
                "WHERE [System.WorkItemType] = 'Test Case' " +
                "AND [System.AreaPath] UNDER '" + areaPath + "' " +
                "ORDER BY [System.Id]";
        
        // Set query in import options
        importOptions.setAdoWorkItemQuery(query);
        
        // Execute WIQL query
        importTestCasesUsingWiql(integration, importOptions, result, stats, httpClient, organization, project, pat);
    }
    
    /**
     * Import all test cases
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importAllTestCases(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) throws Exception {
        
        // Create WIQL query for all test cases
        String query = "SELECT [System.Id] FROM WorkItems " +
                "WHERE [System.WorkItemType] = 'Test Case' " +
                "ORDER BY [System.Id]";
        
        // Set query in import options
        importOptions.setAdoWorkItemQuery(query);
        
        // Execute WIQL query
        importTestCasesUsingWiql(integration, importOptions, result, stats, httpClient, organization, project, pat);
    }
    
    /**
     * Import a test case work item
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param workItem The work item data
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     */
    private void importTestCaseWorkItem(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            Map<String, Object> workItem,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat) {
        
        try {
            // Extract work item details
            Number id = (Number) workItem.get("id");
            Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
            
            String title = (String) fields.get("System.Title");
            String state = (String) fields.get("System.State");
            String areaPath = (String) fields.get("System.AreaPath");
            String iterationPath = (String) fields.get("System.IterationPath");
            String steps = (String) fields.get("Microsoft.VSTS.TCM.Steps");
            
            // Parse test steps HTML
            List<Map<String, String>> parsedSteps = parseTestStepsHtml(steps);
            
            // Download attachments if needed
            List<File> attachments = new ArrayList<>();
            if (importOptions.isIncludeAttachments()) {
                attachments = downloadWorkItemAttachments(
                        workItem, httpClient, organization, project, pat);
                stats.setAttachmentsImported(stats.getAttachmentsImported() + attachments.size());
            }
            
            // In a real implementation, this would create or update a test case in your repository
            // For now, we'll just log the action and update stats
            logger.info("Importing test case: {} ({})", title, id);
            
            // Check if test case already exists
            boolean exists = false;  // In real impl, check against repository
            String action;
            
            if (exists && importOptions.isOverwriteExisting()) {
                // Update existing test case
                action = "UPDATED";
                stats.setUpdated(stats.getUpdated() + 1);
            } else if (!exists) {
                // Create new test case
                action = "CREATED";
                stats.setCreated(stats.getCreated() + 1);
            } else {
                // Skip existing test case
                action = "SKIPPED";
                stats.setSkipped(stats.getSkipped() + 1);
                return;
            }
            
            // Add to imported items
            IntegrationImportResult.ImportedItem importedItem = new IntegrationImportResult.ImportedItem()
                    .setExternalItemId(id.toString())
                    .setLocalItemId(id.longValue())  // In real impl, use actual local ID
                    .setName(title)
                    .setAction(action);
            
            // Add properties
            Map<String, Object> properties = new HashMap<>();
            properties.put("state", state);
            properties.put("areaPath", areaPath);
            properties.put("iterationPath", iterationPath);
            properties.put("stepCount", parsedSteps.size());
            properties.put("attachmentCount", attachments.size());
            
            importedItem.setProperties(properties);
            result.getImportedItems().add(importedItem);
        } catch (Exception e) {
            // Extract ID for error reporting
            Number id = (Number) workItem.get("id");
            Map<String, Object> fields = (Map<String, Object>) workItem.get("fields");
            String title = (String) fields.get("System.Title");
            
            logger.error("Error importing test case: {} ({})", title, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationImportResult.ImportIssue()
                            .setSeverity("ERROR")
                            .setExternalItemId(id.toString())
                            .setMessage("Failed to import test case: " + e.getMessage())
                            .setCode("IMPORT_ERROR"));
        }
    }
    
    /**
     * Import test suites from Azure DevOps
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     */
    private void importTestSuitesFromAzureDevOps(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Set up import stats
        IntegrationImportResult.ImportStats stats = new IntegrationImportResult.ImportStats();
        
        // Validate test plan ID
        Long testPlanId = importOptions.getAdoTestPlanId();
        if (testPlanId == null) {
            throw new IllegalArgumentException("Test plan ID is required to import test suites");
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            // Get test suites for the plan
            String testSuitesUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites", 
                    organization, project, testPlanId);
            
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testSuitesUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> testSuites = (List<Map<String, Object>>) responseMap.get("value");
                    stats.setTotalFound(testSuites.size());
                    
                    // Skip if dry run
                    if (importOptions.isDryRun()) {
                        stats.setSkipped(testSuites.size());
                        result.setStats(stats);
                        result.setSuccessful(true);
                        result.setMessage("Import dry run completed successfully");
                        return;
                    }
                    
                    // Process each test suite
                    int processed = 0;
                    int maxItems = importOptions.getMaxItems() != null ? importOptions.getMaxItems() : Integer.MAX_VALUE;
                    
                    for (Map<String, Object> testSuite : testSuites) {
                        if (processed >= maxItems) {
                            stats.setSkipped(stats.getSkipped() + (testSuites.size() - processed));
                            break;
                        }
                        
                        importTestSuite(integration, importOptions, result, stats, 
                                testSuite, httpClient, organization, project, pat, testPlanId);
                        processed++;
                    }
                    
                    stats.setTotalProcessed(processed);
                    result.setStats(stats);
                    result.setSuccessful(true);
                    result.setMessage("Import completed successfully");
                } else {
                    throw new Exception("Failed to get test suites: Status code " + statusCode);
                }
            }
        }
    }
    
    /**
     * Import a test suite
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param testSuite The test suite data
     * @param httpClient The HTTP client
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param pat The Personal Access Token
     * @param testPlanId The test plan ID
     */
    private void importTestSuite(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            Map<String, Object> testSuite,
            CloseableHttpClient httpClient,
            String organization,
            String project,
            String pat,
            Long testPlanId) {
        
        try {
            // Extract test suite details
            Number id = (Number) testSuite.get("id");
            String name = (String) testSuite.get("name");
            
            // In a real implementation, this would create or update a test suite in your repository
            // For now, we'll just log the action and update stats
            logger.info("Importing test suite: {} ({})", name, id);
            
            // Check if test suite already exists
            boolean exists = false;  // In real impl, check against repository
            String action;
            
            if (exists && importOptions.isOverwriteExisting()) {
                // Update existing test suite
                action = "UPDATED";
                stats.setUpdated(stats.getUpdated() + 1);
            } else if (!exists) {
                // Create new test suite
                action = "CREATED";
                stats.setCreated(stats.getCreated() + 1);
            } else {
                // Skip existing test suite
                action = "SKIPPED";
                stats.setSkipped(stats.getSkipped() + 1);
                return;
            }
            
            // Import child test cases if requested
            if (importOptions.isIncludeChildren()) {
                // Get test cases for this suite
                String testCasesUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                        organization, project, testPlanId, id.longValue());
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> testCaseRefs = (List<Map<String, Object>>) responseMap.get("value");
                        
                        for (Map<String, Object> testCaseRef : testCaseRefs) {
                            Number testCaseId = (Number) testCaseRef.get("id");
                            
                            // Get detailed test case work item
                            String workItemUrl = String.format(
                                    "https://dev.azure.com/%s/%s/_apis/wit/workitems/%d?$expand=all", 
                                    organization, project, testCaseId.intValue());
                            
                            HttpGet workItemGet = new HttpGet(buildAzureDevOpsUri(workItemUrl));
                            workItemGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                            workItemGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                            
                            try (CloseableHttpResponse workItemResponse = httpClient.execute(workItemGet)) {
                                int workItemStatusCode = workItemResponse.getStatusLine().getStatusCode();
                                
                                if (workItemStatusCode == HttpStatus.SC_OK) {
                                    String workItemResponseBody = EntityUtils.toString(workItemResponse.getEntity());
                                    Map<String, Object> workItem = objectMapper.readValue(workItemResponseBody, Map.class);
                                    
                                    // Count as a child item import
                                    stats.setChildItemsImported(stats.getChildItemsImported() + 1);
                                }
                            }
                        }
                    }
                }
            }
            
            // Add to imported items
            IntegrationImportResult.ImportedItem importedItem = new IntegrationImportResult.ImportedItem()
                    .setExternalItemId(id.toString())
                    .setLocalItemId(id.longValue())  // In real impl, use actual local ID
                    .setName(name)
                    .setAction(action);
            
            // Add properties
            Map<String, Object> properties = new HashMap<>();
            properties.put("testPlanId", testPlanId);
            
            importedItem.setProperties(properties);
            result.getImportedItems().add(importedItem);
        } catch (Exception e) {
            // Extract ID for error reporting
            Number id = (Number) testSuite.get("id");
            String name = (String) testSuite.get("name");
            
            logger.error("Error importing test suite: {} ({})", name, id, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationImportResult.ImportIssue()
                            .setSeverity("ERROR")
                            .setExternalItemId(id.toString())
                            .setMessage("Failed to import test suite: " + e.getMessage())
                            .setCode("IMPORT_ERROR"));
        }
    }
    
    /**
     * Import from Azure DevOps Git
     * 
     * @param integration The integration to import from
     * @param importOptions Import options
     * @param result The import result to update
     */
    private void importFromAzureDevOpsGit(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Set up import stats
        IntegrationImportResult.ImportStats stats = new IntegrationImportResult.ImportStats();
        
        // Get content type
        String contentType = importOptions.getContentType();
        if (contentType == null || contentType.trim().isEmpty()) {
            contentType = "TEST_SCRIPT";  // Default content type
        }
        
        // Import based on content type
        switch (contentType) {
            case "TEST_SCRIPT":
                importTestScriptsFromGit(integration, importOptions, result, stats, 
                        organization, project, repositoryId, pat);
                break;
            default:
                throw new IllegalArgumentException("Unsupported content type for Git import: " + contentType);
        }
        
        result.setStats(stats);
    }
    
    /**
     * Import test scripts from Git
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param repositoryId The repository ID
     * @param pat The Personal Access Token
     */
    private void importTestScriptsFromGit(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            String organization,
            String project,
            String repositoryId,
            String pat) throws Exception {
        
        // Get branch if specified
        String branch = importOptions.getAdoGitBranch();
        if (branch == null || branch.trim().isEmpty()) {
            branch = "main";  // Default branch
        }
        
        // Get path pattern if specified
        String pathPattern = importOptions.getAdoGitPathPattern();
        if (pathPattern == null || pathPattern.trim().isEmpty()) {
            pathPattern = "**/*.js,**/*.ts,**/*.java";  // Default path pattern
        }
        
        // Get file extensions if specified
        List<String> fileExtensions = importOptions.getAdoGitFileExtensions();
        if (fileExtensions == null || fileExtensions.isEmpty()) {
            fileExtensions = Arrays.asList(".js", ".ts", ".java");
        }
        
        // Get commit ID if specified
        String commitId = importOptions.getAdoGitCommitId();
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, importOptions.getProxySettings())) {
            // Get the latest commit ID if not specified
            if (commitId == null || commitId.trim().isEmpty()) {
                String branchUrl = String.format(
                        "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s", 
                        organization, project, repositoryId, branch);
                
                HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchUrl));
                httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                
                try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                    int statusCode = response.getStatusLine().getStatusCode();
                    
                    if (statusCode == HttpStatus.SC_OK) {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                        
                        List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                        if (branches != null && !branches.isEmpty()) {
                            for (Map<String, Object> branchObj : branches) {
                                String name = (String) branchObj.get("name");
                                if (name != null && name.endsWith("/" + branch)) {
                                    // Found the branch
                                    Map<String, Object> objectId = (Map<String, Object>) branchObj.get("objectId");
                                    commitId = (String) objectId;
                                    break;
                                }
                            }
                        }
                    } else {
                        String responseBody = EntityUtils.toString(response.getEntity());
                        throw new Exception("Failed to get branch: Status code " + 
                                statusCode + ", Response: " + responseBody);
                    }
                }
                
                if (commitId == null || commitId.trim().isEmpty()) {
                    throw new Exception("Could not determine latest commit ID for branch: " + branch);
                }
            }
            
            // Get the items in the repository
            String itemsUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/items", 
                    organization, project, repositoryId);
            
            // Build URL with query parameters
            URIBuilder uriBuilder = new URIBuilder(itemsUrl);
            uriBuilder.addParameter("scopePath", "/");
            uriBuilder.addParameter("recursionLevel", "Full");
            uriBuilder.addParameter("includeContentMetadata", "true");
            uriBuilder.addParameter("versionDescriptor.version", commitId);
            uriBuilder.addParameter("versionDescriptor.versionType", "commit");
            uriBuilder.addParameter("api-version", ADO_API_VERSION);
            
            HttpGet httpGet = new HttpGet(uriBuilder.build());
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> items = (List<Map<String, Object>>) responseMap.get("value");
                    
                    // Filter items based on path pattern and file extensions
                    List<Map<String, Object>> filteredItems = new ArrayList<>();
                    
                    for (Map<String, Object> item : items) {
                        String path = (String) item.get("path");
                        boolean isFolder = (boolean) item.get("isFolder");
                        
                        if (!isFolder) {
                            // Check file extension
                            boolean matchesExtension = false;
                            for (String ext : fileExtensions) {
                                if (path.endsWith(ext)) {
                                    matchesExtension = true;
                                    break;
                                }
                            }
                            
                            if (matchesExtension) {
                                // Check path pattern
                                String[] patterns = pathPattern.split(",");
                                for (String pattern : patterns) {
                                    if (matchesPathPattern(path, pattern.trim())) {
                                        filteredItems.add(item);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    stats.setTotalFound(filteredItems.size());
                    
                    // Skip if dry run
                    if (importOptions.isDryRun()) {
                        stats.setSkipped(filteredItems.size());
                        return;
                    }
                    
                    // Check for changed files only
                    if (importOptions.isAdoGitOnlyChangedFiles() && 
                            integration.getMetadata().containsKey("lastImportCommitId")) {
                        
                        String lastCommitId = (String) integration.getMetadata().get("lastImportCommitId");
                        
                        // Get changes between last import and current commit
                        String commitUrl = String.format(
                                "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/diffs/commits", 
                                organization, project, repositoryId);
                        
                        URIBuilder commitUriBuilder = new URIBuilder(commitUrl);
                        commitUriBuilder.addParameter("baseVersion", lastCommitId);
                        commitUriBuilder.addParameter("targetVersion", commitId);
                        commitUriBuilder.addParameter("api-version", ADO_API_VERSION);
                        
                        HttpGet commitGet = new HttpGet(commitUriBuilder.build());
                        commitGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        commitGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        try (CloseableHttpResponse commitResponse = httpClient.execute(commitGet)) {
                            if (commitResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                String commitResponseBody = EntityUtils.toString(commitResponse.getEntity());
                                Map<String, Object> commitResponseMap = objectMapper.readValue(
                                        commitResponseBody, Map.class);
                                
                                List<Map<String, Object>> changes = (List<Map<String, Object>>) 
                                        commitResponseMap.get("changes");
                                
                                // Extract changed file paths
                                Set<String> changedPaths = new HashSet<>();
                                for (Map<String, Object> change : changes) {
                                    String changePath = (String) change.get("item").get("path");
                                    changedPaths.add(changePath);
                                }
                                
                                // Filter items to only changed files
                                List<Map<String, Object>> changedItems = new ArrayList<>();
                                for (Map<String, Object> item : filteredItems) {
                                    String path = (String) item.get("path");
                                    if (changedPaths.contains(path)) {
                                        changedItems.add(item);
                                    }
                                }
                                
                                filteredItems = changedItems;
                                stats.setTotalFound(filteredItems.size());
                            }
                        }
                    }
                    
                    // Download and process each file
                    int maxItems = importOptions.getMaxItems() != null ? importOptions.getMaxItems() : Integer.MAX_VALUE;
                    int processed = 0;
                    
                    for (Map<String, Object> item : filteredItems) {
                        if (processed >= maxItems) {
                            stats.setSkipped(stats.getSkipped() + (filteredItems.size() - processed));
                            break;
                        }
                        
                        String path = (String) item.get("path");
                        String downloadUrl = (String) item.get("url");
                        
                        // Download file content
                        HttpGet contentGet = new HttpGet(downloadUrl);
                        contentGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                        contentGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                        
                        try (CloseableHttpResponse contentResponse = httpClient.execute(contentGet)) {
                            if (contentResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(contentResponse.getEntity());
                                
                                // Process the file
                                importGitTestScript(integration, importOptions, result, stats, path, content);
                                processed++;
                            } else {
                                // Add error
                                String errorBody = EntityUtils.toString(contentResponse.getEntity());
                                result.getIssues().add(
                                        new IntegrationImportResult.ImportIssue()
                                                .setSeverity("ERROR")
                                                .setExternalItemId(path)
                                                .setMessage("Failed to download file: Status code " + 
                                                        contentResponse.getStatusLine().getStatusCode() + 
                                                        ", Response: " + errorBody)
                                                .setCode("DOWNLOAD_ERROR"));
                                
                                stats.setErrors(stats.getErrors() + 1);
                            }
                        }
                    }
                    
                    stats.setTotalProcessed(processed);
                    
                    // Update last import commit ID in integration metadata
                    Map<String, Object> metadata = integration.getMetadata();
                    metadata.put("lastImportCommitId", commitId);
                    integration.setMetadata(metadata);
                    integrationRepository.save(integration);
                    
                    // Set result metadata
                    result.getStats().getAdditionalStats().put("commitId", commitId);
                    result.getStats().getAdditionalStats().put("branch", branch);
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get repository items: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
        }
    }
    
    /**
     * Import a Git test script
     * 
     * @param integration The integration
     * @param importOptions Import options
     * @param result The import result to update
     * @param stats The import stats to update
     * @param path The file path
     * @param content The file content
     */
    private void importGitTestScript(
            Integration integration, 
            IntegrationImportOptions importOptions,
            IntegrationImportResult result,
            IntegrationImportResult.ImportStats stats,
            String path,
            String content) {
        
        try {
            // Create target folder if not exists
            Long targetFolderId = importOptions.getTargetFolderId();
            
            // In a real implementation, this would create or update a test script in your repository
            // For now, we'll just log the action and update stats
            logger.info("Importing test script: {}", path);
            
            // Check if test script already exists
            boolean exists = false;  // In real impl, check against repository
            String action;
            
            if (exists && importOptions.isOverwriteExisting()) {
                // Update existing test script
                action = "UPDATED";
                stats.setUpdated(stats.getUpdated() + 1);
            } else if (!exists) {
                // Create new test script
                action = "CREATED";
                stats.setCreated(stats.getCreated() + 1);
            } else {
                // Skip existing test script
                action = "SKIPPED";
                stats.setSkipped(stats.getSkipped() + 1);
                return;
            }
            
            // Add to imported items
            Long localItemId = System.currentTimeMillis();  // In real impl, use actual local ID
            IntegrationImportResult.ImportedItem importedItem = new IntegrationImportResult.ImportedItem()
                    .setExternalItemId(path)
                    .setLocalItemId(localItemId)
                    .setName(path.substring(path.lastIndexOf('/') + 1))
                    .setAction(action);
            
            // Add properties
            Map<String, Object> properties = new HashMap<>();
            properties.put("path", path);
            properties.put("size", content.length());
            properties.put("targetFolderId", targetFolderId);
            
            importedItem.setProperties(properties);
            result.getImportedItems().add(importedItem);
        } catch (Exception e) {
            logger.error("Error importing test script: {}", path, e);
            stats.setErrors(stats.getErrors() + 1);
            
            // Add error to result
            result.getIssues().add(
                    new IntegrationImportResult.ImportIssue()
                            .setSeverity("ERROR")
                            .setExternalItemId(path)
                            .setMessage("Failed to import test script: " + e.getMessage())
                            .setCode("IMPORT_ERROR"));
        }
    }
    
    @Override
    public IntegrationExportResult exportToIntegration(
            String projectId, String integrationId, IntegrationExportOptions exportOptions) {
        
        logger.info("Exporting to integration: {} for project: {}", integrationId, projectId);
        
        Integration integration = getIntegrationById(projectId, integrationId);
        IntegrationExportResult result = new IntegrationExportResult();
        result.setIntegrationId(integration.getId());
        result.setStartedAt(LocalDateTime.now());
        result.setDryRun(exportOptions != null && exportOptions.isDryRun());
        result.setContentType(exportOptions != null ? exportOptions.getContentType() : null);
        
        long startTime = System.currentTimeMillis();
        
        // Perform export based on integration type
        try {
            if (TYPE_AZURE_DEVOPS.equals(integration.getType())) {
                exportToAzureDevOps(integration, exportOptions, result);
            } else if (TYPE_AZURE_DEVOPS_GIT.equals(integration.getType())) {
                exportToAzureDevOpsGit(integration, exportOptions, result);
            } else {
                result.setSuccessful(false);
                result.setMessage("Unsupported integration type: " + integration.getType());
                result.setErrorCode("UNSUPPORTED_TYPE");
            }
        } catch (Exception e) {
            logger.error("Error during export", e);
            result.setSuccessful(false);
            result.setMessage("Export failed: " + e.getMessage());
            result.setErrorCode("EXPORT_ERROR");
            result.setErrorDetail(e.getMessage());
        }
        
        // Set completion time and duration
        result.setCompletedAt(LocalDateTime.now());
        result.setDurationMs(System.currentTimeMillis() - startTime);
        
        return result;
    }
    
    /**
     * Export to Azure DevOps
     * 
     * @param integration The integration to export to
     * @param exportOptions Export options
     * @param result The export result to update
     */
    private void exportToAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Validate content type
        String contentType = exportOptions.getContentType();
        if (contentType == null || contentType.trim().isEmpty()) {
            contentType = "TEST_RESULT";  // Default content type
        }
        
        // Export based on content type
        switch (contentType) {
            case "TEST_RESULT":
                exportTestResultsToAzureDevOps(integration, exportOptions, result);
                break;
            default:
                throw new IllegalArgumentException("Unsupported content type for export: " + contentType);
        }
    }
    
    /**
     * Export test results to Azure DevOps
     * 
     * @param integration The integration to export to
     * @param exportOptions Export options
     * @param result The export result to update
     */
    private void exportTestResultsToAzureDevOps(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String pat = (String) settings.get("pat");
        
        // Set up export stats
        IntegrationExportResult.ExportStats stats = new IntegrationExportResult.ExportStats();
        
        // Get test plan ID and test suite ID
        Long testPlanId = exportOptions.getAdoTestPlanId();
        Long testSuiteId = exportOptions.getAdoTestSuiteId();
        
        if (testPlanId == null || testSuiteId == null) {
            throw new IllegalArgumentException("Test plan ID and test suite ID are required to export test results");
        }
        
        // Skip if dry run
        if (exportOptions.isDryRun()) {
            logger.info("Dry run: Skipping export of test results");
            stats.setSkipped(10);  // Simulate 10 skipped results
            result.setStats(stats);
            result.setSuccessful(true);
            result.setMessage("Export dry run completed successfully");
            return;
        }
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            // Create a test run
            String testRunTitleFormat = exportOptions.getAdoTestRunTitleFormat();
            if (testRunTitleFormat == null || testRunTitleFormat.trim().isEmpty()) {
                testRunTitleFormat = "Test Run - {date}";
            }
            
            // Apply format
            String testRunTitle = testRunTitleFormat
                    .replace("{date}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE))
                    .replace("{time}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME))
                    .replace("{datetime}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
            
            Map<String, Object> testRunPayload = new HashMap<>();
            testRunPayload.put("name", testRunTitle);
            testRunPayload.put("plan", new HashMap<String, Object>() {{
                put("id", testPlanId);
            }});
            
            // Add test suite ID
            List<Map<String, Object>> testSuites = new ArrayList<>();
            testSuites.add(new HashMap<String, Object>() {{
                put("id", testSuiteId);
            }});
            testRunPayload.put("testSuites", testSuites);
            
            // Create test run
            String testRunsUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/test/runs", 
                    organization, project);
            
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(testRunsUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            StringEntity entity = new StringEntity(
                    objectMapper.writeValueAsString(testRunPayload),
                    ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> testRun = objectMapper.readValue(responseBody, Map.class);
                    
                    // Get test run ID
                    Number testRunId = (Number) testRun.get("id");
                    
                    // Add test run info to result
                    result.setAdoTestRunId(testRunId.longValue());
                    result.setAdoTestRunUrl(String.format(
                            "https://dev.azure.com/%s/%s/_test/runs/%d", 
                            organization, project, testRunId.longValue()));
                    
                    // Get test cases in the test suite
                    String testCasesUrl = String.format(
                            "https://dev.azure.com/%s/%s/_apis/test/plans/%d/suites/%d/testcases", 
                            organization, project, testPlanId, testSuiteId);
                    
                    HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(testCasesUrl));
                    httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                    httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                    
                    try (CloseableHttpResponse testCasesResponse = httpClient.execute(httpGet)) {
                        if (testCasesResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                            String testCasesResponseBody = EntityUtils.toString(testCasesResponse.getEntity());
                            Map<String, Object> testCasesResponseMap = objectMapper.readValue(
                                    testCasesResponseBody, Map.class);
                            
                            List<Map<String, Object>> testCaseRefs = (List<Map<String, Object>>) 
                                    testCasesResponseMap.get("value");
                            
                            stats.setTotalSelected(testCaseRefs.size());
                            
                            // In a real implementation, this would fetch test results from your repository
                            // For now, we'll generate sample test results
                            
                            // Generate test results
                            List<Map<String, Object>> testResults = new ArrayList<>();
                            
                            // Get item IDs if specified
                            List<Long> itemIds = exportOptions.getItemIds();
                            
                            if (itemIds != null && !itemIds.isEmpty()) {
                                // Generate test results for specific items
                                for (Map<String, Object> testCaseRef : testCaseRefs) {
                                    Number testCaseId = (Number) testCaseRef.get("id");
                                    
                                    if (itemIds.contains(testCaseId.longValue())) {
                                        // Generate test result
                                        String[] outcomes = {"Passed", "Failed", "NotExecuted"};
                                        String outcome = outcomes[new Random().nextInt(outcomes.length)];
                                        
                                        Map<String, Object> testResult = new HashMap<>();
                                        testResult.put("testCase", new HashMap<String, Object>() {{
                                            put("id", testCaseId);
                                        }});
                                        testResult.put("outcome", outcome);
                                        testResult.put("state", "Completed");
                                        testResult.put("comment", "Automated test result");
                                        testResult.put("startedDate", LocalDateTime.now().minusMinutes(5)
                                                .format(DATETIME_FORMATTER));
                                        testResult.put("completedDate", LocalDateTime.now()
                                                .format(DATETIME_FORMATTER));
                                        
                                        testResults.add(testResult);
                                    }
                                }
                            } else {
                                // Generate test results for all test cases
                                for (Map<String, Object> testCaseRef : testCaseRefs) {
                                    Number testCaseId = (Number) testCaseRef.get("id");
                                    
                                    // Generate test result
                                    String[] outcomes = {"Passed", "Failed", "NotExecuted"};
                                    String outcome = outcomes[new Random().nextInt(outcomes.length)];
                                    
                                    Map<String, Object> testResult = new HashMap<>();
                                    testResult.put("testCase", new HashMap<String, Object>() {{
                                        put("id", testCaseId);
                                    }});
                                    testResult.put("outcome", outcome);
                                    testResult.put("state", "Completed");
                                    testResult.put("comment", "Automated test result");
                                    testResult.put("startedDate", LocalDateTime.now().minusMinutes(5)
                                            .format(DATETIME_FORMATTER));
                                    testResult.put("completedDate", LocalDateTime.now()
                                            .format(DATETIME_FORMATTER));
                                    
                                    testResults.add(testResult);
                                }
                            }
                            
                            int maxItems = exportOptions.getMaxItems() != null ? 
                                    exportOptions.getMaxItems() : Integer.MAX_VALUE;
                            
                            if (testResults.size() > maxItems) {
                                testResults = testResults.subList(0, maxItems);
                            }
                            
                            stats.setTotalProcessed(testResults.size());
                            
                            // Submit test results
                            String testResultsUrl = String.format(
                                    "https://dev.azure.com/%s/%s/_apis/test/runs/%d/results", 
                                    organization, project, testRunId.longValue());
                            
                            HttpPost testResultsPost = new HttpPost(buildAzureDevOpsUri(testResultsUrl));
                            testResultsPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                            testResultsPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                            testResultsPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                            
                            StringEntity testResultsEntity = new StringEntity(
                                    objectMapper.writeValueAsString(testResults),
                                    ContentType.APPLICATION_JSON);
                            testResultsPost.setEntity(testResultsEntity);
                            
                            try (CloseableHttpResponse testResultsResponse = httpClient.execute(testResultsPost)) {
                                int testResultsStatusCode = testResultsResponse.getStatusLine().getStatusCode();
                                
                                if (testResultsStatusCode == HttpStatus.SC_OK 
                                        || testResultsStatusCode == HttpStatus.SC_CREATED) {
                                    
                                    String testResultsResponseBody = EntityUtils.toString(testResultsResponse.getEntity());
                                    List<Map<String, Object>> createdTestResults = (List<Map<String, Object>>) 
                                            objectMapper.readValue(testResultsResponseBody, Map.class).get("value");
                                    
                                    // Update stats
                                    stats.setCreated(createdTestResults.size());
                                    
                                    // Add exported items
                                    for (Map<String, Object> createdTestResult : createdTestResults) {
                                        Number testResultId = (Number) createdTestResult.get("id");
                                        Number testCaseId = (Number) ((Map<String, Object>) createdTestResult.get("testCase")).get("id");
                                        String outcome = (String) createdTestResult.get("outcome");
                                        
                                        IntegrationExportResult.ExportedItem exportedItem = 
                                                new IntegrationExportResult.ExportedItem()
                                                        .setLocalItemId(testCaseId.longValue())
                                                        .setExternalItemId(testResultId.toString())
                                                        .setName("Test Result for Test Case " + testCaseId)
                                                        .setAction("CREATED")
                                                        .setExternalUrl(String.format(
                                                                "https://dev.azure.com/%s/%s/_test/runs/%d/results/%d", 
                                                                organization, project, 
                                                                testRunId.longValue(), testResultId.longValue()));
                                        
                                        // Add properties
                                        Map<String, Object> properties = new HashMap<>();
                                        properties.put("outcome", outcome);
                                        properties.put("testCaseId", testCaseId);
                                        properties.put("testRunId", testRunId);
                                        
                                        exportedItem.setProperties(properties);
                                        result.getExportedItems().add(exportedItem);
                                    }
                                    
                                    // Track passed/failed counts
                                    Map<String, AtomicInteger> outcomeCounts = new HashMap<>();
                                    for (Map<String, Object> createdTestResult : createdTestResults) {
                                        String outcome = (String) createdTestResult.get("outcome");
                                        outcomeCounts.computeIfAbsent(outcome, k -> new AtomicInteger(0))
                                                .incrementAndGet();
                                    }
                                    
                                    for (Map.Entry<String, AtomicInteger> entry : outcomeCounts.entrySet()) {
                                        stats.getAdditionalStats().put(entry.getKey(), entry.getValue().get());
                                    }
                                    
                                    // Close the test run
                                    String updateTestRunUrl = String.format(
                                            "https://dev.azure.com/%s/%s/_apis/test/runs/%d", 
                                            organization, project, testRunId.longValue());
                                    
                                    Map<String, Object> updateTestRunPayload = new HashMap<>();
                                    updateTestRunPayload.put("state", "Completed");
                                    
                                    HttpPatch httpPatch = new HttpPatch(buildAzureDevOpsUri(updateTestRunUrl));
                                    httpPatch.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
                                    httpPatch.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
                                    httpPatch.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
                                    
                                    StringEntity updateEntity = new StringEntity(
                                            objectMapper.writeValueAsString(updateTestRunPayload),
                                            ContentType.APPLICATION_JSON);
                                    httpPatch.setEntity(updateEntity);
                                    
                                    try (CloseableHttpResponse updateResponse = httpClient.execute(httpPatch)) {
                                        if (updateResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                            logger.info("Test run completed successfully");
                                        } else {
                                            logger.warn("Failed to complete test run: Status code {}", 
                                                    updateResponse.getStatusLine().getStatusCode());
                                            
                                            result.getIssues().add(
                                                    new IntegrationExportResult.ExportIssue()
                                                            .setSeverity("WARNING")
                                                            .setMessage("Failed to complete test run")
                                                            .setCode("COMPLETE_TEST_RUN_ERROR"));
                                        }
                                    }
                                    
                                    // Set result
                                    result.setStats(stats);
                                    result.setSuccessful(true);
                                    result.setMessage("Exported " + createdTestResults.size() + " test results successfully");
                                    
                                    // Add URLs
                                    result.getExportedUrls().put("testRun", result.getAdoTestRunUrl());
                                } else {
                                    String errorBody = EntityUtils.toString(testResultsResponse.getEntity());
                                    throw new Exception("Failed to submit test results: Status code " + 
                                            testResultsStatusCode + ", Response: " + errorBody);
                                }
                            }
                        } else {
                            String errorBody = EntityUtils.toString(testCasesResponse.getEntity());
                            throw new Exception("Failed to get test cases: Status code " + 
                                    testCasesResponse.getStatusLine().getStatusCode() + 
                                    ", Response: " + errorBody);
                        }
                    }
                } else {
                    String errorBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to create test run: Status code " + 
                            statusCode + ", Response: " + errorBody);
                }
            }
        }
    }
    
    /**
     * Export to Azure DevOps Git
     * 
     * @param integration The integration to export to
     * @param exportOptions Export options
     * @param result The export result to update
     */
    private void exportToAzureDevOpsGit(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result) throws Exception {
        
        // Extract settings
        Map<String, Object> settings = integration.getSettings();
        String organization = (String) settings.get("organization");
        String project = (String) settings.get("project");
        String repositoryId = (String) settings.get("repositoryId");
        String pat = (String) settings.get("pat");
        
        // Set up export stats
        IntegrationExportResult.ExportStats stats = new IntegrationExportResult.ExportStats();
        
        // Validate content type
        String contentType = exportOptions.getContentType();
        if (contentType == null || contentType.trim().isEmpty()) {
            contentType = "TEST_RESULT";  // Default content type
        }
        
        // Get branch if specified
        String branch = exportOptions.getAdoGitBranch();
        if (branch == null || branch.trim().isEmpty()) {
            branch = "main";  // Default branch
        }
        
        // Get base path if specified
        String basePath = exportOptions.getAdoGitBasePath();
        if (basePath == null || basePath.trim().isEmpty()) {
            basePath = "test-results/";
        }
        
        // Ensure base path ends with slash
        if (!basePath.endsWith("/")) {
            basePath += "/";
        }
        
        // Get file format if specified
        String fileFormat = exportOptions.getAdoGitFileFormat();
        if (fileFormat == null || fileFormat.trim().isEmpty()) {
            fileFormat = "HTML";
        }
        
        // Skip if dry run
        if (exportOptions.isDryRun()) {
            logger.info("Dry run: Skipping export to Git");
            stats.setSkipped(1);  // Simulate 1 skipped export
            result.setStats(stats);
            result.setSuccessful(true);
            result.setMessage("Export dry run completed successfully");
            return;
        }
        
        // Export based on content type
        switch (contentType) {
            case "TEST_RESULT":
                exportTestResultsToGit(integration, exportOptions, result, stats,
                        organization, project, repositoryId, pat, branch, basePath, fileFormat);
                break;
            default:
                throw new IllegalArgumentException("Unsupported content type for Git export: " + contentType);
        }
    }
    
    /**
     * Export test results to Git
     * 
     * @param integration The integration
     * @param exportOptions Export options
     * @param result The export result to update
     * @param stats The export stats to update
     * @param organization The Azure DevOps organization
     * @param project The Azure DevOps project
     * @param repositoryId The repository ID
     * @param pat The Personal Access Token
     * @param branch The branch
     * @param basePath The base path
     * @param fileFormat The file format
     */
    private void exportTestResultsToGit(
            Integration integration, 
            IntegrationExportOptions exportOptions,
            IntegrationExportResult result,
            IntegrationExportResult.ExportStats stats,
            String organization,
            String project,
            String repositoryId,
            String pat,
            String branch,
            String basePath,
            String fileFormat) throws Exception {
        
        try (CloseableHttpClient httpClient = createAzureDevOpsHttpClient(integration, exportOptions.getProxySettings())) {
            // Get the latest commit ID for the branch
            String branchUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/refs?filter=heads/%s", 
                    organization, project, repositoryId, branch);
            
            HttpGet httpGet = new HttpGet(buildAzureDevOpsUri(branchUrl));
            httpGet.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpGet.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            String oldCommitId = null;
            
            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> responseMap = objectMapper.readValue(responseBody, Map.class);
                    
                    List<Map<String, Object>> branches = (List<Map<String, Object>>) responseMap.get("value");
                    if (branches != null && !branches.isEmpty()) {
                        for (Map<String, Object> branchObj : branches) {
                            String name = (String) branchObj.get("name");
                            if (name != null && name.endsWith("/" + branch)) {
                                // Found the branch
                                oldCommitId = (String) branchObj.get("objectId");
                                break;
                            }
                        }
                    }
                } else {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to get branch: Status code " + 
                            statusCode + ", Response: " + responseBody);
                }
            }
            
            if (oldCommitId == null) {
                throw new Exception("Could not determine latest commit ID for branch: " + branch);
            }
            
            // In a real implementation, this would get test results from your repository
            // Here we'll generate a sample test result file
            
            // Generate timestamp for file name
            String timestamp = LocalDateTime.now().format(
                    DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            
            // Generate file content based on format
            String fileName;
            String fileContent;
            
            if ("HTML".equalsIgnoreCase(fileFormat)) {
                fileName = "test-report-" + timestamp + ".html";
                fileContent = generateSampleTestReport();
            } else if ("MARKDOWN".equalsIgnoreCase(fileFormat)) {
                fileName = "test-report-" + timestamp + ".md";
                fileContent = generateSampleTestReportMarkdown();
            } else if ("JSON".equalsIgnoreCase(fileFormat)) {
                fileName = "test-report-" + timestamp + ".json";
                fileContent = generateSampleTestReportJson();
            } else if ("XML".equalsIgnoreCase(fileFormat)) {
                fileName = "test-report-" + timestamp + ".xml";
                fileContent = generateSampleTestReportXml();
            } else {
                // Default to HTML
                fileName = "test-report-" + timestamp + ".html";
                fileContent = generateSampleTestReport();
            }
            
            String filePath = basePath + fileName;
            
            // Create commit message
            String commitMessageFormat = exportOptions.getAdoGitCommitMessageFormat();
            if (commitMessageFormat == null || commitMessageFormat.trim().isEmpty()) {
                commitMessageFormat = "Add test results report: {date}";
            }
            
            // Apply format
            String commitMessage = commitMessageFormat
                    .replace("{date}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE))
                    .replace("{time}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME))
                    .replace("{datetime}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
                    .replace("{filename}", fileName);
            
            // Create push request
            Map<String, Object> pushRequest = new HashMap<>();
            pushRequest.put("refUpdates", Arrays.asList(
                    new HashMap<String, Object>() {{
                        put("name", "refs/heads/" + branch);
                        put("oldObjectId", oldCommitId);
                    }}
            ));
            
            List<Map<String, Object>> commits = new ArrayList<>();
            Map<String, Object> commit = new HashMap<>();
            commit.put("comment", commitMessage);
            
            List<Map<String, Object>> changes = new ArrayList<>();
            Map<String, Object> change = new HashMap<>();
            change.put("changeType", "add");
            change.put("item", new HashMap<String, Object>() {{
                put("path", filePath);
            }});
            change.put("newContent", new HashMap<String, Object>() {{
                put("content", fileContent);
                put("contentType", "rawtext");
            }});
            
            changes.add(change);
            commit.put("changes", changes);
            commits.add(commit);
            pushRequest.put("commits", commits);
            
            // Push to Git
            String pushUrl = String.format(
                    "https://dev.azure.com/%s/%s/_apis/git/repositories/%s/pushes", 
                    organization, project, repositoryId);
            
            HttpPost httpPost = new HttpPost(buildAzureDevOpsUri(pushUrl));
            httpPost.setHeader(HttpHeaders.CONTENT_TYPE, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType());
            httpPost.setHeader(HttpHeaders.AUTHORIZATION, getAzureDevOpsAuthHeader(pat));
            
            StringEntity entity = new StringEntity(
                    objectMapper.writeValueAsString(pushRequest),
                    ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            
            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                
                if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                    String responseBody = EntityUtils.toString(response.getEntity());
                    Map<String, Object> pushResponse = objectMapper.readValue(responseBody, Map.class);
                    
                    // Get commit ID
                    List<Map<String, Object>> pushedCommits = (List<Map<String, Object>>) pushResponse.get("commits");
                    if (pushedCommits != null && !pushedCommits.isEmpty()) {
                        String commitId = (String) pushedCommits.get(0).get("commitId");
                        
                        // Add commit info to result
                        result.setAdoGitCommitId(commitId);
                        result.setAdoGitCommitUrl(String.format(
                                "https://dev.azure.com/%s/%s/_git/%s/commit/%s", 
                                organization, project, repositoryId, commitId));
                    }
                    
                    // Add file URL
                    result.getExportedUrls().put("file", String.format(
                            "https://dev.azure.com/%s/%s/_git/%s?path=%s", 
                            organization, project, repositoryId, 
                            filePath.replace("/", "%2F")));
                    
                    // Update stats
                    stats.setTotalSelected(1);
                    stats.setTotalProcessed(1);
                    stats.setCreated(1);
                    
                    // Add exported item
                    IntegrationExportResult.ExportedItem exportedItem = new IntegrationExportResult.ExportedItem()
                            .setLocalItemId(0L)  // No specific local item
                            .setExternalItemId(filePath)
                            .setName(fileName)
                            .setAction("CREATED")
                            .setExternalUrl(result.getExportedUrls().get("file"));
                    
                    result.getExportedItems().add(exportedItem);
                    
                    // Set result
                    result.setStats(stats);
                    result.setSuccessful(true);
                    result.setMessage("Exported test results report to Git successfully");
                } else {
                    String errorBody = EntityUtils.toString(response.getEntity());
                    throw new Exception("Failed to push to Git: Status code " + 
                            statusCode + ", Response: " + errorBody);
                }
            }
        }
    }
    
    /**
     * Generate a sample test report in Markdown format
     * 
     * @return Markdown test report
     */
    private String generateSampleTestReportMarkdown() {
        StringBuilder markdown = new StringBuilder();
        markdown.append("# Test Execution Report\n\n");
        
        markdown.append("## Summary\n\n");
        markdown.append("- **Execution Date:** " + 
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "\n");
        markdown.append("- **Executed By:** CS Test Forge\n");
        markdown.append("- **Summary:** 10 Tests (7 Passed, 2 Failed, 1 Blocked)\n\n");
        
        markdown.append("## Test Results\n\n");
        markdown.append("| ID | Test Case | Status | Duration (s) | Comments |\n");
        markdown.append("|---|-----------|--------|--------------|----------|\n");
        
        // Generate sample test results
        String[] statuses = {"Pass", "Pass", "Pass", "Fail", "Pass", "Pass", "Block", "Pass", "Fail", "Pass"};
        String[] testCases = {
                "Login with valid credentials", 
                "Login with invalid credentials", 
                "Password reset functionality", 
                "User registration with existing email", 
                "User profile update", 
                "Search functionality", 
                "Payment processing with invalid card", 
                "Product filtering", 
                "Checkout with empty cart", 
                "Logout functionality"};
        
        Random random = new Random();
        
        for (int i = 0; i < 10; i++) {
            String status = statuses[i];
            String testCase = testCases[i];
            int duration = random.nextInt(10) + 1;  // 1-10 seconds
            
            markdown.append("| TC-").append(i+1).append(" | ")
                    .append(testCase).append(" | ")
                    .append(status).append(" | ")
                    .append(duration).append(" | ");
            
            if ("Fail".equals(status)) {
                markdown.append("Failed assertion: Expected result not achieved |\n");
            } else if ("Block".equals(status)) {
                markdown.append("Test blocked due to dependency failure |\n");
            } else {
                markdown.append("Test executed successfully |\n");
            }
        }
        
        return markdown.toString();
    }
    
    /**
     * Generate a sample test report in JSON format
     * 
     * @return JSON test report
     */
    private String generateSampleTestReportJson() {
        Map<String, Object> report = new HashMap<>();
        
        // Add metadata
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("executionDate", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        metadata.put("executedBy", "CS Test Forge");
        metadata.put("totalTests", 10);
        metadata.put("passed", 7);
        metadata.put("failed", 2);
        metadata.put("blocked", 1);
        
        report.put("metadata", metadata);
        
        // Generate test results
        String[] statuses = {"PASS", "PASS", "PASS", "FAIL", "PASS", "PASS", "BLOCK", "PASS", "FAIL", "PASS"};
        String[] testCases = {
                "Login with valid credentials", 
                "Login with invalid credentials", 
                "Password reset functionality", 
                "User registration with existing email", 
                "User profile update", 
                "Search functionality", 
                "Payment processing with invalid card", 
                "Product filtering", 
                "Checkout with empty cart", 
                "Logout functionality"};
        
        Random random = new Random();
        List<Map<String, Object>> testResults = new ArrayList<>();
        
        for (int i = 0; i < 10; i++) {
            String status = statuses[i];
            String testCase = testCases[i];
            int duration = random.nextInt(10) + 1;  // 1-10 seconds
            
            Map<String, Object> result = new HashMap<>();
            result.put("id", "TC-" + (i+1));
            result.put("name", testCase);
            result.put("status", status);
            result.put("duration", duration);
            
            if ("FAIL".equals(status)) {
                result.put("comment", "Failed assertion: Expected result not achieved");
            } else if ("BLOCK".equals(status)) {
                result.put("comment", "Test blocked due to dependency failure");
            } else {
                result.put("comment", "Test executed successfully");
            }
            
            testResults.add(result);
        }
        
        report.put("testResults", testResults);
        
        try {
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(report);
        } catch (JsonProcessingException e) {
            logger.error("Error generating JSON test report", e);
            return "{ \"error\": \"Failed to generate JSON report\" }";
        }
    }
    
    /**
     * Generate a sample test report in XML format
     * 
     * @return XML test report
     */
    private String generateSampleTestReportXml() {
        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        xml.append("<testReport>\n");
        
        // Add metadata
        xml.append("  <metadata>\n");
        xml.append("    <executionDate>").append(
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)).append("</executionDate>\n");
        xml.append("    <executedBy>CS Test Forge</executedBy>\n");
        xml.append("    <summary>\n");
        xml.append("      <totalTests>10</totalTests>\n");
        xml.append("      <passed>7</passed>\n");
        xml.append("      <failed>2</failed>\n");
        xml.append("      <blocked>1</blocked>\n");
        xml.append("    </summary>\n");
        xml.append("  </metadata>\n");
        
        // Generate test results
        String[] statuses = {"PASS", "PASS", "PASS", "FAIL", "PASS", "PASS", "BLOCK", "PASS", "FAIL", "PASS"};
        String[] testCases = {
                "Login with valid credentials", 
                "Login with invalid credentials", 
                "Password reset functionality", 
                "User registration with existing email", 
                "User profile update", 
                "Search functionality", 
                "Payment processing with invalid card", 
                "Product filtering", 
                "Checkout with empty cart", 
                "Logout functionality"};
        
        Random random = new Random();
        
        xml.append("  <testResults>\n");
        
        for (int i = 0; i < 10; i++) {
            String status = statuses[i];
            String testCase = testCases[i];
            int duration = random.nextInt(10) + 1;  // 1-10 seconds
            
            xml.append("    <testResult>\n");
            xml.append("      <id>TC-").append(i+1).append("</id>\n");
            xml.append("      <name>").append(escapeXml(testCase)).append("</name>\n");
            xml.append("      <status>").append(status).append("</status>\n");
            xml.append("      <duration>").append(duration).append("</duration>\n");
            
            if ("FAIL".equals(status)) {
                xml.append("      <comment>Failed assertion: Expected result not achieved</comment>\n");
            } else if ("BLOCK".equals(status)) {
                xml.append("      <comment>Test blocked due to dependency failure</comment>\n");
            } else {
                xml.append("      <comment>Test executed successfully</comment>\n");
            }
            
            xml.append("    </testResult>\n");
        }
        
        xml.append("  </testResults>\n");
        xml.append("</testReport>");
        
        return xml.toString();
    }
    
    /**
     * Escape XML special characters
     * 
     * @param input Input string
     * @return Escaped string
     */
    private String escapeXml(String input) {
        return input.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&apos;");
    }
    
    @Override
    public List<IntegrationType> getAvailableIntegrationTypes() {
        logger.info("Getting available integration types");
        
        List<IntegrationType> types = new ArrayList<>();
        
        // Add Azure DevOps integration type
        IntegrationType adoType = new IntegrationType()
                .setId(TYPE_AZURE_DEVOPS)
                .setName("Azure DevOps")
                .setDescription("Integration with Azure DevOps for test case management")
                .setIconUrl("/assets/images/integrations/azure-devops.png")
                .setSupportedFeatures(Arrays.asList(
                        "TEST_CASE_IMPORT", 
                        "TEST_RESULT_EXPORT", 
                        "TEST_SUITE_SYNC"))
                .setVersion("1.0")
                .setEnabled(true);
        
        types.add(adoType);
        
        // Add Azure DevOps Git integration type
        IntegrationType adoGitType = new IntegrationType()
                .setId(TYPE_AZURE_DEVOPS_GIT)
                .setName("Azure DevOps Git")
                .setDescription("Integration with Azure DevOps Git repositories")
                .setIconUrl("/assets/images/integrations/azure-devops-git.png")
                .setSupportedFeatures(Arrays.asList(
                        "TEST_SCRIPT_IMPORT", 
                        "TEST_RESULT_EXPORT"))
                .setVersion("1.0")
                .setEnabled(true);
        
        types.add(adoGitType);
        
        return types;
    }
    
    @Override
    public IntegrationSettingsSchema getSettingsSchemaForType(String type) {
        logger.info("Getting settings schema for integration type: {}", type);
        
        validateIntegrationType(type);
        
        // Get schema from cache
        IntegrationSettingsSchema schema = settingsSchemas.get(type);
        
        if (schema == null) {
            // Create schema on the fly
            switch (type) {
                case TYPE_AZURE_DEVOPS:
                    schema = createAzureDevOpsSettingsSchema();
                    break;
                case TYPE_AZURE_DEVOPS_GIT:
                    schema = createAzureDevOpsGitSettingsSchema();
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported integration type: " + type);
            }
            
            // Cache schema
            settingsSchemas.put(type, schema);
        }
        
        return schema;
    }
    
    /**
     * Create settings schema for Azure DevOps integration
     * 
     * @return Settings schema
     */
    private IntegrationSettingsSchema createAzureDevOpsSettingsSchema() {
        IntegrationSettingsSchema schema = new IntegrationSettingsSchema()
                .setIntegrationType(TYPE_AZURE_DEVOPS)
                .setVersion("1.0");
        
        List<IntegrationSettingsSchema.SettingsField> fields = new ArrayList<>();
        
        // Organization field
        IntegrationSettingsSchema.SettingsField orgField = new IntegrationSettingsSchema.SettingsField()
                .setId("organization")
                .setName("Organization")
                .setDescription("Azure DevOps organization name")
                .setType("text")
                .setRequired(true);
        
        fields.add(orgField);
        
        // Project field
        IntegrationSettingsSchema.SettingsField projectField = new IntegrationSettingsSchema.SettingsField()
                .setId("project")
                .setName("Project")
                .setDescription("Azure DevOps project name")
                .setType("text")
                .setRequired(true);
        
        fields.add(projectField);
        
        // PAT field
        IntegrationSettingsSchema.SettingsField patField = new IntegrationSettingsSchema.SettingsField()
                .setId("pat")
                .setName("Personal Access Token")
                .setDescription("Azure DevOps Personal Access Token with appropriate permissions")
                .setType("password")
                .setRequired(true);
        
        fields.add(patField);
        
        // Proxy settings
        IntegrationSettingsSchema.SettingsField proxyHostField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyHost")
                .setName("Proxy Host")
                .setDescription("Proxy server hostname")
                .setType("text")
                .setRequired(false);
        
        fields.add(proxyHostField);
        
        IntegrationSettingsSchema.SettingsField proxyPortField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyPort")
                .setName("Proxy Port")
                .setDescription("Proxy server port")
                .setType("number")
                .setRequired(false);
        
        fields.add(proxyPortField);
        
        IntegrationSettingsSchema.SettingsField proxyUserField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyUsername")
                .setName("Proxy Username")
                .setDescription("Username for proxy authentication")
                .setType("text")
                .setRequired(false);
        
        fields.add(proxyUserField);
        
        IntegrationSettingsSchema.SettingsField proxyPassField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyPassword")
                .setName("Proxy Password")
                .setDescription("Password for proxy authentication")
                .setType("password")
                .setRequired(false);
        
        fields.add(proxyPassField);
        
        schema.setFields(fields);
        
        return schema;
    }
    
    /**
     * Create settings schema for Azure DevOps Git integration
     * 
     * @return Settings schema
     */
    private IntegrationSettingsSchema createAzureDevOpsGitSettingsSchema() {
        IntegrationSettingsSchema schema = new IntegrationSettingsSchema()
                .setIntegrationType(TYPE_AZURE_DEVOPS_GIT)
                .setVersion("1.0");
        
        List<IntegrationSettingsSchema.SettingsField> fields = new ArrayList<>();
        
        // Organization field
        IntegrationSettingsSchema.SettingsField orgField = new IntegrationSettingsSchema.SettingsField()
                .setId("organization")
                .setName("Organization")
                .setDescription("Azure DevOps organization name")
                .setType("text")
                .setRequired(true);
        
        fields.add(orgField);
        
        // Project field
        IntegrationSettingsSchema.SettingsField projectField = new IntegrationSettingsSchema.SettingsField()
                .setId("project")
                .setName("Project")
                .setDescription("Azure DevOps project name")
                .setType("text")
                .setRequired(true);
        
        fields.add(projectField);
        
        // Repository ID field
        IntegrationSettingsSchema.SettingsField repoField = new IntegrationSettingsSchema.SettingsField()
                .setId("repositoryId")
                .setName("Repository ID")
                .setDescription("Azure DevOps Git repository ID")
                .setType("text")
                .setRequired(true);
        
        fields.add(repoField);
        
        // PAT field
        IntegrationSettingsSchema.SettingsField patField = new IntegrationSettingsSchema.SettingsField()
                .setId("pat")
                .setName("Personal Access Token")
                .setDescription("Azure DevOps Personal Access Token with appropriate permissions")
                .setType("password")
                .setRequired(true);
        
        fields.add(patField);
        
        // Default branch field
        IntegrationSettingsSchema.SettingsField branchField = new IntegrationSettingsSchema.SettingsField()
                .setId("defaultBranch")
                .setName("Default Branch")
                .setDescription("Default Git branch name")
                .setType("text")
                .setRequired(false)
                .setDefaultValue("main");
        
        fields.add(branchField);
        
        // Proxy settings
        IntegrationSettingsSchema.SettingsField proxyHostField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyHost")
                .setName("Proxy Host")
                .setDescription("Proxy server hostname")
                .setType("text")
                .setRequired(false);
        
        fields.add(proxyHostField);
        
        IntegrationSettingsSchema.SettingsField proxyPortField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyPort")
                .setName("Proxy Port")
                .setDescription("Proxy server port")
                .setType("number")
                .setRequired(false);
        
        fields.add(proxyPortField);
        
        IntegrationSettingsSchema.SettingsField proxyUserField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyUsername")
                .setName("Proxy Username")
                .setDescription("Username for proxy authentication")
                .setType("text")
                .setRequired(false);
        
        fields.add(proxyUserField);
        
        IntegrationSettingsSchema.SettingsField proxyPassField = new IntegrationSettingsSchema.SettingsField()
                .setId("proxyPassword")
                .setName("Proxy Password")
                .setDescription("Password for proxy authentication")
                .setType("password")
                .setRequired(false);
        
        fields.add(proxyPassField);
        
        schema.setFields(fields);
        
        return schema;
    }
    
    /**
     * Load settings schemas from configuration directory
     */
    private void loadSettingsSchemas() {
        Path schemasDir = Paths.get(schemasDirectory);
        
        if (!Files.exists(schemasDir)) {
            logger.info("Creating integration schemas directory: {}", schemasDir);
            try {
                Files.createDirectories(schemasDir);
            } catch (IOException e) {
                logger.error("Failed to create integration schemas directory", e);
                return;
            }
        }
        
        logger.info("Loading integration settings schemas from: {}", schemasDir);
        
        try (Stream<Path> paths = Files.list(schemasDir)) {
            paths.filter(path -> path.toString().endsWith(".json"))
                    .forEach(path -> {
                        try {
                            IntegrationSettingsSchema schema = objectMapper.readValue(
                                    path.toFile(), IntegrationSettingsSchema.class);
                            
                            if (schema.getIntegrationType() != null) {
                                settingsSchemas.put(schema.getIntegrationType(), schema);
                                logger.info("Loaded schema for integration type: {}", 
                                        schema.getIntegrationType());
                            }
                        } catch (IOException e) {
                            logger.error("Failed to load schema file: {}", path, e);
                        }
                    });
        } catch (IOException e) {
            logger.error("Failed to list schema files", e);
        }
        
        // If schemas directory is empty or no schemas were loaded, create default schemas
        if (settingsSchemas.isEmpty()) {
            logger.info("No schemas found, creating default schemas");
            
            IntegrationSettingsSchema adoSchema = createAzureDevOpsSettingsSchema();
            settingsSchemas.put(adoSchema.getIntegrationType(), adoSchema);
            
            IntegrationSettingsSchema adoGitSchema = createAzureDevOpsGitSettingsSchema();
            settingsSchemas.put(adoGitSchema.getIntegrationType(), adoGitSchema);
            
            // Save default schemas to disk
            saveDefaultSchemas();
        }
    }
    
    /**
     * Save default schemas to disk
     */
    private void saveDefaultSchemas() {
        Path schemasDir = Paths.get(schemasDirectory);
        
        for (Map.Entry<String, IntegrationSettingsSchema> entry : settingsSchemas.entrySet()) {
            String type = entry.getKey();
            IntegrationSettingsSchema schema = entry.getValue();
            
            Path schemaPath = schemasDir.resolve(type + ".json");
            
            try {
                objectMapper.writerWithDefaultPrettyPrinter()
                        .writeValue(schemaPath.toFile(), schema);
                
                logger.info("Saved default schema for integration type: {} to {}", 
                        type, schemaPath);
            } catch (IOException e) {
                logger.error("Failed to save default schema for integration type: {}", type, e);
            }
        }
    }
    
    /**
     * Validate integration type
     * 
     * @param type Integration type
     * @throws IllegalArgumentException if type is invalid
     */
    private void validateIntegrationType(String type) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Integration type is required");
        }
        
        switch (type) {
            case TYPE_AZURE_DEVOPS:
            case TYPE_AZURE_DEVOPS_GIT:
                break;
            default:
                throw new IllegalArgumentException("Unsupported integration type: " + type);
        }
    }
    
    /**
     * Build Azure DevOps URI with API version
     * 
     * @param url Base URL
     * @return URI with API version
     * @throws URISyntaxException if URI is invalid
     */
    private URI buildAzureDevOpsUri(String url) throws URISyntaxException {
        URIBuilder uriBuilder = new URIBuilder(url);
        
        // Add API version if not present
        if (uriBuilder.getQueryParams().stream()
                .noneMatch(p -> p.getName().equals("api-version"))) {
            uriBuilder.addParameter("api-version", ADO_API_VERSION);
        }
        
        return uriBuilder.build();
    }
    
    /**
     * Get Azure DevOps authentication header
     * 
     * @param pat Personal Access Token
     * @return Authentication header
     */
    private String getAzureDevOpsAuthHeader(String pat) {
        String credentials = ":" + pat;
        String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
        return "Basic " + encoded;
    }
    
    /**
     * Create HTTP client for Azure DevOps with proxy settings
     * 
     * @param integration The integration
     * @return HTTP client
     */
    private CloseableHttpClient createAzureDevOpsHttpClient(Integration integration) {
        return createAzureDevOpsHttpClient(integration, null);
    }
    
    /**
     * Create HTTP client for Azure DevOps with proxy settings
     * 
     * @param integration The integration
     * @param proxySettings Custom proxy settings
     * @return HTTP client
     */
    private CloseableHttpClient createAzureDevOpsHttpClient(
            Integration integration, IntegrationSyncOptions.ProxySettings proxySettings) {
        
        // If custom proxy settings provided, use them
        if (proxySettings != null) {
            return proxyConfig.createHttpClient(proxySettings);
        }
        
        // Check if integration has proxy settings
        Map<String, Object> settings = integration.getSettings();
        String proxyHost = (String) settings.get("proxyHost");
        Object proxyPortObj = settings.get("proxyPort");
        String proxyUsername = (String) settings.get("proxyUsername");
        String proxyPassword = (String) settings.get("proxyPassword");
        
        if (StringUtils.hasText(proxyHost) && proxyPortObj != null) {
            int proxyPort;
            
            if (proxyPortObj instanceof Number) {
                proxyPort = ((Number) proxyPortObj).intValue();
            } else if (proxyPortObj instanceof String) {
                try {
                    proxyPort = Integer.parseInt((String) proxyPortObj);
                } catch (NumberFormatException e) {
                    logger.warn("Invalid proxy port: {}", proxyPortObj);
                    proxyPort = 0;
                }
            } else {
                logger.warn("Invalid proxy port type: {}", proxyPortObj.getClass());
                proxyPort = 0;
            }
            
            if (proxyPort > 0) {
                IntegrationSyncOptions.ProxySettings settings = new IntegrationSyncOptions.ProxySettings()
                        .setHost(proxyHost)
                        .setPort(proxyPort)
                        .setUsername(proxyUsername)
                        .setPassword(proxyPassword);
                
                return proxyConfig.createHttpClient(settings);
            }
        }
        
        // Use default HTTP client with global proxy settings
        return proxyConfig.httpClient();
    }
}

application.properties
------------------------

# CS Test Forge Application Configuration

# Application data directory
app.data.directory=./data

# Integration schemas directory
app.integrations.schemas.directory=./config/integration-schemas

# HTTP Proxy Settings
# Uncomment and configure these properties to use a proxy
# http.proxy.host=proxy.example.com
# http.proxy.port=8080
# http.proxy.username=username
# http.proxy.password=password
# http.proxy.nonProxyHosts=localhost|127.0.0.1

# HTTP Connection Settings
http.connection.timeout=30000
http.socket.timeout=30000
http.connection.request.timeout=30000

# Logging Configuration
logging.level.root=INFO
logging.level.com.cstestforge=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.file.name=logs/cstestforge.log
logging.file.max-size=10MB
logging.file.max-history=10

# Server Configuration
server.port=8080
server.servlet.context-path=/
server.compression.enabled=true
server.error.include-message=always

# File Upload Settings
spring.servlet.multipart.max-file-size=25MB
spring.servlet.multipart.max-request-size=25MB

# Jackson JSON Configuration
spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
spring.jackson.deserialization.FAIL_ON_UNKNOWN_PROPERTIES=false
spring.jackson.default-property-inclusion=non_null

# Security Configuration
# Uncomment and configure these properties for production use
# security.require-ssl=true
# server.ssl.key-store=classpath:keystore.p12
# server.ssl.key-store-password=changeit
# server.ssl.key-store-type=PKCS12
# server.ssl.key-alias=cstestforge


